{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-13236",
  "base_commit": "626c33ecf8334a36d99263faa474f3cf63a03638",
  "patch": "diff --git a/sympy/core/assumptions.py b/sympy/core/assumptions.py\n--- a/sympy/core/assumptions.py\n+++ b/sympy/core/assumptions.py\n@@ -189,6 +189,7 @@\n \n     'prime          ->  integer & positive',\n     'composite      ->  integer & positive & !prime',\n+    '!composite     ->  !positive | !even | prime',\n \n     'irrational     ==  real & !rational',\n \ndiff --git a/sympy/core/exprtools.py b/sympy/core/exprtools.py\n--- a/sympy/core/exprtools.py\n+++ b/sympy/core/exprtools.py\n@@ -79,9 +79,17 @@ def _monotonic_sign(self):\n                 return S(3)\n             else:\n                 return S(2)\n+        elif s.is_composite:\n+            if s.is_odd:\n+                return S(9)\n+            else:\n+                return S(4)\n         elif s.is_positive:\n             if s.is_even:\n-                return S(2)\n+                if s.is_prime is False:\n+                    return S(4)\n+                else:\n+                    return S(2)\n             elif s.is_integer:\n                 return S.One\n             else:\ndiff --git a/sympy/core/mod.py b/sympy/core/mod.py\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -36,12 +36,11 @@ def doit(p, q):\n             to be less than or equal q.\n             \"\"\"\n \n+            if q == S.Zero:\n+                raise ZeroDivisionError(\"Modulo by zero\")\n             if p.is_infinite or q.is_infinite or p is nan or q is nan:\n                 return nan\n-            if (p == q or p == -q or\n-                    p.is_Pow and p.exp.is_integer and p.base == q and q.is_integer\n-                    and p.exp.is_positive or\n-                    p.is_integer and q == 1):\n+            if p == S.Zero or p == q or p == -q or (p.is_integer and q == 1):\n                 return S.Zero\n \n             if q.is_Number:\n@@ -53,6 +52,11 @@ def doit(p, q):\n                     elif p.is_odd:\n                         return S.One\n \n+            if hasattr(p, '_eval_Mod'):\n+                rv = getattr(p, '_eval_Mod')(q)\n+                if rv is not None:\n+                    return rv\n+\n             # by ratio\n             r = p/q\n             try:\n@@ -67,12 +71,22 @@ def doit(p, q):\n                     return rv\n \n             # by difference\n-            d = p - q\n-            if d.is_negative:\n-                if q.is_negative:\n-                    return d\n-                elif q.is_positive:\n-                    return p\n+            # -2|q| < p < 2|q|\n+            d = abs(p)\n+            for _ in range(2):\n+                d -= abs(q)\n+                if d.is_negative:\n+                    if q.is_positive:\n+                        if p.is_positive:\n+                            return d + q\n+                        elif p.is_negative:\n+                            return -d\n+                    elif q.is_negative:\n+                        if p.is_positive:\n+                            return d\n+                        elif p.is_negative:\n+                            return -d + q\n+                    break\n \n         rv = doit(p, q)\n         if rv is not None:\n@@ -80,11 +94,20 @@ def doit(p, q):\n \n         # denest\n         if p.func is cls:\n-            # easy\n             qinner = p.args[1]\n-            if qinner == q:\n+            if qinner % q == 0:\n+                return cls(p.args[0], q)\n+            elif (qinner*(q - qinner)).is_nonnegative:\n+                # |qinner| < |q| and have same sign\n+                return p\n+        elif (-p).func is cls:\n+            qinner = (-p).args[1]\n+            if qinner % q == 0:\n+                return cls(-(-p).args[0], q)\n+            elif (qinner*(q + qinner)).is_nonpositive:\n+                # |qinner| < |q| and have different sign\n                 return p\n-            # XXX other possibilities?\n+        # XXX other possibilities?\n \n         # extract gcd; any further simplification should be done by the user\n         G = gcd(p, q)\ndiff --git a/sympy/core/mul.py b/sympy/core/mul.py\n--- a/sympy/core/mul.py\n+++ b/sympy/core/mul.py\n@@ -1315,28 +1315,12 @@ def _eval_is_even(self):\n         elif is_integer is False:\n             return False\n \n-    def _eval_is_prime(self):\n-        \"\"\"\n-        If product is a positive integer, multiplication\n-        will never result in a prime number.\n-        \"\"\"\n-        if self.is_number:\n-            \"\"\"\n-            If input is a number that is not completely simplified.\n-            e.g. Mul(sqrt(3), sqrt(3), evaluate=False)\n-            So we manually evaluate it and return whether that is prime or not.\n-            \"\"\"\n-            # Note: `doit()` was not used due to test failing (Infinite Recursion)\n-            r = S.One\n-            for arg in self.args:\n-                r *= arg\n-            return r.is_prime\n-\n+    def _eval_is_composite(self):\n         if self.is_integer and self.is_positive:\n             \"\"\"\n             Here we count the number of arguments that have a minimum value\n             greater than two.\n-            If there are more than one of such a symbol then the result is not prime.\n+            If there are more than one of such a symbol then the result is composite.\n             Else, the result cannot be determined.\n             \"\"\"\n             number_of_args = 0 # count of symbols with minimum value greater than one\n@@ -1345,7 +1329,7 @@ def _eval_is_prime(self):\n                     number_of_args += 1\n \n             if number_of_args > 1:\n-                return False\n+                return True\n \n     def _eval_subs(self, old, new):\n         from sympy.functions.elementary.complexes import sign\ndiff --git a/sympy/core/power.py b/sympy/core/power.py\n--- a/sympy/core/power.py\n+++ b/sympy/core/power.py\n@@ -338,6 +338,18 @@ def _n2(e):\n         if s is not None:\n             return s*Pow(b, e*other)\n \n+    def _eval_Mod(self, q):\n+        if self.exp.is_integer and self.exp.is_positive:\n+            if q.is_integer and self.base % q == 0:\n+                return S.Zero\n+\n+            '''\n+            For unevaluated Integer power, use built-in pow modular\n+            exponentiation.\n+            '''\n+            if self.base.is_Integer and self.exp.is_Integer and q.is_Integer:\n+                return pow(int(self.base), int(self.exp), int(q))\n+\n     def _eval_is_even(self):\n         if self.exp.is_integer and self.exp.is_positive:\n             return self.base.is_even\n@@ -545,18 +557,20 @@ def _eval_is_finite(self):\n                 return True\n \n     def _eval_is_prime(self):\n-        if self.exp == S.One:\n-            return self.base.is_prime\n-        if self.is_number:\n-            return self.doit().is_prime\n+        '''\n+        An integer raised to the n(>=2)-th power cannot be a prime.\n+        '''\n+        if self.base.is_integer and self.exp.is_integer and (self.exp-1).is_positive:\n+            return False\n \n-        if self.is_integer and self.is_positive:\n-            \"\"\"\n-            a Power will be non-prime only if both base and exponent\n-            are greater than 1\n-            \"\"\"\n-            if (self.base-1).is_positive or (self.exp-1).is_positive:\n-                return False\n+    def _eval_is_composite(self):\n+        \"\"\"\n+        A power is composite if both base and exponent are greater than 1\n+        \"\"\"\n+        if (self.base.is_integer and self.exp.is_integer and\n+            ((self.base-1).is_positive and (self.exp-1).is_positive or\n+            (self.base+1).is_negative and self.exp.is_positive and self.exp.is_even)):\n+            return True\n \n     def _eval_is_polar(self):\n         return self.base.is_polar\ndiff --git a/sympy/functions/combinatorial/factorials.py b/sympy/functions/combinatorial/factorials.py\n--- a/sympy/functions/combinatorial/factorials.py\n+++ b/sympy/functions/combinatorial/factorials.py\n@@ -189,9 +189,14 @@ def _eval_is_positive(self):\n         if self.args[0].is_integer and self.args[0].is_nonnegative:\n             return True\n \n+    def _eval_is_even(self):\n+        x = self.args[0]\n+        if x.is_integer and x.is_nonnegative:\n+            return (x - 2).is_nonnegative\n+\n     def _eval_is_composite(self):\n         x = self.args[0]\n-        if x.is_integer:\n+        if x.is_integer and x.is_nonnegative:\n             return (x - 3).is_nonnegative\n \n     def _eval_is_real(self):\n@@ -199,6 +204,25 @@ def _eval_is_real(self):\n         if x.is_nonnegative or x.is_noninteger:\n             return True\n \n+    def _eval_Mod(self, q):\n+        x = self.args[0]\n+        if x.is_integer and x.is_nonnegative and q.is_integer:\n+            aq = abs(q)\n+            d = x - aq\n+            if d.is_nonnegative:\n+                return 0\n+            elif d == -1:\n+                '''\n+                Apply Wilson's theorem-if a natural number n > 1\n+                is a prime number, (n-1)! = -1 mod n-and its\n+                inverse-if n > 4 is a composite number,\n+                (n-1)! = 0 mod n\n+                '''\n+                if aq.is_prime:\n+                    return -1 % q\n+                elif aq.is_composite and (aq - 6).is_nonnegative:\n+                    return 0\n+\n \n class MultiFactorial(CombinatorialFunction):\n     pass\ndiff --git a/sympy/ntheory/factor_.py b/sympy/ntheory/factor_.py\n--- a/sympy/ntheory/factor_.py\n+++ b/sympy/ntheory/factor_.py\n@@ -942,6 +942,8 @@ def factorint(n, limit=None, use_trial=True, use_rho=True, use_pm1=True,\n     ``factorint`` also periodically checks if the remaining part is\n     a prime number or a perfect power, and in those cases stops.\n \n+    For unevaluated factorial, it uses Legendre's formula(theorem).\n+\n \n     If ``verbose`` is set to ``True``, detailed progress is printed.\n \n@@ -1000,6 +1002,28 @@ def factorint(n, limit=None, use_trial=True, use_rho=True, use_pm1=True,\n \n     assert use_trial or use_rho or use_pm1\n \n+    # for unevaluated factorial, if n < 20!, direct computation is faster\n+    # since it uses lookup table\n+    from sympy.functions.combinatorial.factorials import factorial\n+    if isinstance(n, factorial) and n.args[0].is_Integer and n.args[0] >= 20:\n+        x = n.args[0]\n+        factors = {}\n+        for p in sieve.primerange(2, x):\n+            m = 0\n+            d = p\n+            q = x // p\n+            while q != 0:\n+                m += q\n+                d *= p\n+                q = x // d\n+            factors[p] = m\n+        if factors and verbose:\n+            for k in sorted(factors):\n+                print(factor_msg % (k, factors[k]))\n+        if verbose:\n+            print(complete_msg)\n+        return factors\n+\n     n = as_int(n)\n     if limit:\n         limit = int(limit)\n",
  "test_patch": "diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1513,6 +1513,17 @@ def test_Mod():\n     assert Mod(1, nan) == nan\n     assert Mod(nan, nan) == nan\n \n+    Mod(0, x) == 0\n+    with raises(ZeroDivisionError):\n+        Mod(x, 0)\n+\n+    k = Symbol('k', integer=True)\n+    m = Symbol('m', integer=True, positive=True)\n+    assert (x**m % x).func is Mod\n+    assert (k**(-m) % k).func is Mod\n+    assert k**m % k == 0\n+    assert (-2*k)**m % k == 0\n+\n     # Float handling\n     point3 = Float(3.3) % 1\n     assert (x - 3.3) % 1 == Mod(1.*x + 1 - point3, 1)\n@@ -1541,22 +1552,31 @@ def test_Mod():\n             assert Mod(3*x + y, 9).subs(reps) == (3*_x + _y) % 9\n \n     # denesting\n-    #   easy case\n-    assert Mod(Mod(x, y), y) == Mod(x, y)\n-    #   in case someone attempts more denesting\n-    for i in [-3, -2, 2, 3]:\n-        for j in [-3, -2, 2, 3]:\n-            for k in range(3):\n-                assert Mod(Mod(k, i), j) == (k % i) % j\n+    t = Symbol('t', real=True)\n+    assert Mod(Mod(x, t), t) == Mod(x, t)\n+    assert Mod(-Mod(x, t), t) == Mod(-x, t)\n+    assert Mod(Mod(x, 2*t), t) == Mod(x, t)\n+    assert Mod(-Mod(x, 2*t), t) == Mod(-x, t)\n+    assert Mod(Mod(x, t), 2*t) == Mod(x, t)\n+    assert Mod(-Mod(x, t), -2*t) == -Mod(x, t)\n+    for i in [-4, -2, 2, 4]:\n+        for j in [-4, -2, 2, 4]:\n+            for k in range(4):\n+                assert Mod(Mod(x, i), j).subs({x: k}) == (k % i) % j\n+                assert Mod(-Mod(x, i), j).subs({x: k}) == -(k % i) % j\n \n     # known difference\n     assert Mod(5*sqrt(2), sqrt(5)) == 5*sqrt(2) - 3*sqrt(5)\n     p = symbols('p', positive=True)\n-    assert Mod(p + 1, p + 3) == p + 1\n-    n = symbols('n', negative=True)\n-    assert Mod(n - 3, n - 1) == -2\n-    assert Mod(n - 2*p, n - p) == -p\n-    assert Mod(p - 2*n, p - n) == -n\n+    assert Mod(2, p + 3) == 2\n+    assert Mod(-2, p + 3) == p + 1\n+    assert Mod(2, -p - 3) == -p - 1\n+    assert Mod(-2, -p - 3) == -2\n+    assert Mod(p + 5, p + 3) == 2\n+    assert Mod(-p - 5, p + 3) == p + 1\n+    assert Mod(p + 5, -p - 3) == -p - 1\n+    assert Mod(-p - 5, -p - 3) == -2\n+    assert Mod(p + 1, p - 1).func is Mod\n \n     # handling sums\n     assert (x + 3) % 1 == Mod(x, 1)\n@@ -1596,7 +1616,21 @@ def test_Mod():\n \n     # issue 8677\n     n = Symbol('n', integer=True, positive=True)\n-    assert (factorial(n) % n).equals(0) is not False\n+    assert factorial(n) % n == 0\n+    assert factorial(n + 2) % n == 0\n+    assert (factorial(n + 4) % (n + 5)).func is Mod\n+\n+    # modular exponentiation\n+    assert Mod(Pow(4, 13, evaluate=False), 497) == Mod(Pow(4, 13), 497)\n+\n+    # Wilson's theorem\n+    factorial(18042, evaluate=False) % 18043 == 18042\n+    p = Symbol('n', prime=True)\n+    factorial(p - 1) % p == p - 1\n+    factorial(p - 1) % -p == -1\n+    (factorial(3, evaluate=False) % 4).doit() == 2\n+    n = Symbol('n', composite=True, odd=True)\n+    factorial(n - 1) % n == 0\n \n     # symbolic with known parity\n     n = Symbol('n', even=True)\ndiff --git a/sympy/core/tests/test_assumptions.py b/sympy/core/tests/test_assumptions.py\n--- a/sympy/core/tests/test_assumptions.py\n+++ b/sympy/core/tests/test_assumptions.py\n@@ -520,6 +520,9 @@ def test_composite():\n     x = Dummy(integer=True, positive=True, prime=False)\n     assert x.is_composite is None # x could be 1\n     assert (x + 1).is_composite is None\n+    x = Dummy(positive=True, even=True, prime=False)\n+    assert x.is_integer is True\n+    assert x.is_composite is True\n \n \n def test_prime_symbol():\n@@ -764,33 +767,31 @@ def test_Pow_is_algebraic():\n     assert (pi**r).is_algebraic is True\n \n \n-def test_Mul_is_prime():\n+def test_Mul_is_prime_composite():\n     from sympy import Mul\n     x = Symbol('x', positive=True, integer=True)\n     y = Symbol('y', positive=True, integer=True)\n     assert (x*y).is_prime is None\n     assert ( (x+1)*(y+1) ).is_prime is False\n+    assert ( (x+1)*(y+1) ).is_composite is True\n \n     x = Symbol('x', positive=True)\n-    assert (x*y).is_prime is None\n-\n-    assert Mul(6, S.Half, evaluate=False).is_prime is True\n-    assert Mul(sqrt(3), sqrt(3), evaluate=False).is_prime is True\n-    assert Mul(5, S.Half, evaluate=False).is_prime is False\n+    assert ( (x+1)*(y+1) ).is_prime is None\n+    assert ( (x+1)*(y+1) ).is_composite is None\n \n-def test_Pow_is_prime():\n+def test_Pow_is_prime_composite():\n     from sympy import Pow\n     x = Symbol('x', positive=True, integer=True)\n     y = Symbol('y', positive=True, integer=True)\n     assert (x**y).is_prime is None\n+    assert ( x**(y+1) ).is_prime is False\n+    assert ( x**(y+1) ).is_composite is None\n+    assert ( (x+1)**(y+1) ).is_composite is True\n+    assert ( (-x-1)**(2*y) ).is_composite is True\n \n     x = Symbol('x', positive=True)\n     assert (x**y).is_prime is None\n \n-    assert Pow(6, S.One, evaluate=False).is_prime is False\n-    assert Pow(9, S.Half, evaluate=False).is_prime is True\n-    assert Pow(5, S.One, evaluate=False).is_prime is True\n-\n \n def test_Mul_is_infinite():\n     x = Symbol('x')\n@@ -979,11 +980,15 @@ def test_issues_8632_8633_8638_8675_8992():\n     assert (n - 3).is_nonpositive\n \n \n-def test_issue_9115():\n+def test_issue_9115_9150():\n     n = Dummy('n', integer=True, nonnegative=True)\n     assert (factorial(n) >= 1) == True\n     assert (factorial(n) < 1) == False\n \n+    assert factorial(n + 1).is_even is None\n+    assert factorial(n + 2).is_even is True\n+    assert factorial(n + 2) >= 2\n+\n \n def test_issue_9165():\n     z = Symbol('z', zero=True)\ndiff --git a/sympy/core/tests/test_expr.py b/sympy/core/tests/test_expr.py\n--- a/sympy/core/tests/test_expr.py\n+++ b/sympy/core/tests/test_expr.py\n@@ -1771,7 +1771,7 @@ def test_issue_6325():\n def test_issue_7426():\n     f1 = a % c\n     f2 = x % z\n-    assert f1.equals(f2) == False\n+    assert f1.equals(f2) is None\n \n \n def test_issue_1112():\ndiff --git a/sympy/core/tests/test_exprtools.py b/sympy/core/tests/test_exprtools.py\n--- a/sympy/core/tests/test_exprtools.py\n+++ b/sympy/core/tests/test_exprtools.py\n@@ -384,8 +384,11 @@ def test_monotonic_sign():\n     assert F(-x) is None\n     assert F(Dummy(prime=True)) == 2\n     assert F(Dummy(prime=True, odd=True)) == 3\n+    assert F(Dummy(composite=True)) == 4\n+    assert F(Dummy(composite=True, odd=True)) == 9\n     assert F(Dummy(positive=True, integer=True)) == 1\n     assert F(Dummy(positive=True, even=True)) == 2\n+    assert F(Dummy(positive=True, even=True, prime=False)) == 4\n     assert F(Dummy(negative=True, integer=True)) == -1\n     assert F(Dummy(negative=True, even=True)) == -2\n     assert F(Dummy(zero=True)) == 0\ndiff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py\n--- a/sympy/core/tests/test_numbers.py\n+++ b/sympy/core/tests/test_numbers.py\n@@ -77,7 +77,6 @@ def test_mod():\n \n     p = Symbol('p', infinite=True)\n \n-    assert zoo % 0 == nan\n     assert oo % oo == nan\n     assert zoo % oo == nan\n     assert 5 % oo == nan\n@@ -122,20 +121,6 @@ def test_mod():\n     assert Integer(10) % 4 == Integer(2)\n     assert 15 % Integer(4) == Integer(3)\n \n-    h = Symbol('h')\n-    m = h ** 2 % h\n-    k = h ** -2 % h\n-    l = Symbol('l', integer=True)\n-    p = Symbol('p', integer=True, positive=True)\n-    q = Symbol('q', integer=True, negative=True)\n-\n-    assert m == h * (h % 1)\n-    assert k == Mod(h ** -2, h, evaluate=False)\n-    assert Mod(l ** p, l) == 0\n-    assert Mod(l ** 2, l) == 0\n-    assert (l ** q % l) == Mod(l ** q, l, evaluate=False)\n-    assert (l ** -2 % l) == Mod(l ** -2, l, evaluate=False)\n-\n \n def test_divmod():\n     assert divmod(S(12), S(8)) == Tuple(1, 4)\ndiff --git a/sympy/functions/combinatorial/tests/test_comb_factorials.py b/sympy/functions/combinatorial/tests/test_comb_factorials.py\n--- a/sympy/functions/combinatorial/tests/test_comb_factorials.py\n+++ b/sympy/functions/combinatorial/tests/test_comb_factorials.py\n@@ -128,7 +128,6 @@ def test_factorial():\n     s = Symbol('s', integer=False, negative=True)\n     t = Symbol('t', nonnegative=True)\n     u = Symbol('u', noninteger=True)\n-    v = Symbol('v', integer=True, negative=True)\n \n     assert factorial(-2) == zoo\n     assert factorial(0) == 1\n@@ -162,7 +161,6 @@ def test_factorial():\n     assert factorial(s).is_composite is None\n     assert factorial(t).is_composite is None\n     assert factorial(u).is_composite is None\n-    assert factorial(v).is_composite is False\n \n     assert factorial(oo) == oo\n \ndiff --git a/sympy/ntheory/tests/test_factor_.py b/sympy/ntheory/tests/test_factor_.py\n--- a/sympy/ntheory/tests/test_factor_.py\n+++ b/sympy/ntheory/tests/test_factor_.py\n@@ -174,13 +174,17 @@ def test_factorint():\n     assert factorint(2**(2**6) + 1, multiple=True) == [274177, 67280421310721]\n \n     assert multiproduct(factorint(fac(200))) == fac(200)\n+    assert multiproduct(factorint(fac(200, evaluate=False))) == fac(200)\n     for b, e in factorint(fac(150)).items():\n         assert e == fac_multiplicity(150, b)\n+    for b, e in factorint(fac(150, evaluate=False)).items():\n+        assert e == fac_multiplicity(150, b)\n     assert factorint(103005006059**7) == {103005006059: 7}\n     assert factorint(31337**191) == {31337: 191}\n     assert factorint(2**1000 * 3**500 * 257**127 * 383**60) == \\\n         {2: 1000, 3: 500, 257: 127, 383: 60}\n     assert len(factorint(fac(10000))) == 1229\n+    assert len(factorint(fac(10000, evaluate=False))) == 1229\n     assert factorint(12932983746293756928584532764589230) == \\\n         {2: 1, 5: 1, 73: 1, 727719592270351: 1, 63564265087747: 1, 383: 1}\n     assert factorint(727719592270351) == {727719592270351: 1}\n",
  "problem_statement": "factorial(n) should \"know\" that it is divisible by n\nThis is related to #8531, but is not really the same.\n\nIt would be nice if `factorial(n)` would \"know\" that it divisible by `n`, or, even better, that it is divisible by any `k` for which `1 <= k <= n`. `n` and `k` in my example are both positive integers.\n\nFormally, it would be nice if `factorial(n) % n` would simplify automatically to 0, and even better, that `factorial(n) % k` would simplify to 0 if `k` is known to be an integer from `1` to `n`.\n\nCurrently, something a little bit weird happens.\n\n``` python\n>>> n = Symbol('n', integer=True, positive=True)\n>>> (factorial(n) % n).equals(0)\nFalse\n```\n\nHowever, any substitution of positive integer `n` would return 0, so something is wrong there.  (Note: this is fixed in #8687)\n\n",
  "hints_text": "This is more important (bug):\n\n```\n>>> (factorial(n) % n).equals(0)\nFalse\n```\n\n#8681 \n\nThere's no real way to assume that k is between 0 and n, so that one will have to wait. \n\nSo it all boils down to the same idea: why won't we have another, fairly simple, \"assumptions\" method for reals, which generalizes the assumptions \"nonnegative\", \"negative\", \"nonpositive\" and \"positive\", to a \"best known lower bound\" (which is a tuple, a number and a boolean, where's the boolean signifies whether this is a strict or non-strict lower bound), which is `-oo` by default, and a \"best known upper bound\", which is the symmetric case.\n\nThis way, we can replace:\n- `nonnegative=True` -> `lbound=0, False`\n- `negative=True` -> `ubound=0, True`\n- `nonpositive=True` -> `ubound=0, False`\n- `positive=True` -> `lbound=0, True`\n\nSuch a system can help:\n- fixing this issue (by checking if it is known for an integer `k` to have a \"best known upper bound at most `n`, non-strict\")\n- fixing #8632, #8633 and #8636 as the assumption `integer` together with the assumption `positive` would imply \"best known lower bound is 1, non-strict\", and together with `even` it would imply \"best known lower bound is 2, non-strict\"\n- fixing #8670 (at least the `<2` case), as the `sign` function will have some kind of `_eval_lbound` and `_eval_ubound` methods, returning, without further knowledge, non-strict -1 and non-strict 1 respectively.\n- fixing #8675, as the `prime` assumption will imply \"best known lower bound: 2, non-strict\", or, together with `odd`, would imply \"best known lower bound: 3, non-strict\"\n\nWhat do you think?\n\n@skirpichev, do you think I should report a new issue for the `equals(0)` bug?\n\nsure @asmeurer , I would love to chip in by the way\n\n@pelegm, see https://github.com/sympy/sympy/pull/8687\n\nI think a simpler way to represent inequalities is with `a > b` == `Q.positive(a - b)`. \n\nor `(a - b).is_positive`...\n\nI don't get it. How can you use `Q.positive(a - b)` to achieve this? For example, how can I let the `sign` function \"know\" that its value is at least -1 using such a method?\n\nOn Wed, Dec 31, 2014 at 01:53:39AM -0800, Peleg wrote:\n\n>    I don't get it. How can you use Q.positive(a - b) to achieve this? For\n>    example, how can I let the sign function \"know\" that its value is at least\n>    -1 using such a method?\n\nQ.positive(a + 1)\n\nI apologize, but I still don't get it. What is `a`? What is the method / property that I have to add to the `sign` class in order to be able to see that `(sign(x)+1).is_nonnegative` for every real `x`? Where do I use `Q` to achieve this?\n\nMy proposition regarding the bounds can also help solving #8533. I agree with @asmeurer that doing so with inequalities is probably a better idea, but I was wondering **(a)** whether this is possible in the \"old\" assumptions system, and **(b)** how can I really implement it in the \"new\" assumptions system.\n",
  "created_at": "2017-09-01T16:22:24Z",
  "version": "1.1",
  "FAIL_TO_PASS": "[\"test_pow_E\", \"test_Mul_doesnt_expand_exp\", \"test_Add_Mul_is_integer\", \"test_Add_is_negative_positive\", \"test_Pow_is_real\", \"test_Mod\", \"test_add_flatten\", \"test_issue_8247_8354\", \"test_composite\", \"test_issue_4822\", \"test_Mul_is_prime_composite\", \"test_Pow_is_prime_composite\", \"test_special_assumptions\", \"test_issue_9115_9150\", \"test_issue_10302\", \"test_leadterm\", \"test_as_leading_term\", \"test_leadterm2\", \"test_as_leading_term2\", \"test_as_ordered_terms\", \"test_is_constant\", \"test_equals\", \"test_issue_7426\", \"test_gcd_terms\", \"test_factor_nc\", \"test_issue_7903\", \"test_powers_Integer\", \"test_factorial_series\", \"test_factorial2_rewrite\", \"test_factorint\"]",
  "PASS_TO_PASS": "[\"test_bug1\", \"test_Symbol\", \"test_arit0\", \"test_div\", \"test_pow\", \"test_pow2\", \"test_pow3\", \"test_pow_issue_3516\", \"test_pow_im\", \"test_real_mul\", \"test_ncmul\", \"test_ncpow\", \"test_powerbug\", \"test_Add_Mul_is_finite\", \"test_Mul_is_even_odd\", \"test_evenness_in_ternary_integer_product_with_even\", \"test_oddness_in_ternary_integer_product_with_even\", \"test_Mul_is_rational\", \"test_Add_is_rational\", \"test_Add_is_even_odd\", \"test_Mul_is_negative_positive\", \"test_Mul_is_negative_positive_2\", \"test_Mul_is_nonpositive_nonnegative\", \"test_Add_is_nonpositive_nonnegative\", \"test_Pow_is_integer\", \"test_Pow_is_finite\", \"test_Pow_is_even_odd\", \"test_Pow_is_negative_positive\", \"test_Pow_is_zero\", \"test_Pow_is_nonpositive_nonnegative\", \"test_Mul_is_imaginary_real\", \"test_Mul_hermitian_antihermitian\", \"test_Add_is_comparable\", \"test_Mul_is_comparable\", \"test_Pow_is_comparable\", \"test_Add_is_positive_2\", \"test_Add_is_irrational\", \"test_issue_3531b\", \"test_bug3\", \"test_suppressed_evaluation\", \"test_Add_as_coeff_mul\", \"test_Pow_as_coeff_mul_doesnt_expand\", \"test_issue_3514\", \"test_make_args\", \"test_issue_5126\", \"test_Rational_as_content_primitive\", \"test_Add_as_content_primitive\", \"test_Mul_as_content_primitive\", \"test_Pow_as_content_primitive\", \"test_issue_5460\", \"test_product_irrational\", \"test_issue_5919\", \"test_Mod_is_integer\", \"test_Mod_is_nonposneg\", \"test_issue_6001\", \"test_polar\", \"test_issue_6040\", \"test_issue_6082\", \"test_issue_6077\", \"test_mul_flatten_oo\", \"test_issue_5160_6087_6089_6090\", \"test_float_int\", \"test_issue_6611a\", \"test_denest_add_mul\", \"test_mul_zero_detection\", \"test_Mul_with_zero_infinite\", \"test_symbol_unset\", \"test_zero\", \"test_one\", \"test_negativeone\", \"test_infinity\", \"test_neg_infinity\", \"test_nan\", \"test_pos_rational\", \"test_neg_rational\", \"test_pi\", \"test_E\", \"test_I\", \"test_symbol_real\", \"test_symbol_imaginary\", \"test_symbol_zero\", \"test_symbol_positive\", \"test_neg_symbol_positive\", \"test_symbol_nonpositive\", \"test_neg_symbol_nonpositive\", \"test_symbol_falsepositive\", \"test_symbol_falsepositive_mul\", \"test_neg_symbol_falsepositive\", \"test_neg_symbol_falsenegative\", \"test_symbol_falsepositive_real\", \"test_neg_symbol_falsepositive_real\", \"test_symbol_falsenonnegative\", \"test_symbol_falsenonnegative_real\", \"test_neg_symbol_falsenonnegative_real\", \"test_prime\", \"test_prime_symbol\", \"test_symbol_noncommutative\", \"test_other_symbol\", \"test_issue_3825\", \"test_hash_vs_typeinfo\", \"test_hash_vs_typeinfo_2\", \"test_hash_vs_eq\", \"test_Add_is_pos_neg\", \"test_Add_is_imaginary\", \"test_Add_is_algebraic\", \"test_Mul_is_algebraic\", \"test_Pow_is_algebraic\", \"test_Mul_is_infinite\", \"test_special_is_rational\", \"test_sanitize_assumptions\", \"test_inconsistent\", \"test_issue_6631\", \"test_issue_2730\", \"test_issue_4149\", \"test_issue_2920\", \"test_issue_7899\", \"test_issue_8075\", \"test_issue_8642\", \"test_issues_8632_8633_8638_8675_8992\", \"test_issue_9165\", \"test_issue_10024\", \"test_basic\", \"test_ibasic\", \"test_relational\", \"test_relational_assumptions\", \"test_relational_noncommutative\", \"test_basic_nostr\", \"test_series_expansion_for_uniform_order\", \"test_leadterm3\", \"test_as_leading_term3\", \"test_as_leading_term4\", \"test_as_leading_term_stub\", \"test_as_leading_term_deriv_integral\", \"test_atoms\", \"test_is_polynomial\", \"test_is_rational_function\", \"test_is_algebraic_expr\", \"test_SAGE1\", \"test_SAGE2\", \"test_SAGE3\", \"test_len\", \"test_doit\", \"test_attribute_error\", \"test_args\", \"test_noncommutative_expand_issue_3757\", \"test_as_numer_denom\", \"test_as_independent\", \"test_replace\", \"test_find\", \"test_count\", \"test_has_basics\", \"test_has_multiple\", \"test_has_piecewise\", \"test_has_iterative\", \"test_has_integrals\", \"test_has_tuple\", \"test_has_units\", \"test_has_polys\", \"test_has_physics\", \"test_as_poly_as_expr\", \"test_nonzero\", \"test_is_number\", \"test_as_coeff_add\", \"test_as_coeff_mul\", \"test_as_coeff_exponent\", \"test_extractions\", \"test_nan_extractions\", \"test_coeff\", \"test_coeff2\", \"test_coeff2_0\", \"test_coeff_expand\", \"test_integrate\", \"test_as_base_exp\", \"test_issue_4963\", \"test_as_powers_dict\", \"test_as_coefficients_dict\", \"test_args_cnc\", \"test_new_rawargs\", \"test_issue_5226\", \"test_free_symbols\", \"test_issue_5300\", \"test_floordiv\", \"test_as_coeff_Mul\", \"test_as_coeff_Add\", \"test_expr_sorting\", \"test_as_ordered_factors\", \"test_sort_key_atomic_expr\", \"test_eval_interval\", \"test_primitive\", \"test_issue_5843\", \"test_random\", \"test_round\", \"test_held_expression_UnevaluatedExpr\", \"test_round_exception_nostr\", \"test_extract_branch_factor\", \"test_identity_removal\", \"test_float_0\", \"test_issue_6325\", \"test_issue_1112\", \"test_issue_10161\", \"test_issue_10755\", \"test_issue_11877\", \"test_decompose_power\", \"test_Factors\", \"test_Term\", \"test_factor_terms\", \"test_xreplace\", \"test_issue_6360\", \"test_integers_cache\", \"test_seterr\", \"test_mod\", \"test_divmod\", \"test_igcd\", \"test_igcd_lehmer\", \"test_igcd2\", \"test_ilcm\", \"test_igcdex\", \"test_Integer_new\", \"test_Rational_new\", \"test_Number_new\", \"test_Rational_cmp\", \"test_Float\", \"test_float_mpf\", \"test_Float_RealElement\", \"test_Float_default_to_highprec_from_str\", \"test_Float_eval\", \"test_Float_issue_2107\", \"test_Infinity\", \"test_Infinity_2\", \"test_Mul_Infinity_Zero\", \"test_Div_By_Zero\", \"test_Infinity_inequations\", \"test_NaN\", \"test_special_numbers\", \"test_powers\", \"test_integer_nthroot_overflow\", \"test_isqrt\", \"test_powers_Rational\", \"test_powers_Float\", \"test_abs1\", \"test_accept_int\", \"test_dont_accept_str\", \"test_int\", \"test_long\", \"test_real_bug\", \"test_bug_sqrt\", \"test_pi_Pi\", \"test_no_len\", \"test_issue_3321\", \"test_issue_3692\", \"test_issue_3423\", \"test_issue_3449\", \"test_Integer_factors\", \"test_Rational_factors\", \"test_issue_4107\", \"test_IntegerInteger\", \"test_Rational_gcd_lcm_cofactors\", \"test_Float_gcd_lcm_cofactors\", \"test_issue_4611\", \"test_conversion_to_mpmath\", \"test_Integer_as_index\", \"test_Rational_int\", \"test_zoo\", \"test_issue_4122\", \"test_GoldenRatio_expand\", \"test_as_content_primitive\", \"test_hashing_sympy_integers\", \"test_issue_4172\", \"test_Catalan_EulerGamma_prec\", \"test_Float_eq\", \"test_int_NumberSymbols\", \"test_issue_6640\", \"test_issue_6349\", \"test_mpf_norm\", \"test_latex\", \"test_issue_7742\", \"test_simplify_AlgebraicNumber\", \"test_Float_idempotence\", \"test_comp\", \"test_issue_9491\", \"test_issue_10063\", \"test_issue_10020\", \"test_invert_numbers\", \"test_mod_inverse\", \"test_golden_ratio_rewrite_as_sqrt\", \"test_comparisons_with_unknown_type\", \"test_rf_eval_apply\", \"test_ff_eval_apply\", \"test_factorial\", \"test_factorial_diff\", \"test_factorial_rewrite\", \"test_factorial2\", \"test_binomial\", \"test_binomial_diff\", \"test_binomial_rewrite\", \"test_trailing_bitcount\", \"test_multiplicity\", \"test_perfect_power\", \"test_divisors_and_divisor_count\", \"test_udivisors_and_udivisor_count\", \"test_issue_6981\", \"test_totient\", \"test_reduced_totient\", \"test_divisor_sigma\", \"test_udivisor_sigma\", \"test_issue_4356\", \"test_divisors\", \"test_divisor_count\", \"test_antidivisors\", \"test_antidivisor_count\", \"test_smoothness_and_smoothness_p\", \"test_visual_factorint\", \"test_factorrat\", \"test_visual_io\", \"test_core\", \"test_digits\", \"test_primenu\"]",
  "environment_setup_commit": "ec9e3c0436fbff934fa84e22bf07f1b3ef5bfac3",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.081264",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}