{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-14704",
  "base_commit": "68044b061d7abc0c16f632890939438033306161",
  "patch": "diff --git a/sklearn/model_selection/_split.py b/sklearn/model_selection/_split.py\n--- a/sklearn/model_selection/_split.py\n+++ b/sklearn/model_selection/_split.py\n@@ -601,8 +601,20 @@ class StratifiedKFold(_BaseKFold):\n \n     Notes\n     -----\n-    Train and test sizes may be different in each fold, with a difference of at\n-    most ``n_classes``.\n+    The implementation is designed to:\n+\n+    * Generate test sets such that all contain the same distribution of\n+      classes, or as close as possible.\n+    * Be invariant to class label: relabelling ``y = [\"Happy\", \"Sad\"]`` to\n+      ``y = [1, 0]`` should not change the indices generated.\n+    * Preserve order dependencies in the dataset ordering, when\n+      ``shuffle=False``: all samples from class k in some test set were\n+      contiguous in y, or separated in y by samples from classes other than k.\n+    * Generate test sets where the smallest and largest differ by at most one\n+      sample.\n+\n+    .. versionchanged:: 0.22\n+        The previous implementation did not follow the last constraint.\n \n     See also\n     --------\n@@ -623,9 +635,16 @@ def _make_test_folds(self, X, y=None):\n                     allowed_target_types, type_of_target_y))\n \n         y = column_or_1d(y)\n-        n_samples = y.shape[0]\n-        unique_y, y_inversed = np.unique(y, return_inverse=True)\n-        y_counts = np.bincount(y_inversed)\n+\n+        _, y_idx, y_inv = np.unique(y, return_index=True, return_inverse=True)\n+        # y_inv encodes y according to lexicographic order. We invert y_idx to\n+        # map the classes so that they are encoded by order of appearance:\n+        # 0 represents the first label appearing in y, 1 the second, etc.\n+        _, class_perm = np.unique(y_idx, return_inverse=True)\n+        y_encoded = class_perm[y_inv]\n+\n+        n_classes = len(y_idx)\n+        y_counts = np.bincount(y_encoded)\n         min_groups = np.min(y_counts)\n         if np.all(self.n_splits > y_counts):\n             raise ValueError(\"n_splits=%d cannot be greater than the\"\n@@ -633,35 +652,29 @@ def _make_test_folds(self, X, y=None):\n                              % (self.n_splits))\n         if self.n_splits > min_groups:\n             warnings.warn((\"The least populated class in y has only %d\"\n-                           \" members, which is too few. The minimum\"\n-                           \" number of members in any class cannot\"\n-                           \" be less than n_splits=%d.\"\n-                           % (min_groups, self.n_splits)), Warning)\n-\n-        # pre-assign each sample to a test fold index using individual KFold\n-        # splitting strategies for each class so as to respect the balance of\n-        # classes\n-        # NOTE: Passing the data corresponding to ith class say X[y==class_i]\n-        # will break when the data is not 100% stratifiable for all classes.\n-        # So we pass np.zeroes(max(c, n_splits)) as data to the KFold\n-        per_cls_cvs = [\n-            KFold(self.n_splits, shuffle=self.shuffle,\n-                  random_state=rng).split(np.zeros(max(count, self.n_splits)))\n-            for count in y_counts]\n-\n-        test_folds = np.zeros(n_samples, dtype=np.int)\n-        for test_fold_indices, per_cls_splits in enumerate(zip(*per_cls_cvs)):\n-            for cls, (_, test_split) in zip(unique_y, per_cls_splits):\n-                cls_test_folds = test_folds[y == cls]\n-                # the test split can be too big because we used\n-                # KFold(...).split(X[:max(c, n_splits)]) when data is not 100%\n-                # stratifiable for all the classes\n-                # (we use a warning instead of raising an exception)\n-                # If this is the case, let's trim it:\n-                test_split = test_split[test_split < len(cls_test_folds)]\n-                cls_test_folds[test_split] = test_fold_indices\n-                test_folds[y == cls] = cls_test_folds\n-\n+                           \" members, which is less than n_splits=%d.\"\n+                           % (min_groups, self.n_splits)), UserWarning)\n+\n+        # Determine the optimal number of samples from each class in each fold,\n+        # using round robin over the sorted y. (This can be done direct from\n+        # counts, but that code is unreadable.)\n+        y_order = np.sort(y_encoded)\n+        allocation = np.asarray(\n+            [np.bincount(y_order[i::self.n_splits], minlength=n_classes)\n+             for i in range(self.n_splits)])\n+\n+        # To maintain the data order dependencies as best as possible within\n+        # the stratification constraint, we assign samples from each class in\n+        # blocks (and then mess that up when shuffle=True).\n+        test_folds = np.empty(len(y), dtype='i')\n+        for k in range(n_classes):\n+            # since the kth column of allocation stores the number of samples\n+            # of class k in each test set, this generates blocks of fold\n+            # indices corresponding to the allocation for class k.\n+            folds_for_class = np.arange(self.n_splits).repeat(allocation[:, k])\n+            if self.shuffle:\n+                rng.shuffle(folds_for_class)\n+            test_folds[y_encoded == k] = folds_for_class\n         return test_folds\n \n     def _iter_test_masks(self, X, y=None, groups=None):\n",
  "test_patch": "diff --git a/sklearn/model_selection/tests/test_search.py b/sklearn/model_selection/tests/test_search.py\n--- a/sklearn/model_selection/tests/test_search.py\n+++ b/sklearn/model_selection/tests/test_search.py\n@@ -210,7 +210,7 @@ def check_hyperparameter_searcher_with_fit_params(klass, **klass_kwargs):\n                          \"Expected fit parameter(s) ['eggs'] not seen.\",\n                          searcher.fit, X, y, spam=np.ones(10))\n     assert_raise_message(AssertionError,\n-                         \"Fit parameter spam has length 1; expected 4.\",\n+                         \"Fit parameter spam has length 1; expected\",\n                          searcher.fit, X, y, spam=np.ones(1),\n                          eggs=np.zeros(10))\n     searcher.fit(X, y, spam=np.ones(10), eggs=np.zeros(10))\ndiff --git a/sklearn/model_selection/tests/test_split.py b/sklearn/model_selection/tests/test_split.py\n--- a/sklearn/model_selection/tests/test_split.py\n+++ b/sklearn/model_selection/tests/test_split.py\n@@ -6,8 +6,9 @@\n from scipy import stats\n from itertools import combinations\n from itertools import combinations_with_replacement\n+from itertools import permutations\n \n-from sklearn.utils.testing import assert_almost_equal\n+from sklearn.utils.testing import assert_allclose\n from sklearn.utils.testing import assert_raises\n from sklearn.utils.testing import assert_raises_regexp\n from sklearn.utils.testing import assert_array_almost_equal\n@@ -368,8 +369,17 @@ def test_stratified_kfold_no_shuffle():\n         list(StratifiedKFold(2).split(X, y1)),\n         list(StratifiedKFold(2).split(X, y2)))\n \n+    # Check equivalence to KFold\n+    y = [0, 1, 0, 1, 0, 1, 0, 1]\n+    X = np.ones_like(y)\n+    np.testing.assert_equal(\n+        list(StratifiedKFold(3).split(X, y)),\n+        list(KFold(3).split(X, y)))\n+\n \n-def test_stratified_kfold_ratios():\n+@pytest.mark.parametrize('shuffle', [False, True])\n+@pytest.mark.parametrize('k', [4, 5, 6, 7, 8, 9, 10])\n+def test_stratified_kfold_ratios(k, shuffle):\n     # Check that stratified kfold preserves class ratios in individual splits\n     # Repeat with shuffling turned off and on\n     n_samples = 1000\n@@ -377,15 +387,38 @@ def test_stratified_kfold_ratios():\n     y = np.array([4] * int(0.10 * n_samples) +\n                  [0] * int(0.89 * n_samples) +\n                  [1] * int(0.01 * n_samples))\n+    distr = np.bincount(y) / len(y)\n+\n+    test_sizes = []\n+    skf = StratifiedKFold(k, random_state=0, shuffle=shuffle)\n+    for train, test in skf.split(X, y):\n+        assert_allclose(np.bincount(y[train]) / len(train), distr, atol=0.02)\n+        assert_allclose(np.bincount(y[test]) / len(test), distr, atol=0.02)\n+        test_sizes.append(len(test))\n+    assert np.ptp(test_sizes) <= 1\n+\n+\n+@pytest.mark.parametrize('shuffle', [False, True])\n+@pytest.mark.parametrize('k', [4, 6, 7])\n+def test_stratified_kfold_label_invariance(k, shuffle):\n+    # Check that stratified kfold gives the same indices regardless of labels\n+    n_samples = 100\n+    y = np.array([2] * int(0.10 * n_samples) +\n+                 [0] * int(0.89 * n_samples) +\n+                 [1] * int(0.01 * n_samples))\n+    X = np.ones(len(y))\n+\n+    def get_splits(y):\n+        return [(list(train), list(test))\n+                for train, test\n+                in StratifiedKFold(k, random_state=0,\n+                                   shuffle=shuffle).split(X, y)]\n \n-    for shuffle in (False, True):\n-        for train, test in StratifiedKFold(5, shuffle=shuffle).split(X, y):\n-            assert_almost_equal(np.sum(y[train] == 4) / len(train), 0.10, 2)\n-            assert_almost_equal(np.sum(y[train] == 0) / len(train), 0.89, 2)\n-            assert_almost_equal(np.sum(y[train] == 1) / len(train), 0.01, 2)\n-            assert_almost_equal(np.sum(y[test] == 4) / len(test), 0.10, 2)\n-            assert_almost_equal(np.sum(y[test] == 0) / len(test), 0.89, 2)\n-            assert_almost_equal(np.sum(y[test] == 1) / len(test), 0.01, 2)\n+    splits_base = get_splits(y)\n+    for perm in permutations([0, 1, 2]):\n+        y_perm = np.take(perm, y)\n+        splits_perm = get_splits(y_perm)\n+        assert splits_perm == splits_base\n \n \n def test_kfold_balance():\n@@ -536,7 +569,7 @@ def test_kfold_can_detect_dependent_samples_on_digits():  # see #2372\n \n     cv = StratifiedKFold(n_splits)\n     mean_score = cross_val_score(model, X, y, cv=cv).mean()\n-    assert 0.93 > mean_score\n+    assert 0.94 > mean_score\n     assert mean_score > 0.80\n \n \ndiff --git a/sklearn/model_selection/tests/test_validation.py b/sklearn/model_selection/tests/test_validation.py\n--- a/sklearn/model_selection/tests/test_validation.py\n+++ b/sklearn/model_selection/tests/test_validation.py\n@@ -961,7 +961,7 @@ def test_cross_val_predict_unbalanced():\n     # Change the first sample to a new class\n     y[0] = 2\n     clf = LogisticRegression(random_state=1, solver=\"liblinear\")\n-    cv = StratifiedKFold(n_splits=2, random_state=1)\n+    cv = StratifiedKFold(n_splits=2)\n     train, test = list(cv.split(X, y))\n     yhat_proba = cross_val_predict(clf, X, y, cv=cv, method=\"predict_proba\")\n     assert y[test[0]][0] == 2  # sanity check for further assertions\n",
  "problem_statement": "StratifiedKFold makes fold-sizes very unequal\nI found this when trying to write tests for #14560.\r\nRight now, ``StratifiedKFold`` might have the fold sizes unequal by ``n_classes``:\r\n\r\n```python\r\nimport numpy as np\r\nfrom sklearn.model_selection import StratifiedKFold\r\n\r\ny = np.array([1, 1, 5, 3, 4, 4, 3, 1, 4, 2, 4, 2, 4, 3, 4, 1, 5, 3, 3, 2, 2, 4,\r\n       2, 2, 1, 3, 1, 3, 2, 5, 3, 5, 2, 3, 1, 1, 5, 4, 3, 1, 3, 5, 2, 1,\r\n       1, 5, 2, 2, 5, 2, 2, 5, 2, 2, 3, 1, 1, 5, 5, 3, 4, 2, 3, 4, 4, 5,\r\n       4, 2, 4, 1, 1, 1, 3, 1, 5, 5, 4, 3, 3, 5, 1, 5, 4, 4, 2, 3, 3, 4,\r\n       4, 2, 3, 4, 5, 5, 2, 1, 1, 5, 5, 4])\r\n\r\n[len(x[1]) for x in StratifiedKFold(n_splits=7).split(y, y)]\r\n```\r\n> [15, 15, 15, 15, 15, 15, 10]\r\n\r\nWe could achieve something like\r\n> [15, 15, 14, 14, 14, 14, 14]\r\n\r\nbut our rounding doesn't let us :-/\n",
  "hints_text": "I think there have been several issues about this.\n\nI think we should go back to a sort-then-round-robin approach.\n\nthis behaviour is actually well-documented, see https://scikit-learn.org/dev/modules/generated/sklearn.model_selection.StratifiedKFold.html:\r\nTrain and test sizes may be different in each fold, with a difference of at most n_classes.\r\nrelated issues: #10274 #2372\r\nI agree that we might want a better StratifiedKFold\n@jnothman could you provide more details about your solution?\r\nYou said in #10274:\r\nThe critique in #2372 was that the sampling did not maintain order of samples within each class, but I contend that could have been achieved with a stable sort rather than default sort.\r\nBut seems that the critique in #2372 is to preserve the dataset dependency, so stable sort won't solve the problem.\nOhhhh... Maybe I misunderstood all along. Hmm. Yuck. But determining the\nnumber of test samples in each class by the equivalent of round robin\nshould solve the problem, shouldn't it??\n",
  "created_at": "2019-08-21T08:52:44Z",
  "version": "0.22",
  "FAIL_TO_PASS": "[\"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_no_shuffle\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_ratios[4-False]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_ratios[4-True]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_ratios[6-False]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_ratios[6-True]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_ratios[7-False]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_ratios[7-True]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_ratios[8-False]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_ratios[8-True]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_ratios[9-False]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_ratios[9-True]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_label_invariance[4-True]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_label_invariance[6-True]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_label_invariance[7-True]\"]",
  "PASS_TO_PASS": "[\"sklearn/model_selection/tests/test_search.py::test_validate_parameter_input[0-TypeError-Parameter\", \"sklearn/model_selection/tests/test_search.py::test_validate_parameter_input[input1-TypeError-Parameter\", \"sklearn/model_selection/tests/test_search.py::test_validate_parameter_input[input2-TypeError-Parameter.*\", \"sklearn/model_selection/tests/test_search.py::test_parameter_grid\", \"sklearn/model_selection/tests/test_search.py::test_grid_search\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_with_fit_params\", \"sklearn/model_selection/tests/test_search.py::test_random_search_with_fit_params\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_no_score\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_score_method\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_groups\", \"sklearn/model_selection/tests/test_search.py::test_classes__property\", \"sklearn/model_selection/tests/test_search.py::test_trivial_cv_results_attr\", \"sklearn/model_selection/tests/test_search.py::test_no_refit\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_error\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_one_grid_point\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_when_param_grid_includes_range\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_bad_param_grid\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_sparse\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_sparse_scoring\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_precomputed_kernel\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_precomputed_kernel_error_nonsquare\", \"sklearn/model_selection/tests/test_search.py::test_refit\", \"sklearn/model_selection/tests/test_search.py::test_refit_callable\", \"sklearn/model_selection/tests/test_search.py::test_refit_callable_invalid_type\", \"sklearn/model_selection/tests/test_search.py::test_refit_callable_out_bound[RandomizedSearchCV--1]\", \"sklearn/model_selection/tests/test_search.py::test_refit_callable_out_bound[RandomizedSearchCV-2]\", \"sklearn/model_selection/tests/test_search.py::test_refit_callable_out_bound[GridSearchCV--1]\", \"sklearn/model_selection/tests/test_search.py::test_refit_callable_out_bound[GridSearchCV-2]\", \"sklearn/model_selection/tests/test_search.py::test_refit_callable_multi_metric\", \"sklearn/model_selection/tests/test_search.py::test_gridsearch_nd\", \"sklearn/model_selection/tests/test_search.py::test_X_as_list\", \"sklearn/model_selection/tests/test_search.py::test_y_as_list\", \"sklearn/model_selection/tests/test_search.py::test_pandas_input\", \"sklearn/model_selection/tests/test_search.py::test_unsupervised_grid_search\", \"sklearn/model_selection/tests/test_search.py::test_gridsearch_no_predict\", \"sklearn/model_selection/tests/test_search.py::test_param_sampler\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_cv_results\", \"sklearn/model_selection/tests/test_search.py::test_random_search_cv_results\", \"sklearn/model_selection/tests/test_search.py::test_search_default_iid[GridSearchCV-specialized_params0]\", \"sklearn/model_selection/tests/test_search.py::test_search_default_iid[RandomizedSearchCV-specialized_params1]\", \"sklearn/model_selection/tests/test_search.py::test_search_iid_param\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_cv_results_multimetric\", \"sklearn/model_selection/tests/test_search.py::test_random_search_cv_results_multimetric\", \"sklearn/model_selection/tests/test_search.py::test_search_cv_results_rank_tie_breaking\", \"sklearn/model_selection/tests/test_search.py::test_search_cv_results_none_param\", \"sklearn/model_selection/tests/test_search.py::test_search_cv_timing\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_correct_score_results\", \"sklearn/model_selection/tests/test_search.py::test_fit_grid_point\", \"sklearn/model_selection/tests/test_search.py::test_pickle\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_with_multioutput_data\", \"sklearn/model_selection/tests/test_search.py::test_predict_proba_disabled\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_allows_nans\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_failing_classifier\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_failing_classifier_raise\", \"sklearn/model_selection/tests/test_search.py::test_parameters_sampler_replacement\", \"sklearn/model_selection/tests/test_search.py::test_stochastic_gradient_loss_param\", \"sklearn/model_selection/tests/test_search.py::test_search_train_scores_set_to_false\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_cv_splits_consistency\", \"sklearn/model_selection/tests/test_search.py::test_transform_inverse_transform_round_trip\", \"sklearn/model_selection/tests/test_search.py::test_custom_run_search\", \"sklearn/model_selection/tests/test_search.py::test__custom_fit_no_run_search\", \"sklearn/model_selection/tests/test_search.py::test_deprecated_grid_search_iid[False]\", \"sklearn/model_selection/tests/test_search.py::test_deprecated_grid_search_iid[True]\", \"sklearn/model_selection/tests/test_search.py::test_empty_cv_iterator_error\", \"sklearn/model_selection/tests/test_search.py::test_random_search_bad_cv\", \"sklearn/model_selection/tests/test_split.py::test_cross_validator_with_default_params\", \"sklearn/model_selection/tests/test_split.py::test_2d_y\", \"sklearn/model_selection/tests/test_split.py::test_kfold_valueerrors\", \"sklearn/model_selection/tests/test_split.py::test_kfold_indices\", \"sklearn/model_selection/tests/test_split.py::test_kfold_no_shuffle\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_ratios[5-False]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_ratios[5-True]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_ratios[10-False]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_ratios[10-True]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_label_invariance[4-False]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_label_invariance[6-False]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_kfold_label_invariance[7-False]\", \"sklearn/model_selection/tests/test_split.py::test_kfold_balance\", \"sklearn/model_selection/tests/test_split.py::test_stratifiedkfold_balance\", \"sklearn/model_selection/tests/test_split.py::test_shuffle_kfold\", \"sklearn/model_selection/tests/test_split.py::test_shuffle_kfold_stratifiedkfold_reproducibility\", \"sklearn/model_selection/tests/test_split.py::test_shuffle_stratifiedkfold\", \"sklearn/model_selection/tests/test_split.py::test_kfold_can_detect_dependent_samples_on_digits\", \"sklearn/model_selection/tests/test_split.py::test_shuffle_split\", \"sklearn/model_selection/tests/test_split.py::test_shuffle_split_default_test_size[None-9-1-ShuffleSplit]\", \"sklearn/model_selection/tests/test_split.py::test_shuffle_split_default_test_size[None-9-1-StratifiedShuffleSplit]\", \"sklearn/model_selection/tests/test_split.py::test_shuffle_split_default_test_size[8-8-2-ShuffleSplit]\", \"sklearn/model_selection/tests/test_split.py::test_shuffle_split_default_test_size[8-8-2-StratifiedShuffleSplit]\", \"sklearn/model_selection/tests/test_split.py::test_shuffle_split_default_test_size[0.8-8-2-ShuffleSplit]\", \"sklearn/model_selection/tests/test_split.py::test_shuffle_split_default_test_size[0.8-8-2-StratifiedShuffleSplit]\", \"sklearn/model_selection/tests/test_split.py::test_group_shuffle_split_default_test_size[None-8-2]\", \"sklearn/model_selection/tests/test_split.py::test_group_shuffle_split_default_test_size[7-7-3]\", \"sklearn/model_selection/tests/test_split.py::test_group_shuffle_split_default_test_size[0.7-7-3]\", \"sklearn/model_selection/tests/test_split.py::test_stratified_shuffle_split_init\", \"sklearn/model_selection/tests/test_split.py::test_stratified_shuffle_split_respects_test_size\", \"sklearn/model_selection/tests/test_split.py::test_stratified_shuffle_split_iter\", \"sklearn/model_selection/tests/test_split.py::test_stratified_shuffle_split_even\", \"sklearn/model_selection/tests/test_split.py::test_stratified_shuffle_split_overlap_train_test_bug\", \"sklearn/model_selection/tests/test_split.py::test_stratified_shuffle_split_multilabel\", \"sklearn/model_selection/tests/test_split.py::test_stratified_shuffle_split_multilabel_many_labels\", \"sklearn/model_selection/tests/test_split.py::test_predefinedsplit_with_kfold_split\", \"sklearn/model_selection/tests/test_split.py::test_group_shuffle_split\", \"sklearn/model_selection/tests/test_split.py::test_leave_one_p_group_out\", \"sklearn/model_selection/tests/test_split.py::test_leave_group_out_changing_groups\", \"sklearn/model_selection/tests/test_split.py::test_leave_one_p_group_out_error_on_fewer_number_of_groups\", \"sklearn/model_selection/tests/test_split.py::test_repeated_cv_value_errors\", \"sklearn/model_selection/tests/test_split.py::test_repeated_kfold_determinstic_split\", \"sklearn/model_selection/tests/test_split.py::test_get_n_splits_for_repeated_kfold\", \"sklearn/model_selection/tests/test_split.py::test_get_n_splits_for_repeated_stratified_kfold\", \"sklearn/model_selection/tests/test_split.py::test_repeated_stratified_kfold_determinstic_split\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_errors\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_invalid_sizes1[1.2-0.8]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_invalid_sizes1[1.0-0.8]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_invalid_sizes1[0.0-0.8]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_invalid_sizes1[-0.2-0.8]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_invalid_sizes1[0.8-1.2]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_invalid_sizes1[0.8-1.0]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_invalid_sizes1[0.8-0.0]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_invalid_sizes1[0.8--0.2]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_invalid_sizes2[-10-0.8]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_invalid_sizes2[0-0.8]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_invalid_sizes2[11-0.8]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_invalid_sizes2[0.8--10]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_invalid_sizes2[0.8-0]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_invalid_sizes2[0.8-11]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_default_test_size[None-7-3]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_default_test_size[8-8-2]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_default_test_size[0.8-8-2]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_pandas\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_sparse\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_mock_pandas\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_list_input\", \"sklearn/model_selection/tests/test_split.py::test_shufflesplit_errors[2.0-None]\", \"sklearn/model_selection/tests/test_split.py::test_shufflesplit_errors[1.0-None]\", \"sklearn/model_selection/tests/test_split.py::test_shufflesplit_errors[0.1-0.95]\", \"sklearn/model_selection/tests/test_split.py::test_shufflesplit_errors[None-train_size3]\", \"sklearn/model_selection/tests/test_split.py::test_shufflesplit_errors[11-None]\", \"sklearn/model_selection/tests/test_split.py::test_shufflesplit_errors[10-None]\", \"sklearn/model_selection/tests/test_split.py::test_shufflesplit_errors[8-3]\", \"sklearn/model_selection/tests/test_split.py::test_shufflesplit_reproducible\", \"sklearn/model_selection/tests/test_split.py::test_stratifiedshufflesplit_list_input\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_allow_nans\", \"sklearn/model_selection/tests/test_split.py::test_check_cv\", \"sklearn/model_selection/tests/test_split.py::test_cv_iterable_wrapper\", \"sklearn/model_selection/tests/test_split.py::test_group_kfold\", \"sklearn/model_selection/tests/test_split.py::test_time_series_cv\", \"sklearn/model_selection/tests/test_split.py::test_time_series_max_train_size\", \"sklearn/model_selection/tests/test_split.py::test_nested_cv\", \"sklearn/model_selection/tests/test_split.py::test_build_repr\", \"sklearn/model_selection/tests/test_split.py::test_shuffle_split_empty_trainset[ShuffleSplit]\", \"sklearn/model_selection/tests/test_split.py::test_shuffle_split_empty_trainset[GroupShuffleSplit]\", \"sklearn/model_selection/tests/test_split.py::test_shuffle_split_empty_trainset[StratifiedShuffleSplit]\", \"sklearn/model_selection/tests/test_split.py::test_train_test_split_empty_trainset\", \"sklearn/model_selection/tests/test_split.py::test_leave_one_out_empty_trainset\", \"sklearn/model_selection/tests/test_split.py::test_leave_p_out_empty_trainset\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_score\", \"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\", \"sklearn/model_selection/tests/test_validation.py::test_cross_validate_invalid_scoring_param\", \"sklearn/model_selection/tests/test_validation.py::test_cross_validate\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_score_predict_groups\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_score_pandas\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_score_mask\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_score_precomputed\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_score_fit_params\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_score_score_func\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_score_errors\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_score_with_score_func_classification\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_score_with_score_func_regression\", \"sklearn/model_selection/tests/test_validation.py::test_permutation_score\", \"sklearn/model_selection/tests/test_validation.py::test_permutation_test_score_allow_nans\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_score_allow_nans\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_score_multilabel\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_predict\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_predict_decision_function_shape\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_predict_predict_proba_shape\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_predict_predict_log_proba_shape\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_predict_input_types\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_predict_pandas\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_predict_unbalanced\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_score_sparse_fit_params\", \"sklearn/model_selection/tests/test_validation.py::test_learning_curve\", \"sklearn/model_selection/tests/test_validation.py::test_learning_curve_unsupervised\", \"sklearn/model_selection/tests/test_validation.py::test_learning_curve_verbose\", \"sklearn/model_selection/tests/test_validation.py::test_learning_curve_incremental_learning_not_possible\", \"sklearn/model_selection/tests/test_validation.py::test_learning_curve_incremental_learning\", \"sklearn/model_selection/tests/test_validation.py::test_learning_curve_incremental_learning_unsupervised\", \"sklearn/model_selection/tests/test_validation.py::test_learning_curve_batch_and_incremental_learning_are_equal\", \"sklearn/model_selection/tests/test_validation.py::test_learning_curve_n_sample_range_out_of_bounds\", \"sklearn/model_selection/tests/test_validation.py::test_learning_curve_remove_duplicate_sample_sizes\", \"sklearn/model_selection/tests/test_validation.py::test_learning_curve_with_boolean_indices\", \"sklearn/model_selection/tests/test_validation.py::test_learning_curve_with_shuffle\", \"sklearn/model_selection/tests/test_validation.py::test_validation_curve\", \"sklearn/model_selection/tests/test_validation.py::test_validation_curve_clone_estimator\", \"sklearn/model_selection/tests/test_validation.py::test_validation_curve_cv_splits_consistency\", \"sklearn/model_selection/tests/test_validation.py::test_check_is_permutation\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_predict_sparse_prediction\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_predict_with_method\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_predict_method_checking\", \"sklearn/model_selection/tests/test_validation.py::test_gridsearchcv_cross_val_predict_with_method\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_predict_with_method_multilabel_ovr\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_predict_with_method_multilabel_rf\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_predict_with_method_rare_class\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_predict_with_method_multilabel_rf_rare_class\", \"sklearn/model_selection/tests/test_validation.py::test_cross_val_predict_class_subset\", \"sklearn/model_selection/tests/test_validation.py::test_score_memmap\", \"sklearn/model_selection/tests/test_validation.py::test_permutation_test_score_pandas\", \"sklearn/model_selection/tests/test_validation.py::test_fit_and_score_failing\", \"sklearn/model_selection/tests/test_validation.py::test_fit_and_score_working\", \"sklearn/model_selection/tests/test_validation.py::test_fit_and_score_verbosity[False-three_params_scorer-[CV]\", \"sklearn/model_selection/tests/test_validation.py::test_fit_and_score_verbosity[True-three_params_scorer-[CV]\", \"sklearn/model_selection/tests/test_validation.py::test_fit_and_score_verbosity[True-scorer2-[CV]\", \"sklearn/model_selection/tests/test_validation.py::test_score\"]",
  "environment_setup_commit": "7e85a6d1f038bbb932b36f18d75df6be937ed00d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.006589",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}