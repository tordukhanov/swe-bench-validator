{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-13574",
  "base_commit": "b3934e4121cb382cd05aeb92662a636c8f7f539e",
  "patch": "diff --git a/sympy/matrices/dense.py b/sympy/matrices/dense.py\n--- a/sympy/matrices/dense.py\n+++ b/sympy/matrices/dense.py\n@@ -1278,6 +1278,7 @@ def hessian(f, varlist, constraints=[]):\n             out[j, i] = out[i, j]\n     return out\n \n+\n def jordan_cell(eigenval, n):\n     \"\"\"\n     Create a Jordan block:\n@@ -1386,33 +1387,36 @@ def randMatrix(r, c=None, min=0, max=99, seed=None, symmetric=False,\n     >>> A == randMatrix(3, seed=1)\n     True\n     >>> randMatrix(3, symmetric=True, percent=50) # doctest:+SKIP\n-    [0, 68, 43]\n-    [0, 68,  0]\n-    [0, 91, 34]\n+    [77, 70,  0],\n+    [70,  0,  0],\n+    [ 0,  0, 88]\n     \"\"\"\n     if c is None:\n         c = r\n     # Note that ``Random()`` is equivalent to ``Random(None)``\n     prng = prng or random.Random(seed)\n-    if symmetric and r != c:\n-        raise ValueError(\n-            'For symmetric matrices, r must equal c, but %i != %i' % (r, c))\n+\n     if not symmetric:\n         m = Matrix._new(r, c, lambda i, j: prng.randint(min, max))\n-    else:\n-        m = zeros(r)\n-        for i in range(r):\n-            for j in range(i, r):\n-                m[i, j] = prng.randint(min, max)\n-        for i in range(r):\n-            for j in range(i):\n-                m[i, j] = m[j, i]\n-    if percent == 100:\n-        return m\n-    else:\n-        z = int(r*c*percent // 100)\n+        if percent == 100:\n+            return m\n+        z = int(r*c*(100 - percent) // 100)\n         m._mat[:z] = [S.Zero]*z\n         prng.shuffle(m._mat)\n+\n+        return m\n+\n+    # Symmetric case\n+    if r != c:\n+        raise ValueError('For symmetric matrices, r must equal c, but %i != %i' % (r, c))\n+    m = zeros(r)\n+    ij = [(i, j) for i in range(r) for j in range(i, r)]\n+    if percent != 100:\n+        ij = prng.sample(ij, int(len(ij)*percent // 100))\n+\n+    for i, j in ij:\n+        value = prng.randint(min, max)\n+        m[i, j] = m[j, i] = value\n     return m\n \n \n",
  "test_patch": "diff --git a/sympy/matrices/tests/test_matrices.py b/sympy/matrices/tests/test_matrices.py\n--- a/sympy/matrices/tests/test_matrices.py\n+++ b/sympy/matrices/tests/test_matrices.py\n@@ -581,6 +581,20 @@ def test_random():\n     rng = random.Random(4)\n     assert M == randMatrix(3, symmetric=True, prng=rng)\n \n+    # Ensure symmetry\n+    for size in (10, 11): # Test odd and even\n+        for percent in (100, 70, 30):\n+            M = randMatrix(size, symmetric=True, percent=percent, prng=rng)\n+            assert M == M.T\n+\n+    M = randMatrix(10, min=1, percent=70)\n+    zero_count = 0\n+    for i in range(M.shape[0]):\n+        for j in range(M.shape[1]):\n+            if M[i, j] == 0:\n+                zero_count += 1\n+    assert zero_count == 30\n+\n \n def test_LUdecomp():\n     testmat = Matrix([[0, 2, 5, 3],\n",
  "problem_statement": " randMatrix won't generatte symmetric sparse matrices\nWhen setting the percent parameter to anything else than 100, randMatrix fails to generate symmetric matrices. Consider the following examples:\r\n\r\n' ' ' \r\nIn [1]: import sympy\r\n\r\nIn [2]: from sympy.matrices import randMatrix\r\n\r\nIn [3]: randMatrix(3, symmetric=True, percent=1)\r\nOut[3]: \r\nMatrix([\r\n[13, 61, 13],\r\n[59, 29, 59],\r\n[88, 13, 61]])\r\n\r\nIn [4]: randMatrix(3, symmetric=True, percent=50)\r\nOut[4]: \r\nMatrix([\r\n[90, 60,  0],\r\n[ 0,  0,  0],\r\n[60, 59, 25]])\r\n\r\nIn [7]: randMatrix(3, symmetric=True, percent=99)\r\nOut[7]: \r\nMatrix([\r\n[0, 0, 19],\r\n[0, 0,  0],\r\n[0, 0,  0]])\r\n\r\nIn [9]: randMatrix(3, symmetric=True, percent=0)\r\nOut[9]: \r\nMatrix([\r\n[78, 78, 61],\r\n[68,  8, 61],\r\n[22, 68,  8]])\r\n' ' ' \r\n\r\nAlso, the documentation says `If percent is less than 100 then only approximately the given percentage of elements will be non-zero.`, but the behaviour is the opposite. Setting it to 100 (default) produces the expected behaviour.\r\n\r\nThe problem happens with both the released version from pypi and git master.\n",
  "hints_text": "The problem is here:\r\n\r\nhttps://github.com/sympy/sympy/blob/master/sympy/matrices/dense.py#L1413-L1415\r\n\r\nAfter some values are set to 0, the matrix is shuffled, ruining the symmetry. I'm writing a fix.",
  "created_at": "2017-11-07T17:47:18Z",
  "version": "1.1",
  "FAIL_TO_PASS": "[\"test_random\"]",
  "PASS_TO_PASS": "[\"test_args\", \"test_division\", \"test_sum\", \"test_abs\", \"test_addition\", \"test_fancy_index_matrix\", \"test_multiplication\", \"test_power\", \"test_creation\", \"test_tolist\", \"test_as_mutable\", \"test_determinant\", \"test_det_LU_decomposition\", \"test_slicing\", \"test_submatrix_assignment\", \"test_extract\", \"test_reshape\", \"test_applyfunc\", \"test_expand\", \"test_LUdecomp\", \"test_LUsolve\", \"test_QRsolve\", \"test_inverse\", \"test_matrix_inverse_mod\", \"test_util\", \"test_jacobian_hessian\", \"test_QR\", \"test_QR_non_square\", \"test_nullspace\", \"test_columnspace\", \"test_wronskian\", \"test_eigen\", \"test_subs\", \"test_xreplace\", \"test_simplify\", \"test_transpose\", \"test_conjugate\", \"test_conj_dirac\", \"test_trace\", \"test_shape\", \"test_col_row_op\", \"test_zip_row_op\", \"test_issue_3950\", \"test_issue_3981\", \"test_evalf\", \"test_is_symbolic\", \"test_is_upper\", \"test_is_lower\", \"test_is_nilpotent\", \"test_zeros_ones_fill\", \"test_empty_zeros\", \"test_issue_3749\", \"test_inv_iszerofunc\", \"test_jacobian_metrics\", \"test_jacobian2\", \"test_issue_4564\", \"test_nonvectorJacobian\", \"test_vec\", \"test_vech\", \"test_vech_errors\", \"test_diag\", \"test_get_diag_blocks1\", \"test_get_diag_blocks2\", \"test_inv_block\", \"test_creation_args\", \"test_diagonal_symmetrical\", \"test_diagonalization\", \"test_jordan_form\", \"test_jordan_form_complex_issue_9274\", \"test_issue_10220\", \"test_Matrix_berkowitz_charpoly\", \"test_exp\", \"test_has\", \"test_LUdecomposition_Simple_iszerofunc\", \"test_LUdecomposition_iszerofunc\", \"test_find_reasonable_pivot_naive_finds_guaranteed_nonzero1\", \"test_find_reasonable_pivot_naive_finds_guaranteed_nonzero2\", \"test_find_reasonable_pivot_naive_simplifies\", \"test_errors\", \"test_len\", \"test_integrate\", \"test_limit\", \"test_diff\", \"test_getattr\", \"test_hessenberg\", \"test_cholesky\", \"test_LDLdecomposition\", \"test_cholesky_solve\", \"test_LDLsolve\", \"test_lower_triangular_solve\", \"test_upper_triangular_solve\", \"test_diagonal_solve\", \"test_matrix_norm\", \"test_condition_number\", \"test_equality\", \"test_col_join\", \"test_row_insert\", \"test_col_insert\", \"test_normalized\", \"test_print_nonzero\", \"test_zeros_eye\", \"test_is_zero\", \"test_rotation_matrices\", \"test_DeferredVector\", \"test_DeferredVector_not_iterable\", \"test_DeferredVector_Matrix\", \"test_GramSchmidt\", \"test_casoratian\", \"test_zero_dimension_multiply\", \"test_slice_issue_2884\", \"test_slice_issue_3401\", \"test_copyin\", \"test_invertible_check\", \"test_issue_5964\", \"test_issue_7604\", \"test_is_Identity\", \"test_dot\", \"test_dual\", \"test_anti_symmetric\", \"test_normalize_sort_diogonalization\", \"test_issue_5321\", \"test_issue_5320\", \"test_issue_11944\", \"test_cross\", \"test_hash\", \"test_adjoint\", \"test_simplify_immutable\", \"test_rank\", \"test_issue_11434\", \"test_rank_regression_from_so\", \"test_replace\", \"test_replace_map\", \"test_atoms\", \"test_pinv_solve\", \"test_gauss_jordan_solve\", \"test_issue_7201\", \"test_free_symbols\", \"test_hermitian\", \"test_doit\", \"test_issue_9457_9467_9876\", \"test_issue_9422\", \"test_issue_10770\", \"test_issue_10658\", \"test_opportunistic_simplification\", \"test_partial_pivoting\", \"test_iszero_substitution\", \"test_as_real_imag\"]",
  "environment_setup_commit": "ec9e3c0436fbff934fa84e22bf07f1b3ef5bfac3",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.084585",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}