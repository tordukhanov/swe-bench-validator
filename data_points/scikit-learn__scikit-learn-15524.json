{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-15524",
  "base_commit": "0aab6213948926f8e5990f8e878d57f2a899e876",
  "patch": "diff --git a/sklearn/model_selection/_search.py b/sklearn/model_selection/_search.py\n--- a/sklearn/model_selection/_search.py\n+++ b/sklearn/model_selection/_search.py\n@@ -414,6 +414,11 @@ def __init__(self, estimator, scoring=None, n_jobs=None, iid='deprecated',\n     def _estimator_type(self):\n         return self.estimator._estimator_type\n \n+    @property\n+    def _pairwise(self):\n+        # allows cross-validation to see 'precomputed' metrics\n+        return getattr(self.estimator, '_pairwise', False)\n+\n     def score(self, X, y=None):\n         \"\"\"Returns the score on the given data, if the estimator has been refit.\n \n",
  "test_patch": "diff --git a/sklearn/model_selection/tests/test_search.py b/sklearn/model_selection/tests/test_search.py\n--- a/sklearn/model_selection/tests/test_search.py\n+++ b/sklearn/model_selection/tests/test_search.py\n@@ -56,11 +56,13 @@\n from sklearn.tree import DecisionTreeClassifier\n from sklearn.cluster import KMeans\n from sklearn.neighbors import KernelDensity\n+from sklearn.neighbors import KNeighborsClassifier\n from sklearn.metrics import f1_score\n from sklearn.metrics import recall_score\n from sklearn.metrics import accuracy_score\n from sklearn.metrics import make_scorer\n from sklearn.metrics import roc_auc_score\n+from sklearn.metrics.pairwise import euclidean_distances\n from sklearn.impute import SimpleImputer\n from sklearn.pipeline import Pipeline\n from sklearn.linear_model import Ridge, SGDClassifier, LinearRegression\n@@ -1798,3 +1800,50 @@ def get_n_splits(self, *args, **kw):\n                              'inconsistent results. Expected \\\\d+ '\n                              'splits, got \\\\d+'):\n         ridge.fit(X[:train_size], y[:train_size])\n+\n+\n+def test_search_cv__pairwise_property_delegated_to_base_estimator():\n+    \"\"\"\n+    Test implementation of BaseSearchCV has the _pairwise property\n+    which matches the _pairwise property of its estimator.\n+    This test make sure _pairwise is delegated to the base estimator.\n+\n+    Non-regression test for issue #13920.\n+    \"\"\"\n+    est = BaseEstimator()\n+    attr_message = \"BaseSearchCV _pairwise property must match estimator\"\n+\n+    for _pairwise_setting in [True, False]:\n+        setattr(est, '_pairwise', _pairwise_setting)\n+        cv = GridSearchCV(est, {'n_neighbors': [10]})\n+        assert _pairwise_setting == cv._pairwise, attr_message\n+\n+\n+def test_search_cv__pairwise_property_equivalence_of_precomputed():\n+    \"\"\"\n+    Test implementation of BaseSearchCV has the _pairwise property\n+    which matches the _pairwise property of its estimator.\n+    This test ensures the equivalence of 'precomputed'.\n+\n+    Non-regression test for issue #13920.\n+    \"\"\"\n+    n_samples = 50\n+    n_splits = 2\n+    X, y = make_classification(n_samples=n_samples, random_state=0)\n+    grid_params = {'n_neighbors': [10]}\n+\n+    # defaults to euclidean metric (minkowski p = 2)\n+    clf = KNeighborsClassifier()\n+    cv = GridSearchCV(clf, grid_params, cv=n_splits)\n+    cv.fit(X, y)\n+    preds_original = cv.predict(X)\n+\n+    # precompute euclidean metric to validate _pairwise is working\n+    X_precomputed = euclidean_distances(X)\n+    clf = KNeighborsClassifier(metric='precomputed')\n+    cv = GridSearchCV(clf, grid_params, cv=n_splits)\n+    cv.fit(X_precomputed, y)\n+    preds_precomputed = cv.predict(X_precomputed)\n+\n+    attr_message = \"GridSearchCV not identical with precomputed metric\"\n+    assert (preds_original == preds_precomputed).all(), attr_message\n",
  "problem_statement": "Nested Cross Validation for precomputed KNN\n#### Description\r\nA nested cross validation prediction using a knn with precomputed metric raised an error\r\n\r\n\r\n#### Code to Reproduce\r\n```python\r\nfrom sklearn import datasets\r\nfrom sklearn.model_selection import cross_val_predict, GridSearchCV\r\nfrom sklearn.neighbors import KNeighborsClassifier\r\nfrom sklearn.metrics.pairwise import euclidean_distances\r\n\r\n# Open data\r\niris = datasets.load_iris()\r\n\r\n# Compute pairwise metric\r\nmetric = euclidean_distances(iris.data)\r\n\r\n# Create nested cross validation\r\nknn = KNeighborsClassifier(metric = 'precomputed')\r\nknngs = GridSearchCV(knn, param_grid={\"n_neighbors\": [1, 5, 10]})\r\npredicted = cross_val_predict(knngs, metric, iris.target, cv=10)\r\n```\r\n\r\n#### Expected Results\r\nShould return the predictions made by the model as the following code produces:\r\n\r\n```python\r\nfrom sklearn import datasets\r\nfrom sklearn.model_selection import cross_val_predict, GridSearchCV\r\nfrom sklearn.neighbors import KNeighborsClassifier\r\n\r\n# Open data\r\niris = datasets.load_iris()\r\n\r\n# Create nested cross validation\r\nknn = KNeighborsClassifier()\r\nknngs = GridSearchCV(knn, param_grid={\"n_neighbors\": [1, 5, 10]})\r\npredicted = cross_val_predict(knngs, iris.data, iris.target, cv=10)\r\n```\r\n\r\n\r\n#### Actual Results\r\n```\r\nValueError                                Traceback (most recent call last)\r\n<ipython-input-8-97c590e3aa1e> in <module>()\r\n     10 \r\n     11 knngs = GridSearchCV(knn, param_grid={\"n_neighbors\": [1, 5, 10]})\r\n---> 12 predicted = cross_val_predict(knngs, metric, iris.target, cv=10)\r\n\r\n/sklearn/model_selection/_validation.py in cross_val_predict(estimator, X, y, groups, cv, n_jobs, verbose, fit_params, pre_dispatch, method)\r\n    775     prediction_blocks = parallel(delayed(_fit_and_predict)(\r\n    776         clone(estimator), X, y, train, test, verbose, fit_params, method)\r\n--> 777         for train, test in cv.split(X, y, groups))\r\n    778 \r\n    779     # Concatenate the predictions\r\n\r\n/sklearn/externals/joblib/parallel.py in __call__(self, iterable)\r\n    915             # remaining jobs.\r\n    916             self._iterating = False\r\n--> 917             if self.dispatch_one_batch(iterator):\r\n    918                 self._iterating = self._original_iterator is not None\r\n    919 \r\n\r\n/sklearn/externals/joblib/parallel.py in dispatch_one_batch(self, iterator)\r\n    757                 return False\r\n    758             else:\r\n--> 759                 self._dispatch(tasks)\r\n    760                 return True\r\n    761 \r\n\r\n/sklearn/externals/joblib/parallel.py in _dispatch(self, batch)\r\n    714         with self._lock:\r\n    715             job_idx = len(self._jobs)\r\n--> 716             job = self._backend.apply_async(batch, callback=cb)\r\n    717             # A job can complete so quickly than its callback is\r\n    718             # called before we get here, causing self._jobs to\r\n\r\n/sklearn/externals/joblib/_parallel_backends.py in apply_async(self, func, callback)\r\n    180     def apply_async(self, func, callback=None):\r\n    181         \"\"\"Schedule a func to be run\"\"\"\r\n--> 182         result = ImmediateResult(func)\r\n    183         if callback:\r\n    184             callback(result)\r\n\r\n/sklearn/externals/joblib/_parallel_backends.py in __init__(self, batch)\r\n    547         # Don't delay the application, to avoid keeping the input\r\n    548         # arguments in memory\r\n--> 549         self.results = batch()\r\n    550 \r\n    551     def get(self):\r\n\r\n/sklearn/externals/joblib/parallel.py in __call__(self)\r\n    223         with parallel_backend(self._backend, n_jobs=self._n_jobs):\r\n    224             return [func(*args, **kwargs)\r\n--> 225                     for func, args, kwargs in self.items]\r\n    226 \r\n    227     def __len__(self):\r\n\r\n/sklearn/externals/joblib/parallel.py in <listcomp>(.0)\r\n    223         with parallel_backend(self._backend, n_jobs=self._n_jobs):\r\n    224             return [func(*args, **kwargs)\r\n--> 225                     for func, args, kwargs in self.items]\r\n    226 \r\n    227     def __len__(self):\r\n\r\n/sklearn/model_selection/_validation.py in _fit_and_predict(estimator, X, y, train, test, verbose, fit_params, method)\r\n    848         estimator.fit(X_train, **fit_params)\r\n    849     else:\r\n--> 850         estimator.fit(X_train, y_train, **fit_params)\r\n    851     func = getattr(estimator, method)\r\n    852     predictions = func(X_test)\r\n\r\n/sklearn/model_selection/_search.py in fit(self, X, y, groups, **fit_params)\r\n    720                 return results_container[0]\r\n    721 \r\n--> 722             self._run_search(evaluate_candidates)\r\n    723 \r\n    724         results = results_container[0]\r\n\r\n/sklearn/model_selection/_search.py in _run_search(self, evaluate_candidates)\r\n   1189     def _run_search(self, evaluate_candidates):\r\n   1190         \"\"\"Search all candidates in param_grid\"\"\"\r\n-> 1191         evaluate_candidates(ParameterGrid(self.param_grid))\r\n   1192 \r\n   1193 \r\n\r\n/sklearn/model_selection/_search.py in evaluate_candidates(candidate_params)\r\n    709                                for parameters, (train, test)\r\n    710                                in product(candidate_params,\r\n--> 711                                           cv.split(X, y, groups)))\r\n    712 \r\n    713                 all_candidate_params.extend(candidate_params)\r\n\r\n/sklearn/externals/joblib/parallel.py in __call__(self, iterable)\r\n    915             # remaining jobs.\r\n    916             self._iterating = False\r\n--> 917             if self.dispatch_one_batch(iterator):\r\n    918                 self._iterating = self._original_iterator is not None\r\n    919 \r\n\r\n/sklearn/externals/joblib/parallel.py in dispatch_one_batch(self, iterator)\r\n    757                 return False\r\n    758             else:\r\n--> 759                 self._dispatch(tasks)\r\n    760                 return True\r\n    761 \r\n\r\n/sklearn/externals/joblib/parallel.py in _dispatch(self, batch)\r\n    714         with self._lock:\r\n    715             job_idx = len(self._jobs)\r\n--> 716             job = self._backend.apply_async(batch, callback=cb)\r\n    717             # A job can complete so quickly than its callback is\r\n    718             # called before we get here, causing self._jobs to\r\n\r\n/sklearn/externals/joblib/_parallel_backends.py in apply_async(self, func, callback)\r\n    180     def apply_async(self, func, callback=None):\r\n    181         \"\"\"Schedule a func to be run\"\"\"\r\n--> 182         result = ImmediateResult(func)\r\n    183         if callback:\r\n    184             callback(result)\r\n\r\n/sklearn/externals/joblib/_parallel_backends.py in __init__(self, batch)\r\n    547         # Don't delay the application, to avoid keeping the input\r\n    548         # arguments in memory\r\n--> 549         self.results = batch()\r\n    550 \r\n    551     def get(self):\r\n\r\n/sklearn/externals/joblib/parallel.py in __call__(self)\r\n    223         with parallel_backend(self._backend, n_jobs=self._n_jobs):\r\n    224             return [func(*args, **kwargs)\r\n--> 225                     for func, args, kwargs in self.items]\r\n    226 \r\n    227     def __len__(self):\r\n\r\n/sklearn/externals/joblib/parallel.py in <listcomp>(.0)\r\n    223         with parallel_backend(self._backend, n_jobs=self._n_jobs):\r\n    224             return [func(*args, **kwargs)\r\n--> 225                     for func, args, kwargs in self.items]\r\n    226 \r\n    227     def __len__(self):\r\n\r\n/sklearn/model_selection/_validation.py in _fit_and_score(estimator, X, y, scorer, train, test, verbose, parameters, fit_params, return_train_score, return_parameters, return_n_test_samples, return_times, return_estimator, error_score)\r\n    516     start_time = time.time()\r\n    517 \r\n--> 518     X_train, y_train = _safe_split(estimator, X, y, train)\r\n    519     X_test, y_test = _safe_split(estimator, X, y, test, train)\r\n    520 \r\n\r\n/sklearn/utils/metaestimators.py in _safe_split(estimator, X, y, indices, train_indices)\r\n    195         # X is a precomputed square kernel matrix\r\n    196         if X.shape[0] != X.shape[1]:\r\n--> 197             raise ValueError(\"X should be a square kernel matrix\")\r\n    198         if train_indices is None:\r\n    199             X_subset = X[np.ix_(indices, indices)]\r\n\r\nValueError: X should be a square kernel matrix\r\n```\r\n\r\n#### Versions\r\nsklearn 0.20.2\r\n\n",
  "hints_text": "This seems to be because BaseSearchCV doesn't define the _pairwise property. It should, as should other meta-estimators.​\nThanks for the report. A patch is welcome.\n\n@Jeanselme are you working on a fix for this? I've been looking for a good first issue and happen to have done a couple projects with meta-estimators recently\nNo, I didn’t dig into the code, feel free to fix it. Thank you !\nGotcha. I think I'll give it a shot then \nThanks!\n\nNo problem! I think I might have found a small wrinkle in the plan, though.\r\n\r\nFixing the BaseSearchCV to have the _pairwise property is pretty straightforward and I think I've managed to set it up by just adding the _pairwise property kinda like #11453, or more explicitly just throwing this into BaseSearchCV:\r\n\r\n```python\r\n@property\r\ndef _pairwise(self):\r\n    # For cross-validation routines to split data correctly\r\n    return self.estimator.metric == 'precomputed'\r\n```\r\n\r\n\r\n....but I'm worried that doing so won't support someone wanting to compare 'precomputed' with other distance metrics within the same grid search. (e.g. for an exotic square X such as a normalized graph Laplacian matrix)\r\n\r\nFor example,\r\n```python\r\nfrom sklearn import datasets\r\nfrom sklearn.model_selection import cross_val_predict, GridSearchCV\r\nfrom sklearn.neighbors import KNeighborsClassifier\r\nfrom sklearn.metrics.pairwise import euclidean_distances\r\n\r\n# Open data\r\niris = datasets.load_iris()\r\n\r\n# Compute pairwise metric\r\nmetric = euclidean_distances(iris.data)\r\n\r\n# Create nested cross validation\r\nknn = KNeighborsClassifier()\r\nknngs = GridSearchCV(knn, param_grid={\"n_neighbors\": [1, 5, 10], \"metric\":[\"euclidean\", \"precomputed\"]}, cv=10)\r\npredicted = cross_val_predict(knngs, metric, iris.target, cv=10)\r\n```\r\n\r\nThis code would throw the same error even with the _pairwise fix in BaseSearchCV unless `knn = KNeighborsClassifier(metric='precomputed')`. However, forcing the base_estimator to have `metric='precomputed'` _will be inherited to all of the other estimators during search_, and  this will result in incorrectly slicing non-precomputed metrics during [`_safe_split`.](https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/utils/metaestimators.py) \r\n\r\nWe might have to disable precomputed distance metrics from being used jointly in a BaseSearchCV, if we just add a _pairwise property to it, otherwise I think we'd have to modify either [`_safe_split`](https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/utils/metaestimators.py) or [`evaluate_candidates`](https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/utils/metaestimators.py) in to simultaneously support 'precomputed' and other metrics.\nWe could certainly just take the easy way of adding the _pairwise property to BaseSearchCV and barring simultaneous searches of 'precomputed' with other distance metrics. Of course, someone else might see a better way to support simultaneity.\r\n\r\nAny thoughts/preferences?\nI think this is closer to the mark:\r\n```py\r\n@property\r\ndef _pairwise(self):\r\n    # For cross-validation routines to split data correctly\r\n    return getattr(self.estimator, '_pairwise', False)\r\n```\r\n\r\n> I'm worried that doing so won't support someone wanting to compare 'precomputed' with other distance metrics within the same grid search.\r\n\r\nI don't think that's reasonable in the sense that the precomputed input has completely different semantics (columns are samples) to non-precomputed (columns are features). \nThat is a good point. I'll adjust the code I've written based on your advice and submit when I can ",
  "created_at": "2019-11-03T00:40:19Z",
  "version": "0.22",
  "FAIL_TO_PASS": "[\"sklearn/model_selection/tests/test_search.py::test_search_cv__pairwise_property_delegated_to_base_estimator\"]",
  "PASS_TO_PASS": "[\"sklearn/model_selection/tests/test_search.py::test_validate_parameter_input[0-TypeError-Parameter\", \"sklearn/model_selection/tests/test_search.py::test_validate_parameter_input[input1-TypeError-Parameter\", \"sklearn/model_selection/tests/test_search.py::test_validate_parameter_input[input2-TypeError-Parameter.*\", \"sklearn/model_selection/tests/test_search.py::test_parameter_grid\", \"sklearn/model_selection/tests/test_search.py::test_grid_search\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_pipeline_steps\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_with_fit_params\", \"sklearn/model_selection/tests/test_search.py::test_random_search_with_fit_params\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_no_score\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_score_method\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_groups\", \"sklearn/model_selection/tests/test_search.py::test_classes__property\", \"sklearn/model_selection/tests/test_search.py::test_trivial_cv_results_attr\", \"sklearn/model_selection/tests/test_search.py::test_no_refit\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_error\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_one_grid_point\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_when_param_grid_includes_range\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_bad_param_grid\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_sparse\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_sparse_scoring\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_precomputed_kernel\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_precomputed_kernel_error_nonsquare\", \"sklearn/model_selection/tests/test_search.py::test_refit\", \"sklearn/model_selection/tests/test_search.py::test_refit_callable\", \"sklearn/model_selection/tests/test_search.py::test_refit_callable_invalid_type\", \"sklearn/model_selection/tests/test_search.py::test_refit_callable_out_bound[RandomizedSearchCV--1]\", \"sklearn/model_selection/tests/test_search.py::test_refit_callable_out_bound[RandomizedSearchCV-2]\", \"sklearn/model_selection/tests/test_search.py::test_refit_callable_out_bound[GridSearchCV--1]\", \"sklearn/model_selection/tests/test_search.py::test_refit_callable_out_bound[GridSearchCV-2]\", \"sklearn/model_selection/tests/test_search.py::test_refit_callable_multi_metric\", \"sklearn/model_selection/tests/test_search.py::test_gridsearch_nd\", \"sklearn/model_selection/tests/test_search.py::test_X_as_list\", \"sklearn/model_selection/tests/test_search.py::test_y_as_list\", \"sklearn/model_selection/tests/test_search.py::test_pandas_input\", \"sklearn/model_selection/tests/test_search.py::test_unsupervised_grid_search\", \"sklearn/model_selection/tests/test_search.py::test_gridsearch_no_predict\", \"sklearn/model_selection/tests/test_search.py::test_param_sampler\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_cv_results\", \"sklearn/model_selection/tests/test_search.py::test_random_search_cv_results\", \"sklearn/model_selection/tests/test_search.py::test_search_default_iid[GridSearchCV-specialized_params0]\", \"sklearn/model_selection/tests/test_search.py::test_search_default_iid[RandomizedSearchCV-specialized_params1]\", \"sklearn/model_selection/tests/test_search.py::test_search_iid_param\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_cv_results_multimetric\", \"sklearn/model_selection/tests/test_search.py::test_random_search_cv_results_multimetric\", \"sklearn/model_selection/tests/test_search.py::test_search_cv_results_rank_tie_breaking\", \"sklearn/model_selection/tests/test_search.py::test_search_cv_results_none_param\", \"sklearn/model_selection/tests/test_search.py::test_search_cv_timing\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_correct_score_results\", \"sklearn/model_selection/tests/test_search.py::test_fit_grid_point\", \"sklearn/model_selection/tests/test_search.py::test_pickle\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_with_multioutput_data\", \"sklearn/model_selection/tests/test_search.py::test_predict_proba_disabled\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_allows_nans\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_failing_classifier\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_failing_classifier_raise\", \"sklearn/model_selection/tests/test_search.py::test_parameters_sampler_replacement\", \"sklearn/model_selection/tests/test_search.py::test_stochastic_gradient_loss_param\", \"sklearn/model_selection/tests/test_search.py::test_search_train_scores_set_to_false\", \"sklearn/model_selection/tests/test_search.py::test_grid_search_cv_splits_consistency\", \"sklearn/model_selection/tests/test_search.py::test_transform_inverse_transform_round_trip\", \"sklearn/model_selection/tests/test_search.py::test_custom_run_search\", \"sklearn/model_selection/tests/test_search.py::test__custom_fit_no_run_search\", \"sklearn/model_selection/tests/test_search.py::test_deprecated_grid_search_iid[False]\", \"sklearn/model_selection/tests/test_search.py::test_deprecated_grid_search_iid[True]\", \"sklearn/model_selection/tests/test_search.py::test_empty_cv_iterator_error\", \"sklearn/model_selection/tests/test_search.py::test_random_search_bad_cv\", \"sklearn/model_selection/tests/test_search.py::test_search_cv__pairwise_property_equivalence_of_precomputed\"]",
  "environment_setup_commit": "7e85a6d1f038bbb932b36f18d75df6be937ed00d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.013553",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}