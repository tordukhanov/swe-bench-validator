{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-13259",
  "base_commit": "8850d4eb343002601ba3c8fb37cb20dcf4a551cb",
  "patch": "diff --git a/sympy/functions/elementary/hyperbolic.py b/sympy/functions/elementary/hyperbolic.py\n--- a/sympy/functions/elementary/hyperbolic.py\n+++ b/sympy/functions/elementary/hyperbolic.py\n@@ -1,6 +1,7 @@\n from __future__ import print_function, division\n \n from sympy.core import S, sympify, cacheit\n+from sympy.core.add import Add\n from sympy.core.function import Function, ArgumentIndexError, _coeff_isneg\n \n from sympy.functions.elementary.miscellaneous import sqrt\n@@ -33,6 +34,39 @@ class HyperbolicFunction(Function):\n     unbranched = True\n \n \n+def _peeloff_ipi(arg):\n+    \"\"\"\n+    Split ARG into two parts, a \"rest\" and a multiple of I*pi/2.\n+    This assumes ARG to be an Add.\n+    The multiple of I*pi returned in the second position is always a Rational.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy.functions.elementary.hyperbolic import _peeloff_ipi as peel\n+    >>> from sympy import pi, I\n+    >>> from sympy.abc import x, y\n+    >>> peel(x + I*pi/2)\n+    (x, I*pi/2)\n+    >>> peel(x + I*2*pi/3 + I*pi*y)\n+    (x + I*pi*y + I*pi/6, I*pi/2)\n+    \"\"\"\n+    for a in Add.make_args(arg):\n+        if a == S.Pi*S.ImaginaryUnit:\n+            K = S.One\n+            break\n+        elif a.is_Mul:\n+            K, p = a.as_two_terms()\n+            if p == S.Pi*S.ImaginaryUnit and K.is_Rational:\n+                break\n+    else:\n+        return arg, S.Zero\n+\n+    m1 = (K % S.Half)*S.Pi*S.ImaginaryUnit\n+    m2 = K*S.Pi*S.ImaginaryUnit - m1\n+    return arg - m2, m2\n+\n+\n class sinh(HyperbolicFunction):\n     r\"\"\"\n     The hyperbolic sine function, `\\frac{e^x - e^{-x}}{2}`.\n@@ -89,6 +123,11 @@ def eval(cls, arg):\n                 if _coeff_isneg(arg):\n                     return -cls(-arg)\n \n+            if arg.is_Add:\n+                x, m = _peeloff_ipi(arg)\n+                if m:\n+                    return sinh(m)*cosh(x) + cosh(m)*sinh(x)\n+\n             if arg.func == asinh:\n                 return arg.args[0]\n \n@@ -243,6 +282,11 @@ def eval(cls, arg):\n                 if _coeff_isneg(arg):\n                     return cls(-arg)\n \n+            if arg.is_Add:\n+                x, m = _peeloff_ipi(arg)\n+                if m:\n+                    return cosh(m)*cosh(x) + sinh(m)*sinh(x)\n+\n             if arg.func == asinh:\n                 return sqrt(1 + arg.args[0]**2)\n \n@@ -398,6 +442,15 @@ def eval(cls, arg):\n                 if _coeff_isneg(arg):\n                     return -cls(-arg)\n \n+            if arg.is_Add:\n+                x, m = _peeloff_ipi(arg)\n+                if m:\n+                    tanhm = tanh(m)\n+                    if tanhm is S.ComplexInfinity:\n+                        return coth(x)\n+                    else: # tanhm == 0\n+                        return tanh(x)\n+\n             if arg.func == asinh:\n                 x = arg.args[0]\n                 return x/sqrt(1 + x**2)\n@@ -530,6 +583,15 @@ def eval(cls, arg):\n                 if _coeff_isneg(arg):\n                     return -cls(-arg)\n \n+            if arg.is_Add:\n+                x, m = _peeloff_ipi(arg)\n+                if m:\n+                    cothm = coth(m)\n+                    if cotm is S.ComplexInfinity:\n+                        return coth(x)\n+                    else: # cothm == 0\n+                        return tanh(x)\n+\n             if arg.func == asinh:\n                 x = arg.args[0]\n                 return sqrt(1 + x**2)/x\ndiff --git a/sympy/functions/elementary/trigonometric.py b/sympy/functions/elementary/trigonometric.py\n--- a/sympy/functions/elementary/trigonometric.py\n+++ b/sympy/functions/elementary/trigonometric.py\n@@ -1018,10 +1018,10 @@ def eval(cls, arg):\n             x, m = _peeloff_pi(arg)\n             if m:\n                 tanm = tan(m)\n-                tanx = tan(x)\n                 if tanm is S.ComplexInfinity:\n                     return -cot(x)\n-                return (tanm + tanx)/(1 - tanm*tanx)\n+                else: # tanm == 0\n+                    return tan(x)\n \n         if arg.func is atan:\n             return arg.args[0]\n@@ -1300,14 +1300,10 @@ def eval(cls, arg):\n             x, m = _peeloff_pi(arg)\n             if m:\n                 cotm = cot(m)\n-                if cotm == 0:\n-                    return -tan(x)\n-                cotx = cot(x)\n                 if cotm is S.ComplexInfinity:\n-                    return cotx\n-                if cotm.is_Rational:\n-                    return (cotm*cotx - 1) / (cotm + cotx)\n-            return None\n+                    return cot(x)\n+                else: # cotm == 0\n+                    return -tan(x)\n \n         if arg.func is acot:\n             return arg.args[0]\ndiff --git a/sympy/simplify/fu.py b/sympy/simplify/fu.py\n--- a/sympy/simplify/fu.py\n+++ b/sympy/simplify/fu.py\n@@ -195,7 +195,7 @@\n from sympy.functions.elementary.trigonometric import (\n     cos, sin, tan, cot, sec, csc, sqrt, TrigonometricFunction)\n from sympy.functions.elementary.hyperbolic import (\n-    cosh, sinh, tanh, coth, HyperbolicFunction)\n+    cosh, sinh, tanh, coth, sech, csch, HyperbolicFunction)\n from sympy.core.compatibility import ordered, range\n from sympy.core.expr import Expr\n from sympy.core.mul import Mul\n@@ -2049,6 +2049,10 @@ def f(rv):\n             return I*tan(a)\n         elif rv.func is coth:\n             return cot(a)/I\n+        elif rv.func is sech:\n+            return sec(a)\n+        elif rv.func is csch:\n+            return csc(a)/I\n         else:\n             raise NotImplementedError('unhandled %s' % rv.func)\n \n@@ -2074,7 +2078,8 @@ def _osbornei(e, d):\n     def f(rv):\n         if not isinstance(rv, TrigonometricFunction):\n             return rv\n-        a = rv.args[0].xreplace({d: S.One})\n+        const, x = rv.args[0].as_independent(d, as_Add=True)\n+        a = x.xreplace({d: S.One}) + const*I\n         if rv.func is sin:\n             return sinh(a)/I\n         elif rv.func is cos:\n@@ -2084,9 +2089,9 @@ def f(rv):\n         elif rv.func is cot:\n             return coth(a)*I\n         elif rv.func is sec:\n-            return 1/cosh(a)\n+            return sech(a)\n         elif rv.func is csc:\n-            return I/sinh(a)\n+            return csch(a)*I\n         else:\n             raise NotImplementedError('unhandled %s' % rv.func)\n \n",
  "test_patch": "diff --git a/sympy/simplify/tests/test_fu.py b/sympy/simplify/tests/test_fu.py\n--- a/sympy/simplify/tests/test_fu.py\n+++ b/sympy/simplify/tests/test_fu.py\n@@ -1,10 +1,10 @@\n from sympy import (\n-    Add, Mul, S, Symbol, cos, cot, pi, I, sin, sqrt, tan, root,\n-    powsimp, symbols, sinh, cosh, tanh, coth, Dummy)\n+    Add, Mul, S, Symbol, cos, cot, pi, I, sin, sqrt, tan, root, csc, sec,\n+    powsimp, symbols, sinh, cosh, tanh, coth, sech, csch, Dummy)\n from sympy.simplify.fu import (\n     L, TR1, TR10, TR10i, TR11, TR12, TR12i, TR13, TR14, TR15, TR16,\n     TR111, TR2, TR2i, TR3, TR5, TR6, TR7, TR8, TR9, TRmorrie, _TR56 as T,\n-    hyper_as_trig, csc, fu, process_common_addends, sec, trig_split,\n+    hyper_as_trig, fu, process_common_addends, trig_split,\n     as_f_sign_1)\n from sympy.utilities.randtest import verify_numerically\n from sympy.core.compatibility import range\n@@ -349,18 +349,20 @@ def test_hyper_as_trig():\n     assert o(tanh(x), d) == I*tan(x*d)\n     assert o(coth(x), d) == cot(x*d)/I\n     assert o(cosh(x), d) == cos(x*d)\n-    for func in (sinh, cosh, tanh, coth):\n+    assert o(sech(x), d) == sec(x*d)\n+    assert o(csch(x), d) == csc(x*d)/I\n+    for func in (sinh, cosh, tanh, coth, sech, csch):\n         h = func(pi)\n         assert i(o(h, d), d) == h\n     # /!\\ the _osborne functions are not meant to work\n     # in the o(i(trig, d), d) direction so we just check\n     # that they work as they are supposed to work\n-    assert i(cos(x*y), y) == cosh(x)\n-    assert i(sin(x*y), y) == sinh(x)/I\n-    assert i(tan(x*y), y) == tanh(x)/I\n-    assert i(cot(x*y), y) == coth(x)*I\n-    assert i(sec(x*y), y) == 1/cosh(x)\n-    assert i(csc(x*y), y) == I/sinh(x)\n+    assert i(cos(x*y + z), y) == cosh(x + z*I)\n+    assert i(sin(x*y + z), y) == sinh(x + z*I)/I\n+    assert i(tan(x*y + z), y) == tanh(x + z*I)/I\n+    assert i(cot(x*y + z), y) == coth(x + z*I)*I\n+    assert i(sec(x*y + z), y) == sech(x + z*I)\n+    assert i(csc(x*y + z), y) == csch(x + z*I)*I\n \n \n def test_TR12i():\ndiff --git a/sympy/simplify/tests/test_trigsimp.py b/sympy/simplify/tests/test_trigsimp.py\n--- a/sympy/simplify/tests/test_trigsimp.py\n+++ b/sympy/simplify/tests/test_trigsimp.py\n@@ -276,6 +276,10 @@ def test_hyperbolic_simp():\n     assert trigsimp(y*tanh(x)**2/sinh(x)**2) == y/cosh(x)**2\n     assert trigsimp(coth(x)/cosh(x)) == 1/sinh(x)\n \n+    for a in (pi/6*I, pi/4*I, pi/3*I):\n+        assert trigsimp(sinh(a)*cosh(x) + cosh(a)*sinh(x)) == sinh(x + a)\n+        assert trigsimp(-sinh(a)*cosh(x) + cosh(a)*sinh(x)) == sinh(x - a)\n+\n     e = 2*cosh(x)**2 - 2*sinh(x)**2\n     assert trigsimp(log(e)) == log(2)\n \n",
  "problem_statement": "simplify: wrong simplification with trigonometric functions with complex arguments\nsympy version is 1.0\n\n```\n>>> from sympy import *\n>>> a = 2*sqrt(2)*I*cos(pi/6 - `I*asinh(5*sqrt(2)/2)/3)/3`\n>>> a\n2*sqrt(2)*I*cos(pi/6 - I*asinh(5*sqrt(2)/2)/3)/3\n>>> a.evalf()\n-0.333333333333333 + 1.0*I\n>>> b = a.simplify()\n>>> b\n2*sqrt(2)*I*cosh(pi/6 + asinh(5*sqrt(2)/2)/3)/3\n>>> b.evalf()\n1.6818694524863*I\n```\n\n> > > So **a** should equal **b** numerically, which is not at all the case. The reason seems to be  that \n> > > `cos(pi/6 -I*asinh() )` is converted into `cosh(pi/6 + asinh())` instead of \n> > > `cosh(I*pi/6 + asinh())`\n\nRemarkably: if we remove the factors in the expression above, simplify leaves the expression unchanged \n\n```\n>>> c= cos(pi/6 - I*asinh(5*sqrt(2)/2)/3)\n>>> c.simplify()\ncos(pi/6 - I*asinh(5*sqrt(2)/2)/3)\n```\n\n",
  "hints_text": "Can I work on this issue?\n\nGo for it.\n\nThis seems to be problem in hyper_as_trig(osborne) in fu.\nThe implemented osborne's rule isn't valid for simplification like TR10i.",
  "created_at": "2017-09-05T04:53:51Z",
  "version": "1.1",
  "FAIL_TO_PASS": "[\"test_hyper_as_trig\", \"test_hyperbolic_simp\"]",
  "PASS_TO_PASS": "[\"test_TR1\", \"test_TR2\", \"test_TR2i\", \"test_TR3\", \"test__TR56\", \"test_TR5\", \"test_TR6\", \"test_TR7\", \"test_TR8\", \"test_TR9\", \"test_TR10\", \"test_TR10i\", \"test_TR11\", \"test_TR12\", \"test_TR13\", \"test_L\", \"test_fu\", \"test_objective\", \"test_process_common_addends\", \"test_trig_split\", \"test_TRmorrie\", \"test_TR12i\", \"test_TR14\", \"test_TR15_16_17\", \"test_trigsimp1\", \"test_trigsimp1a\", \"test_trigsimp2\", \"test_issue_4373\", \"test_trigsimp3\", \"test_issue_4661\", \"test_issue_4494\", \"test_issue_5948\", \"test_issue_4775\", \"test_issue_4280\", \"test_issue_3210\", \"test_trigsimp_issues\", \"test_trigsimp_issue_2515\", \"test_trigsimp_issue_3826\", \"test_trigsimp_issue_4032\", \"test_trigsimp_issue_7761\", \"test_trigsimp_noncommutative\", \"test_trigsimp_groebner\", \"test_issue_2827_trigsimp_methods\", \"test_exptrigsimp\", \"test_powsimp_on_numbers\"]",
  "environment_setup_commit": "ec9e3c0436fbff934fa84e22bf07f1b3ef5bfac3",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.081650",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}