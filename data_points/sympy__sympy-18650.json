{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-18650",
  "base_commit": "fcefd30cfbc6c929fb50b99403a5764ca019a603",
  "patch": "diff --git a/sympy/core/power.py b/sympy/core/power.py\n--- a/sympy/core/power.py\n+++ b/sympy/core/power.py\n@@ -1022,6 +1022,11 @@ def pred(x):\n \n         rv = S.One\n         if cargs:\n+            if e.is_Rational:\n+                npow, cargs = sift(cargs, lambda x: x.is_Pow and\n+                    x.exp.is_Rational and x.base.is_number,\n+                    binary=True)\n+                rv = Mul(*[self.func(b.func(*b.args), e) for b in npow])\n             rv *= Mul(*[self.func(b, e, evaluate=False) for b in cargs])\n         if other:\n             rv *= self.func(Mul(*other), e, evaluate=False)\n",
  "test_patch": "diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1459,11 +1459,12 @@ def test_Pow_as_coeff_mul_doesnt_expand():\n     assert exp(x + exp(x + y)) != exp(x + exp(x)*exp(y))\n \n \n-def test_issue_3514():\n+def test_issue_3514_18626():\n     assert sqrt(S.Half) * sqrt(6) == 2 * sqrt(3)/2\n     assert S.Half*sqrt(6)*sqrt(2) == sqrt(3)\n     assert sqrt(6)/2*sqrt(2) == sqrt(3)\n     assert sqrt(6)*sqrt(2)/2 == sqrt(3)\n+    assert sqrt(8)**Rational(2, 3) == 2\n \n \n def test_make_args():\n",
  "problem_statement": "sqrt(8)**Rational(2, 3) doesn't simplify\n```py\r\n>>> sqrt(8)**Rational(2, 3)\r\n2**(1/3)*2**(2/3)\r\n```\r\n\r\nThe results should just be `2`.\n",
  "hints_text": "```\r\n>>> from sympy import sqrt, Rational, Pow\r\n>>> sqrt(8, evaluate=False)**Rational(2, 3)\r\n2\r\n>>> p = Pow(8, Rational(1,2), evaluate=False)\r\n>>> p.args\r\n(8, 1/2)\r\n>>> p = Pow(8, Rational(1,2))\r\n>>> p.args\r\n(2, sqrt(2))\r\n```\r\nI think it is because of `evaluate=False` which should be used in `as_base_exp(self)` to calculate `b, e`.\n```\r\n--- a/sympy/functions/elementary/miscellaneous.py\r\n+++ b/sympy/functions/elementary/miscellaneous.py\r\n@@ -56,7 +56,7 @@ def __new__(cls):\r\n ###############################################################################\r\n \r\n \r\n-def sqrt(arg, evaluate=None):\r\n+def sqrt(arg, evaluate=False):\r\n     \"\"\"Returns the principal square root.\r\n \r\n     Parameters\r\n\r\n```\r\nThis returns correct result\nsqrt(8) does return `2*sqrt(2)`, but it should work even for `(2*sqrt(2))**Rational(2, 3)`. The core has an algorithm that simplifies products of rational powers of rational numbers that isn't being applied correctly here. \n```\r\n>>> sqrt(8)**Rational(2, 3)\r\n2**(1/3)*2**(2/3)\r\n>>> powsimp(_)\r\n2\r\n```\r\n\r\n> that isn't being applied correctly here.\r\n\r\nor that isn't being applied ~correctly~ here. In `Mul._eval_power` this is not a special case of `b**(x/2)` so it is passed for power-base *expansion*. The reconstruction of commutative args `cargs` uses unevaluated `Pow(b,e, evaluate=False)` to reconstruct factors and then they are not recognized during Mul flattening as being able to combine.\r\n\nThis passes core without recursion errors:\r\n```diff\r\ndiff --git a/sympy/core/power.py b/sympy/core/power.py\r\nindex dcdbf63..57544fe 100644\r\n--- a/sympy/core/power.py\r\n+++ b/sympy/core/power.py\r\n@@ -1037,6 +1037,11 @@ def pred(x):\r\n \r\n         rv = S.One\r\n         if cargs:\r\n+            if e.is_Rational:\r\n+                npow, cargs = sift(cargs, lambda x: x.is_Pow and\r\n+                    x.exp.is_Rational and x.base.is_number,\r\n+                    binary=True)\r\n+                rv = Mul(*[self.func(b.func(*b.args), e) for b in npow])\r\n             rv *= Mul(*[self.func(b, e, evaluate=False) for b in cargs])\r\n         if other:\r\n             rv *= self.func(Mul(*other), e, evaluate=False)\r\ndiff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\r\nindex 807048d..6b05362 100644\r\n--- a/sympy/core/tests/test_arit.py\r\n+++ b/sympy/core/tests/test_arit.py\r\n@@ -1458,11 +1458,12 @@ def test_Pow_as_coeff_mul_doesnt_expand():\r\n     assert exp(x + exp(x + y)) != exp(x + exp(x)*exp(y))\r\n \r\n \r\n-def test_issue_3514():\r\n+def test_issue_3514_18626():\r\n     assert sqrt(S.Half) * sqrt(6) == 2 * sqrt(3)/2\r\n     assert S.Half*sqrt(6)*sqrt(2) == sqrt(3)\r\n     assert sqrt(6)/2*sqrt(2) == sqrt(3)\r\n     assert sqrt(6)*sqrt(2)/2 == sqrt(3)\r\n+    assert sqrt(8)**Rational(2, 3) == 2\r\n \r\n \r\n def test_make_args():\r\n```\nI'm having a weird situation: I edit `test_evaluate.py` but the edits don't show up in the git diff. Any ideas why this might be, @asmeurer ?\r\n\r\nThis test fails locally\r\n```python\r\nassert 10.333 * (S(1) / 2) == Mul(10.333, 2**-1)\r\n```\r\nI think it should be\r\n```python\r\nassert 10.333 * (S(1) / 2) == Mul(10.333, S(2)**-1)\r\n```\r\nWhen I run the tests they pass with this change but...the diff is not showing up.\nThe following also show as XPASSing in master:\r\n```\r\n________________________________ xpassed tests ____________\r\nsympy\\core\\tests\\test_arit.py: test_issue_3531\r\nsympy\\core\\tests\\test_arit.py: test_failing_Mod_Pow_nested\r\n```\nI think test_evaluate.py is some file that you have that isn't in master. I don't see it in the repo.\n> The reconstruction of commutative args cargs uses unevaluated Pow(b,e, evaluate=False) to reconstruct factors and then they are not recognized during Mul flattening as being able to combine.\r\n\r\nWhy does it use evaluate=False? \n> Why does it use evaluate=False?\r\n\r\nto avoid recursion errors. I didn't investigate deeply; I recall having these sort of issues in the past.\r\n\r\nAhh. `test_evaluate` was renamed in `8a0c402f71a1e91bc99f8fc91bb54cdd792c5be8`. I saw it in gitk but didn't notice the note indicating the rename.\n`git clean -n` to the rescue. Thanks, @asmeurer \nAlways having a local checkout with no untracked files has advantages, although I personally can't manage it myself with sympy because I have so many untracked scratch files. If you use the git prompt that comes with git it uses % at the end to indicate untracked files and you can choose to be aggressive about removing those with `git clean`.\n@smichr are you of the opinion that this should auto-evaluate or not? I thought that Mul and Pow always fully canonicalized rational powers of rational numbers. But maybe what really happens is that they are split but not always necessarily combined.  \nI tend to think it should. When Pow passes to Mul for the power-base expansion it isn't expecting that there would be things that will combine. The diff suggested allows numerical factors to reevaluate so they can be combined during Mul flattening.",
  "created_at": "2020-02-13T18:01:04Z",
  "version": "1.6",
  "FAIL_TO_PASS": "[\"test_issue_3514_18626\"]",
  "PASS_TO_PASS": "[\"test_bug1\", \"test_Symbol\", \"test_arit0\", \"test_div\", \"test_pow\", \"test_pow2\", \"test_pow3\", \"test_mod_pow\", \"test_pow_E\", \"test_pow_issue_3516\", \"test_pow_im\", \"test_real_mul\", \"test_ncmul\", \"test_ncpow\", \"test_powerbug\", \"test_Mul_doesnt_expand_exp\", \"test_Add_Mul_is_integer\", \"test_Add_Mul_is_finite\", \"test_Mul_is_even_odd\", \"test_evenness_in_ternary_integer_product_with_even\", \"test_oddness_in_ternary_integer_product_with_even\", \"test_Mul_is_rational\", \"test_Add_is_rational\", \"test_Add_is_even_odd\", \"test_Mul_is_negative_positive\", \"test_Mul_is_negative_positive_2\", \"test_Mul_is_nonpositive_nonnegative\", \"test_Add_is_negative_positive\", \"test_Add_is_nonpositive_nonnegative\", \"test_Pow_is_integer\", \"test_Pow_is_real\", \"test_real_Pow\", \"test_Pow_is_finite\", \"test_Pow_is_even_odd\", \"test_Pow_is_negative_positive\", \"test_Pow_is_zero\", \"test_Pow_is_nonpositive_nonnegative\", \"test_Mul_is_imaginary_real\", \"test_Mul_hermitian_antihermitian\", \"test_Add_is_comparable\", \"test_Mul_is_comparable\", \"test_Pow_is_comparable\", \"test_Add_is_positive_2\", \"test_Add_is_irrational\", \"test_Mul_is_irrational\", \"test_issue_3531b\", \"test_bug3\", \"test_suppressed_evaluation\", \"test_Add_as_coeff_mul\", \"test_Pow_as_coeff_mul_doesnt_expand\", \"test_make_args\", \"test_issue_5126\", \"test_Rational_as_content_primitive\", \"test_Add_as_content_primitive\", \"test_Mul_as_content_primitive\", \"test_Pow_as_content_primitive\", \"test_issue_5460\", \"test_product_irrational\", \"test_issue_5919\", \"test_Mod\", \"test_Mod_Pow\", \"test_Mod_is_integer\", \"test_Mod_is_nonposneg\", \"test_issue_6001\", \"test_polar\", \"test_issue_6040\", \"test_issue_6082\", \"test_issue_6077\", \"test_mul_flatten_oo\", \"test_add_flatten\", \"test_issue_5160_6087_6089_6090\", \"test_float_int_round\", \"test_issue_6611a\", \"test_denest_add_mul\", \"test_mul_coeff\", \"test_mul_zero_detection\", \"test_Mul_with_zero_infinite\", \"test_Mul_does_not_cancel_infinities\", \"test_Mul_does_not_distribute_infinity\", \"test_issue_8247_8354\", \"test_Add_is_zero\", \"test_issue_14392\", \"test_divmod\", \"test__neg__\"]",
  "environment_setup_commit": "28b41c73c12b70d6ad9f6e45109a80649c4456da",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.125610",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}