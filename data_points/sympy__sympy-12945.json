{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-12945",
  "base_commit": "3a771edb034c81957c0975ca06f0e0d51ab3741b",
  "patch": "diff --git a/sympy/core/basic.py b/sympy/core/basic.py\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -303,13 +303,6 @@ def __eq__(self, other):\n         if self is other:\n             return True\n \n-        from .function import AppliedUndef, UndefinedFunction as UndefFunc\n-\n-        if isinstance(self, UndefFunc) and isinstance(other, UndefFunc):\n-            if self.class_key() == other.class_key():\n-                return True\n-            else:\n-                return False\n         if type(self) is not type(other):\n             # issue 6100 a**1.0 == a like a**2.0 == a**2\n             if isinstance(self, Pow) and self.exp == 1:\n@@ -321,11 +314,7 @@ def __eq__(self, other):\n             except SympifyError:\n                 return False    # sympy != other\n \n-            if isinstance(self, AppliedUndef) and isinstance(other,\n-                                                             AppliedUndef):\n-                if self.class_key() != other.class_key():\n-                    return False\n-            elif type(self) is not type(other):\n+            if type(self) != type(other):\n                 return False\n \n         return self._hashable_content() == other._hashable_content()\ndiff --git a/sympy/core/function.py b/sympy/core/function.py\n--- a/sympy/core/function.py\n+++ b/sympy/core/function.py\n@@ -32,7 +32,7 @@\n from __future__ import print_function, division\n \n from .add import Add\n-from .assumptions import ManagedProperties\n+from .assumptions import ManagedProperties, _assume_defined\n from .basic import Basic\n from .cache import cacheit\n from .compatibility import iterable, is_sequence, as_int, ordered\n@@ -315,7 +315,8 @@ def _eval_subs(self, old, new):\n \n \n class Function(Application, Expr):\n-    \"\"\"Base class for applied mathematical functions.\n+    \"\"\"\n+    Base class for applied mathematical functions.\n \n     It also serves as a constructor for undefined function classes.\n \n@@ -340,6 +341,16 @@ class Function(Application, Expr):\n     >>> g.diff(x)\n     Derivative(g(x), x)\n \n+    Assumptions can be passed to Function.\n+\n+    >>> f_real = Function('f', real=True)\n+    >>> f_real(x).is_real\n+    True\n+\n+    Note that assumptions on a function are unrelated to the assumptions on\n+    the variable it is called on. If you want to add a relationship, subclass\n+    Function and define the appropriate ``_eval_is_assumption`` methods.\n+\n     In the following example Function is used as a base class for\n     ``my_func`` that represents a mathematical function *my_func*. Suppose\n     that it is well known, that *my_func(0)* is *1* and *my_func* at infinity\n@@ -383,6 +394,7 @@ class Function(Application, Expr):\n     ...     nargs = (1, 2)\n     ...\n     >>>\n+\n     \"\"\"\n \n     @property\n@@ -777,7 +789,14 @@ class UndefinedFunction(FunctionClass):\n     \"\"\"\n     def __new__(mcl, name, bases=(AppliedUndef,), __dict__=None, **kwargs):\n         __dict__ = __dict__ or {}\n+        # Allow Function('f', real=True)\n+        __dict__.update({'is_' + arg: val for arg, val in kwargs.items() if arg in _assume_defined})\n+        # You can add other attributes, although they do have to be hashable\n+        # (but seriously, if you want to add anything other than assumptions,\n+        # just subclass Function)\n         __dict__.update(kwargs)\n+        # Save these for __eq__\n+        __dict__.update({'_extra_kwargs': kwargs})\n         __dict__['__module__'] = None # For pickling\n         ret = super(UndefinedFunction, mcl).__new__(mcl, name, bases, __dict__)\n         return ret\n@@ -785,8 +804,18 @@ def __new__(mcl, name, bases=(AppliedUndef,), __dict__=None, **kwargs):\n     def __instancecheck__(cls, instance):\n         return cls in type(instance).__mro__\n \n-UndefinedFunction.__eq__ = lambda s, o: (isinstance(o, s.__class__) and\n-                                         (s.class_key() == o.class_key()))\n+    _extra_kwargs = {}\n+\n+    def __hash__(self):\n+        return hash((self.class_key(), frozenset(self._extra_kwargs.items())))\n+\n+    def __eq__(self, other):\n+        return (isinstance(other, self.__class__) and\n+            self.class_key() == other.class_key() and\n+            self._extra_kwargs == other._extra_kwargs)\n+\n+    def __ne__(self, other):\n+        return not self == other\n \n class WildFunction(Function, AtomicExpr):\n     \"\"\"\ndiff --git a/sympy/utilities/lambdify.py b/sympy/utilities/lambdify.py\n--- a/sympy/utilities/lambdify.py\n+++ b/sympy/utilities/lambdify.py\n@@ -667,7 +667,8 @@ def implemented_function(symfunc, implementation):\n     ----------\n     symfunc : ``str`` or ``UndefinedFunction`` instance\n        If ``str``, then create new ``UndefinedFunction`` with this as\n-       name.  If `symfunc` is a sympy function, attach implementation to it.\n+       name.  If `symfunc` is an Undefined function, create a new function\n+       with the same name and the implemented function attached.\n     implementation : callable\n        numerical implementation to be called by ``evalf()`` or ``lambdify``\n \n@@ -682,7 +683,7 @@ def implemented_function(symfunc, implementation):\n     >>> from sympy.abc import x\n     >>> from sympy.utilities.lambdify import lambdify, implemented_function\n     >>> from sympy import Function\n-    >>> f = implemented_function(Function('f'), lambda x: x+1)\n+    >>> f = implemented_function('f', lambda x: x+1)\n     >>> lam_f = lambdify(x, f(x))\n     >>> lam_f(4)\n     5\n@@ -690,11 +691,15 @@ def implemented_function(symfunc, implementation):\n     # Delayed import to avoid circular imports\n     from sympy.core.function import UndefinedFunction\n     # if name, create function to hold implementation\n+    _extra_kwargs = {}\n+    if isinstance(symfunc, UndefinedFunction):\n+        _extra_kwargs = symfunc._extra_kwargs\n+        symfunc = symfunc.__name__\n     if isinstance(symfunc, string_types):\n-        symfunc = UndefinedFunction(symfunc)\n+        # Keyword arguments to UndefinedFunction are added as attributes to\n+        # the created class.\n+        symfunc = UndefinedFunction(symfunc, _imp_=staticmethod(implementation), **_extra_kwargs)\n     elif not isinstance(symfunc, UndefinedFunction):\n         raise ValueError('symfunc should be either a string or'\n                          ' an UndefinedFunction instance.')\n-    # We need to attach as a method because symfunc will be a class\n-    symfunc._imp_ = staticmethod(implementation)\n     return symfunc\n",
  "test_patch": "diff --git a/sympy/core/tests/test_function.py b/sympy/core/tests/test_function.py\n--- a/sympy/core/tests/test_function.py\n+++ b/sympy/core/tests/test_function.py\n@@ -828,3 +828,34 @@ def test_issue_12005():\n     e5 = Subs(Derivative(f(x), x), (y, z), (y, z))\n     assert e5.diff(x) == Derivative(f(x), x, x)\n     assert f(g(x)).diff(g(x), g(x)) == Subs(Derivative(f(y), y, y), (y,), (g(x),))\n+\n+def test_undefined_function_eq():\n+    f = Function('f')\n+    f2 = Function('f')\n+    g = Function('g')\n+    f_real = Function('f', is_real=True)\n+\n+    # This test may only be meaningful if the cache is turned off\n+    assert f == f2\n+    assert hash(f) == hash(f2)\n+    assert f == f\n+\n+    assert f != g\n+\n+    assert f != f_real\n+\n+def test_function_assumptions():\n+    x = Symbol('x')\n+    f = Function('f')\n+    f_real = Function('f', real=True)\n+\n+    assert f != f_real\n+    assert f(x) != f_real(x)\n+\n+    assert f(x).is_real is None\n+    assert f_real(x).is_real is True\n+\n+    # Can also do it this way, but it won't be equal to f_real because of the\n+    # way UndefinedFunction.__new__ works.\n+    f_real2 = Function('f', is_real=True)\n+    assert f_real2(x).is_real is True\ndiff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -610,7 +610,7 @@ def test_imps():\n     func = sympy.Function('myfunc')\n     assert not hasattr(func, '_imp_')\n     my_f = implemented_function(func, lambda x: 2*x)\n-    assert hasattr(func, '_imp_')\n+    assert hasattr(my_f, '_imp_')\n     # Error for functions with same name and different implementation\n     f2 = implemented_function(\"f\", lambda x: x + 101)\n     raises(ValueError, lambda: lambdify(x, f(f2(x))))\n",
  "problem_statement": "Assumptions do not work for Functions\n```\nIn [73]: Function('W', real=True)(x).expand(complex=True)\nOut[73]: re(W(re(x) + ⅈ⋅im(x))) + ⅈ⋅im(W(re(x) + ⅈ⋅im(x)))\n\nIn [74]: Function('W', real=True)(x).is_real\nNone\n\nIt should also inherit any assumptions from Symbol if created using Symbol.__call__.\n```\n\nOriginal issue for #6494: http://code.google.com/p/sympy/issues/detail?id=3395\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n",
  "hints_text": "",
  "created_at": "2017-07-11T16:06:18Z",
  "version": "1.1",
  "FAIL_TO_PASS": "[\"test_undefined_function_eq\"]",
  "PASS_TO_PASS": "[\"test_f_expand_complex\", \"test_bug1\", \"test_general_function\", \"test_derivative_subs_bug\", \"test_derivative_subs_self_bug\", \"test_derivative_linearity\", \"test_derivative_evaluate\", \"test_diff_symbols\", \"test_Function\", \"test_nargs\", \"test_Lambda\", \"test_IdentityFunction\", \"test_Lambda_symbols\", \"test_Lambda_arguments\", \"test_Lambda_equality\", \"test_expand_function\", \"test_function_comparable\", \"test_deriv1\", \"test_deriv2\", \"test_func_deriv\", \"test_suppressed_evaluation\", \"test_function_evalf\", \"test_extensibility_eval\", \"test_function_non_commutative\", \"test_function_complex\", \"test_doit\", \"test_evalf_default\", \"test_issue_5399\", \"test_derivative_numerically\", \"test_fdiff_argument_index_error\", \"test_deriv_wrt_function\", \"test_diff_wrt_value\", \"test_diff_wrt\", \"test_diff_wrt_func_subs\", \"test_diff_wrt_not_allowed\", \"test_klein_gordon_lagrangian\", \"test_sho_lagrangian\", \"test_straight_line\", \"test_sort_variable\", \"test_unhandled\", \"test_issue_4711\", \"test_issue_7068\", \"test_issue_7687\", \"test_issue_7688\", \"test_mexpand\", \"test_issue_8469\", \"test_Derivative_as_finite_difference\", \"test_issue_11159\", \"test_issue_12005\", \"test_no_args\", \"test_single_arg\", \"test_list_args\", \"test_str_args\", \"test_own_namespace\", \"test_own_module\", \"test_bad_args\", \"test_atoms\", \"test_sympy_lambda\", \"test_math_lambda\", \"test_mpmath_lambda\", \"test_number_precision\", \"test_mpmath_precision\", \"test_math_transl\", \"test_mpmath_transl\", \"test_exponentiation\", \"test_sqrt\", \"test_trig\", \"test_vector_simple\", \"test_vector_discontinuous\", \"test_trig_symbolic\", \"test_trig_float\", \"test_docs\", \"test_math\", \"test_sin\", \"test_matrix\", \"test_issue9474\", \"test_integral\", \"test_sym_single_arg\", \"test_sym_list_args\", \"test_namespace_order\", \"test_imps\", \"test_imps_errors\", \"test_imps_wrong_args\", \"test_lambdify_imps\", \"test_dummification\", \"test_python_keywords\", \"test_lambdify_docstring\", \"test_special_printers\", \"test_true_false\", \"test_issue_2790\", \"test_issue_12092\", \"test_ITE\", \"test_Min_Max\"]",
  "environment_setup_commit": "ec9e3c0436fbff934fa84e22bf07f1b3ef5bfac3",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.078760",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}