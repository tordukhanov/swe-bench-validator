{
  "repo": "psf/requests",
  "instance_id": "psf__requests-2754",
  "base_commit": "0acbf2b91d9a196a58535e926531f810d44c4d3f",
  "patch": "diff --git a/requests/sessions.py b/requests/sessions.py\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -13,7 +13,7 @@\n from datetime import datetime\n \n from .auth import _basic_auth_str\n-from .compat import cookielib, OrderedDict, urljoin, urlparse\n+from .compat import cookielib, OrderedDict, urljoin, urlparse, is_py3, str\n from .cookies import (\n     cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar, merge_cookies)\n from .models import Request, PreparedRequest, DEFAULT_REDIRECT_LIMIT\n@@ -132,6 +132,13 @@ def resolve_redirects(self, response, stream=False, timeout=None,\n             parsed = urlparse(location_url)\n             location_url = parsed.geturl()\n \n+            # On Python 3, the location header was decoded using Latin 1, but\n+            # urlparse in requote_uri will encode it with UTF-8 before quoting.\n+            # Because of this insanity, we need to fix it up ourselves by\n+            # sending the URL back to bytes ourselves.\n+            if is_py3 and isinstance(location_url, str):\n+                location_url = location_url.encode('latin1')\n+\n             # Facilitate relative 'location' headers, as allowed by RFC 7231.\n             # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n             # Compliant with RFC3986, we percent encode the url.\ndiff --git a/requests/utils.py b/requests/utils.py\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -26,7 +26,7 @@\n from .compat import parse_http_list as _parse_list_header\n from .compat import (quote, urlparse, bytes, str, OrderedDict, unquote, is_py2,\n                      builtin_str, getproxies, proxy_bypass, urlunparse,\n-                     basestring)\n+                     basestring, is_py3)\n from .cookies import RequestsCookieJar, cookiejar_from_dict\n from .structures import CaseInsensitiveDict\n from .exceptions import InvalidURL, FileModeWarning\n@@ -422,7 +422,26 @@ def unquote_unreserved(uri):\n     \"\"\"Un-escape any percent-escape sequences in a URI that are unreserved\n     characters. This leaves all reserved, illegal and non-ASCII bytes encoded.\n     \"\"\"\n-    parts = uri.split('%')\n+    # This convert function is used to optionally convert the output of `chr`.\n+    # In Python 3, `chr` returns a unicode string, while in Python 2 it returns\n+    # a bytestring. Here we deal with that by optionally converting.\n+    def convert(is_bytes, c):\n+        if is_py2 and not is_bytes:\n+            return c.decode('ascii')\n+        elif is_py3 and is_bytes:\n+            return c.encode('ascii')\n+        else:\n+            return c\n+\n+    # Handle both bytestrings and unicode strings.\n+    is_bytes = isinstance(uri, bytes)\n+    splitchar = u'%'\n+    base = u''\n+    if is_bytes:\n+        splitchar = splitchar.encode('ascii')\n+        base = base.encode('ascii')\n+\n+    parts = uri.split(splitchar)\n     for i in range(1, len(parts)):\n         h = parts[i][0:2]\n         if len(h) == 2 and h.isalnum():\n@@ -432,12 +451,12 @@ def unquote_unreserved(uri):\n                 raise InvalidURL(\"Invalid percent-escape sequence: '%s'\" % h)\n \n             if c in UNRESERVED_SET:\n-                parts[i] = c + parts[i][2:]\n+                parts[i] = convert(is_bytes, c) + parts[i][2:]\n             else:\n-                parts[i] = '%' + parts[i]\n+                parts[i] = splitchar + parts[i]\n         else:\n-            parts[i] = '%' + parts[i]\n-    return ''.join(parts)\n+            parts[i] = splitchar + parts[i]\n+    return base.join(parts)\n \n \n def requote_uri(uri):\n",
  "test_patch": "diff --git a/test_requests.py b/test_requests.py\n--- a/test_requests.py\n+++ b/test_requests.py\n@@ -17,7 +17,7 @@\n from requests.auth import HTTPDigestAuth, _basic_auth_str\n from requests.compat import (\n     Morsel, cookielib, getproxies, str, urljoin, urlparse, is_py3,\n-    builtin_str, OrderedDict)\n+    builtin_str, OrderedDict, is_py2)\n from requests.cookies import cookiejar_from_dict, morsel_to_cookie\n from requests.exceptions import (\n     ConnectionError, ConnectTimeout, InvalidScheme, InvalidURL, MissingScheme,\n@@ -1468,6 +1468,20 @@ def test_requote_uri_properly_requotes(self):\n         quoted = 'http://example.com/fiz?buz=%25ppicture'\n         assert quoted == requote_uri(quoted)\n \n+    def test_unquote_unreserved_handles_unicode(self):\n+        \"\"\"Unicode strings can be passed to unquote_unreserved\"\"\"\n+        from requests.utils import unquote_unreserved\n+        uri = u'http://example.com/fizz?buzz=%41%2C'\n+        unquoted = u'http://example.com/fizz?buzz=A%2C'\n+        assert unquoted == unquote_unreserved(uri)\n+\n+    def test_unquote_unreserved_handles_bytes(self):\n+        \"\"\"Bytestrings can be passed to unquote_unreserved\"\"\"\n+        from requests.utils import unquote_unreserved\n+        uri = b'http://example.com/fizz?buzz=%41%2C'\n+        unquoted = b'http://example.com/fizz?buzz=A%2C'\n+        assert unquoted == unquote_unreserved(uri)\n+\n \n class TestMorselToCookieExpires:\n     \"\"\"Tests for morsel_to_cookie when morsel contains expires.\"\"\"\n@@ -1589,6 +1603,7 @@ def __init__(self, order_of_redirects):\n         self.max_redirects = 30\n         self.cookies = {}\n         self.trust_env = False\n+        self.location = '/'\n \n     def send(self, *args, **kwargs):\n         self.calls.append(SendCall(args, kwargs))\n@@ -1603,7 +1618,7 @@ def build_response(self):\n         except IndexError:\n             r.status_code = 200\n \n-        r.headers = CaseInsensitiveDict({'Location': '/'})\n+        r.headers = CaseInsensitiveDict({'Location': self.location})\n         r.raw = self._build_raw()\n         r.request = request\n         return r\n@@ -1637,6 +1652,18 @@ def test_requests_are_updated_each_time(self, httpbin):\n                                  TestRedirects.default_keyword_args)\n             assert session.calls[-1] == send_call\n \n+    @pytest.mark.skipif(is_py2, reason=\"requires python 3\")\n+    def test_redirects_with_latin1_header(self, httpbin):\n+        \"\"\"Test that redirect headers decoded with Latin 1 are correctly\n+        followed\"\"\"\n+        session = RedirectSession([303])\n+        session.location = u'http://xn--n8jyd3c767qtje.xn--q9jyb4c/ã\\x83\\x96ã\\x83\\xadã\\x82°/'\n+        prep = requests.Request('GET', httpbin('get')).prepare()\n+        r0 = session.send(prep)\n+\n+        responses = list(session.resolve_redirects(r0, prep))\n+        assert len(responses) == 1\n+        assert responses[0].request.url == u'http://xn--n8jyd3c767qtje.xn--q9jyb4c/%E3%83%96%E3%83%AD%E3%82%B0/'\n \n @pytest.fixture\n def list_of_tuples():\n",
  "problem_statement": ".htaccesss redirect to non ASCII folder does not work\nHello,\n\nI have the following setup on a shared hoster:\n- Apache 2.2.15\n- A Japanese language .みんな (.minna; xn--q9jyb4c) IDN domain.\n- A blog which is in the subfolder ブログ (blog)\n- A redirect in the .htaccess file like this: `Redirect /index.html /ブログ/`\n\nSo I usually open the domain http://test.みんな and the server redirects to http://test.みんな/ブログ. This works fine in Firefox etc.\n\nWith requests, I get the following error (Python 3.4 with Requests 2.7.0 on a Japanese Ubuntu 15.04):\n\n```\n'<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\\n<html><head>\\n<title>404 Not Found</title>\\n</head><body>\\n<h1>Not Found</h1>\\n<p>The requested URL /Ã£Â\\x83Â\\x96Ã£Â\\x83Â\\xadÃ£Â\\x82Â°/ was not found on this server.</p>\\n<hr>\\n<address>Apache/2.2.15 (CentOS) Server at test.xn--q9jyb4c Port 80</address>\\n</body></html>\\n'\n```\n\nSo I guess the request lib gets a redirect from a server with Japanese characters, but then fails to convert the characters correctly. If I do `requests.get(http://test.みんな/ブログ)` directly it works, only the redirect does not.\n\n",
  "hints_text": "Is that error output from response.content or response.text? If it's text, can you show me response.content please?\n\nCould you also show us\n\n``` py\nprint(response.request.url)\nprint(response.history)\nfor resp in response.history:\n    print('---')\n    print('Request URI: {}'.format(resp.request.url))\n    print('Status: {}'.format(resp.status_code))\n    print('Location: {}'.format(resp.headers['Location']))\n```\n\nHello, thanks for your answer.\n\n@Lukasa \nThis is both from response.text and from response.content:\n\n``` python\nIn [3]: r = requests.get(\"http://test.みんな\")\nIn [5]: r.text\nOut[5]: '<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\\n<html><head>\\n<title>404 Not Found</title>\\n</head><body>\\n<h1>Not Found</h1>\\n<p>The requested URL /Ã£Â\\x83Â\\x96Ã£Â\\x83Â\\xadÃ£Â\\x82Â°/ was not found on this server.</p>\\n<hr>\\n<address>Apache/2.2.15 (CentOS) Server at test.xn--q9jyb4c Port 80</address>\\n</body></html>\\n'\nIn [6]: r.content\nOut[6]: b'<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\\n<html><head>\\n<title>404 Not Found</title>\\n</head><body>\\n<h1>Not Found</h1>\\n<p>The requested URL /\\xc3\\xa3\\xc2\\x83\\xc2\\x96\\xc3\\xa3\\xc2\\x83\\xc2\\xad\\xc3\\xa3\\xc2\\x82\\xc2\\xb0/ was not found on this server.</p>\\n<hr>\\n<address>Apache/2.2.15 (CentOS) Server at test.xn--q9jyb4c Port 80</address>\\n</body></html>\\n'\n```\n\n@sigmavirus24 \n\n``` python\nIn [9]: r.request.url\nOut[9]: 'http://test.xn--q9jyb4c/%C3%A3%C2%83%C2%96%C3%A3%C2%83%C2%AD%C3%A3%C2%82%C2%B0/'\n\nIn [11]: r.history\nOut[11]: [<Response [302]>]\n\nIn [13]: for resp in r.history:\n   ....:         print('---')\n   ....:         print('Request URI: {}'.format(resp.request.url))\n   ....:         print('Status: {}'.format(resp.status_code))\n   ....:         print('Location: {}'.format(resp.headers['Location']))\n---\nRequest URI: http://test.xn--q9jyb4c/\nStatus: 302\nLocation: http://test.xn--q9jyb4c/ãã­ã°/\n```\n\nMaybe it is also a problem that the Apache server sends the header in ISO-8859-1? But this would likely be a problem of the shared hoster setup, I guess?\n\n``` python\nIn [21]: r.history[0].headers\nOut[21]: {'server': 'Apache/2.2.15 (CentOS)', 'content-type': 'text/html; charset=iso-8859-1', 'location': 'http://test.xn--q9jyb4c/ã\\x83\\x96ã\\x83\\xadã\\x82°/', 'content-length': '328', 'date': 'Sat, 27 Jun 2015 19:02:37 GMT', 'connection': 'close'}\n```\n\nI am sorry that I have obfuscated my original domain. Can I somehow privately send it to you? I would not really like to have it here on Github for all eternity, but of course I have no problem sending it directly to you so that you can check it out.\n\nSo it looks like the redirect URI is encoded in shift-JIS. Requests receives those bytes and puts them back on the wire. I wonder if we're hurting when we round trip.\n\nYou can mail me at cory [at] lukasa [dot] co [dot] uk.\n\nOk, this is a Python 3 bug. Everything works fine if I use Python 2. This is because on Python 2 the bytestring Location header is treated as a bytestring, which we turn into a bytestring URI, which we then correctly percent-encode and send back to urllib3.\n\nPython 3 doesn't work like that. If I use httplib directly:\n\n``` python\n>>> import http.client\n>>> c = http.client.HTTPConnection('変哲もない.みんな', 80)\n>>> c.request('GET', '/')\n>>> r = c.getresponse()\n>>> r.getheader('Location')\n'http://xn--n8jyd3c767qtje.xn--q9jyb4c/ã\\x83\\x96ã\\x83\\xadã\\x82°/'\n```\n\nNotice that this is a unicode string, but it's weirdly a Latin-1 encoded string. I think somewhere in our stack we're re-encoding this as UTF-8, where we should re-encode it as Latin-1.\n\nOk, this problem seems to boil down to our `requote_uri` function:\n\n``` python\n>>> url = 'http://xn--n8jyd3c767qtje.xn--q9jyb4c/ã\\x83\\x96ã\\x83\\xadã\\x82°/'\n>>> requote_uri(url)\n'http://xn--n8jyd3c767qtje.xn--q9jyb4c/%C3%A3%C2%83%C2%96%C3%A3%C2%83%C2%AD%C3%A3%C2%82%C2%B0/'\n```\n\nThis is the wrong URI: specifically, it has been treated as utf-8 and it should have been treated as latin-1.\n\nThe problem actually appears to be with passing the string directly to `urllib.parse.quote`:\n\n``` python\n>>> from urllib.parse import quote\n>>> >>> quote('/ã\\x83\\x96ã\\x83\\xadã\\x82°/')\n'/%C3%A3%C2%83%C2%96%C3%A3%C2%83%C2%AD%C3%A3%C2%82%C2%B0/'\n>>> quote('/ã\\x83\\x96ã\\x83\\xadã\\x82°/'.encode('latin1'))\n'/%E3%83%96%E3%83%AD%E3%82%B0/'\n```\n\nSo, my bet is that `quote` makes a UTF-8 assumption that is simply not valid.\n\nYup, just checked the code: that's exactly what it does.\n\nSo, this is a bit tricky now. I _think_ we want to round-trip through `Latin1`, but I have to work out where best to do it.\n\nOr is it rather a problem of the Apache setup on my web hoster? Because it replies as ISO-8859-1, not as UTF-8.\n\nNo, I think Python screwed this up. Out of interest, if it's easy, can you set it to reply with UTF-8 and see if that changes anything?\n\nSorry, I guess not, I don't have root access. It is a shared hoster (albeit a really cool one; www.uberspace.de). \n\nMy suspicion is that Python's httplib is decoding the header as latin 1, which means if we re-encode with latin 1 we'll get exactly the bytes your server sent. I need to confirm that though. Time to dumpster dive through the code. ;)\n\nYup, httplib definitely decodes as 'iso-8859-1' on Python 3. Ok, we can do special case hellishness to fix this. =D\n\nIt's a little frustrating that these two parts of the stdlib are inconsistent, but there we go.\n",
  "created_at": "2015-09-01T08:35:36Z",
  "version": "3.0",
  "FAIL_TO_PASS": "[\"test_requests.py::TestUtils::test_unquote_unreserved_handles_bytes\"]",
  "PASS_TO_PASS": "[\"test_requests.py::TestRequests::test_entry_points\", \"test_requests.py::TestRequests::test_invalid_url[MissingScheme-hiwpefhipowhefopw]\", \"test_requests.py::TestRequests::test_invalid_url[InvalidScheme-localhost:3128]\", \"test_requests.py::TestRequests::test_invalid_url[InvalidScheme-localhost.localdomain:3128/]\", \"test_requests.py::TestRequests::test_invalid_url[InvalidScheme-10.122.1.1:3128/]\", \"test_requests.py::TestRequests::test_invalid_url[InvalidURL-http://]\", \"test_requests.py::TestRequests::test_basic_building\", \"test_requests.py::TestRequests::test_path_is_not_double_encoded\", \"test_requests.py::TestRequests::test_params_are_added_before_fragment[http://example.com/path#fragment-http://example.com/path?a=b#fragment]\", \"test_requests.py::TestRequests::test_params_are_added_before_fragment[http://example.com/path?key=value#fragment-http://example.com/path?key=value&a=b#fragment]\", \"test_requests.py::TestRequests::test_params_original_order_is_preserved_by_default\", \"test_requests.py::TestRequests::test_params_bytes_are_encoded\", \"test_requests.py::TestRequests::test_binary_put\", \"test_requests.py::TestRequests::test_errors[http://doesnotexist.google.com-ConnectionError]\", \"test_requests.py::TestRequests::test_errors[http://localhost:1-ConnectionError]\", \"test_requests.py::TestRequests::test_errors[http://fe80::5054:ff:fe5a:fc0-InvalidURL]\", \"test_requests.py::TestRequests::test_prepare_request_with_bytestring_url\", \"test_requests.py::TestRequests::test_links\", \"test_requests.py::TestRequests::test_cookie_parameters\", \"test_requests.py::TestRequests::test_cookie_as_dict_keeps_len\", \"test_requests.py::TestRequests::test_cookie_as_dict_keeps_items\", \"test_requests.py::TestRequests::test_cookie_as_dict_keys\", \"test_requests.py::TestRequests::test_cookie_as_dict_values\", \"test_requests.py::TestRequests::test_cookie_as_dict_items\", \"test_requests.py::TestRequests::test_response_is_iterable\", \"test_requests.py::TestRequests::test_response_decode_unicode\", \"test_requests.py::TestRequests::test_get_auth_from_url\", \"test_requests.py::TestRequests::test_get_auth_from_url_encoded_spaces\", \"test_requests.py::TestRequests::test_get_auth_from_url_not_encoded_spaces\", \"test_requests.py::TestRequests::test_get_auth_from_url_percent_chars\", \"test_requests.py::TestRequests::test_get_auth_from_url_encoded_hashes\", \"test_requests.py::TestRequests::test_http_error\", \"test_requests.py::TestRequests::test_transport_adapter_ordering\", \"test_requests.py::TestRequests::test_long_authinfo_in_url\", \"test_requests.py::TestRequests::test_nonhttp_schemes_dont_check_URLs\", \"test_requests.py::TestRequests::test_basic_auth_str_is_always_native\", \"test_requests.py::TestContentEncodingDetection::test_none\", \"test_requests.py::TestContentEncodingDetection::test_pragmas[<meta\", \"test_requests.py::TestContentEncodingDetection::test_pragmas[<?xml\", \"test_requests.py::TestContentEncodingDetection::test_precedence\", \"test_requests.py::TestCaseInsensitiveDict::test_init[cid0]\", \"test_requests.py::TestCaseInsensitiveDict::test_init[cid1]\", \"test_requests.py::TestCaseInsensitiveDict::test_init[cid2]\", \"test_requests.py::TestCaseInsensitiveDict::test_docstring_example\", \"test_requests.py::TestCaseInsensitiveDict::test_len\", \"test_requests.py::TestCaseInsensitiveDict::test_getitem\", \"test_requests.py::TestCaseInsensitiveDict::test_fixes_649\", \"test_requests.py::TestCaseInsensitiveDict::test_delitem\", \"test_requests.py::TestCaseInsensitiveDict::test_contains\", \"test_requests.py::TestCaseInsensitiveDict::test_get\", \"test_requests.py::TestCaseInsensitiveDict::test_update\", \"test_requests.py::TestCaseInsensitiveDict::test_update_retains_unchanged\", \"test_requests.py::TestCaseInsensitiveDict::test_iter\", \"test_requests.py::TestCaseInsensitiveDict::test_equality\", \"test_requests.py::TestCaseInsensitiveDict::test_setdefault\", \"test_requests.py::TestCaseInsensitiveDict::test_lower_items\", \"test_requests.py::TestCaseInsensitiveDict::test_preserve_key_case\", \"test_requests.py::TestCaseInsensitiveDict::test_preserve_last_key_case\", \"test_requests.py::TestCaseInsensitiveDict::test_copy\", \"test_requests.py::TestUtils::test_super_len_io_streams\", \"test_requests.py::TestUtils::test_super_len_correctly_calculates_len_of_partially_read_file\", \"test_requests.py::TestUtils::test_get_environ_proxies_ip_ranges\", \"test_requests.py::TestUtils::test_get_environ_proxies\", \"test_requests.py::TestUtils::test_select_proxies\", \"test_requests.py::TestUtils::test_guess_filename_when_int\", \"test_requests.py::TestUtils::test_guess_filename_when_filename_is_an_int\", \"test_requests.py::TestUtils::test_guess_filename_with_file_like_obj\", \"test_requests.py::TestUtils::test_guess_filename_with_unicode_name\", \"test_requests.py::TestUtils::test_is_ipv4_address\", \"test_requests.py::TestUtils::test_is_valid_cidr\", \"test_requests.py::TestUtils::test_dotted_netmask\", \"test_requests.py::TestUtils::test_address_in_network\", \"test_requests.py::TestUtils::test_get_auth_from_url\", \"test_requests.py::TestUtils::test_requote_uri_with_unquoted_percents\", \"test_requests.py::TestUtils::test_requote_uri_properly_requotes\", \"test_requests.py::TestUtils::test_unquote_unreserved_handles_unicode\", \"test_requests.py::TestMorselToCookieExpires::test_expires_valid_str\", \"test_requests.py::TestMorselToCookieExpires::test_expires_invalid_int[100-TypeError]\", \"test_requests.py::TestMorselToCookieExpires::test_expires_invalid_int[woops-ValueError]\", \"test_requests.py::TestMorselToCookieExpires::test_expires_none\", \"test_requests.py::TestMorselToCookieMaxAge::test_max_age_valid_int\", \"test_requests.py::TestMorselToCookieMaxAge::test_max_age_invalid_str\", \"test_requests.py::TestTimeout::test_connect_timeout\", \"test_requests.py::TestTimeout::test_total_timeout_connect\", \"test_requests.py::test_data_argument_accepts_tuples\", \"test_requests.py::test_prepared_request_empty_copy\", \"test_requests.py::test_prepared_request_no_cookies_copy\", \"test_requests.py::test_prepared_request_complete_copy\", \"test_requests.py::test_prepare_unicode_url\", \"test_requests.py::test_prepare_requires_a_request_method\", \"test_requests.py::test_vendor_aliases\"]",
  "environment_setup_commit": "f3cdbcb86d9535f054f56d937e29293cebc3c55d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.860524",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}