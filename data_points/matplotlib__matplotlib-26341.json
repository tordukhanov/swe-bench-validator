{
  "repo": "matplotlib/matplotlib",
  "instance_id": "matplotlib__matplotlib-26341",
  "base_commit": "2aee6ccd7c7e1f8d282c1e7579f4ee546b838542",
  "patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -2,7 +2,6 @@\n from contextlib import ExitStack\n import functools\n import inspect\n-import itertools\n import logging\n from numbers import Real\n from operator import attrgetter\n@@ -224,18 +223,11 @@ def __init__(self, command='plot'):\n         self.command = command\n         self.set_prop_cycle(None)\n \n-    def __getstate__(self):\n-        # note: it is not possible to pickle a generator (and thus a cycler).\n-        return {'command': self.command}\n-\n-    def __setstate__(self, state):\n-        self.__dict__ = state.copy()\n-        self.set_prop_cycle(None)\n-\n     def set_prop_cycle(self, cycler):\n         if cycler is None:\n             cycler = mpl.rcParams['axes.prop_cycle']\n-        self.prop_cycler = itertools.cycle(cycler)\n+        self._idx = 0\n+        self._cycler_items = [*cycler]\n         self._prop_keys = cycler.keys  # This should make a copy\n \n     def __call__(self, axes, *args, data=None, **kwargs):\n@@ -315,7 +307,9 @@ def get_next_color(self):\n         \"\"\"Return the next color in the cycle.\"\"\"\n         if 'color' not in self._prop_keys:\n             return 'k'\n-        return next(self.prop_cycler)['color']\n+        c = self._cycler_items[self._idx]['color']\n+        self._idx = (self._idx + 1) % len(self._cycler_items)\n+        return c\n \n     def _getdefaults(self, ignore, kw):\n         \"\"\"\n@@ -328,7 +322,8 @@ def _getdefaults(self, ignore, kw):\n         if any(kw.get(k, None) is None for k in prop_keys):\n             # Need to copy this dictionary or else the next time around\n             # in the cycle, the dictionary could be missing entries.\n-            default_dict = next(self.prop_cycler).copy()\n+            default_dict = self._cycler_items[self._idx].copy()\n+            self._idx = (self._idx + 1) % len(self._cycler_items)\n             for p in ignore:\n                 default_dict.pop(p, None)\n         else:\ndiff --git a/lib/matplotlib/sankey.py b/lib/matplotlib/sankey.py\n--- a/lib/matplotlib/sankey.py\n+++ b/lib/matplotlib/sankey.py\n@@ -723,7 +723,7 @@ def _get_angle(a, r):\n             fc = kwargs.pop('fc', kwargs.pop('facecolor', None))\n             lw = kwargs.pop('lw', kwargs.pop('linewidth', None))\n         if fc is None:\n-            fc = next(self.ax._get_patches_for_fill.prop_cycler)['color']\n+            fc = self.ax._get_patches_for_fill.get_next_color()\n         patch = PathPatch(Path(vertices, codes), fc=fc, lw=lw, **kwargs)\n         self.ax.add_patch(patch)\n \n",
  "test_patch": "diff --git a/lib/matplotlib/tests/test_cycles.py b/lib/matplotlib/tests/test_cycles.py\n--- a/lib/matplotlib/tests/test_cycles.py\n+++ b/lib/matplotlib/tests/test_cycles.py\n@@ -1,3 +1,6 @@\n+import contextlib\n+from io import StringIO\n+\n import matplotlib as mpl\n import matplotlib.pyplot as plt\n import numpy as np\n@@ -120,15 +123,22 @@ def test_valid_input_forms():\n \n def test_cycle_reset():\n     fig, ax = plt.subplots()\n+    prop0 = StringIO()\n+    prop1 = StringIO()\n+    prop2 = StringIO()\n+\n+    with contextlib.redirect_stdout(prop0):\n+        plt.getp(ax.plot([1, 2], label=\"label\")[0])\n \n-    # Can't really test a reset because only a cycle object is stored\n-    # but we can test the first item of the cycle.\n-    prop = next(ax._get_lines.prop_cycler)\n     ax.set_prop_cycle(linewidth=[10, 9, 4])\n-    assert prop != next(ax._get_lines.prop_cycler)\n+    with contextlib.redirect_stdout(prop1):\n+        plt.getp(ax.plot([1, 2], label=\"label\")[0])\n+    assert prop1.getvalue() != prop0.getvalue()\n+\n     ax.set_prop_cycle(None)\n-    got = next(ax._get_lines.prop_cycler)\n-    assert prop == got\n+    with contextlib.redirect_stdout(prop2):\n+        plt.getp(ax.plot([1, 2], label=\"label\")[0])\n+    assert prop2.getvalue() == prop0.getvalue()\n \n \n def test_invalid_input_forms():\ndiff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -292,3 +292,12 @@ def test_dynamic_norm():\n def test_vertexselector():\n     line, = plt.plot([0, 1], picker=True)\n     pickle.loads(pickle.dumps(VertexSelector(line)))\n+\n+\n+def test_cycler():\n+    ax = plt.figure().add_subplot()\n+    ax.set_prop_cycle(c=[\"c\", \"m\", \"y\", \"k\"])\n+    ax.plot([1, 2])\n+    ax = pickle.loads(pickle.dumps(ax))\n+    l, = ax.plot([3, 4])\n+    assert l.get_color() == \"m\"\n",
  "problem_statement": "[MNT]: Make cyclers indexable and rely on indexing them rather than itertools.cycle\n### Summary\n\nCurrently the prop_cycle code (in _process_plot_var_args) creates an itertools.cycle over the Cycler instance to yield the successive line properties.  itertools.cycle objects are opaque, which creates some difficulties e.g. in _parse_scatter_color_args which needs to use self._get_patches_for_fill.get_next_color to workaround the impossibility to peek at the next color in the cycle without advancing the iterator, and also with pickling (currently we just completely drop the cycler state when pickling/unpickling).\r\n\r\nAn alternative would be to drop the use of itertools.cycle and instead simply store in _process_plot_var_args both the Cycler object and an integer index, which simply gets incremented at each use, and add support for indexing Cyclers (perhaps something like `cycler.get_nth(idx)` or forcing the caller to explicitly write `cycler[idx % len(cycler)]`, to avoid confusion with the fact that `len(cycler)` returns the finite, non-cycled length).\r\nThis would both make peeking at the next color easier, and directly solve the issue of picklability.\n\n### Proposed fix\n\n_No response_\n",
  "hints_text": "xref matplotlib/cycler#27 matplotlib/cycler#8\r\n\r\nTechnically it is _possible_ to do indexing to the cycler object (though of course the itertools.cycle wrapper obscures this internally, as you mention, and it is not super pretty):\r\n\r\n```python\r\nnext(iter(mpl.rcParams[\"axes.prop_cycle\"][2:]))\r\n```\r\n\r\n- Slicing on cycler is only implemented currently for slice object, not integer indices\r\n- `next(cycler)` raises, so we need `next(iter(cycler))`\r\n\r\nThat said, it does feel odd that a cycler object won't actually cycle on its own...\n> That said, it does feel odd that a cycler object won't actually cycle on its own...\r\n\r\nIf they cycled on their own the composition would break\nCurrently, `Cycler` as a collection type implements `Iterable` and `Sized` (plus some non-canonical behavior). We may consider making it a more refined collection type such as `Sequence`. See https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes\nThis may be better discussed on the cycler repo, but adding a `FiniteCycler` subclass that supports indexing may be the way to go.",
  "created_at": "2023-07-18T09:13:18Z",
  "version": "3.7",
  "FAIL_TO_PASS": "[\"lib/matplotlib/tests/test_pickle.py::test_cycler\"]",
  "PASS_TO_PASS": "[\"lib/matplotlib/tests/test_cycles.py::test_colorcycle_basic\", \"lib/matplotlib/tests/test_cycles.py::test_marker_cycle\", \"lib/matplotlib/tests/test_cycles.py::test_marker_cycle_kwargs_arrays_iterators\", \"lib/matplotlib/tests/test_cycles.py::test_linestylecycle_basic\", \"lib/matplotlib/tests/test_cycles.py::test_fillcycle_basic\", \"lib/matplotlib/tests/test_cycles.py::test_fillcycle_ignore\", \"lib/matplotlib/tests/test_cycles.py::test_property_collision_plot\", \"lib/matplotlib/tests/test_cycles.py::test_property_collision_fill\", \"lib/matplotlib/tests/test_cycles.py::test_valid_input_forms\", \"lib/matplotlib/tests/test_cycles.py::test_cycle_reset\", \"lib/matplotlib/tests/test_cycles.py::test_invalid_input_forms\", \"lib/matplotlib/tests/test_pickle.py::test_simple\", \"lib/matplotlib/tests/test_pickle.py::test_complete[png]\", \"lib/matplotlib/tests/test_pickle.py::test_gcf\", \"lib/matplotlib/tests/test_pickle.py::test_no_pyplot\", \"lib/matplotlib/tests/test_pickle.py::test_renderer\", \"lib/matplotlib/tests/test_pickle.py::test_image\", \"lib/matplotlib/tests/test_pickle.py::test_polar\", \"lib/matplotlib/tests/test_pickle.py::test_transform\", \"lib/matplotlib/tests/test_pickle.py::test_rrulewrapper\", \"lib/matplotlib/tests/test_pickle.py::test_shared\", \"lib/matplotlib/tests/test_pickle.py::test_inset_and_secondary\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap0]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap1]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap2]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap3]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap4]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap5]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap6]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap7]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap8]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap9]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap10]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap11]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap12]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap13]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap14]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap15]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap16]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap17]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap18]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap19]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap20]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap21]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap22]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap23]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap24]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap25]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap26]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap27]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap28]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap29]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap30]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap31]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap32]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap33]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap34]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap35]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap36]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap37]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap38]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap39]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap40]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap41]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap42]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap43]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap44]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap45]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap46]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap47]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap48]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap49]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap50]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap51]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap52]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap53]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap54]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap55]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap56]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap57]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap58]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap59]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap60]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap61]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap62]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap63]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap64]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap65]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap66]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap67]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap68]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap69]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap70]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap71]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap72]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap73]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap74]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap75]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap76]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap77]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap78]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap79]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap80]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap81]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap82]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap83]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap84]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap85]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap86]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap87]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap88]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap89]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap90]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap91]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap92]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap93]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap94]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap95]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap96]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap97]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap98]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap99]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap100]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap101]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap102]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap103]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap104]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap105]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap106]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap107]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap108]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap109]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap110]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap111]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap112]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap113]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap114]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap115]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap116]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap117]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap118]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap119]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap120]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap121]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap122]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap123]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap124]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap125]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap126]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap127]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap128]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap129]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap130]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap131]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap132]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap133]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap134]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap135]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap136]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap137]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap138]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap139]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap140]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap141]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap142]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap143]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap144]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap145]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap146]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap147]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap148]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap149]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap150]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap151]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap152]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap153]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap154]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap155]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap156]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap157]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap158]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap159]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap160]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap161]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap162]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap163]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap164]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap165]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap166]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap167]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap168]\", \"lib/matplotlib/tests/test_pickle.py::test_cmap[cmap169]\", \"lib/matplotlib/tests/test_pickle.py::test_unpickle_canvas\", \"lib/matplotlib/tests/test_pickle.py::test_mpl_toolkits\", \"lib/matplotlib/tests/test_pickle.py::test_standard_norm\", \"lib/matplotlib/tests/test_pickle.py::test_dynamic_norm\", \"lib/matplotlib/tests/test_pickle.py::test_vertexselector\"]",
  "environment_setup_commit": "0849036fd992a2dd133a0cffc3f84f58ccf1840f",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.832495",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}