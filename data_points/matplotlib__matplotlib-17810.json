{
  "repo": "matplotlib/matplotlib",
  "instance_id": "matplotlib__matplotlib-17810",
  "base_commit": "d29056c492dbf8067f2a60b0d920e18c4a892116",
  "patch": "diff --git a/lib/matplotlib/animation.py b/lib/matplotlib/animation.py\n--- a/lib/matplotlib/animation.py\n+++ b/lib/matplotlib/animation.py\n@@ -1666,8 +1666,21 @@ def _init_draw(self):\n         # For blitting, the init_func should return a sequence of modified\n         # artists.\n         if self._init_func is None:\n-            self._draw_frame(next(self.new_frame_seq()))\n-\n+            try:\n+                frame_data = next(self.new_frame_seq())\n+            except StopIteration:\n+                # we can't start the iteration, it may have already been\n+                # exhausted by a previous save or just be 0 length.\n+                # warn and bail.\n+                warnings.warn(\n+                    \"Can not start iterating the frames for the initial draw. \"\n+                    \"This can be caused by passing in a 0 length sequence \"\n+                    \"for *frames*.\\n\\n\"\n+                    \"If you passed *frames* as a generator \"\n+                    \"it may be exhausted due to a previous display or save.\"\n+                )\n+                return\n+            self._draw_frame(frame_data)\n         else:\n             self._drawn_artists = self._init_func()\n             if self._blit:\n",
  "test_patch": "diff --git a/lib/matplotlib/tests/test_animation.py b/lib/matplotlib/tests/test_animation.py\n--- a/lib/matplotlib/tests/test_animation.py\n+++ b/lib/matplotlib/tests/test_animation.py\n@@ -359,3 +359,36 @@ def animate(i):\n \n     with pytest.raises(RuntimeError):\n         animation.FuncAnimation(fig, animate, blit=True)\n+\n+\n+def test_exhausted_animation(tmpdir):\n+    fig, ax = plt.subplots()\n+\n+    def update(frame):\n+        return []\n+\n+    anim = animation.FuncAnimation(\n+        fig, update, frames=iter(range(10)), repeat=False,\n+        cache_frame_data=False\n+    )\n+\n+    with tmpdir.as_cwd():\n+        anim.save(\"test.gif\", writer='pillow')\n+\n+    with pytest.warns(UserWarning, match=\"exhausted\"):\n+        anim._start()\n+\n+\n+def test_no_frame_warning(tmpdir):\n+    fig, ax = plt.subplots()\n+\n+    def update(frame):\n+        return []\n+\n+    anim = animation.FuncAnimation(\n+        fig, update, frames=[], repeat=False,\n+        cache_frame_data=False\n+    )\n+\n+    with pytest.warns(UserWarning, match=\"exhausted\"):\n+        anim._start()\n",
  "problem_statement": "animation.save and fig.savefig interfere with each other and raise StopIteration\nThe following code snippet raises StopIteration:\r\n``` python\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib.animation import FuncAnimation\r\n\r\nfig, ax = plt.subplots()\r\nplt.plot([1,2,3],[2,4,3])\r\ndef update(frame):\r\n\treturn []\r\nanimation = FuncAnimation(fig, update, frames=iter(range(10)), repeat=False, blit=True, interval=100)\r\nanimation.save(\"hi.mp4\")\r\n\r\nfig2, ax2 = plt.subplots()\r\nax2.plot([7, 6, 3], [3, 5, 2])\r\nfig2.savefig(\"hi.png\")\r\n```\r\nThe same also happens if the figure is saved before the animation. \r\nThe interesting thing is that the two parts of the script work fine when run alone, so there must be some interference between the two.\r\n\r\nThe output produced by the above code:\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"/home/eugenio/miniconda3/envs/jax_agents_env/lib/python3.7/site-packages/matplotlib/cbook/__init__.py\", line 196, in process\r\n    func(*args, **kwargs)\r\n  File \"/home/eugenio/miniconda3/envs/jax_agents_env/lib/python3.7/site-packages/matplotlib/animation.py\", line 951, in _start\r\n    self._init_draw()\r\n  File \"/home/eugenio/miniconda3/envs/jax_agents_env/lib/python3.7/site-packages/matplotlib/animation.py\", line 1743, in _init_draw\r\n    self._draw_frame(next(self.new_frame_seq()))\r\nStopIteration\r\n```\r\n\r\n**Matplotlib version**\r\n<!--Please specify your platform and versions of the relevant libraries you are using:-->\r\n  * Operating system: Ubunut 18.04\r\n  * Matplotlib version: 3.2.2\r\n  * Matplotlib backend (`print(matplotlib.get_backend())`): TkAgg\r\n  * Python version: 3.7.7\r\n  * Jupyter version (if applicable): No Jupyter\r\n  * Other libraries: \r\n\r\nMatplotlib installed using pip inside a conda environment\r\n\r\n\n",
  "hints_text": "Looks like this basically comes from trying to re-draw() a figure hosting an non-repeating animation, after the animation has finished running (tbh it's not clear to me what the semantics should be).  In the OP's example this comes from savefig() returning to the event loop, but this can be triggered with a single figure with\r\n```python\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib.animation import FuncAnimation\r\n\r\nfig, ax = plt.subplots()\r\nplt.plot([1,2,3],[2,4,3])\r\ndef update(frame):\r\n\treturn []\r\nanimation = FuncAnimation(fig, update, frames=iter(range(10)), repeat=False, blit=True, interval=100)\r\nanimation.save(\"hi.mp4\")\r\n\r\nfig.canvas.draw()\r\n```\r\nand appears to throw at least as far back as 3.0.\nHi @anntzer, thank you for your answer! In my application the animation and the figure to save are completely unrelated, they even live in different files, nevertheless I am experiencing this issue. If you have any tips on how to overcome this, please let know :).\nok, I understand @anntzer 's minimal reproduction case (the animation installis a single-shot callback to run after the first `draw` to start the \"live\" animation, we exhaust the data source before it gets drawn so the callback fails.\r\n\r\nOn `tkagg` I get a much deeper callback which shows this:\r\n\r\n```\r\n\r\nIn [1]: import matplotlib.pyplot as plt \r\n   ...: from matplotlib.animation import FuncAnimation \r\n   ...:  \r\n   ...: fig, ax = plt.subplots() \r\n   ...: plt.plot([1,2,3],[2,4,3]) \r\n   ...: def update(frame): \r\n   ...: ^Ireturn [] \r\n   ...: animation = FuncAnimation(fig, update, frames=iter(range(10)), repeat=False, blit=True, interval=100) \r\n   ...: animation.save(\"hi.mp4\") \r\n   ...:  \r\n   ...: fig.canvas.draw()                                                                                                                                            \r\n---------------------------------------------------------------------------\r\nStopIteration                             Traceback (most recent call last)\r\n<ipython-input-1-8ae542acb6bd> in <module>\r\n      8 animation = FuncAnimation(fig, update, frames=iter(range(10)), repeat=False, blit=True, interval=100)\r\n      9 animation.save(\"hi.mp4\")\r\n---> 11 fig.canvas.draw()\r\n\r\n~/.virtualenvs/bleeding/lib/python3.10/site-packages/matplotlib/backends/backend_tkagg.py in FigureCanvasTkAgg.draw(self)\r\n      8 def draw(self):\r\n----> 9     super(FigureCanvasTkAgg, self).draw()\r\n     10     _backend_tk.blit(self._tkphoto, self.renderer._renderer, (0, 1, 2, 3))\r\n     11     self._master.update_idletasks()\r\n\r\n~/.virtualenvs/bleeding/lib/python3.10/site-packages/matplotlib/backends/backend_agg.py in FigureCanvasAgg.draw(self)\r\n    403 # Acquire a lock on the shared font cache.\r\n    404 with RendererAgg.lock, \\\r\n    405      (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\r\n    406       else nullcontext()):\r\n--> 407     self.figure.draw(self.renderer)\r\n    408     # A GUI class may be need to update a window using this draw, so\r\n    409     # don't forget to call the superclass.\r\n    410     super().draw()\r\n\r\n~/.virtualenvs/bleeding/lib/python3.10/site-packages/matplotlib/artist.py in allow_rasterization.<locals>.draw_wrapper(artist, renderer, *args, **kwargs)\r\n     38     if artist.get_agg_filter() is not None:\r\n     39         renderer.start_filter()\r\n---> 41     return draw(artist, renderer, *args, **kwargs)\r\n     42 finally:\r\n     43     if artist.get_agg_filter() is not None:\r\n\r\n~/.virtualenvs/bleeding/lib/python3.10/site-packages/matplotlib/figure.py in Figure.draw(self, renderer)\r\n   1865 finally:\r\n   1866     self.stale = False\r\n-> 1868 self.canvas.draw_event(renderer)\r\n\r\n~/.virtualenvs/bleeding/lib/python3.10/site-packages/matplotlib/backend_bases.py in FigureCanvasBase.draw_event(self, renderer)\r\n   1757 s = 'draw_event'\r\n   1758 event = DrawEvent(s, self, renderer)\r\n-> 1759 self.callbacks.process(s, event)\r\n\r\n~/.virtualenvs/bleeding/lib/python3.10/site-packages/matplotlib/cbook/__init__.py in CallbackRegistry.process(self, s, *args, **kwargs)\r\n    228 except Exception as exc:\r\n    229     if self.exception_handler is not None:\r\n--> 230         self.exception_handler(exc)\r\n    231     else:\r\n    232         raise\r\n\r\n~/.virtualenvs/bleeding/lib/python3.10/site-packages/matplotlib/cbook/__init__.py in _exception_printer(exc)\r\n     80 def _exception_printer(exc):\r\n     81     if _get_running_interactive_framework() in [\"headless\", None]:\r\n---> 82         raise exc\r\n     83     else:\r\n     84         traceback.print_exc()\r\n\r\n~/.virtualenvs/bleeding/lib/python3.10/site-packages/matplotlib/cbook/__init__.py in CallbackRegistry.process(self, s, *args, **kwargs)\r\n    223 if func is not None:\r\n    224     try:\r\n--> 225         func(*args, **kwargs)\r\n    226     # this does not capture KeyboardInterrupt, SystemExit,\r\n    227     # and GeneratorExit\r\n    228     except Exception as exc:\r\n\r\n~/.virtualenvs/bleeding/lib/python3.10/site-packages/matplotlib/animation.py in Animation._start(self, *args)\r\n    947 self._fig.canvas.mpl_disconnect(self._first_draw_id)\r\n    949 # Now do any initial draw\r\n--> 950 self._init_draw()\r\n    952 # Add our callback for stepping the animation and\r\n    953 # actually start the event_source.\r\n    954 self.event_source.add_callback(self._step)\r\n\r\n~/.virtualenvs/bleeding/lib/python3.10/site-packages/matplotlib/animation.py in FuncAnimation._init_draw(self)\r\n   1688 def _init_draw(self):\r\n   1689     # Initialize the drawing either using the given init_func or by\r\n   1690     # calling the draw function with the first item of the frame sequence.\r\n   1691     # For blitting, the init_func should return a sequence of modified\r\n   1692     # artists.\r\n   1693     if self._init_func is None:\r\n-> 1694         self._draw_frame(next(self.new_frame_seq()))\r\n   1696     else:\r\n   1697         self._drawn_artists = self._init_func()\r\n\r\nStopIteration: \r\n```\r\n\r\nI am however at a loss for how @chisarie is triggering this issue and why saving a _different figure_ would trigger this.  If I run the code in the OP as a script (via `python test.py`) then I don't get a trace back so I suspect that does have something to do with coming back to the prompt (and something pulling up the GUI window).   I'll have a PR to fix this open later tonight (have a fix, just need to write the test).",
  "created_at": "2020-07-01T02:07:46Z",
  "version": "3.2",
  "FAIL_TO_PASS": "[\"lib/matplotlib/tests/test_animation.py::test_exhausted_animation\", \"lib/matplotlib/tests/test_animation.py::test_no_frame_warning\"]",
  "PASS_TO_PASS": "[\"lib/matplotlib/tests/test_animation.py::test_null_movie_writer\", \"lib/matplotlib/tests/test_animation.py::test_animation_delete[anim0]\", \"lib/matplotlib/tests/test_animation.py::test_movie_writer_dpi_default\", \"lib/matplotlib/tests/test_animation.py::test_animation_repr_html[anim0-none-None-ffmpeg]\", \"lib/matplotlib/tests/test_animation.py::test_animation_repr_html[anim0-none-None-imagemagick]\", \"lib/matplotlib/tests/test_animation.py::test_animation_repr_html[anim0-html5-<video\", \"lib/matplotlib/tests/test_animation.py::test_animation_repr_html[anim0-jshtml-<script\", \"lib/matplotlib/tests/test_animation.py::test_no_length_frames[anim0]\", \"lib/matplotlib/tests/test_animation.py::test_movie_writer_registry\", \"lib/matplotlib/tests/test_animation.py::test_embed_limit[anim0-to_html5_video]\", \"lib/matplotlib/tests/test_animation.py::test_embed_limit[anim0-to_jshtml]\", \"lib/matplotlib/tests/test_animation.py::test_cleanup_temporaries[anim0-to_html5_video]\", \"lib/matplotlib/tests/test_animation.py::test_cleanup_temporaries[anim0-to_jshtml]\", \"lib/matplotlib/tests/test_animation.py::test_failing_ffmpeg\", \"lib/matplotlib/tests/test_animation.py::test_funcanimation_cache_frame_data[False]\", \"lib/matplotlib/tests/test_animation.py::test_funcanimation_cache_frame_data[True]\", \"lib/matplotlib/tests/test_animation.py::test_draw_frame[None]\", \"lib/matplotlib/tests/test_animation.py::test_draw_frame[string]\", \"lib/matplotlib/tests/test_animation.py::test_draw_frame[1]\", \"lib/matplotlib/tests/test_animation.py::test_draw_frame[return_value3]\", \"lib/matplotlib/tests/test_animation.py::test_draw_frame[artist]\"]",
  "environment_setup_commit": "c54a5a9b45eff7148e73e9134f206126842307e1",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.787515",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}