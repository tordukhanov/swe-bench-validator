{
  "repo": "sphinx-doc/sphinx",
  "instance_id": "sphinx-doc__sphinx-10021",
  "base_commit": "8ddf3f09c62e2a4651458759fcc97e751ca63063",
  "patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -80,45 +80,53 @@ class ModuleEntry(NamedTuple):\n     deprecated: bool\n \n \n-def type_to_xref(target: str, env: BuildEnvironment = None, suppress_prefix: bool = False\n-                 ) -> addnodes.pending_xref:\n-    \"\"\"Convert a type string to a cross reference node.\"\"\"\n-    if target == 'None' or target.startswith('typing.'):\n+def parse_reftarget(reftarget: str, suppress_prefix: bool = False\n+                    ) -> Tuple[str, str, str, bool]:\n+    \"\"\"Parse a type string and return (reftype, reftarget, title, refspecific flag)\"\"\"\n+    refspecific = False\n+    if reftarget.startswith('.'):\n+        reftarget = reftarget[1:]\n+        title = reftarget\n+        refspecific = True\n+    elif reftarget.startswith('~'):\n+        reftarget = reftarget[1:]\n+        title = reftarget.split('.')[-1]\n+    elif suppress_prefix:\n+        title = reftarget.split('.')[-1]\n+    elif reftarget.startswith('typing.'):\n+        title = reftarget[7:]\n+    else:\n+        title = reftarget\n+\n+    if reftarget == 'None' or reftarget.startswith('typing.'):\n         # typing module provides non-class types.  Obj reference is good to refer them.\n         reftype = 'obj'\n     else:\n         reftype = 'class'\n \n+    return reftype, reftarget, title, refspecific\n+\n+\n+def type_to_xref(target: str, env: BuildEnvironment = None, suppress_prefix: bool = False\n+                 ) -> addnodes.pending_xref:\n+    \"\"\"Convert a type string to a cross reference node.\"\"\"\n     if env:\n         kwargs = {'py:module': env.ref_context.get('py:module'),\n                   'py:class': env.ref_context.get('py:class')}\n     else:\n         kwargs = {}\n \n-    refspecific = False\n-    if target.startswith('.'):\n-        target = target[1:]\n-        text = target\n-        refspecific = True\n-    elif target.startswith('~'):\n-        target = target[1:]\n-        text = target.split('.')[-1]\n-    elif suppress_prefix:\n-        text = target.split('.')[-1]\n-    elif target.startswith('typing.'):\n-        text = target[7:]\n-    else:\n-        text = target\n+    reftype, target, title, refspecific = parse_reftarget(target, suppress_prefix)\n \n     if env.config.python_use_unqualified_type_names:\n         # Note: It would be better to use qualname to describe the object to support support\n         # nested classes.  But python domain can't access the real python object because this\n         # module should work not-dynamically.\n-        shortname = text.split('.')[-1]\n+        shortname = title.split('.')[-1]\n         contnodes: List[Node] = [pending_xref_condition('', shortname, condition='resolved'),\n-                                 pending_xref_condition('', text, condition='*')]\n+                                 pending_xref_condition('', title, condition='*')]\n     else:\n-        contnodes = [nodes.Text(text)]\n+        contnodes = [nodes.Text(title)]\n \n     return pending_xref('', *contnodes,\n                         refdomain='py', reftype=reftype, reftarget=target,\n@@ -354,27 +362,27 @@ def make_xref(self, rolename: str, domain: str, target: str,\n         result = super().make_xref(rolename, domain, target,  # type: ignore\n                                    innernode, contnode,\n                                    env, inliner=None, location=None)\n-        result['refspecific'] = True\n-        result['py:module'] = env.ref_context.get('py:module')\n-        result['py:class'] = env.ref_context.get('py:class')\n-        if target.startswith(('.', '~')):\n-            prefix, result['reftarget'] = target[0], target[1:]\n-            if prefix == '.':\n-                text = target[1:]\n-            elif prefix == '~':\n-                text = target.split('.')[-1]\n-            for node in list(result.traverse(nodes.Text)):\n-                node.parent[node.parent.index(node)] = nodes.Text(text)\n-                break\n-        elif isinstance(result, pending_xref) and env.config.python_use_unqualified_type_names:\n-            children = result.children\n-            result.clear()\n-\n-            shortname = target.split('.')[-1]\n-            textnode = innernode('', shortname)\n-            contnodes = [pending_xref_condition('', '', textnode, condition='resolved'),\n-                         pending_xref_condition('', '', *children, condition='*')]\n-            result.extend(contnodes)\n+        if isinstance(result, pending_xref):\n+            result['refspecific'] = True\n+            result['py:module'] = env.ref_context.get('py:module')\n+            result['py:class'] = env.ref_context.get('py:class')\n+\n+            reftype, reftarget, reftitle, _ = parse_reftarget(target)\n+            if reftarget != reftitle:\n+                result['reftype'] = reftype\n+                result['reftarget'] = reftarget\n+\n+                result.clear()\n+                result += innernode(reftitle, reftitle)\n+            elif env.config.python_use_unqualified_type_names:\n+                children = result.children\n+                result.clear()\n+\n+                shortname = target.split('.')[-1]\n+                textnode = innernode('', shortname)\n+                contnodes = [pending_xref_condition('', '', textnode, condition='resolved'),\n+                             pending_xref_condition('', '', *children, condition='*')]\n+                result.extend(contnodes)\n \n         return result\n \n@@ -407,16 +415,7 @@ def make_xrefs(self, rolename: str, domain: str, target: str,\n \n \n class PyField(PyXrefMixin, Field):\n-    def make_xref(self, rolename: str, domain: str, target: str,\n-                  innernode: Type[TextlikeNode] = nodes.emphasis,\n-                  contnode: Node = None, env: BuildEnvironment = None,\n-                  inliner: Inliner = None, location: Node = None) -> Node:\n-        if rolename == 'class' and target == 'None':\n-            # None is not a type, so use obj role instead.\n-            rolename = 'obj'\n-\n-        return super().make_xref(rolename, domain, target, innernode, contnode,\n-                                 env, inliner, location)\n+    pass\n \n \n class PyGroupedField(PyXrefMixin, GroupedField):\n@@ -424,16 +423,7 @@ class PyGroupedField(PyXrefMixin, GroupedField):\n \n \n class PyTypedField(PyXrefMixin, TypedField):\n-    def make_xref(self, rolename: str, domain: str, target: str,\n-                  innernode: Type[TextlikeNode] = nodes.emphasis,\n-                  contnode: Node = None, env: BuildEnvironment = None,\n-                  inliner: Inliner = None, location: Node = None) -> Node:\n-        if rolename == 'class' and target == 'None':\n-            # None is not a type, so use obj role instead.\n-            rolename = 'obj'\n-\n-        return super().make_xref(rolename, domain, target, innernode, contnode,\n-                                 env, inliner, location)\n+    pass\n \n \n class PyObject(ObjectDescription[Tuple[str, str]]):\ndiff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -23,6 +23,11 @@\n def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                      options: Dict, args: str, retann: str) -> None:\n     \"\"\"Record type hints to env object.\"\"\"\n+    if app.config.autodoc_typehints_format == 'short':\n+        mode = 'smart'\n+    else:\n+        mode = 'fully-qualified'\n+\n     try:\n         if callable(obj):\n             annotations = app.env.temp_data.setdefault('annotations', {})\n@@ -30,9 +35,9 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n             sig = inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases)\n             for param in sig.parameters.values():\n                 if param.annotation is not param.empty:\n-                    annotation[param.name] = typing.stringify(param.annotation)\n+                    annotation[param.name] = typing.stringify(param.annotation, mode)\n             if sig.return_annotation is not sig.empty:\n-                annotation['return'] = typing.stringify(sig.return_annotation)\n+                annotation['return'] = typing.stringify(sig.return_annotation, mode)\n     except (TypeError, ValueError):\n         pass\n \n",
  "test_patch": "diff --git a/tests/test_domain_py.py b/tests/test_domain_py.py\n--- a/tests/test_domain_py.py\n+++ b/tests/test_domain_py.py\n@@ -1196,7 +1196,9 @@ def test_type_field(app):\n     text = (\".. py:data:: var1\\n\"\n             \"   :type: .int\\n\"\n             \".. py:data:: var2\\n\"\n-            \"   :type: ~builtins.int\\n\")\n+            \"   :type: ~builtins.int\\n\"\n+            \".. py:data:: var3\\n\"\n+            \"   :type: typing.Optional[typing.Tuple[int, typing.Any]]\\n\")\n     doctree = restructuredtext.parse(app, text)\n     assert_node(doctree, (addnodes.index,\n                           [desc, ([desc_signature, ([desc_name, \"var1\"],\n@@ -1209,9 +1211,28 @@ def test_type_field(app):\n                                                     [desc_annotation, ([desc_sig_punctuation, ':'],\n                                                                        desc_sig_space,\n                                                                        [pending_xref, \"int\"])])],\n+                                  [desc_content, ()])],\n+                          addnodes.index,\n+                          [desc, ([desc_signature, ([desc_name, \"var3\"],\n+                                                    [desc_annotation, ([desc_sig_punctuation, \":\"],\n+                                                                       desc_sig_space,\n+                                                                       [pending_xref, \"Optional\"],\n+                                                                       [desc_sig_punctuation, \"[\"],\n+                                                                       [pending_xref, \"Tuple\"],\n+                                                                       [desc_sig_punctuation, \"[\"],\n+                                                                       [pending_xref, \"int\"],\n+                                                                       [desc_sig_punctuation, \",\"],\n+                                                                       desc_sig_space,\n+                                                                       [pending_xref, \"Any\"],\n+                                                                       [desc_sig_punctuation, \"]\"],\n+                                                                       [desc_sig_punctuation, \"]\"])])],\n                                   [desc_content, ()])]))\n     assert_node(doctree[1][0][1][2], pending_xref, reftarget='int', refspecific=True)\n     assert_node(doctree[3][0][1][2], pending_xref, reftarget='builtins.int', refspecific=False)\n+    assert_node(doctree[5][0][1][2], pending_xref, reftarget='typing.Optional', refspecific=False)\n+    assert_node(doctree[5][0][1][4], pending_xref, reftarget='typing.Tuple', refspecific=False)\n+    assert_node(doctree[5][0][1][6], pending_xref, reftarget='int', refspecific=False)\n+    assert_node(doctree[5][0][1][9], pending_xref, reftarget='typing.Any', refspecific=False)\n \n \n @pytest.mark.sphinx(freshenv=True)\ndiff --git a/tests/test_ext_autodoc_configs.py b/tests/test_ext_autodoc_configs.py\n--- a/tests/test_ext_autodoc_configs.py\n+++ b/tests/test_ext_autodoc_configs.py\n@@ -835,7 +835,7 @@ def test_autodoc_typehints_description(app):\n             '      **x** (*Tuple**[**int**, **Union**[**int**, **str**]**]*) --\\n'\n             '\\n'\n             '   Return type:\\n'\n-            '      Tuple[int, int]\\n'\n+            '      *Tuple*[int, int]\\n'\n             in context)\n \n     # Overloads still get displayed in the signature\n@@ -887,7 +887,7 @@ def test_autodoc_typehints_description_no_undoc(app):\n             '      another tuple\\n'\n             '\\n'\n             '   Return type:\\n'\n-            '      Tuple[int, int]\\n'\n+            '      *Tuple*[int, int]\\n'\n             in context)\n \n \n@@ -978,7 +978,7 @@ def test_autodoc_typehints_both(app):\n             '      **x** (*Tuple**[**int**, **Union**[**int**, **str**]**]*) --\\n'\n             '\\n'\n             '   Return type:\\n'\n-            '      Tuple[int, int]\\n'\n+            '      *Tuple*[int, int]\\n'\n             in context)\n \n     # Overloads still get displayed in the signature\n",
  "problem_statement": "autodoc_unqualified_typehints does not work well with autodoc_typehints=\"description\"\n### Describe the bug\n\nautodoc_unqualified_typehints does not work well with autodoc_typehints=\"description\".\n\n### How to Reproduce\n\n```\r\nautodoc_unqualified_typehints = True\r\nautodoc_typehints = \"description\"\r\n```\n\n### Expected behavior\n\nTypehints in info-field-list are also changed to the short style when autodoc_unqualifed_typehints enabled.\n\n### Your project\n\nN/A\n\n### Screenshots\n\n_No response_\n\n### OS\n\nMac\n\n### Python version\n\n3.10.1\n\n### Sphinx version\n\nHEAD of 4.x\n\n### Sphinx extensions\n\nautodoc\n\n### Extra tools\n\n_No response_\n\n### Additional context\n\n_No response_\n",
  "hints_text": "",
  "created_at": "2021-12-26T17:01:29Z",
  "version": "4.4",
  "FAIL_TO_PASS": "[\"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_description\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_description_no_undoc\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_both\"]",
  "PASS_TO_PASS": "[\"tests/test_domain_py.py::test_function_signatures\", \"tests/test_domain_py.py::test_domain_py_xrefs\", \"tests/test_domain_py.py::test_domain_py_xrefs_abbreviations\", \"tests/test_domain_py.py::test_domain_py_objects\", \"tests/test_domain_py.py::test_resolve_xref_for_properties\", \"tests/test_domain_py.py::test_domain_py_find_obj\", \"tests/test_domain_py.py::test_domain_py_canonical\", \"tests/test_domain_py.py::test_get_full_qualified_name\", \"tests/test_domain_py.py::test_parse_annotation\", \"tests/test_domain_py.py::test_parse_annotation_suppress\", \"tests/test_domain_py.py::test_parse_annotation_Literal\", \"tests/test_domain_py.py::test_pyfunction_signature\", \"tests/test_domain_py.py::test_pyfunction_signature_full\", \"tests/test_domain_py.py::test_pyfunction_signature_full_py38\", \"tests/test_domain_py.py::test_pyfunction_with_number_literals\", \"tests/test_domain_py.py::test_pyfunction_with_union_type_operator\", \"tests/test_domain_py.py::test_optional_pyfunction_signature\", \"tests/test_domain_py.py::test_pyexception_signature\", \"tests/test_domain_py.py::test_pydata_signature\", \"tests/test_domain_py.py::test_pydata_signature_old\", \"tests/test_domain_py.py::test_pydata_with_union_type_operator\", \"tests/test_domain_py.py::test_pyobject_prefix\", \"tests/test_domain_py.py::test_pydata\", \"tests/test_domain_py.py::test_pyfunction\", \"tests/test_domain_py.py::test_pyclass_options\", \"tests/test_domain_py.py::test_pymethod_options\", \"tests/test_domain_py.py::test_pyclassmethod\", \"tests/test_domain_py.py::test_pystaticmethod\", \"tests/test_domain_py.py::test_pyattribute\", \"tests/test_domain_py.py::test_pyproperty\", \"tests/test_domain_py.py::test_pydecorator_signature\", \"tests/test_domain_py.py::test_pydecoratormethod_signature\", \"tests/test_domain_py.py::test_canonical\", \"tests/test_domain_py.py::test_canonical_definition_overrides\", \"tests/test_domain_py.py::test_canonical_definition_skip\", \"tests/test_domain_py.py::test_canonical_duplicated\", \"tests/test_domain_py.py::test_info_field_list\", \"tests/test_domain_py.py::test_info_field_list_piped_type\", \"tests/test_domain_py.py::test_info_field_list_Literal\", \"tests/test_domain_py.py::test_info_field_list_var\", \"tests/test_domain_py.py::test_type_field\", \"tests/test_domain_py.py::test_module_index\", \"tests/test_domain_py.py::test_module_index_submodule\", \"tests/test_domain_py.py::test_module_index_not_collapsed\", \"tests/test_domain_py.py::test_modindex_common_prefix\", \"tests/test_domain_py.py::test_noindexentry\", \"tests/test_domain_py.py::test_python_python_use_unqualified_type_names\", \"tests/test_domain_py.py::test_python_python_use_unqualified_type_names_disabled\", \"tests/test_domain_py.py::test_warn_missing_reference\", \"tests/test_ext_autodoc_configs.py::test_autoclass_content_class\", \"tests/test_ext_autodoc_configs.py::test_autoclass_content_init\", \"tests/test_ext_autodoc_configs.py::test_autodoc_class_signature_mixed\", \"tests/test_ext_autodoc_configs.py::test_autodoc_class_signature_separated_init\", \"tests/test_ext_autodoc_configs.py::test_autodoc_class_signature_separated_new\", \"tests/test_ext_autodoc_configs.py::test_autoclass_content_both\", \"tests/test_ext_autodoc_configs.py::test_autodoc_inherit_docstrings\", \"tests/test_ext_autodoc_configs.py::test_autodoc_docstring_signature\", \"tests/test_ext_autodoc_configs.py::test_autoclass_content_and_docstring_signature_class\", \"tests/test_ext_autodoc_configs.py::test_autoclass_content_and_docstring_signature_init\", \"tests/test_ext_autodoc_configs.py::test_autoclass_content_and_docstring_signature_both\", \"tests/test_ext_autodoc_configs.py::test_mocked_module_imports\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_signature\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_none\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_none_for_overload\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_description_with_documented_init\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_description_with_documented_init_no_undoc\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_description_for_invalid_node\", \"tests/test_ext_autodoc_configs.py::test_autodoc_type_aliases\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_description_and_type_aliases\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_format_short\", \"tests/test_ext_autodoc_configs.py::test_autodoc_default_options\", \"tests/test_ext_autodoc_configs.py::test_autodoc_default_options_with_values\"]",
  "environment_setup_commit": "0938c193ea6f56dbb930bfb323602bc4e2b7b9c6",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.029646",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}