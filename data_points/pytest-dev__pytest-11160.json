{
  "repo": "pytest-dev/pytest",
  "instance_id": "pytest-dev__pytest-11160",
  "base_commit": "6995257cf470d2143ad1683824962de4071c0eb7",
  "patch": "diff --git a/src/_pytest/recwarn.py b/src/_pytest/recwarn.py\n--- a/src/_pytest/recwarn.py\n+++ b/src/_pytest/recwarn.py\n@@ -206,10 +206,21 @@ def __len__(self) -> int:\n         return len(self._list)\n \n     def pop(self, cls: Type[Warning] = Warning) -> \"warnings.WarningMessage\":\n-        \"\"\"Pop the first recorded warning, raise exception if not exists.\"\"\"\n+        \"\"\"Pop the first recorded warning which is an instance of ``cls``,\n+        but not an instance of a child class of any other match.\n+        Raises ``AssertionError`` if there is no match.\n+        \"\"\"\n+        best_idx: Optional[int] = None\n         for i, w in enumerate(self._list):\n-            if issubclass(w.category, cls):\n-                return self._list.pop(i)\n+            if w.category == cls:\n+                return self._list.pop(i)  # exact match, stop looking\n+            if issubclass(w.category, cls) and (\n+                best_idx is None\n+                or not issubclass(w.category, self._list[best_idx].category)\n+            ):\n+                best_idx = i\n+        if best_idx is not None:\n+            return self._list.pop(best_idx)\n         __tracebackhide__ = True\n         raise AssertionError(f\"{cls!r} not found in warning list\")\n \n",
  "test_patch": "diff --git a/testing/test_recwarn.py b/testing/test_recwarn.py\n--- a/testing/test_recwarn.py\n+++ b/testing/test_recwarn.py\n@@ -1,5 +1,7 @@\n import warnings\n+from typing import List\n from typing import Optional\n+from typing import Type\n \n import pytest\n from _pytest.pytester import Pytester\n@@ -37,6 +39,47 @@ def test_recwarn_captures_deprecation_warning(recwarn: WarningsRecorder) -> None\n     assert recwarn.pop(DeprecationWarning)\n \n \n+class TestSubclassWarningPop:\n+    class ParentWarning(Warning):\n+        pass\n+\n+    class ChildWarning(ParentWarning):\n+        pass\n+\n+    class ChildOfChildWarning(ChildWarning):\n+        pass\n+\n+    @staticmethod\n+    def raise_warnings_from_list(_warnings: List[Type[Warning]]):\n+        for warn in _warnings:\n+            warnings.warn(f\"Warning {warn().__repr__()}\", warn)\n+\n+    def test_pop_finds_exact_match(self):\n+        with pytest.warns((self.ParentWarning, self.ChildWarning)) as record:\n+            self.raise_warnings_from_list(\n+                [self.ChildWarning, self.ParentWarning, self.ChildOfChildWarning]\n+            )\n+\n+        assert len(record) == 3\n+        _warn = record.pop(self.ParentWarning)\n+        assert _warn.category is self.ParentWarning\n+\n+    def test_pop_raises_if_no_match(self):\n+        with pytest.raises(AssertionError):\n+            with pytest.warns(self.ParentWarning) as record:\n+                self.raise_warnings_from_list([self.ParentWarning])\n+            record.pop(self.ChildOfChildWarning)\n+\n+    def test_pop_finds_best_inexact_match(self):\n+        with pytest.warns(self.ParentWarning) as record:\n+            self.raise_warnings_from_list(\n+                [self.ChildOfChildWarning, self.ChildWarning, self.ChildOfChildWarning]\n+            )\n+\n+        _warn = record.pop(self.ParentWarning)\n+        assert _warn.category is self.ChildWarning\n+\n+\n class TestWarningsRecorderChecker:\n     def test_recording(self) -> None:\n         rec = WarningsRecorder(_ispytest=True)\n",
  "problem_statement": "WarningsRecorder.pop() improperly matches warning\nWhen trying to pop a specific warning from a WarningsRecorder instance, the wrong warning is returned. I believe the issue is that pop uses issubclass https://github.com/pytest-dev/pytest/blob/3c1534944cbd34e8a41bc9e76818018fadefc9a1/src/_pytest/recwarn.py#L210\r\n\r\nI believe the correct comparison should be:\r\n```python\r\nif w.category is cls:\r\n```\r\n\r\nHere is a minimum working example that triggers the buggy behavior:\r\n```python\r\nimport pytest\r\nimport warnings\r\n\r\nclass RWarning(Warning):\r\n    pass\r\n    \r\nclass SWarning(RWarning):\r\n    pass\r\n\r\ndef raise_warnings():\r\n    warnings.warn(\"Warning 1\", SWarning)\r\n    warnings.warn(\"Warning 2\", RWarning)\r\n    \r\ndef test_pop():\r\n    with pytest.warns((RWarning, SWarning)) as record:\r\n        raise_warnings()\r\n        \r\n    assert len(record) == 2\r\n    _warn = record.pop(RWarning)\r\n    assert _warn.category is RWarning  # This fails because _warn.category is SWarning\r\n```\r\nThe test output is\r\n```\r\n========================================================================================= FAILURES ==========================================================================================\r\n_________________________________________________________________________________________ test_pop __________________________________________________________________________________________\r\n\r\n    def test_pop():\r\n        with pytest.warns((RWarning, SWarning)) as record:\r\n            raise_warnings()\r\n\r\n        assert len(record) == 2\r\n        _warn = record.pop(RWarning)\r\n>       assert _warn.category is RWarning\r\nE       AssertionError: assert <class 'pytest_bug.SWarning'> is RWarning\r\nE        +  where <class 'pytest_bug.SWarning'> = <warnings.WarningMessage object at 0x7fea08a72010>.category\r\n\r\npytest_bug.py:24: AssertionError\r\n```\r\n\r\npytest 7.2.1 on archlinux.\r\nvirtual environment is a clean conda environment with only python and pytest (and their dependencies installed from conda-forge).\r\n\r\nIf this is indeed a bug, I'm happy to open a PR with my proposed solution.\r\n\nWarningsRecorder.pop() improperly matches warning\nWhen trying to pop a specific warning from a WarningsRecorder instance, the wrong warning is returned. I believe the issue is that pop uses issubclass https://github.com/pytest-dev/pytest/blob/3c1534944cbd34e8a41bc9e76818018fadefc9a1/src/_pytest/recwarn.py#L210\r\n\r\nI believe the correct comparison should be:\r\n```python\r\nif w.category is cls:\r\n```\r\n\r\nHere is a minimum working example that triggers the buggy behavior:\r\n```python\r\nimport pytest\r\nimport warnings\r\n\r\nclass RWarning(Warning):\r\n    pass\r\n    \r\nclass SWarning(RWarning):\r\n    pass\r\n\r\ndef raise_warnings():\r\n    warnings.warn(\"Warning 1\", SWarning)\r\n    warnings.warn(\"Warning 2\", RWarning)\r\n    \r\ndef test_pop():\r\n    with pytest.warns((RWarning, SWarning)) as record:\r\n        raise_warnings()\r\n        \r\n    assert len(record) == 2\r\n    _warn = record.pop(RWarning)\r\n    assert _warn.category is RWarning  # This fails because _warn.category is SWarning\r\n```\r\nThe test output is\r\n```\r\n========================================================================================= FAILURES ==========================================================================================\r\n_________________________________________________________________________________________ test_pop __________________________________________________________________________________________\r\n\r\n    def test_pop():\r\n        with pytest.warns((RWarning, SWarning)) as record:\r\n            raise_warnings()\r\n\r\n        assert len(record) == 2\r\n        _warn = record.pop(RWarning)\r\n>       assert _warn.category is RWarning\r\nE       AssertionError: assert <class 'pytest_bug.SWarning'> is RWarning\r\nE        +  where <class 'pytest_bug.SWarning'> = <warnings.WarningMessage object at 0x7fea08a72010>.category\r\n\r\npytest_bug.py:24: AssertionError\r\n```\r\n\r\npytest 7.2.1 on archlinux.\r\nvirtual environment is a clean conda environment with only python and pytest (and their dependencies installed from conda-forge).\r\n\r\nIf this is indeed a bug, I'm happy to open a PR with my proposed solution.\r\n\n",
  "hints_text": "Yeah, it looks like this code never anticipated the possibility that a later warning might be a better match than the current warning.  That said, we need to preserve the current behavior of matching if the warning was a subclass, so instead of the current\r\n\r\n```python\r\nfor i, w in enumerate(self._list):\r\n    if issubclass(w.category, cls):\r\n        return self._list.pop(i)\r\n```\r\nI propose we do something like\r\n```python\r\n# Match the first warning that is a subtype of `cls`, where there\r\n# is *not* a later captured warning which is a subtype of this one.\r\nmatches = []\r\nfor i, w in enumerate(self._list):\r\n    if w.category == cls:  # in this case we can exit early\r\n        return self._list.pop(i)\r\n    if issubclass(w.category, cls):\r\n        matches.append((i, w))\r\nif not matches:\r\n    raise ... # see current code for details\r\n(idx, best), *rest = matches\r\nfor i, w in rest:\r\n    if issubclass(w, best) and not issubclass(best, w):\r\n        idx, best = i, w\r\nreturn self._list.pop(idx)\r\n```\r\n\r\nand it would be awesome if you could open a PR with this, tests, a changelog entry, and of course adding yourself to the contributors list üôè \nThank you for your comments @Zac-HD. Let me start by describing the challenge I am trying to work out in my code. I have a function that returns several warnings, and I want to check that for a certain set of arguments, all the expected warnings are emitted. This would mean checking that the proper warning classes have been captured and a matched portion of the warning message is also present. In an ideal world, I would think my test would probably look like:\r\n```python\r\ndef test_warnings():\r\n    with pytest.warns(RWarning) as record:   # RWarning is the base warning class for the library and all other warning inherit from it\r\n        my_function('a', 'b')\r\n    assert len(record) == 2\r\n    assert record.contains(RWarning, match_expr=\"Warning2\") # this would be looking explicitly for RWarning, not its subclasses\r\n    assert record.contains(SWarning, match_expr=\"Warning1\")\r\n```\r\nI was thinking about this more and testing the code you wrote and feel that maybe a separate method would be a better solution.\r\n\r\nMy ideas are:\r\n1. a `.contains` method that does exact class checking. True if specified warning exists (and if an optional match_expr matches the warning message). See above for possible usage example.  Returns True/False\r\nPossible implementation\r\n```python\r\ndef contains(self, cls, match_expr=None):\r\n    if match_expr:\r\n        match_re = re.compile(match_expr)\r\n        for w in self._list:\r\n            if w.category is cls and match_re.search(str(w.message)):\r\n                return True\r\n    else:\r\n        for w in self._list:\r\n            if w.category is cls:\r\n                return True\r\n    return False\r\n```\r\n2. a `.search` or `.findall` (inspired by the regex library) method that can do strict or subclass checking with a keyword argument switch. Returns a list of matching warnings. This could also do message matching, if desired.\r\n```python\r\nm = list(record.match(RWarning, subclasses=False)) # do exact class matching\r\nm = list(record.match(RWarning, subclasses=True)) # match with classes that are RWarnings or where RWarning is a base class\r\n```\r\nPossible implentation:\r\n```python\r\ndef match(self, cls, subclasses=False):\r\n    \"\"\" Match cls or cls subclasses \"\"\"\r\n    if subclasses:\r\n        op = issubclass\r\n    else:\r\n        op = operator.is_\r\n\t\r\n    for i, w in enumerate(self._list):\r\n\tif op(w.category, cls):\r\n            yield i\r\n\r\n# Then .pop becomes\r\ndef pop(self, cls):\r\n    try:\r\n        i = next(self.match(cls, subclasses=True))\r\n        return self._list.pop(i)\r\n    except StopIteration:\r\n        __tracebackhide__ = True\r\n        raise AssertionError(f\"{cls!r} not found in warning list\")\r\n```\r\n\r\nWhat are your thoughts, @Zac-HD?\nSeems like you might be better of with [the stdlib `with warnings.catch_warnings(record=True, ...) as list_of_caught_warnings:`](https://docs.python.org/3/library/warnings.html#testing-warnings) function, and making assertions manually?\r\n\r\nPytest helpers are nice, but sometimes it's worth using the rest of Python instead üòÅ \nIt does remind me of the plan to integrate dirty equals better into pytest, it would be nice if there was a way to spell the warning matches for the contains check \nYeah, it looks like this code never anticipated the possibility that a later warning might be a better match than the current warning.  That said, we need to preserve the current behavior of matching if the warning was a subclass, so instead of the current\r\n\r\n```python\r\nfor i, w in enumerate(self._list):\r\n    if issubclass(w.category, cls):\r\n        return self._list.pop(i)\r\n```\r\nI propose we do something like\r\n```python\r\n# Match the first warning that is a subtype of `cls`, where there\r\n# is *not* a later captured warning which is a subtype of this one.\r\nmatches = []\r\nfor i, w in enumerate(self._list):\r\n    if w.category == cls:  # in this case we can exit early\r\n        return self._list.pop(i)\r\n    if issubclass(w.category, cls):\r\n        matches.append((i, w))\r\nif not matches:\r\n    raise ... # see current code for details\r\n(idx, best), *rest = matches\r\nfor i, w in rest:\r\n    if issubclass(w, best) and not issubclass(best, w):\r\n        idx, best = i, w\r\nreturn self._list.pop(idx)\r\n```\r\n\r\nand it would be awesome if you could open a PR with this, tests, a changelog entry, and of course adding yourself to the contributors list üôè \nThank you for your comments @Zac-HD. Let me start by describing the challenge I am trying to work out in my code. I have a function that returns several warnings, and I want to check that for a certain set of arguments, all the expected warnings are emitted. This would mean checking that the proper warning classes have been captured and a matched portion of the warning message is also present. In an ideal world, I would think my test would probably look like:\r\n```python\r\ndef test_warnings():\r\n    with pytest.warns(RWarning) as record:   # RWarning is the base warning class for the library and all other warning inherit from it\r\n        my_function('a', 'b')\r\n    assert len(record) == 2\r\n    assert record.contains(RWarning, match_expr=\"Warning2\") # this would be looking explicitly for RWarning, not its subclasses\r\n    assert record.contains(SWarning, match_expr=\"Warning1\")\r\n```\r\nI was thinking about this more and testing the code you wrote and feel that maybe a separate method would be a better solution.\r\n\r\nMy ideas are:\r\n1. a `.contains` method that does exact class checking. True if specified warning exists (and if an optional match_expr matches the warning message). See above for possible usage example.  Returns True/False\r\nPossible implementation\r\n```python\r\ndef contains(self, cls, match_expr=None):\r\n    if match_expr:\r\n        match_re = re.compile(match_expr)\r\n        for w in self._list:\r\n            if w.category is cls and match_re.search(str(w.message)):\r\n                return True\r\n    else:\r\n        for w in self._list:\r\n            if w.category is cls:\r\n                return True\r\n    return False\r\n```\r\n2. a `.search` or `.findall` (inspired by the regex library) method that can do strict or subclass checking with a keyword argument switch. Returns a list of matching warnings. This could also do message matching, if desired.\r\n```python\r\nm = list(record.match(RWarning, subclasses=False)) # do exact class matching\r\nm = list(record.match(RWarning, subclasses=True)) # match with classes that are RWarnings or where RWarning is a base class\r\n```\r\nPossible implentation:\r\n```python\r\ndef match(self, cls, subclasses=False):\r\n    \"\"\" Match cls or cls subclasses \"\"\"\r\n    if subclasses:\r\n        op = issubclass\r\n    else:\r\n        op = operator.is_\r\n\t\r\n    for i, w in enumerate(self._list):\r\n\tif op(w.category, cls):\r\n            yield i\r\n\r\n# Then .pop becomes\r\ndef pop(self, cls):\r\n    try:\r\n        i = next(self.match(cls, subclasses=True))\r\n        return self._list.pop(i)\r\n    except StopIteration:\r\n        __tracebackhide__ = True\r\n        raise AssertionError(f\"{cls!r} not found in warning list\")\r\n```\r\n\r\nWhat are your thoughts, @Zac-HD?\nSeems like you might be better of with [the stdlib `with warnings.catch_warnings(record=True, ...) as list_of_caught_warnings:`](https://docs.python.org/3/library/warnings.html#testing-warnings) function, and making assertions manually?\r\n\r\nPytest helpers are nice, but sometimes it's worth using the rest of Python instead üòÅ \nIt does remind me of the plan to integrate dirty equals better into pytest, it would be nice if there was a way to spell the warning matches for the contains check ",
  "created_at": "2023-07-02T12:19:27Z",
  "version": "8.0",
  "FAIL_TO_PASS": "[\"testing/test_recwarn.py::TestSubclassWarningPop::test_pop_finds_exact_match\", \"testing/test_recwarn.py::TestSubclassWarningPop::test_pop_finds_best_inexact_match\"]",
  "PASS_TO_PASS": "[\"testing/test_recwarn.py::test_recwarn_stacklevel\", \"testing/test_recwarn.py::test_recwarn_captures_deprecation_warning\", \"testing/test_recwarn.py::TestSubclassWarningPop::test_pop_raises_if_no_match\", \"testing/test_recwarn.py::TestWarningsRecorderChecker::test_recording\", \"testing/test_recwarn.py::TestWarningsRecorderChecker::test_warn_stacklevel\", \"testing/test_recwarn.py::TestWarningsRecorderChecker::test_typechecking\", \"testing/test_recwarn.py::TestWarningsRecorderChecker::test_invalid_enter_exit\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_call_raises\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_call\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_call_ret\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_call_preserves\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_explicit_call_raises\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_explicit_call\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_call_no_warning[context_manager]\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_call_no_warning[call]\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_call_modes[True-context_manager-PendingDeprecationWarning]\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_call_modes[True-context_manager-DeprecationWarning]\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_call_modes[True-call-PendingDeprecationWarning]\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_call_modes[True-call-DeprecationWarning]\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_call_modes[False-context_manager-PendingDeprecationWarning]\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_call_modes[False-context_manager-DeprecationWarning]\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_call_modes[False-call-PendingDeprecationWarning]\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_call_modes[False-call-DeprecationWarning]\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_call_specificity\", \"testing/test_recwarn.py::TestDeprecatedCall::test_deprecated_call_supports_match\", \"testing/test_recwarn.py::TestWarns::test_check_callable\", \"testing/test_recwarn.py::TestWarns::test_several_messages\", \"testing/test_recwarn.py::TestWarns::test_function\", \"testing/test_recwarn.py::TestWarns::test_warning_tuple\", \"testing/test_recwarn.py::TestWarns::test_as_contextmanager\", \"testing/test_recwarn.py::TestWarns::test_record\", \"testing/test_recwarn.py::TestWarns::test_record_only\", \"testing/test_recwarn.py::TestWarns::test_record_only_none_deprecated_warn\", \"testing/test_recwarn.py::TestWarns::test_record_by_subclass\", \"testing/test_recwarn.py::TestWarns::test_match_regex\", \"testing/test_recwarn.py::TestWarns::test_one_from_multiple_warns\", \"testing/test_recwarn.py::TestWarns::test_none_of_multiple_warns\", \"testing/test_recwarn.py::TestWarns::test_can_capture_previously_warned\", \"testing/test_recwarn.py::TestWarns::test_warns_context_manager_with_kwargs\", \"testing/test_recwarn.py::TestWarns::test_re_emit_single\", \"testing/test_recwarn.py::TestWarns::test_re_emit_multiple\", \"testing/test_recwarn.py::TestWarns::test_re_emit_match_single\", \"testing/test_recwarn.py::TestWarns::test_re_emit_match_multiple\", \"testing/test_recwarn.py::TestWarns::test_re_emit_non_match_single\", \"testing/test_recwarn.py::TestWarns::test_catch_warning_within_raise\", \"testing/test_recwarn.py::test_recwarn_functional\", \"testing/test_recwarn.py::TestWarns::test_double_test\"]",
  "environment_setup_commit": "10056865d2a4784934ce043908a0e78d0578f677",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.925193",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}