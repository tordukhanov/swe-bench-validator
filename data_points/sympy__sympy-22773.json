{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-22773",
  "base_commit": "96c9c40b2bd41105cf82440cc83c27f032ac5ffc",
  "patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -1066,7 +1066,6 @@ def _print_Abs(self, expr, exp=None):\n             return r\"%s^{%s}\" % (tex, exp)\n         else:\n             return tex\n-    _print_Determinant = _print_Abs\n \n     def _print_re(self, expr, exp=None):\n         if self._settings['gothic_re_im']:\n@@ -1657,7 +1656,7 @@ def _print_Piecewise(self, expr):\n         tex = r\"\\begin{cases} %s \\end{cases}\"\n         return tex % r\" \\\\\".join(ecpairs)\n \n-    def _print_MatrixBase(self, expr):\n+    def _print_matrix_contents(self, expr):\n         lines = []\n \n         for line in range(expr.rows):  # horrible, should be 'rows'\n@@ -1677,12 +1676,16 @@ def _print_MatrixBase(self, expr):\n         out_str = out_str.replace('%MATSTR%', mat_str)\n         if mat_str == 'array':\n             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')\n+        return out_str % r\"\\\\\".join(lines)\n+\n+    def _print_MatrixBase(self, expr):\n+        out_str = self._print_matrix_contents(expr)\n         if self._settings['mat_delim']:\n             left_delim = self._settings['mat_delim']\n             right_delim = self._delim_dict[left_delim]\n             out_str = r'\\left' + left_delim + out_str + \\\n                       r'\\right' + right_delim\n-        return out_str % r\"\\\\\".join(lines)\n+        return out_str\n \n     def _print_MatrixElement(self, expr):\n         return self.parenthesize(expr.parent, PRECEDENCE[\"Atom\"], strict=True)\\\n@@ -1707,8 +1710,9 @@ def _print_BlockMatrix(self, expr):\n \n     def _print_Transpose(self, expr):\n         mat = expr.arg\n-        from sympy.matrices import MatrixSymbol\n-        if not isinstance(mat, MatrixSymbol) and mat.is_MatrixExpr:\n+        from sympy.matrices import MatrixSymbol, BlockMatrix\n+        if (not isinstance(mat, MatrixSymbol) and\n+            not isinstance(mat, BlockMatrix) and mat.is_MatrixExpr):\n             return r\"\\left(%s\\right)^{T}\" % self._print(mat)\n         else:\n             s = self.parenthesize(mat, precedence_traditional(expr), True)\n@@ -1723,8 +1727,9 @@ def _print_Trace(self, expr):\n \n     def _print_Adjoint(self, expr):\n         mat = expr.arg\n-        from sympy.matrices import MatrixSymbol\n-        if not isinstance(mat, MatrixSymbol) and mat.is_MatrixExpr:\n+        from sympy.matrices import MatrixSymbol, BlockMatrix\n+        if (not isinstance(mat, MatrixSymbol) and\n+            not isinstance(mat, BlockMatrix) and mat.is_MatrixExpr):\n             return r\"\\left(%s\\right)^{\\dagger}\" % self._print(mat)\n         else:\n             s = self.parenthesize(mat, precedence_traditional(expr), True)\n@@ -1754,6 +1759,16 @@ def _print_MatMul(self, expr):\n         else:\n             return ' '.join(map(parens, args))\n \n+    def _print_Determinant(self, expr):\n+        mat = expr.arg\n+        if mat.is_MatrixExpr:\n+            from sympy.matrices.expressions.blockmatrix import BlockMatrix\n+            if isinstance(mat, BlockMatrix):\n+                return r\"\\left|{%s}\\right|\" % self._print_matrix_contents(mat.blocks)\n+            return r\"\\left|{%s}\\right|\" % self._print(mat)\n+        return r\"\\left|{%s}\\right|\" % self._print_matrix_contents(mat)\n+\n+\n     def _print_Mod(self, expr, exp=None):\n         if exp is not None:\n             return r'\\left(%s \\bmod %s\\right)^{%s}' % \\\n@@ -1795,7 +1810,7 @@ def _print_KroneckerProduct(self, expr):\n     def _print_MatPow(self, expr):\n         base, exp = expr.base, expr.exp\n         from sympy.matrices import MatrixSymbol\n-        if not isinstance(base, MatrixSymbol):\n+        if not isinstance(base, MatrixSymbol) and base.is_MatrixExpr:\n             return \"\\\\left(%s\\\\right)^{%s}\" % (self._print(base),\n                                               self._print(exp))\n         else:\ndiff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -315,7 +315,6 @@ def _print_Abs(self, e):\n         pform = self._print(e.args[0])\n         pform = prettyForm(*pform.parens('|', '|'))\n         return pform\n-    _print_Determinant = _print_Abs\n \n     def _print_floor(self, e):\n         if self._use_unicode:\n@@ -761,12 +760,24 @@ def _print_matrix_contents(self, e):\n \n         return D\n \n-    def _print_MatrixBase(self, e):\n+    def _print_MatrixBase(self, e, lparens='[', rparens=']'):\n         D = self._print_matrix_contents(e)\n         D.baseline = D.height()//2\n-        D = prettyForm(*D.parens('[', ']'))\n+        D = prettyForm(*D.parens(lparens, rparens))\n         return D\n \n+    def _print_Determinant(self, e):\n+        mat = e.arg\n+        if mat.is_MatrixExpr:\n+            from sympy.matrices.expressions.blockmatrix import BlockMatrix\n+            if isinstance(mat, BlockMatrix):\n+                return self._print_MatrixBase(mat.blocks, lparens='|', rparens='|')\n+            D = self._print(mat)\n+            D.baseline = D.height()//2\n+            return prettyForm(*D.parens('|', '|'))\n+        else:\n+            return self._print_MatrixBase(mat, lparens='|', rparens='|')\n+\n     def _print_TensorProduct(self, expr):\n         # This should somehow share the code with _print_WedgeProduct:\n         if self._use_unicode:\n@@ -842,21 +853,25 @@ def ppslice(x, dim):\n         return pform\n \n     def _print_Transpose(self, expr):\n-        pform = self._print(expr.arg)\n-        from sympy.matrices import MatrixSymbol\n-        if not isinstance(expr.arg, MatrixSymbol) and expr.arg.is_MatrixExpr:\n+        mat = expr.arg\n+        pform = self._print(mat)\n+        from sympy.matrices import MatrixSymbol, BlockMatrix\n+        if (not isinstance(mat, MatrixSymbol) and\n+            not isinstance(mat, BlockMatrix) and mat.is_MatrixExpr):\n             pform = prettyForm(*pform.parens())\n         pform = pform**(prettyForm('T'))\n         return pform\n \n     def _print_Adjoint(self, expr):\n-        pform = self._print(expr.arg)\n+        mat = expr.arg\n+        pform = self._print(mat)\n         if self._use_unicode:\n             dag = prettyForm('\\N{DAGGER}')\n         else:\n             dag = prettyForm('+')\n-        from sympy.matrices import MatrixSymbol\n-        if not isinstance(expr.arg, MatrixSymbol) and expr.arg.is_MatrixExpr:\n+        from sympy.matrices import MatrixSymbol, BlockMatrix\n+        if (not isinstance(mat, MatrixSymbol) and\n+            not isinstance(mat, BlockMatrix) and mat.is_MatrixExpr):\n             pform = prettyForm(*pform.parens())\n         pform = pform**dag\n         return pform\n@@ -925,7 +940,7 @@ def _print_DotProduct(self, expr):\n     def _print_MatPow(self, expr):\n         pform = self._print(expr.base)\n         from sympy.matrices import MatrixSymbol\n-        if not isinstance(expr.base, MatrixSymbol):\n+        if not isinstance(expr.base, MatrixSymbol) and expr.base.is_MatrixExpr:\n             pform = prettyForm(*pform.parens())\n         pform = pform**(self._print(expr.exp))\n         return pform\n",
  "test_patch": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -53,7 +53,8 @@\n     bernoulli, fibonacci, tribonacci, lucas, stieltjes, mathieuc, mathieus,\n     mathieusprime, mathieucprime)\n \n-from sympy.matrices import Adjoint, Inverse, MatrixSymbol, Transpose, KroneckerProduct\n+from sympy.matrices import (Adjoint, Inverse, MatrixSymbol, Transpose,\n+                            KroneckerProduct, BlockMatrix, OneMatrix, ZeroMatrix)\n from sympy.matrices.expressions import hadamard_power\n \n from sympy.physics import mechanics\n@@ -3672,6 +3673,60 @@ def test_Adjoint():\n         '‚éõ‚é°1  2‚é§    ‚éû \\n'\\\n         '‚éú‚é¢    ‚é• + X‚éü \\n'\\\n         '‚éù‚é£3  4‚é¶    ‚é† '\n+    assert upretty(Adjoint(BlockMatrix(((OneMatrix(2, 2), X),\n+                                        (m, ZeroMatrix(2, 2)))))) == \\\n+        '           ‚Ä†\\n'\\\n+        '‚é°  ùüô     X‚é§ \\n'\\\n+        '‚é¢         ‚é• \\n'\\\n+        '‚é¢‚é°1  2‚é§   ‚é• \\n'\\\n+        '‚é¢‚é¢    ‚é•  ùüò‚é• \\n'\\\n+        '‚é£‚é£3  4‚é¶   ‚é¶ '\n+\n+\n+def test_Transpose():\n+    X = MatrixSymbol('X', 2, 2)\n+    Y = MatrixSymbol('Y', 2, 2)\n+    assert pretty(Transpose(X)) == \" T\\nX \"\n+    assert pretty(Transpose(X + Y)) == \"       T\\n(X + Y) \"\n+    assert pretty(Transpose(X) + Transpose(Y)) == \" T    T\\nX  + Y \"\n+    assert pretty(Transpose(X*Y)) == \"     T\\n(X*Y) \"\n+    assert pretty(Transpose(Y)*Transpose(X)) == \" T  T\\nY *X \"\n+    assert pretty(Transpose(X**2)) == \"    T\\n/ 2\\\\ \\n\\\\X / \"\n+    assert pretty(Transpose(X)**2) == \"    2\\n/ T\\\\ \\n\\\\X / \"\n+    assert pretty(Transpose(Inverse(X))) == \"     T\\n/ -1\\\\ \\n\\\\X  / \"\n+    assert pretty(Inverse(Transpose(X))) == \"    -1\\n/ T\\\\  \\n\\\\X /  \"\n+    assert upretty(Transpose(X)) == \" T\\nX \"\n+    assert upretty(Transpose(X + Y)) == \"       T\\n(X + Y) \"\n+    assert upretty(Transpose(X) + Transpose(Y)) == \" T    T\\nX  + Y \"\n+    assert upretty(Transpose(X*Y)) == \"     T\\n(X‚ãÖY) \"\n+    assert upretty(Transpose(Y)*Transpose(X)) == \" T  T\\nY ‚ãÖX \"\n+    assert upretty(Transpose(X**2)) == \\\n+        \"    T\\n‚éõ 2‚éû \\n‚éùX ‚é† \"\n+    assert upretty(Transpose(X)**2) == \\\n+        \"    2\\n‚éõ T‚éû \\n‚éùX ‚é† \"\n+    assert upretty(Transpose(Inverse(X))) == \\\n+        \"     T\\n‚éõ -1‚éû \\n‚éùX  ‚é† \"\n+    assert upretty(Inverse(Transpose(X))) == \\\n+        \"    -1\\n‚éõ T‚éû  \\n‚éùX ‚é†  \"\n+    m = Matrix(((1, 2), (3, 4)))\n+    assert upretty(Transpose(m)) == \\\n+        '      T\\n'\\\n+        '‚é°1  2‚é§ \\n'\\\n+        '‚é¢    ‚é• \\n'\\\n+        '‚é£3  4‚é¶ '\n+    assert upretty(Transpose(m+X)) == \\\n+        '            T\\n'\\\n+        '‚éõ‚é°1  2‚é§    ‚éû \\n'\\\n+        '‚éú‚é¢    ‚é• + X‚éü \\n'\\\n+        '‚éù‚é£3  4‚é¶    ‚é† '\n+    assert upretty(Transpose(BlockMatrix(((OneMatrix(2, 2), X),\n+                                          (m, ZeroMatrix(2, 2)))))) == \\\n+        '           T\\n'\\\n+        '‚é°  ùüô     X‚é§ \\n'\\\n+        '‚é¢         ‚é• \\n'\\\n+        '‚é¢‚é°1  2‚é§   ‚é• \\n'\\\n+        '‚é¢‚é¢    ‚é•  ùüò‚é• \\n'\\\n+        '‚é£‚é£3  4‚é¶   ‚é¶ '\n \n \n def test_pretty_Trace_issue_9044():\n@@ -3816,6 +3871,30 @@ def test_pretty_dotproduct():\n     assert upretty(DotProduct(C, D)) == \"[1  2  3]‚ãÖ[1  3  4]\"\n \n \n+def test_pretty_Determinant():\n+    from sympy.matrices import Determinant, Inverse, BlockMatrix, OneMatrix, ZeroMatrix\n+    m = Matrix(((1, 2), (3, 4)))\n+    assert upretty(Determinant(m)) == '‚îÇ1  2‚îÇ\\n‚îÇ    ‚îÇ\\n‚îÇ3  4‚îÇ'\n+    assert upretty(Determinant(Inverse(m))) == \\\n+        '‚îÇ      -1‚îÇ\\n'\\\n+        '‚îÇ‚é°1  2‚é§  ‚îÇ\\n'\\\n+        '‚îÇ‚é¢    ‚é•  ‚îÇ\\n'\\\n+        '‚îÇ‚é£3  4‚é¶  ‚îÇ'\n+    X = MatrixSymbol('X', 2, 2)\n+    assert upretty(Determinant(X)) == '‚îÇX‚îÇ'\n+    assert upretty(Determinant(X + m)) == \\\n+        '‚îÇ‚é°1  2‚é§    ‚îÇ\\n'\\\n+        '‚îÇ‚é¢    ‚é• + X‚îÇ\\n'\\\n+        '‚îÇ‚é£3  4‚é¶    ‚îÇ'\n+    assert upretty(Determinant(BlockMatrix(((OneMatrix(2, 2), X),\n+                                            (m, ZeroMatrix(2, 2)))))) == \\\n+        '‚îÇ  ùüô     X‚îÇ\\n'\\\n+        '‚îÇ         ‚îÇ\\n'\\\n+        '‚îÇ‚é°1  2‚é§   ‚îÇ\\n'\\\n+        '‚îÇ‚é¢    ‚é•  ùüò‚îÇ\\n'\\\n+        '‚îÇ‚é£3  4‚é¶   ‚îÇ'\n+\n+\n def test_pretty_piecewise():\n     expr = Piecewise((x, x < 1), (x**2, True))\n     ascii_str = \\\ndiff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1940,6 +1940,21 @@ def test_Tr():\n     assert latex(t) == r'\\operatorname{tr}\\left(A B\\right)'\n \n \n+def test_Determinant():\n+    from sympy.matrices import Determinant, Inverse, BlockMatrix, OneMatrix, ZeroMatrix\n+    m = Matrix(((1, 2), (3, 4)))\n+    assert latex(Determinant(m)) == '\\\\left|{\\\\begin{matrix}1 & 2\\\\\\\\3 & 4\\\\end{matrix}}\\\\right|'\n+    assert latex(Determinant(Inverse(m))) == \\\n+        '\\\\left|{\\\\left[\\\\begin{matrix}1 & 2\\\\\\\\3 & 4\\\\end{matrix}\\\\right]^{-1}}\\\\right|'\n+    X = MatrixSymbol('X', 2, 2)\n+    assert latex(Determinant(X)) == '\\\\left|{X}\\\\right|'\n+    assert latex(Determinant(X + m)) == \\\n+        '\\\\left|{\\\\left[\\\\begin{matrix}1 & 2\\\\\\\\3 & 4\\\\end{matrix}\\\\right] + X}\\\\right|'\n+    assert latex(Determinant(BlockMatrix(((OneMatrix(2, 2), X),\n+                                          (m, ZeroMatrix(2, 2)))))) == \\\n+        '\\\\left|{\\\\begin{matrix}1 & X\\\\\\\\\\\\left[\\\\begin{matrix}1 & 2\\\\\\\\3 & 4\\\\end{matrix}\\\\right] & 0\\\\end{matrix}}\\\\right|'\n+\n+\n def test_Adjoint():\n     from sympy.matrices import Adjoint, Inverse, Transpose\n     X = MatrixSymbol('X', 2, 2)\n@@ -1960,6 +1975,10 @@ def test_Adjoint():\n     assert latex(Adjoint(m)) == '\\\\left[\\\\begin{matrix}1 & 2\\\\\\\\3 & 4\\\\end{matrix}\\\\right]^{\\\\dagger}'\n     assert latex(Adjoint(m+X)) == \\\n         '\\\\left(\\\\left[\\\\begin{matrix}1 & 2\\\\\\\\3 & 4\\\\end{matrix}\\\\right] + X\\\\right)^{\\\\dagger}'\n+    from sympy.matrices import BlockMatrix, OneMatrix, ZeroMatrix\n+    assert latex(Adjoint(BlockMatrix(((OneMatrix(2, 2), X),\n+                                      (m, ZeroMatrix(2, 2)))))) == \\\n+        '\\\\left[\\\\begin{matrix}1 & X\\\\\\\\\\\\left[\\\\begin{matrix}1 & 2\\\\\\\\3 & 4\\\\end{matrix}\\\\right] & 0\\\\end{matrix}\\\\right]^{\\\\dagger}'\n     # Issue 20959\n     Mx = MatrixSymbol('M^x', 2, 2)\n     assert latex(Adjoint(Mx)) == r'\\left(M^{x}\\right)^{\\dagger}'\n@@ -1980,6 +1999,10 @@ def test_Transpose():\n     assert latex(Transpose(m)) == '\\\\left[\\\\begin{matrix}1 & 2\\\\\\\\3 & 4\\\\end{matrix}\\\\right]^{T}'\n     assert latex(Transpose(m+X)) == \\\n         '\\\\left(\\\\left[\\\\begin{matrix}1 & 2\\\\\\\\3 & 4\\\\end{matrix}\\\\right] + X\\\\right)^{T}'\n+    from sympy.matrices import BlockMatrix, OneMatrix, ZeroMatrix\n+    assert latex(Transpose(BlockMatrix(((OneMatrix(2, 2), X),\n+                                        (m, ZeroMatrix(2, 2)))))) == \\\n+        '\\\\left[\\\\begin{matrix}1 & X\\\\\\\\\\\\left[\\\\begin{matrix}1 & 2\\\\\\\\3 & 4\\\\end{matrix}\\\\right] & 0\\\\end{matrix}\\\\right]^{T}'\n     # Issue 20959\n     Mx = MatrixSymbol('M^x', 2, 2)\n     assert latex(Transpose(Mx)) == r'\\left(M^{x}\\right)^{T}'\n",
  "problem_statement": "Incorrect LaTeX display of a determinant\nIt displays like |(A)| instead of |A|. I fixed that issue for myself in LatexPrinter like this:\r\n```python\r\n    def _print_Determinant(self, expr, exp=None):\r\n        mat_delim_backup = self._settings['mat_delim']\r\n        self._settings['mat_delim'] = ''\r\n        tex = r\"\\left|{%s}\\right|\" % self._print(expr.args[0])\r\n        self._settings['mat_delim'] = mat_delim_backup\r\n        if exp is not None:\r\n            return r\"%s^{%s}\" % (tex, exp)\r\n        else:\r\n            return tex\r\n```\r\ninstead of `_print_Determinant = _print_Abs`, but for two reasons I didn't create the pull request: I don't have time to comply with all the requiements and I'm not sure this is the best way to solve this issue\n",
  "hints_text": "I think this is probably a good enough way to solve it. The option would be to set the delimiter to `|`, but both approaches would include modifying and restoring the delimiter, so I cannot really see any benefit of the other way, rather the opposite.\r\n\r\nI think the only \"requirement\" is to add a test for it (and make sure the file ends with a single empty line in case you add the test at the end of the file). And, worst case, update any test that may use the previous formatting (but I do not know if there are any). Think about it, otherwise I can create a PR for it.",
  "created_at": "2021-12-31T12:47:30Z",
  "version": "1.11",
  "FAIL_TO_PASS": "[\"test_Adjoint\", \"test_Transpose\", \"test_pretty_Determinant\", \"test_Determinant\"]",
  "PASS_TO_PASS": "[\"test_pretty_ascii_str\", \"test_pretty_unicode_str\", \"test_upretty_greek\", \"test_upretty_multiindex\", \"test_upretty_sub_super\", \"test_upretty_subs_missing_in_24\", \"test_missing_in_2X_issue_9047\", \"test_upretty_modifiers\", \"test_pretty_Cycle\", \"test_pretty_Permutation\", \"test_pretty_basic\", \"test_negative_fractions\", \"test_Mul\", \"test_issue_5524\", \"test_pretty_ordering\", \"test_EulerGamma\", \"test_GoldenRatio\", \"test_Catalan\", \"test_pretty_relational\", \"test_Assignment\", \"test_AugmentedAssignment\", \"test_pretty_rational\", \"test_pretty_functions\", \"test_pretty_sqrt\", \"test_pretty_sqrt_char_knob\", \"test_pretty_sqrt_longsymbol_no_sqrt_char\", \"test_pretty_KroneckerDelta\", \"test_pretty_product\", \"test_pretty_Lambda\", \"test_pretty_TransferFunction\", \"test_pretty_Series\", \"test_pretty_Parallel\", \"test_pretty_Feedback\", \"test_pretty_MIMOFeedback\", \"test_pretty_TransferFunctionMatrix\", \"test_pretty_order\", \"test_pretty_derivatives\", \"test_pretty_integrals\", \"test_pretty_matrix\", \"test_pretty_ndim_arrays\", \"test_tensor_TensorProduct\", \"test_diffgeom_print_WedgeProduct\", \"test_pretty_Trace_issue_9044\", \"test_MatrixSlice\", \"test_MatrixExpressions\", \"test_pretty_dotproduct\", \"test_pretty_piecewise\", \"test_pretty_ITE\", \"test_pretty_seq\", \"test_any_object_in_sequence\", \"test_print_builtin_set\", \"test_pretty_sets\", \"test_pretty_SetExpr\", \"test_pretty_ImageSet\", \"test_pretty_ConditionSet\", \"test_pretty_ComplexRegion\", \"test_pretty_Union_issue_10414\", \"test_pretty_Intersection_issue_10414\", \"test_ProductSet_exponent\", \"test_ProductSet_parenthesis\", \"test_ProductSet_prod_char_issue_10413\", \"test_pretty_sequences\", \"test_pretty_FourierSeries\", \"test_pretty_FormalPowerSeries\", \"test_pretty_limits\", \"test_pretty_ComplexRootOf\", \"test_pretty_RootSum\", \"test_GroebnerBasis\", \"test_pretty_UniversalSet\", \"test_pretty_Boolean\", \"test_pretty_Domain\", \"test_pretty_prec\", \"test_pprint\", \"test_pretty_class\", \"test_pretty_no_wrap_line\", \"test_settings\", \"test_pretty_sum\", \"test_units\", \"test_pretty_Subs\", \"test_gammas\", \"test_beta\", \"test_function_subclass_different_name\", \"test_SingularityFunction\", \"test_deltas\", \"test_hyper\", \"test_meijerg\", \"test_noncommutative\", \"test_pretty_special_functions\", \"test_pretty_geometry\", \"test_expint\", \"test_elliptic_functions\", \"test_RandomDomain\", \"test_PrettyPoly\", \"test_issue_6285\", \"test_issue_6359\", \"test_issue_6739\", \"test_complicated_symbol_unchanged\", \"test_categories\", \"test_PrettyModules\", \"test_QuotientRing\", \"test_Homomorphism\", \"test_Tr\", \"test_pretty_Add\", \"test_issue_7179\", \"test_issue_7180\", \"test_pretty_Complement\", \"test_pretty_SymmetricDifference\", \"test_pretty_Contains\", \"test_issue_8292\", \"test_issue_4335\", \"test_issue_8344\", \"test_issue_6324\", \"test_issue_7927\", \"test_issue_6134\", \"test_issue_9877\", \"test_issue_13651\", \"test_pretty_primenu\", \"test_pretty_primeomega\", \"test_pretty_Mod\", \"test_issue_11801\", \"test_pretty_UnevaluatedExpr\", \"test_issue_10472\", \"test_MatrixElement_printing\", \"test_issue_12675\", \"test_MatrixSymbol_printing\", \"test_degree_printing\", \"test_vector_expr_pretty_printing\", \"test_pretty_print_tensor_expr\", \"test_pretty_print_tensor_partial_deriv\", \"test_issue_15560\", \"test_print_lerchphi\", \"test_issue_15583\", \"test_matrixSymbolBold\", \"test_center_accent\", \"test_imaginary_unit\", \"test_str_special_matrices\", \"test_pretty_misc_functions\", \"test_hadamard_power\", \"test_issue_17258\", \"test_is_combining\", \"test_issue_17616\", \"test_issue_17857\", \"test_issue_18272\", \"test_Str\", \"test_symbolic_probability\", \"test_issue_21758\", \"test_diffgeom\", \"test_printmethod\", \"test_latex_basic\", \"test_latex_builtins\", \"test_latex_SingularityFunction\", \"test_latex_cycle\", \"test_latex_permutation\", \"test_latex_Float\", \"test_latex_vector_expressions\", \"test_latex_symbols\", \"test_latex_functions\", \"test_hyper_printing\", \"test_latex_bessel\", \"test_latex_fresnel\", \"test_latex_brackets\", \"test_latex_indexed\", \"test_latex_derivatives\", \"test_latex_subs\", \"test_latex_integrals\", \"test_latex_sets\", \"test_latex_SetExpr\", \"test_latex_Range\", \"test_latex_sequences\", \"test_latex_FourierSeries\", \"test_latex_FormalPowerSeries\", \"test_latex_intervals\", \"test_latex_AccumuBounds\", \"test_latex_emptyset\", \"test_latex_universalset\", \"test_latex_commutator\", \"test_latex_union\", \"test_latex_intersection\", \"test_latex_symmetric_difference\", \"test_latex_Complement\", \"test_latex_productset\", \"test_latex_powerset\", \"test_latex_ordinals\", \"test_set_operators_parenthesis\", \"test_latex_Complexes\", \"test_latex_Naturals\", \"test_latex_Naturals0\", \"test_latex_Integers\", \"test_latex_ImageSet\", \"test_latex_ConditionSet\", \"test_latex_ComplexRegion\", \"test_latex_Contains\", \"test_latex_sum\", \"test_latex_product\", \"test_latex_limits\", \"test_latex_log\", \"test_issue_3568\", \"test_latex\", \"test_latex_dict\", \"test_latex_list\", \"test_latex_NumberSymbols\", \"test_latex_rational\", \"test_latex_inverse\", \"test_latex_DiracDelta\", \"test_latex_Heaviside\", \"test_latex_KroneckerDelta\", \"test_latex_LeviCivita\", \"test_mode\", \"test_latex_mathieu\", \"test_latex_Piecewise\", \"test_latex_Matrix\", \"test_latex_matrix_with_functions\", \"test_latex_NDimArray\", \"test_latex_mul_symbol\", \"test_latex_issue_4381\", \"test_latex_issue_4576\", \"test_latex_pow_fraction\", \"test_latex_order\", \"test_latex_Lambda\", \"test_latex_PolyElement\", \"test_latex_FracElement\", \"test_latex_Poly\", \"test_latex_Poly_order\", \"test_latex_ComplexRootOf\", \"test_latex_RootSum\", \"test_latex_numbers\", \"test_latex_euler\", \"test_lamda\", \"test_custom_symbol_names\", \"test_matAdd\", \"test_matMul\", \"test_latex_MatrixSlice\", \"test_latex_RandomDomain\", \"test_integral_transforms\", \"test_PolynomialRingBase\", \"test_Modules\", \"test_Hadamard\", \"test_MatPow\", \"test_ElementwiseApplyFunction\", \"test_ZeroMatrix\", \"test_OneMatrix\", \"test_Identity\", \"test_latex_DFT_IDFT\", \"test_boolean_args_order\", \"test_imaginary\", \"test_builtins_without_args\", \"test_latex_greek_functions\", \"test_translate\", \"test_other_symbols\", \"test_modifiers\", \"test_greek_symbols\", \"test_fancyset_symbols\", \"test_builtin_no_args\", \"test_issue_6853\", \"test_Pow\", \"test_issue_8409\", \"test_issue_8470\", \"test_issue_15439\", \"test_issue_2934\", \"test_issue_10489\", \"test_issue_12886\", \"test_issue_13559\", \"test_latex_UnevaluatedExpr\", \"test_KroneckerProduct_printing\", \"test_Series_printing\", \"test_TransferFunction_printing\", \"test_Parallel_printing\", \"test_TransferFunctionMatrix_printing\", \"test_Feedback_printing\", \"test_MIMOFeedback_printing\", \"test_Quaternion_latex_printing\", \"test_TensorProduct_printing\", \"test_WedgeProduct_printing\", \"test_issue_9216\", \"test_latex_printer_tensor\", \"test_multiline_latex\", \"test_issue_15353\", \"test_latex_symbolic_probability\", \"test_trace\", \"test_print_basic\", \"test_MatrixSymbol_bold\", \"test_AppliedPermutation\", \"test_PermutationMatrix\", \"test_text_re_im\", \"test_latex_diffgeom\", \"test_unit_printing\", \"test_issue_17092\", \"test_latex_decimal_separator\", \"test_latex_escape\", \"test_emptyPrinter\", \"test_global_settings\", \"test_pickleable\"]",
  "environment_setup_commit": "9a6104eab0ea7ac191a09c24f3e2d79dcd66bda5",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.150623",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}