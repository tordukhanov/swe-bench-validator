{
  "repo": "django/django",
  "instance_id": "django__django-14007",
  "base_commit": "619f26d2895d121854b1bed1b535d42b722e2eba",
  "patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1405,6 +1405,7 @@ def execute_sql(self, returning_fields=None):\n             returning_fields and len(self.query.objs) != 1 and\n             not self.connection.features.can_return_rows_from_bulk_insert\n         )\n+        opts = self.query.get_meta()\n         self.returning_fields = returning_fields\n         with self.connection.cursor() as cursor:\n             for sql, params in self.as_sql():\n@@ -1412,13 +1413,21 @@ def execute_sql(self, returning_fields=None):\n             if not self.returning_fields:\n                 return []\n             if self.connection.features.can_return_rows_from_bulk_insert and len(self.query.objs) > 1:\n-                return self.connection.ops.fetch_returned_insert_rows(cursor)\n-            if self.connection.features.can_return_columns_from_insert:\n+                rows = self.connection.ops.fetch_returned_insert_rows(cursor)\n+            elif self.connection.features.can_return_columns_from_insert:\n                 assert len(self.query.objs) == 1\n-                return [self.connection.ops.fetch_returned_insert_columns(cursor, self.returning_params)]\n-            return [(self.connection.ops.last_insert_id(\n-                cursor, self.query.get_meta().db_table, self.query.get_meta().pk.column\n-            ),)]\n+                rows = [self.connection.ops.fetch_returned_insert_columns(\n+                    cursor, self.returning_params,\n+                )]\n+            else:\n+                rows = [(self.connection.ops.last_insert_id(\n+                    cursor, opts.db_table, opts.pk.column,\n+                ),)]\n+        cols = [field.get_col(opts.db_table) for field in self.returning_fields]\n+        converters = self.get_converters(cols)\n+        if converters:\n+            rows = list(self.apply_converters(rows, converters))\n+        return rows\n \n \n class SQLDeleteCompiler(SQLCompiler):\n",
  "test_patch": "diff --git a/tests/custom_pk/fields.py b/tests/custom_pk/fields.py\n--- a/tests/custom_pk/fields.py\n+++ b/tests/custom_pk/fields.py\n@@ -20,7 +20,7 @@ def __eq__(self, other):\n         return self.value == other\n \n \n-class MyAutoField(models.CharField):\n+class MyWrapperField(models.CharField):\n \n     def __init__(self, *args, **kwargs):\n         kwargs['max_length'] = 10\n@@ -58,3 +58,15 @@ def get_db_prep_value(self, value, connection, prepared=False):\n         if isinstance(value, MyWrapper):\n             return str(value)\n         return value\n+\n+\n+class MyAutoField(models.BigAutoField):\n+    def from_db_value(self, value, expression, connection):\n+        if value is None:\n+            return None\n+        return MyWrapper(value)\n+\n+    def get_prep_value(self, value):\n+        if value is None:\n+            return None\n+        return int(value)\ndiff --git a/tests/custom_pk/models.py b/tests/custom_pk/models.py\n--- a/tests/custom_pk/models.py\n+++ b/tests/custom_pk/models.py\n@@ -7,7 +7,7 @@\n \n from django.db import models\n \n-from .fields import MyAutoField\n+from .fields import MyAutoField, MyWrapperField\n \n \n class Employee(models.Model):\n@@ -31,8 +31,12 @@ class Meta:\n \n \n class Bar(models.Model):\n-    id = MyAutoField(primary_key=True, db_index=True)\n+    id = MyWrapperField(primary_key=True, db_index=True)\n \n \n class Foo(models.Model):\n     bar = models.ForeignKey(Bar, models.CASCADE)\n+\n+\n+class CustomAutoFieldModel(models.Model):\n+    id = MyAutoField(primary_key=True)\ndiff --git a/tests/custom_pk/tests.py b/tests/custom_pk/tests.py\n--- a/tests/custom_pk/tests.py\n+++ b/tests/custom_pk/tests.py\n@@ -1,7 +1,8 @@\n from django.db import IntegrityError, transaction\n-from django.test import TestCase, skipIfDBFeature\n+from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n \n-from .models import Bar, Business, Employee, Foo\n+from .fields import MyWrapper\n+from .models import Bar, Business, CustomAutoFieldModel, Employee, Foo\n \n \n class BasicCustomPKTests(TestCase):\n@@ -230,3 +231,13 @@ def test_required_pk(self):\n         with self.assertRaises(IntegrityError):\n             with transaction.atomic():\n                 Employee.objects.create(first_name=\"Tom\", last_name=\"Smith\")\n+\n+    def test_auto_field_subclass_create(self):\n+        obj = CustomAutoFieldModel.objects.create()\n+        self.assertIsInstance(obj.id, MyWrapper)\n+\n+    @skipUnlessDBFeature('can_return_rows_from_bulk_insert')\n+    def test_auto_field_subclass_bulk_create(self):\n+        obj = CustomAutoFieldModel()\n+        CustomAutoFieldModel.objects.bulk_create([obj])\n+        self.assertIsInstance(obj.id, MyWrapper)\n",
  "problem_statement": "Database converters (from_db_value) not called for returning_fields on insert\nDescription\n\t\nMaking a subclass of BigAutoField, I've found that, unlike all other query pathways, on insert the returned integer is not passed through any database converters defined for the field - including the from_db_value hook.\nThis means that a field which would normally use a wrapper class has instead a plain integer.\nTake this field:\nclass MyAutoField(models.BigAutoField):\n\tdef from_db_value(self, value, expression, connection):\n\t\tif value is None:\n\t\t\treturn None\n\t\treturn MyIntWrapper(value)\n\tdef get_prep_value(self, value):\n\t\tif value is None:\n\t\t\treturn None\n\t\treturn int(value)\nAnd a model that uses it:\nclass AutoModel(models.Model):\n\tid = MyAutoField(primary_key=True)\nQueried instances have the wrapper class for id:\n>>> am = AutoModel.objects.first()\n>>> am.id\n<MyIntWrapper: 1>\nBut on creation, the returned integer is directly set as an attribute on the class:\n>>> am2 = AutoModel.objects.create()\n>>> am2.id\n2\nThis also affects bulk_create on backends that support fetching the primary key value:\n>>> ams = [AutoModel()]\n>>> AutoModel.objects.bulk_create(ams)\n[<AutoModel: AutoModel object (2)>]\n>>> ams[0].id\n2\n",
  "hints_text": "",
  "created_at": "2021-02-13T09:00:02Z",
  "version": "4.0",
  "FAIL_TO_PASS": "[\"test_auto_field_subclass_create (custom_pk.tests.CustomPKTests)\"]",
  "PASS_TO_PASS": "[\"Get can accept pk or the real attribute name\", \"Custom pks work with in_bulk, both for integer and non-integer types\", \"pk and attribute name are available on the model\", \"Both pk and custom attribute_name can be used in filter and friends\", \"Custom pk doesn't affect related_name based lookups\", \"Queries across tables, involving primary key\", \"custom pks do not affect save\", \"test_custom_field_pk (custom_pk.tests.CustomPKTests)\", \"New objects can be created both with pk and the custom name\", \"test_unicode_pk (custom_pk.tests.CustomPKTests)\", \"test_unique_pk (custom_pk.tests.CustomPKTests)\", \"test_zero_non_autoincrement_pk (custom_pk.tests.CustomPKTests)\"]",
  "environment_setup_commit": "475cffd1d64c690cdad16ede4d5e81985738ceb4",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.675525",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}