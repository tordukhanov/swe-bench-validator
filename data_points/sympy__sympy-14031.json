{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-14031",
  "base_commit": "19cee9e4cb9f2b5e78d20eb4ec1b7c6f80403f60",
  "patch": "diff --git a/sympy/polys/fields.py b/sympy/polys/fields.py\n--- a/sympy/polys/fields.py\n+++ b/sympy/polys/fields.py\n@@ -7,6 +7,8 @@\n from sympy.core.compatibility import is_sequence, reduce, string_types\n from sympy.core.expr import Expr\n from sympy.core.mod import Mod\n+from sympy.core.numbers import Exp1\n+from sympy.core.singleton import S\n from sympy.core.symbol import Symbol\n from sympy.core.sympify import CantSympify, sympify\n from sympy.functions.elementary.exponential import ExpBase\n@@ -218,16 +220,14 @@ def _rebuild(expr):\n                 return reduce(add, list(map(_rebuild, expr.args)))\n             elif expr.is_Mul:\n                 return reduce(mul, list(map(_rebuild, expr.args)))\n-            elif expr.is_Pow or isinstance(expr, ExpBase):\n+            elif expr.is_Pow or isinstance(expr, (ExpBase, Exp1)):\n                 b, e = expr.as_base_exp()\n                 # look for bg**eg whose integer power may be b**e\n-                choices = tuple((gen, bg, eg) for gen, (bg, eg) in powers\n-                    if bg == b and Mod(e, eg) == 0)\n-                if choices:\n-                    gen, bg, eg = choices[0]\n-                    return mapping.get(gen)**(e/eg)\n-                elif e.is_Integer:\n-                    return _rebuild(expr.base)**int(expr.exp)\n+                for gen, (bg, eg) in powers:\n+                    if bg == b and Mod(e, eg) == 0:\n+                        return mapping.get(gen)**int(e/eg)\n+                if e.is_Integer and e is not S.One:\n+                    return _rebuild(b)**int(e)\n \n             try:\n                 return domain.convert(expr)\n",
  "test_patch": "diff --git a/sympy/integrals/tests/test_integrals.py b/sympy/integrals/tests/test_integrals.py\n--- a/sympy/integrals/tests/test_integrals.py\n+++ b/sympy/integrals/tests/test_integrals.py\n@@ -1262,3 +1262,7 @@ def test_issue_12645():\n \n def test_issue_12677():\n     assert integrate(sin(x) / (cos(x)**3) , (x, 0, pi/6)) == Rational(1,6)\n+\n+def test_issue_14027():\n+    assert integrate(1/(1 + exp(x - S(1)/2)/(1 + exp(x))), x) == \\\n+        x - exp(S(1)/2)*log(exp(x) + exp(S(1)/2)/(1 + exp(S(1)/2)))/(exp(S(1)/2) + E)\ndiff --git a/sympy/polys/tests/test_fields.py b/sympy/polys/tests/test_fields.py\n--- a/sympy/polys/tests/test_fields.py\n+++ b/sympy/polys/tests/test_fields.py\n@@ -6,7 +6,7 @@\n from sympy.polys.orderings import lex\n \n from sympy.utilities.pytest import raises, XFAIL\n-from sympy.core import symbols, E\n+from sympy.core import symbols, E, S\n from sympy import sqrt, Rational, exp, log\n \n def test_FracField___init__():\n@@ -133,6 +133,8 @@ def test_FracElement_from_expr():\n         FracElement)\n     assert isinstance(ZZ[x**2].get_field().convert(x**(-6)),\n         FracElement)\n+    assert isinstance(ZZ[exp(S(1)/3)].get_field().convert(E),\n+        FracElement)\n \n \n def test_FracElement__lt_le_gt_ge__():\n",
  "problem_statement": "Failed coercion of an expression with E and exp to a field element\n```\r\nvar('x')\r\nf = 1/(1 + exp(x - S(1)/2)/(1 + exp(x)))\r\nintegrate(f, x)\r\n```\r\nthrows \r\n> sympy.polys.polyerrors.CoercionFailed: can't convert 1/(1 + E + 2*exp(1/2)) of type <class 'sympy.core.power.Pow'> to ZZ(exp(1/2))\r\n\r\nThis is the same kind of an issue that #13970 dealt with, apparently there is more to be done.\n",
  "hints_text": "@normalhuman  I tried on the sympy 1.0 which is on [live](http://live.sympy.org) console of sympy and that was not throwing an error for this particular expression\nThat's interesting, thanks. SymPy 1.1.1 throws that exception, however, as does the current master branch. \nThe immediate reason for failure, inability to coerce E to a field element, is easy to fix:\r\n```diff\r\ndiff --git a/sympy/polys/fields.py b/sympy/polys/fields.py\r\nindex 9f9fdb4..9338be5 100644\r\n--- a/sympy/polys/fields.py\r\n+++ b/sympy/polys/fields.py\r\n@@ -7,6 +7,8 @@\r\n from sympy.core.compatibility import is_sequence, reduce, string_types\r\n from sympy.core.expr import Expr\r\n from sympy.core.mod import Mod\r\n+from sympy.core.numbers import Exp1\r\n+from sympy.core.singleton import S\r\n from sympy.core.symbol import Symbol\r\n from sympy.core.sympify import CantSympify, sympify\r\n from sympy.functions.elementary.exponential import ExpBase\r\n@@ -218,7 +220,7 @@ def _rebuild(expr):\r\n                 return reduce(add, list(map(_rebuild, expr.args)))\r\n             elif expr.is_Mul:\r\n                 return reduce(mul, list(map(_rebuild, expr.args)))\r\n-            elif expr.is_Pow or isinstance(expr, ExpBase):\r\n+            elif expr.is_Pow or isinstance(expr, (ExpBase, Exp1)):\r\n                 b, e = expr.as_base_exp()\r\n                 # look for bg**eg whose integer power may be b**e\r\n                 choices = tuple((gen, bg, eg) for gen, (bg, eg) in powers\r\n@@ -226,8 +228,8 @@ def _rebuild(expr):\r\n                 if choices:\r\n                     gen, bg, eg = choices[0]\r\n                     return mapping.get(gen)**(e/eg)\r\n-                elif e.is_Integer:\r\n-                    return _rebuild(expr.base)**int(expr.exp)\r\n+                elif e.is_Integer and e is not S.One:\r\n+                    return _rebuild(b)**e\r\n``` \r\nSo, now E is understood to be an element of Z(exp(1/2)). However, there is another error, coming from     `gmpy_gcd(a, b)` getting Integer types instead of expected 'mpz' type, and I don't see why that is happening. ",
  "created_at": "2018-01-29T06:16:00Z",
  "version": "1.1",
  "FAIL_TO_PASS": "[\"test_FracElement_from_expr\"]",
  "PASS_TO_PASS": "[\"test_constructor\", \"test_diff_wrt\", \"test_conjugate_transpose\", \"test_integration\", \"test_multiple_integration\", \"test_issue_3532\", \"test_issue_3560\", \"test_integrate_poly\", \"test_integrate_poly_defined\", \"test_integrate_omit_var\", \"test_integrate_poly_accurately\", \"test_issue_3635\", \"test_issue_3618\", \"test_issue_3623\", \"test_issue_3679\", \"test_integrate_units\", \"test_issue_3788\", \"test_issue_3952\", \"test_issue_4516\", \"test_evalf_issue_939\", \"test_integrate_Abs_sign\", \"test_subs1\", \"test_subs2\", \"test_subs3\", \"test_subs4\", \"test_subs5\", \"test_subs6\", \"test_subs7\", \"test_expand\", \"test_integration_variable\", \"test_expand_integral\", \"test_as_sum_midpoint1\", \"test_as_sum_raises\", \"test_nested_doit\", \"test_issue_4665\", \"test_integral_reconstruct\", \"test_doit_integrals\", \"test_is_number\", \"test_symbols\", \"test_is_zero\", \"test_issue_5413\", \"test_issue_4892a\", \"test_powers\", \"test_issue_4803\", \"test_issue_4950\", \"test_FracField___init__\", \"test_FracField___hash__\", \"test_FracField___eq__\", \"test_sfield\", \"test_FracElement___hash__\", \"test_FracElement_copy\", \"test_FracElement_as_expr\", \"test_FracElement__lt_le_gt_ge__\", \"test_FracElement___neg__\", \"test_FracElement___add__\", \"test_FracElement___sub__\", \"test_FracElement___mul__\", \"test_FracElement___div__\", \"test_FracElement___pow__\", \"test_FracElement_diff\", \"test_FracElement_evaluate\", \"test_FracElement_subs\"]",
  "environment_setup_commit": "ec9e3c0436fbff934fa84e22bf07f1b3ef5bfac3",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.091028",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}