{
  "repo": "psf/requests",
  "instance_id": "psf__requests-1327",
  "base_commit": "e7786ec14fdf20e8c373eddc9ac0f67d211cb1b9",
  "patch": "diff --git a/requests/sessions.py b/requests/sessions.py\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -11,14 +11,13 @@\n import os\n from datetime import datetime\n \n-from .compat import cookielib\n+from .compat import cookielib, OrderedDict, urljoin, urlparse\n from .cookies import cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar\n from .models import Request, PreparedRequest\n from .hooks import default_hooks, dispatch_hook\n from .utils import from_key_val_list, default_headers\n from .exceptions import TooManyRedirects, InvalidSchema\n \n-from .compat import urlparse, urljoin\n from .adapters import HTTPAdapter\n \n from .utils import requote_uri, get_environ_proxies, get_netrc_auth\n@@ -223,9 +222,9 @@ def __init__(self):\n         self.cookies = cookiejar_from_dict({})\n \n         # Default connection adapters.\n-        self.adapters = {}\n-        self.mount('http://', HTTPAdapter())\n+        self.adapters = OrderedDict()\n         self.mount('https://', HTTPAdapter())\n+        self.mount('http://', HTTPAdapter())\n \n     def __enter__(self):\n         return self\n@@ -490,8 +489,13 @@ def close(self):\n             v.close()\n \n     def mount(self, prefix, adapter):\n-        \"\"\"Registers a connection adapter to a prefix.\"\"\"\n+        \"\"\"Registers a connection adapter to a prefix.\n+\n+        Adapters are sorted in descending order by key length.\"\"\"\n         self.adapters[prefix] = adapter\n+        keys_to_move = [k for k in self.adapters if len(k) < len(prefix)]\n+        for key in keys_to_move:\n+            self.adapters[key] = self.adapters.pop(key)\n \n     def __getstate__(self):\n         return dict((attr, getattr(self, attr, None)) for attr in self.__attrs__)\n",
  "test_patch": "diff --git a/test_requests.py b/test_requests.py\n--- a/test_requests.py\n+++ b/test_requests.py\n@@ -11,6 +11,7 @@\n \n import requests\n from requests.auth import HTTPDigestAuth\n+from requests.adapters import HTTPAdapter\n from requests.compat import str, cookielib\n from requests.cookies import cookiejar_from_dict\n from requests.structures import CaseInsensitiveDict\n@@ -482,6 +483,44 @@ def test_fixes_1329(self):\n             'application/json'\n         )\n \n+    def test_transport_adapter_ordering(self):\n+        s = requests.Session()\n+        order = ['https://', 'http://']\n+        self.assertEqual(order, list(s.adapters))\n+        s.mount('http://git', HTTPAdapter())\n+        s.mount('http://github', HTTPAdapter())\n+        s.mount('http://github.com', HTTPAdapter())\n+        s.mount('http://github.com/about/', HTTPAdapter())\n+        order = [\n+            'http://github.com/about/',\n+            'http://github.com',\n+            'http://github',\n+            'http://git',\n+            'https://',\n+            'http://',\n+        ]\n+        self.assertEqual(order, list(s.adapters))\n+        s.mount('http://gittip', HTTPAdapter())\n+        s.mount('http://gittip.com', HTTPAdapter())\n+        s.mount('http://gittip.com/about/', HTTPAdapter())\n+        order = [\n+            'http://github.com/about/',\n+            'http://gittip.com/about/',\n+            'http://github.com',\n+            'http://gittip.com',\n+            'http://github',\n+            'http://gittip',\n+            'http://git',\n+            'https://',\n+            'http://',\n+        ]\n+        self.assertEqual(order, list(s.adapters))\n+        s2 = requests.Session()\n+        s2.adapters = {'http://': HTTPAdapter()}\n+        s2.mount('https://', HTTPAdapter())\n+        self.assertTrue('http://' in s2.adapters)\n+        self.assertTrue('https://' in s2.adapters)\n+\n \n class TestCaseInsensitiveDict(unittest.TestCase):\n \n@@ -627,6 +666,5 @@ def test_preserve_last_key_case(self):\n         self.assertEqual(frozenset(cid), keyset)\n \n \n-\n if __name__ == '__main__':\n     unittest.main()\n",
  "problem_statement": "Transport adapters don't work as advertised\nHaving:\n\n``` python\n  >>> import requests\n  >>> s = requests.Session()\n```\n\nWe cannot currently reliably do::\n\n``` python\n  >>> import requests_testadapter\n  >>> s.mount('http://test.com', requests_testadapter.TestAdapter(b'Mock'))\n```\n\nWe should, this is documented: http://docs.python-requests.org/en/latest/user/advanced/#transport-adapters\n\nInstead, because of [Session.get_adapter()](https://github.com/kennethreitz/requests/blob/master/requests/sessions.py#L478) the following might or might not work as expected:\n\n``` python\n  >>> s.get('http://test.com')\n```\n\nThis is because there is already a default adapter for `'http://'` in the form of `requests.adapters.HTTPAdapter`. Depending on the (seemingly random) order of keys in the `s.adapters` dictionary, for some combinations of keys it will work, for others it won't.\n## Solutions\n\nThere are a couple. As usual, a compromise between backwards compatibility, clarity and performance.\n### Slow but compatible\n\nChange `Session.get_adapter()` so that it sorts the keys every time it fetches an adapter. The advantage is that `session_obj.adapters` is still a vanilla dictionary, if you consider it a public API.\n### A custom dictionary type\n\nSomething like Django's `SortedDict` which would sort the keys on insertion. The advantage is that `session_obj.adapters` is still a mapping and now `Session.get_adapter()` is faster. The disadvantage is the maintenance cost of a custom data structure. Also, mild backwards incompatibility if someone somewhere used the fact that `session_obj.adapters` is exactly of the type `dict` (unlikely, isn't it?).\n### A list of tuples\n\nHaving `Session.mount()` and `Session.get_adapter()` as the public API for adapters, we might just as well implement the sorting while mounting and just maintain `session_obj.adapters` as a list of tuples. The advantage is that it's the fastest solution with no additional maintenance burden. The disadvantage is backwards incompatibility.\n## We have to sort... but how exactly?\n\nThis is another design issue. It appears that sorting first from the longest key to shortest, and then alphabetically (for keys of the same length), is the way.\n## You decide\n\nWhat should we do about it? By the way, this test adapter in the example above [is an actual thing](https://pypi.python.org/pypi/requests-testadapter).\n\n",
  "hints_text": "> This is because there is already a default adapter for 'http://' in the form of requests.adapters.HTTPAdapter. Depending on the (seemingly random) order of keys in the s.adapters dictionary, for some combinations of keys it will work, for others it won't.\n\n**EDIT** None of the information in this comment is correct. There's nothing to see here except my embarrassment.\n\nThis has nothing to do with dictionary order. When we look an adapter we're looking for an adapter based on protocol, not hostname. We use `urlparse` to get the scheme (or protocol) and then we look for that in the adapters dictionary. With this in mind you get\n\n``` python\nuri = urlparse('http://test.com')\nassert uri.scheme == 'http://'\nassert uri.host == 'http://'\n```\n\nAnd we do `self.adapters.get(uri.scheme)` I believe. You would have to monkey patch `get_adapter` to get the behaviour you want.\n\nThat's how we do it now. As for the docs, I have no clue why that example is there because it is just plain wrong. Setting up an adapter for that though would probably be convenient for quite a few people though. One concern I have, though, is that it is a change that sort of breaks the API despite being documented as working that way.\n\n@Lukasa ideas?\n\nActually, @ambv is right. Here's the source code for `get_adapter()`:\n\n``` python\ndef get_adapter(self, url):\n    \"\"\"Returns the appropriate connnection adapter for the given URL.\"\"\"\n    for (prefix, adapter) in self.adapters.items():\n        if url.startswith(prefix):\n            return adapter\n\n    # Nothing matches :-/\n    raise InvalidSchema(\"No connection adapters were found for '%s'\" % url)\n```\n\nThis is awkward, because I've provided Transport Adapter information in the past that directly contradicts this behaviour. I think we need to fix this, because the docs behaviour should be correct. I'm happy to take a swing at this.\n\nI am sincerely sorry @ambv. That'll teach me to work from memory ever again. \n\nHere are my thoughts about this with the code above:\n- We could collect a list of matching adapters instead of returning the first one we find. The problem is then deciding which adapter to use\n- We could maintain two separate adapters registries: 1) user-created 2) default. The user-created adapters would be the first to be searched through and if there's a match in them we could then return that. If none of those match we would then search the default adapters and if nothing matches from there raise the `InvalidSchema` error. To preserve the API we could make `adapters` a property. The `@adapters.setter` method would then only set adapters on the user-created dictionary. The returned information would then be best represented as a list of two-tuples where the user-created items come first and is then followed by the default. This gives an intuitive idea of the overall ordering of discovery of adapters. This, however, would break the case where someone tries to do `session.adapters['http://']`\n- We could create our own `AdaptersRegistry` object which behaves like a dictionary, i.e., has the `__setitem__`, `__getitem__`, `get`, `set`, &c., methods, and does the search for us. Then we just maintain that as the `adapters` attribute.\n\nI could be vastly over-thinking the problem though.\n\nI think we're totally over-engineering this. If we were going to do this properly we'd implement a trie and cause it to mimic the dictionary interface (not hard).\n\nThe reality is, we don't need to. We can assert that the number of transport adapters plugged into any session is likely to be small. If that's the case, we should just do:\n\n``` python\nbest = ''\nfor key, adapter in self.adapters.items():\n    if url.startswith(key) and (len(best) < len(key)):\n        best = key\n\nreturn self.adapters.get(best, None)\n```\n\nThis way we don't have to maintain a new data structure. Unless @kennethreitz wants to, of course, in which case I'll happily whip up a pure-Python trie. =)\n\n> I think we're totally over-engineering this.\n\ns/we/you (where you is me) ;)\n\nAnd yeah that does sound like it should work.\n\nOne of the valid use cases for adapters is unit testing. Tests should run as fast as possible, spending time sorting adapters in place every time is wasteful. I don't like the approach taken in #1323 because `get_adapter()` is called for every single request.\n\nI'd like @kennethreitz to weigh in here whether he considers session.adapters a public API. For what it's worth this attribute is not listed in the \"Developers Interface\" section of the docs here: http://www.python-requests.org/en/latest/api/#request-sessions\n\nRespectfully, I disagree.\n\nYes, it's not completely optimised. However, you have to consider the use cases. The overwhelming majority of cases will have two adapters installed: the defaults. My fix adds one-half of a dictionary iteration (on average), plus four length checks in this case. The next highest number of cases will have one other adapter in place. This means my fix adds one dictionary iteration (on average), plus six length checks. Actually, my performance is better, because we only do the length check if the prefix matches (so if we're doing HTTP, we don't do a length check on `'https://'`).\n\nFor perspective, on a GET request in Requests as we speak, we hit the following:\n\n```\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n7975/7767    0.001    0.000    0.001    0.000 {len}\n       66    0.000    0.000    0.000    0.000 {method 'items' of 'dict' objects}\n```\n\nEven being generous and saying we would save six calls to `len` is barely a drop in the water.\n\nIterating over a dictionary isn't slow either. Using the following test code:\n\n``` python\na = {'hi': 'there', 'hello': 'there', 'sup': 'yo'}\n\nfor i in range(0, 1000000):\n    for key, value in a.items():\n        pass\n```\n\nRunning it in my shell and using `time` (so I'm also bearing the startup and teardown cost of the VM), we get:\n\n```\npython test.py  0.90s user 0.04s system 99% cpu 0.949 total\n```\n\nDividing by the number of iterations gives us 0.949/1000000 = 0.949ms per pass over the dictionary, or 0.3ms per dictionary element. I think we can bear the extra 300 nanoseconds. =)\n\nLet's just do an ordered dict and search backwards for the first compatible adapter.\n\nDoesn't ordered dict mean 'insertion order'? Because that won't actually fix our problem.\n\nOh, nevermind, we'll just rebuild the dict in the call to `mount()`. Ignore me. =)\n\nWould you mind if I prepare the PR? :)\n\nIf that was aimed at me, then the answer is of course not. =)\n",
  "created_at": "2013-04-25T10:01:49Z",
  "version": "1.2",
  "FAIL_TO_PASS": "[\"test_requests.py::RequestsTestCase::test_transport_adapter_ordering\"]",
  "PASS_TO_PASS": "[\"test_requests.py::RequestsTestCase::test_basic_building\", \"test_requests.py::RequestsTestCase::test_cannot_send_unprepared_requests\", \"test_requests.py::RequestsTestCase::test_cookie_parameters\", \"test_requests.py::RequestsTestCase::test_entry_points\", \"test_requests.py::RequestsTestCase::test_get_auth_from_url\", \"test_requests.py::RequestsTestCase::test_hook_receives_request_arguments\", \"test_requests.py::RequestsTestCase::test_http_error\", \"test_requests.py::RequestsTestCase::test_invalid_url\", \"test_requests.py::RequestsTestCase::test_links\", \"test_requests.py::RequestsTestCase::test_no_content_length\", \"test_requests.py::RequestsTestCase::test_params_are_added_before_fragment\", \"test_requests.py::RequestsTestCase::test_path_is_not_double_encoded\", \"test_requests.py::RequestsTestCase::test_response_is_iterable\", \"test_requests.py::TestCaseInsensitiveDict::test_contains\", \"test_requests.py::TestCaseInsensitiveDict::test_delitem\", \"test_requests.py::TestCaseInsensitiveDict::test_docstring_example\", \"test_requests.py::TestCaseInsensitiveDict::test_equality\", \"test_requests.py::TestCaseInsensitiveDict::test_fixes_649\", \"test_requests.py::TestCaseInsensitiveDict::test_get\", \"test_requests.py::TestCaseInsensitiveDict::test_getitem\", \"test_requests.py::TestCaseInsensitiveDict::test_iter\", \"test_requests.py::TestCaseInsensitiveDict::test_iterable_init\", \"test_requests.py::TestCaseInsensitiveDict::test_kwargs_init\", \"test_requests.py::TestCaseInsensitiveDict::test_len\", \"test_requests.py::TestCaseInsensitiveDict::test_lower_items\", \"test_requests.py::TestCaseInsensitiveDict::test_mapping_init\", \"test_requests.py::TestCaseInsensitiveDict::test_preserve_key_case\", \"test_requests.py::TestCaseInsensitiveDict::test_preserve_last_key_case\", \"test_requests.py::TestCaseInsensitiveDict::test_setdefault\", \"test_requests.py::TestCaseInsensitiveDict::test_update\", \"test_requests.py::TestCaseInsensitiveDict::test_update_retains_unchanged\"]",
  "environment_setup_commit": "d8268fb7b44da7b8aa225eb1ca6fbdb4f9dc2457",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.846857",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}