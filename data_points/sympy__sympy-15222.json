{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-15222",
  "base_commit": "678217d5cc4973e2471c20e4396bf39e52d93eb1",
  "patch": "diff --git a/sympy/core/function.py b/sympy/core/function.py\n--- a/sympy/core/function.py\n+++ b/sympy/core/function.py\n@@ -49,7 +49,7 @@\n from sympy.core.compatibility import string_types, with_metaclass, range\n from sympy.utilities import default_sort_key\n from sympy.utilities.misc import filldedent\n-from sympy.utilities.iterables import uniq\n+from sympy.utilities.iterables import has_dups\n from sympy.core.evaluate import global_evaluate\n \n import sys\n@@ -130,8 +130,6 @@ def _getnargs_new(eval_):\n         return tuple(range(num_no_default, num_no_default+num_with_default+1))\n \n \n-\n-\n class FunctionClass(ManagedProperties):\n     \"\"\"\n     Base class for function classes. FunctionClass is a subclass of type.\n@@ -314,7 +312,7 @@ def _eval_subs(self, old, new):\n         if (old.is_Function and new.is_Function and\n             callable(old) and callable(new) and\n             old == self.func and len(self.args) in new.nargs):\n-            return new(*self.args)\n+            return new(*[i._subs(old, new) for i in self.args])\n \n \n class Function(Application, Expr):\n@@ -512,7 +510,7 @@ def is_commutative(self):\n     def _eval_evalf(self, prec):\n         # Lookup mpmath function based on name\n         try:\n-            if isinstance(self.func, UndefinedFunction):\n+            if isinstance(self, AppliedUndef):\n                 # Shouldn't lookup in mpmath but might have ._imp_\n                 raise AttributeError\n             fname = self.func.__name__\n@@ -605,6 +603,7 @@ def _eval_nseries(self, x, n, logx):\n         \"\"\"\n         This function does compute series for multivariate functions,\n         but the expansion is always in terms of *one* variable.\n+\n         Examples\n         ========\n \n@@ -835,6 +834,7 @@ def __eq__(self, other):\n     def __ne__(self, other):\n         return not self == other\n \n+\n class WildFunction(Function, AtomicExpr):\n     \"\"\"\n     A WildFunction function matches any function (with its arguments).\n@@ -1756,14 +1756,17 @@ class Subs(Expr):\n     \"\"\"\n     def __new__(cls, expr, variables, point, **assumptions):\n         from sympy import Symbol\n+\n         if not is_sequence(variables, Tuple):\n             variables = [variables]\n-        variables = list(sympify(variables))\n+        variables = Tuple(*variables)\n \n-        if list(uniq(variables)) != variables:\n-            repeated = [ v for v in set(variables) if variables.count(v) > 1 ]\n-            raise ValueError('cannot substitute expressions %s more than '\n-                             'once.' % repeated)\n+        if has_dups(variables):\n+            repeated = [str(v) for v, i in Counter(variables).items() if i > 1]\n+            __ = ', '.join(repeated)\n+            raise ValueError(filldedent('''\n+                The following expressions appear more than once: %s\n+                ''' % __))\n \n         point = Tuple(*(point if is_sequence(point, Tuple) else [point]))\n \n@@ -1771,7 +1774,16 @@ def __new__(cls, expr, variables, point, **assumptions):\n             raise ValueError('Number of point values must be the same as '\n                              'the number of variables.')\n \n-        expr = sympify(expr)\n+        if not point:\n+            return sympify(expr)\n+\n+        # denest\n+        if isinstance(expr, Subs):\n+            variables = expr.variables + variables\n+            point = expr.point + point\n+            expr = expr.expr\n+        else:\n+            expr = sympify(expr)\n \n         # use symbols with names equal to the point value (with preppended _)\n         # to give a variable-independent expression\n@@ -1842,15 +1854,10 @@ def expr_free_symbols(self):\n         return (self.expr.expr_free_symbols - set(self.variables) |\n             set(self.point.expr_free_symbols))\n \n-    def _has(self, pattern):\n-        if pattern in self.variables and pattern not in self.point:\n-            return False\n-        return super(Subs, self)._has(pattern)\n-\n     def __eq__(self, other):\n         if not isinstance(other, Subs):\n             return False\n-        return self._expr == other._expr\n+        return self._hashable_content() == other._hashable_content()\n \n     def __ne__(self, other):\n         return not(self == other)\n@@ -1859,14 +1866,29 @@ def __hash__(self):\n         return super(Subs, self).__hash__()\n \n     def _hashable_content(self):\n-        return (self._expr.xreplace(self.canonical_variables),)\n+        return (self._expr.xreplace(self.canonical_variables),\n+            ) + tuple(ordered([(v, p) for v, p in\n+            zip(self.variables, self.point) if not self.expr.has(v)]))\n \n     def _eval_subs(self, old, new):\n+        # Subs doit will do the variables in order; the semantics\n+        # of subs for Subs is have the following invariant for\n+        # Subs object foo:\n+        #    foo.doit().subs(reps) == foo.subs(reps).doit()\n+        pt = list(self.point)\n         if old in self.variables:\n-            if old in self.point:\n-                newpoint = tuple(new if i == old else i for i in self.point)\n-                return self.func(self.expr, self.variables, newpoint)\n-            return self\n+            i = self.variables.index(old)\n+            # any occurance of old before this point will get\n+            # handled by replacements from here on\n+            for j in range(i, len(self.variables)):\n+                pt[j] = pt[j]._subs(old, new)\n+            return self.func(self.expr, self.variables, pt)\n+        v = [i._subs(old, new) for i in self.variables]\n+        if v != list(self.variables):\n+            return self.func(self.expr, self.variables + (old,), pt + [new])\n+        expr = self.expr._subs(old, new)\n+        pt = [i._subs(old, new) for i in self.point]\n+        return self.func(expr, v, pt)\n \n     def _eval_derivative(self, s):\n         # Apply the chain rule of the derivative on the substitution variables:\n",
  "test_patch": "diff --git a/sympy/core/tests/test_function.py b/sympy/core/tests/test_function.py\n--- a/sympy/core/tests/test_function.py\n+++ b/sympy/core/tests/test_function.py\n@@ -191,7 +191,6 @@ def test_Lambda():\n     assert Lambda(x, 1)(1) is S.One\n \n \n-\n def test_IdentityFunction():\n     assert Lambda(x, x) is Lambda(y, y) is S.IdentityFunction\n     assert Lambda(x, 2*x) is not S.IdentityFunction\n@@ -221,6 +220,15 @@ def test_Lambda_equality():\n \n \n def test_Subs():\n+    assert Subs(1, (), ()) is S.One\n+    # check null subs influence on hashing\n+    assert Subs(x, y, z) != Subs(x, y, 1)\n+    # self mapping var/point\n+    assert Subs(Derivative(f(x), (x, 2)), x, x).doit() == f(x).diff(x, x)\n+    assert Subs(x, x, 0).has(x)  # it's a structural answer\n+    assert not Subs(x, x, 0).free_symbols\n+    assert Subs(Subs(x + y, x, 2), y, 1) == Subs(x + y, (x, y), (2, 1))\n+    assert Subs(x, (x,), (0,)) == Subs(x, x, 0)\n     assert Subs(x, x, 0) == Subs(y, y, 0)\n     assert Subs(x, x, 0).subs(x, 1) == Subs(x, x, 0)\n     assert Subs(y, x, 0).subs(y, 1) == Subs(1, x, 0)\n@@ -228,8 +236,7 @@ def test_Subs():\n     assert Subs(f(x**2), x**2, 0).doit() == f(0)\n     assert Subs(f(x, y, z), (x, y, z), (0, 1, 1)) != \\\n         Subs(f(x, y, z), (x, y, z), (0, 0, 1))\n-    assert Subs(f(x, y), (x, y, z), (0, 1, 1)) == \\\n-        Subs(f(x, y), (x, y, z), (0, 1, 2))\n+    assert Subs(x, y, 2).subs(x, y).doit() == 2\n     assert Subs(f(x, y), (x, y, z), (0, 1, 1)) != \\\n         Subs(f(x, y) + z, (x, y, z), (0, 1, 0))\n     assert Subs(f(x, y), (x, y), (0, 1)).doit() == f(0, 1)\n@@ -926,6 +933,7 @@ def test_order_could_be_zero():\n     assert diff(y, (x, n + 1)) == S.Zero\n     assert diff(y, (x, m)) == S.Zero\n \n+\n def test_undefined_function_eq():\n     f = Function('f')\n     f2 = Function('f')\n@@ -941,6 +949,7 @@ def test_undefined_function_eq():\n \n     assert f != f_real\n \n+\n def test_function_assumptions():\n     x = Symbol('x')\n     f = Function('f')\ndiff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -780,3 +780,27 @@ def test_issue_12657():\n     reps = [(-oo, 2), (oo, 1)]\n     assert (x < oo).subs(reps) == (x < 1)\n     assert (x < oo).subs(list(reversed(reps))) == (x < 1)\n+\n+\n+def test_recurse_Application_args():\n+    F = Lambda((x, y), exp(2*x + 3*y))\n+    f = Function('f')\n+    A = f(x, f(x, x))\n+    C = F(x, F(x, x))\n+    assert A.subs(f, F) == A.replace(f, F) == C\n+\n+\n+def test_Subs_subs():\n+    assert Subs(x*y, x, x).subs(x, y) == Subs(x*y, x, y)\n+    assert Subs(x*y, x, x + 1).subs(x, y) == \\\n+        Subs(x*y, x, y + 1)\n+    assert Subs(x*y, y, x + 1).subs(x, y) == \\\n+        Subs(y**2, y, y + 1)\n+    a = Subs(x*y*z, (y, x, z), (x + 1, x + z, x))\n+    b = Subs(x*y*z, (y, x, z), (x + 1, y + z, y))\n+    assert a.subs(x, y) == b and \\\n+        a.doit().subs(x, y) == a.subs(x, y).doit()\n+    f = Function('f')\n+    g = Function('g')\n+    assert Subs(2*f(x, y) + g(x), f(x, y), 1).subs(y, 2) == Subs(\n+        2*f(x, y) + g(x), (f(x, y), y), (1, 2))\n",
  "problem_statement": "Subs hashing problem?\n```python\r\n>>> Subs(x+y,(a,),(4,)).subs(a,z)\r\nSubs(x + y, (a,), (4,))  <---|\r\n>>> Subs(x+y,(a,),(a,))      |\r\nSubs(x + y, (a,), (a,))      |\r\n>>> _.subs(a,z)              |\r\nSubs(x + y, (a,), (4,))  <---|  expected this to be Subs(x + y, (a,), (z,))\r\n```\n",
  "hints_text": "",
  "created_at": "2018-09-12T15:15:56Z",
  "version": "1.4",
  "FAIL_TO_PASS": "[\"test_Subs\", \"test_recurse_Application_args\"]",
  "PASS_TO_PASS": "[\"test_f_expand_complex\", \"test_bug1\", \"test_general_function\", \"test_general_function_nullary\", \"test_derivative_subs_bug\", \"test_derivative_subs_self_bug\", \"test_derivative_linearity\", \"test_derivative_evaluate\", \"test_diff_symbols\", \"test_Function\", \"test_nargs\", \"test_Lambda\", \"test_IdentityFunction\", \"test_Lambda_symbols\", \"test_Lambda_arguments\", \"test_Lambda_equality\", \"test_expand_function\", \"test_function_comparable\", \"test_deriv1\", \"test_deriv2\", \"test_func_deriv\", \"test_suppressed_evaluation\", \"test_function_evalf\", \"test_extensibility_eval\", \"test_function_non_commutative\", \"test_function_complex\", \"test_function__eval_nseries\", \"test_doit\", \"test_evalf_default\", \"test_issue_5399\", \"test_derivative_numerically\", \"test_fdiff_argument_index_error\", \"test_deriv_wrt_function\", \"test_diff_wrt_value\", \"test_diff_wrt\", \"test_diff_wrt_func_subs\", \"test_subs_in_derivative\", \"test_diff_wrt_not_allowed\", \"test_klein_gordon_lagrangian\", \"test_sho_lagrangian\", \"test_straight_line\", \"test_sort_variable\", \"test_multiple_derivative\", \"test_unhandled\", \"test_nfloat\", \"test_issue_7068\", \"test_issue_7231\", \"test_issue_7687\", \"test_issue_7688\", \"test_mexpand\", \"test_issue_8469\", \"test_issue_12996\", \"test_should_evalf\", \"test_Derivative_as_finite_difference\", \"test_issue_11159\", \"test_issue_12005\", \"test_issue_13843\", \"test_issue_13873\", \"test_order_could_be_zero\", \"test_undefined_function_eq\", \"test_function_assumptions\", \"test_undef_fcn_float_issue_6938\", \"test_subs\", \"test_subs_Matrix\", \"test_subs_AccumBounds\", \"test_trigonometric\", \"test_powers\", \"test_logexppow\", \"test_bug\", \"test_subbug1\", \"test_subbug2\", \"test_dict_set\", \"test_dict_ambigous\", \"test_deriv_sub_bug3\", \"test_equality_subs1\", \"test_equality_subs2\", \"test_issue_3742\", \"test_subs_dict1\", \"test_mul\", \"test_subs_simple\", \"test_subs_constants\", \"test_subs_commutative\", \"test_subs_noncommutative\", \"test_subs_basic_funcs\", \"test_subs_wild\", \"test_subs_mixed\", \"test_division\", \"test_add\", \"test_subs_issue_4009\", \"test_functions_subs\", \"test_derivative_subs\", \"test_derivative_subs2\", \"test_derivative_subs3\", \"test_issue_5284\", \"test_subs_iter\", \"test_subs_dict\", \"test_no_arith_subs_on_floats\", \"test_issue_5651\", \"test_issue_6075\", \"test_issue_6079\", \"test_issue_4680\", \"test_issue_6158\", \"test_Function_subs\", \"test_simultaneous_subs\", \"test_issue_6419_6421\", \"test_issue_6559\", \"test_issue_5261\", \"test_issue_6923\", \"test_2arg_hack\", \"test_noncommutative_subs\", \"test_issue_2877\", \"test_issue_5910\", \"test_issue_5217\", \"test_issue_10829\", \"test_pow_eval_subs_no_cache\", \"test_RootOf_issue_10092\", \"test_issue_8886\", \"test_issue_12657\"]",
  "environment_setup_commit": "73b3f90093754c5ed1561bd885242330e3583004",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.096920",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}