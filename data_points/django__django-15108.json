{
  "repo": "django/django",
  "instance_id": "django__django-15108",
  "base_commit": "a17becf4c7f4e4057e8c94990e4b4999be0aea95",
  "patch": "diff --git a/django/contrib/postgres/aggregates/mixins.py b/django/contrib/postgres/aggregates/mixins.py\n--- a/django/contrib/postgres/aggregates/mixins.py\n+++ b/django/contrib/postgres/aggregates/mixins.py\n@@ -1,48 +1,27 @@\n-from django.db.models import F, OrderBy\n+from django.db.models.expressions import OrderByList\n \n \n class OrderableAggMixin:\n \n     def __init__(self, *expressions, ordering=(), **extra):\n-        if not isinstance(ordering, (list, tuple)):\n-            ordering = [ordering]\n-        ordering = ordering or []\n-        # Transform minus sign prefixed strings into an OrderBy() expression.\n-        ordering = (\n-            (OrderBy(F(o[1:]), descending=True) if isinstance(o, str) and o[0] == '-' else o)\n-            for o in ordering\n-        )\n+        if isinstance(ordering, (list, tuple)):\n+            self.order_by = OrderByList(*ordering)\n+        else:\n+            self.order_by = OrderByList(ordering)\n         super().__init__(*expressions, **extra)\n-        self.ordering = self._parse_expressions(*ordering)\n \n     def resolve_expression(self, *args, **kwargs):\n-        self.ordering = [expr.resolve_expression(*args, **kwargs) for expr in self.ordering]\n+        self.order_by = self.order_by.resolve_expression(*args, **kwargs)\n         return super().resolve_expression(*args, **kwargs)\n \n-    def as_sql(self, compiler, connection):\n-        if self.ordering:\n-            ordering_params = []\n-            ordering_expr_sql = []\n-            for expr in self.ordering:\n-                expr_sql, expr_params = compiler.compile(expr)\n-                ordering_expr_sql.append(expr_sql)\n-                ordering_params.extend(expr_params)\n-            sql, sql_params = super().as_sql(compiler, connection, ordering=(\n-                'ORDER BY ' + ', '.join(ordering_expr_sql)\n-            ))\n-            return sql, (*sql_params, *ordering_params)\n-        return super().as_sql(compiler, connection, ordering='')\n+    def get_source_expressions(self):\n+        return super().get_source_expressions() + [self.order_by]\n \n     def set_source_expressions(self, exprs):\n-        # Extract the ordering expressions because ORDER BY clause is handled\n-        # in a custom way.\n-        self.ordering = exprs[self._get_ordering_expressions_index():]\n-        return super().set_source_expressions(exprs[:self._get_ordering_expressions_index()])\n+        *exprs, self.order_by = exprs\n+        return super().set_source_expressions(exprs)\n \n-    def get_source_expressions(self):\n-        return super().get_source_expressions() + self.ordering\n-\n-    def _get_ordering_expressions_index(self):\n-        \"\"\"Return the index at which the ordering expressions start.\"\"\"\n-        source_expressions = self.get_source_expressions()\n-        return len(source_expressions) - len(self.ordering)\n+    def as_sql(self, compiler, connection):\n+        order_by_sql, order_by_params = compiler.compile(self.order_by)\n+        sql, sql_params = super().as_sql(compiler, connection, ordering=order_by_sql)\n+        return sql, (*sql_params, *order_by_params)\ndiff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -915,8 +915,8 @@ def get_group_by_cols(self, alias=None):\n class ExpressionList(Func):\n     \"\"\"\n     An expression containing multiple expressions. Can be used to provide a\n-    list of expressions as an argument to another expression, like an\n-    ordering clause.\n+    list of expressions as an argument to another expression, like a partition\n+    clause.\n     \"\"\"\n     template = '%(expressions)s'\n \n@@ -933,6 +933,26 @@ def as_sqlite(self, compiler, connection, **extra_context):\n         return self.as_sql(compiler, connection, **extra_context)\n \n \n+class OrderByList(Func):\n+    template = 'ORDER BY %(expressions)s'\n+\n+    def __init__(self, *expressions, **extra):\n+        expressions = (\n+            (\n+                OrderBy(F(expr[1:]), descending=True)\n+                if isinstance(expr, str) and expr[0] == '-'\n+                else expr\n+            )\n+            for expr in expressions\n+        )\n+        super().__init__(*expressions, **extra)\n+\n+    def as_sql(self, *args, **kwargs):\n+        if not self.source_expressions:\n+            return '', ()\n+        return super().as_sql(*args, **kwargs)\n+\n+\n class ExpressionWrapper(SQLiteNumericMixin, Expression):\n     \"\"\"\n     An expression that can wrap another expression so that it can provide\n@@ -1313,11 +1333,13 @@ def __init__(self, expression, partition_by=None, order_by=None, frame=None, out\n \n         if self.order_by is not None:\n             if isinstance(self.order_by, (list, tuple)):\n-                self.order_by = ExpressionList(*self.order_by)\n-            elif not isinstance(self.order_by, BaseExpression):\n+                self.order_by = OrderByList(*self.order_by)\n+            elif isinstance(self.order_by, (BaseExpression, str)):\n+                self.order_by = OrderByList(self.order_by)\n+            else:\n                 raise ValueError(\n-                    'order_by must be either an Expression or a sequence of '\n-                    'expressions.'\n+                    'Window.order_by must be either a string reference to a '\n+                    'field, an expression, or a list or tuple of them.'\n                 )\n         super().__init__(output_field=output_field)\n         self.source_expression = self._parse_expressions(expression)[0]\n@@ -1343,18 +1365,17 @@ def as_sql(self, compiler, connection, template=None):\n                 compiler=compiler, connection=connection,\n                 template='PARTITION BY %(expressions)s',\n             )\n-            window_sql.extend(sql_expr)\n+            window_sql.append(sql_expr)\n             window_params.extend(sql_params)\n \n         if self.order_by is not None:\n-            window_sql.append(' ORDER BY ')\n             order_sql, order_params = compiler.compile(self.order_by)\n-            window_sql.extend(order_sql)\n+            window_sql.append(order_sql)\n             window_params.extend(order_params)\n \n         if self.frame:\n             frame_sql, frame_params = compiler.compile(self.frame)\n-            window_sql.append(' ' + frame_sql)\n+            window_sql.append(frame_sql)\n             window_params.extend(frame_params)\n \n         params.extend(window_params)\n@@ -1362,7 +1383,7 @@ def as_sql(self, compiler, connection, template=None):\n \n         return template % {\n             'expression': expr_sql,\n-            'window': ''.join(window_sql).strip()\n+            'window': ' '.join(window_sql).strip()\n         }, params\n \n     def as_sqlite(self, compiler, connection):\n@@ -1379,7 +1400,7 @@ def __str__(self):\n         return '{} OVER ({}{}{})'.format(\n             str(self.source_expression),\n             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',\n-            'ORDER BY ' + str(self.order_by) if self.order_by else '',\n+            str(self.order_by or ''),\n             str(self.frame or ''),\n         )\n \n",
  "test_patch": "diff --git a/tests/expressions_window/tests.py b/tests/expressions_window/tests.py\n--- a/tests/expressions_window/tests.py\n+++ b/tests/expressions_window/tests.py\n@@ -51,6 +51,7 @@ def test_dense_rank(self):\n         tests = [\n             ExtractYear(F('hire_date')).asc(),\n             F('hire_date__year').asc(),\n+            'hire_date__year',\n         ]\n         for order_by in tests:\n             with self.subTest(order_by=order_by):\n@@ -473,7 +474,7 @@ def test_ntile(self):\n         \"\"\"\n         qs = Employee.objects.annotate(ntile=Window(\n             expression=Ntile(num_buckets=4),\n-            order_by=F('salary').desc(),\n+            order_by='-salary',\n         )).order_by('ntile', '-salary', 'name')\n         self.assertQuerysetEqual(qs, [\n             ('Miller', 'Management', 100000, 1),\n@@ -875,7 +876,7 @@ def test_window_repr(self):\n         )\n         self.assertEqual(\n             repr(Window(expression=Avg('salary'), order_by=F('department').asc())),\n-            '<Window: Avg(F(salary)) OVER (ORDER BY OrderBy(F(department), descending=False))>'\n+            '<Window: Avg(F(salary)) OVER (OrderByList(OrderBy(F(department), descending=False)))>'\n         )\n \n     def test_window_frame_repr(self):\n@@ -942,9 +943,12 @@ def test_conditional_annotation(self):\n             qs.filter(equal=True)\n \n     def test_invalid_order_by(self):\n-        msg = 'order_by must be either an Expression or a sequence of expressions'\n+        msg = (\n+            'Window.order_by must be either a string reference to a field, an '\n+            'expression, or a list or tuple of them.'\n+        )\n         with self.assertRaisesMessage(ValueError, msg):\n-            Window(expression=Sum('power'), order_by='-horse')\n+            Window(expression=Sum('power'), order_by={'-horse'})\n \n     def test_invalid_source_expression(self):\n         msg = \"Expression 'Upper' isn't compatible with OVER clauses.\"\n",
  "problem_statement": "Window(order_by) should allow usage of descending string syntax to be used\nDescription\n\t \n\t\t(last modified by Simon Charette)\n\t \nThe QuerySet.order_by and â€‹some aggregates ordering kwarg allows for the leading dash syntax to be used but Window.order_by doesn't as it solely wraps the provided order_by in ExpressionList(expressions=order_by).\nThis makes for an inconsistent API so I suggest we reuse the logic in OrderableAggMixin.__init__ in Window.__init__\nAs a related note it seems most of the logic of OrderableAggMixin could be simplified by using ExpressionList.\nIt's a shame that we used ordering and not order_by as a kwarg for OrderableAggMixin as it's now inconsistent. Also not sure how much of a public API the OrderBy expression is but I wish it was initially named Sort (or Ordering?) so that we could define\nclass OrderBy(ExpressionList):\n\ttemplate = 'ORDER BY %(expressions)s'\n\tdef __init__(self, *expressions, *extra):\n\t\texpressions = [\n\t\t\t(Sort(F(expr[1:]), descending=True) if isinstance(expr, str) and expr[0] == '-' else expr)\n\t\t\tfor expr in expressions\n\t\t]\n\t\tsuper().__init__(*expressions, **extra)\nAnd then simply use this abstraction in Window and Postgres orderable aggregates.\nAssigning to myself as I plan to have a look at this in next few days.\n",
  "hints_text": "",
  "created_at": "2021-11-22T05:22:09Z",
  "version": "4.1",
  "FAIL_TO_PASS": "[\"test_invalid_order_by (expressions_window.tests.NonQueryWindowTests)\", \"test_window_repr (expressions_window.tests.NonQueryWindowTests)\", \"test_dense_rank (expressions_window.tests.WindowFunctionTests)\", \"test_department_salary (expressions_window.tests.WindowFunctionTests)\", \"Compute the group for each of the employees across the entire company,\"]",
  "PASS_TO_PASS": "[\"test_unsupported_backend (expressions_window.tests.WindowUnsupportedTests)\", \"test_conditional_annotation (expressions_window.tests.NonQueryWindowTests)\", \"test_empty_group_by_cols (expressions_window.tests.NonQueryWindowTests)\", \"test_frame_empty_group_by_cols (expressions_window.tests.NonQueryWindowTests)\", \"test_frame_window_frame_notimplemented (expressions_window.tests.NonQueryWindowTests)\", \"test_invalid_filter (expressions_window.tests.NonQueryWindowTests)\", \"test_invalid_source_expression (expressions_window.tests.NonQueryWindowTests)\", \"test_window_frame_repr (expressions_window.tests.NonQueryWindowTests)\", \"test_avg_salary_department (expressions_window.tests.WindowFunctionTests)\", \"Compute the cumulative distribution for the employees based on the\", \"Window expressions can't be used in an INSERT statement.\", \"Window expressions can't be used in an UPDATE statement.\", \"test_first_value (expressions_window.tests.WindowFunctionTests)\", \"test_function_list_of_values (expressions_window.tests.WindowFunctionTests)\", \"test_invalid_end_value_range (expressions_window.tests.WindowFunctionTests)\", \"test_invalid_start_value_range (expressions_window.tests.WindowFunctionTests)\", \"test_invalid_type_end_row_range (expressions_window.tests.WindowFunctionTests)\", \"test_invalid_type_end_value_range (expressions_window.tests.WindowFunctionTests)\", \"test_invalid_type_start_row_range (expressions_window.tests.WindowFunctionTests)\", \"test_invalid_type_start_value_range (expressions_window.tests.WindowFunctionTests)\", \"test_key_transform (expressions_window.tests.WindowFunctionTests)\", \"Compute the difference between an employee's salary and the next\", \"test_lag_decimalfield (expressions_window.tests.WindowFunctionTests)\", \"test_last_value (expressions_window.tests.WindowFunctionTests)\", \"Determine what the next person hired in the same department makes.\", \"test_lead_default (expressions_window.tests.WindowFunctionTests)\", \"Determine what the person hired after someone makes. Due to\", \"Find the maximum salary awarded in the same year as the\", \"An alternative way to specify a query for FirstValue.\", \"Accumulate the salaries over the departments based on hire_date.\", \"Find the maximum salary for each department for people hired in the\", \"Find the nth row of the data set. None is returned since there are\", \"test_nthvalue (expressions_window.tests.WindowFunctionTests)\", \"Calculate the percentage rank of the employees across the entire\", \"test_range_n_preceding_and_following (expressions_window.tests.WindowFunctionTests)\", \"A query with RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING.\", \"Rank the employees based on the year they're were hired. Since there\", \"test_related_ordering_with_count (expressions_window.tests.WindowFunctionTests)\", \"The row number window function computes the number based on the order\", \"A query with ROWS BETWEEN UNBOUNDED PRECEDING AND 3 FOLLOWING.\", \"test_subquery_row_range_rank (expressions_window.tests.WindowFunctionTests)\", \"test_window_expression_within_subquery (expressions_window.tests.WindowFunctionTests)\"]",
  "environment_setup_commit": "647480166bfe7532e8c471fef0146e3a17e6c0c9",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.716776",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}