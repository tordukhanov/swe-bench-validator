{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-17696",
  "base_commit": "fed3bb83dec834bd75fd8bcd68fc0c31387f394a",
  "patch": "diff --git a/sympy/assumptions/refine.py b/sympy/assumptions/refine.py\n--- a/sympy/assumptions/refine.py\n+++ b/sympy/assumptions/refine.py\n@@ -291,6 +291,47 @@ def _refine_reim(expr, assumptions):\n     return None\n \n \n+def refine_sign(expr, assumptions):\n+    \"\"\"\n+    Handler for sign\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy.assumptions.refine import refine_sign\n+    >>> from sympy import Symbol, Q, sign, im\n+    >>> x = Symbol('x', real = True)\n+    >>> expr = sign(x)\n+    >>> refine_sign(expr, Q.positive(x) & Q.nonzero(x))\n+    1\n+    >>> refine_sign(expr, Q.negative(x) & Q.nonzero(x))\n+    -1\n+    >>> refine_sign(expr, Q.zero(x))\n+    0\n+    >>> y = Symbol('y', imaginary = True)\n+    >>> expr = sign(y)\n+    >>> refine_sign(expr, Q.positive(im(y)))\n+    I\n+    >>> refine_sign(expr, Q.negative(im(y)))\n+    -I\n+    \"\"\"\n+    arg = expr.args[0]\n+    if ask(Q.zero(arg), assumptions):\n+        return S.Zero\n+    if ask(Q.real(arg)):\n+        if ask(Q.positive(arg), assumptions):\n+            return S.One\n+        if ask(Q.negative(arg), assumptions):\n+            return S.NegativeOne\n+    if ask(Q.imaginary(arg)):\n+        arg_re, arg_im = arg.as_real_imag()\n+        if ask(Q.positive(arg_im), assumptions):\n+            return S.ImaginaryUnit\n+        if ask(Q.negative(arg_im), assumptions):\n+            return -S.ImaginaryUnit\n+    return expr\n+\n+\n handlers_dict = {\n     'Abs': refine_abs,\n     'Pow': refine_Pow,\n@@ -302,5 +343,6 @@ def _refine_reim(expr, assumptions):\n     'StrictGreaterThan': refine_Relational,\n     'StrictLessThan': refine_Relational,\n     're': refine_re,\n-    'im': refine_im\n+    'im': refine_im,\n+    'sign': refine_sign\n }\n",
  "test_patch": "diff --git a/sympy/assumptions/tests/test_refine.py b/sympy/assumptions/tests/test_refine.py\n--- a/sympy/assumptions/tests/test_refine.py\n+++ b/sympy/assumptions/tests/test_refine.py\n@@ -1,8 +1,10 @@\n from sympy import (Abs, exp, Expr, I, pi, Q, Rational, refine, S, sqrt,\n-                   atan, atan2, nan, Symbol, re, im)\n+                   atan, atan2, nan, Symbol, re, im, sign)\n from sympy.abc import w, x, y, z\n from sympy.core.relational import Eq, Ne\n from sympy.functions.elementary.piecewise import Piecewise\n+from sympy.utilities.pytest import slow\n+from sympy.core import S\n \n \n def test_Abs():\n@@ -170,6 +172,23 @@ def test_complex():\n         & Q.real(z)) == w*z + x*y\n \n \n+def test_sign():\n+    x = Symbol('x', real = True)\n+    assert refine(sign(x), Q.positive(x)) == 1\n+    assert refine(sign(x), Q.negative(x)) == -1\n+    assert refine(sign(x), Q.zero(x)) == 0\n+    assert refine(sign(x), True) == sign(x)\n+    assert refine(sign(Abs(x)), Q.nonzero(x)) == 1\n+\n+    x = Symbol('x', imaginary=True)\n+    assert refine(sign(x), Q.positive(im(x))) == S.ImaginaryUnit\n+    assert refine(sign(x), Q.negative(im(x))) == -S.ImaginaryUnit\n+    assert refine(sign(x), True) == sign(x)\n+\n+    x = Symbol('x', complex=True)\n+    assert refine(sign(x), Q.zero(x)) == 0\n+\n+\n def test_func_args():\n     class MyClass(Expr):\n         # A class with nontrivial .func\n",
  "problem_statement": "Refine with sign\nConsider the following code:\r\n```\r\nfrom sympy import *\r\nx = Symbol('x', real = True)\r\n\r\nexpr = sign(x)\r\nexpr2 = refine(expr, Q.positive(x))\r\nexpr3 = refine(expr, Q.positive(x) & Q.nonzero(x))\r\nexpr4 = refine(expr, Q.positive(x + 1))\r\n```\r\nAll the returned expression are `sign(x)`. However, at least for `expr3` and `expr4`, the results should be `1`. This probably is due to the lack of capabilities for `refine`. A PR similar to #17019 should fix this behaviour. \r\n\r\nRelated issues: #8326 and #17052.\n",
  "hints_text": "I would like to work on this issue.\r\nCan someone guide me on exactly what has to be done?\n@kmm555 you can write a function in `refine.py` similar to `refine_abs()`, which returns `0` if the argument is equal to `0`, `1` if positive and so on (see the possible output of `sign` in `complexes.py`",
  "created_at": "2019-10-03T22:21:40Z",
  "version": "1.5",
  "FAIL_TO_PASS": "[\"test_sign\"]",
  "PASS_TO_PASS": "[\"test_Abs\", \"test_pow1\", \"test_pow2\", \"test_exp\", \"test_Relational\", \"test_Piecewise\", \"test_atan2\", \"test_re\", \"test_im\", \"test_complex\", \"test_func_args\", \"test_eval_refine\"]",
  "environment_setup_commit": "70381f282f2d9d039da860e391fe51649df2779d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.117475",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}