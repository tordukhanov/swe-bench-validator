{
  "repo": "django/django",
  "instance_id": "django__django-15087",
  "base_commit": "8d9827c06ce1592cca111e7eafb9ebe0153104ef",
  "patch": "diff --git a/django/db/backends/sqlite3/introspection.py b/django/db/backends/sqlite3/introspection.py\n--- a/django/db/backends/sqlite3/introspection.py\n+++ b/django/db/backends/sqlite3/introspection.py\n@@ -1,8 +1,8 @@\n-import re\n from collections import namedtuple\n \n import sqlparse\n \n+from django.db import DatabaseError\n from django.db.backends.base.introspection import (\n     BaseDatabaseIntrospection, FieldInfo as BaseFieldInfo, TableInfo,\n )\n@@ -84,6 +84,8 @@ def get_table_description(self, cursor, table_name):\n         \"\"\"\n         cursor.execute('PRAGMA table_info(%s)' % self.connection.ops.quote_name(table_name))\n         table_info = cursor.fetchall()\n+        if not table_info:\n+            raise DatabaseError(f'Table {table_name} does not exist (empty pragma).')\n         collations = self._get_column_collations(cursor, table_name)\n         json_columns = set()\n         if self.connection.features.can_introspect_json_field:\n@@ -114,61 +116,16 @@ def get_sequences(self, cursor, table_name, table_fields=()):\n \n     def get_relations(self, cursor, table_name):\n         \"\"\"\n-        Return a dictionary of {field_name: (field_name_other_table, other_table)}\n+        Return a dictionary of {column_name: (ref_column_name, ref_table_name)}\n         representing all foreign keys in the given table.\n         \"\"\"\n-        # Dictionary of relations to return\n-        relations = {}\n-\n-        # Schema for this table\n         cursor.execute(\n-            \"SELECT sql, type FROM sqlite_master \"\n-            \"WHERE tbl_name = %s AND type IN ('table', 'view')\",\n-            [table_name]\n+            'PRAGMA foreign_key_list(%s)' % self.connection.ops.quote_name(table_name)\n         )\n-        create_sql, table_type = cursor.fetchone()\n-        if table_type == 'view':\n-            # It might be a view, then no results will be returned\n-            return relations\n-        results = create_sql[create_sql.index('(') + 1:create_sql.rindex(')')]\n-\n-        # Walk through and look for references to other tables. SQLite doesn't\n-        # really have enforced references, but since it echoes out the SQL used\n-        # to create the table we can look for REFERENCES statements used there.\n-        for field_desc in results.split(','):\n-            field_desc = field_desc.strip()\n-            if field_desc.startswith(\"UNIQUE\"):\n-                continue\n-\n-            m = re.search(r'references (\\S*) ?\\([\"|]?(.*)[\"|]?\\)', field_desc, re.I)\n-            if not m:\n-                continue\n-            table, column = [s.strip('\"') for s in m.groups()]\n-\n-            if field_desc.startswith(\"FOREIGN KEY\"):\n-                # Find name of the target FK field\n-                m = re.match(r'FOREIGN KEY\\s*\\(([^\\)]*)\\).*', field_desc, re.I)\n-                field_name = m[1].strip('\"')\n-            else:\n-                field_name = field_desc.split()[0].strip('\"')\n-\n-            cursor.execute(\"SELECT sql FROM sqlite_master WHERE tbl_name = %s\", [table])\n-            result = cursor.fetchall()[0]\n-            other_table_results = result[0].strip()\n-            li, ri = other_table_results.index('('), other_table_results.rindex(')')\n-            other_table_results = other_table_results[li + 1:ri]\n-\n-            for other_desc in other_table_results.split(','):\n-                other_desc = other_desc.strip()\n-                if other_desc.startswith('UNIQUE'):\n-                    continue\n-\n-                other_name = other_desc.split(' ', 1)[0].strip('\"')\n-                if other_name == column:\n-                    relations[field_name] = (other_name, table)\n-                    break\n-\n-        return relations\n+        return {\n+            column_name: (ref_column_name, ref_table_name)\n+            for _, _, ref_table_name, column_name, ref_column_name, *_ in cursor.fetchall()\n+        }\n \n     def get_primary_key_column(self, cursor, table_name):\n         \"\"\"Return the column name of the primary key for the given table.\"\"\"\n@@ -180,22 +137,6 @@ def get_primary_key_column(self, cursor, table_name):\n                 return name\n         return None\n \n-    def _get_foreign_key_constraints(self, cursor, table_name):\n-        constraints = {}\n-        cursor.execute('PRAGMA foreign_key_list(%s)' % self.connection.ops.quote_name(table_name))\n-        for row in cursor.fetchall():\n-            # Remaining on_update/on_delete/match values are of no interest.\n-            id_, _, table, from_, to = row[:5]\n-            constraints['fk_%d' % id_] = {\n-                'columns': [from_],\n-                'primary_key': False,\n-                'unique': False,\n-                'foreign_key': (table, to),\n-                'check': False,\n-                'index': False,\n-            }\n-        return constraints\n-\n     def _parse_column_or_constraint_definition(self, tokens, columns):\n         token = None\n         is_constraint_definition = None\n@@ -392,7 +333,18 @@ def get_constraints(self, cursor, table_name):\n                 \"check\": False,\n                 \"index\": False,\n             }\n-        constraints.update(self._get_foreign_key_constraints(cursor, table_name))\n+        relations = enumerate(self.get_relations(cursor, table_name).items())\n+        constraints.update({\n+            f'fk_{index}': {\n+                'columns': [column_name],\n+                'primary_key': False,\n+                'unique': False,\n+                'foreign_key': (ref_table_name, ref_column_name),\n+                'check': False,\n+                'index': False,\n+            }\n+            for index, (column_name, (ref_column_name, ref_table_name)) in relations\n+        })\n         return constraints\n \n     def _get_index_columns_orders(self, sql):\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -75,9 +75,8 @@ def _is_referenced_by_fk_constraint(self, table_name, column_name=None, ignore_s\n             for other_table in self.connection.introspection.get_table_list(cursor):\n                 if ignore_self and other_table.name == table_name:\n                     continue\n-                constraints = self.connection.introspection._get_foreign_key_constraints(cursor, other_table.name)\n-                for constraint in constraints.values():\n-                    constraint_table, constraint_column = constraint['foreign_key']\n+                relations = self.connection.introspection.get_relations(cursor, other_table.name)\n+                for constraint_column, constraint_table in relations.values():\n                     if (constraint_table == table_name and\n                             (column_name is None or constraint_column == column_name)):\n                         return True\n",
  "test_patch": "diff --git a/tests/introspection/tests.py b/tests/introspection/tests.py\n--- a/tests/introspection/tests.py\n+++ b/tests/introspection/tests.py\n@@ -1,5 +1,3 @@\n-from unittest import mock, skipUnless\n-\n from django.db import DatabaseError, connection\n from django.db.models import Index\n from django.test import TransactionTestCase, skipUnlessDBFeature\n@@ -152,22 +150,6 @@ def test_get_relations(self):\n             editor.add_field(Article, body)\n         self.assertEqual(relations, expected_relations)\n \n-    @skipUnless(connection.vendor == 'sqlite', \"This is an sqlite-specific issue\")\n-    def test_get_relations_alt_format(self):\n-        \"\"\"\n-        With SQLite, foreign keys can be added with different syntaxes and\n-        formatting.\n-        \"\"\"\n-        create_table_statements = [\n-            \"CREATE TABLE track(id, art_id INTEGER, FOREIGN KEY(art_id) REFERENCES {}(id));\",\n-            \"CREATE TABLE track(id, art_id INTEGER, FOREIGN KEY (art_id) REFERENCES {}(id));\"\n-        ]\n-        for statement in create_table_statements:\n-            with connection.cursor() as cursor:\n-                cursor.fetchone = mock.Mock(return_value=[statement.format(Article._meta.db_table), 'table'])\n-                relations = connection.introspection.get_relations(cursor, 'mocked_table')\n-            self.assertEqual(relations, {'art_id': ('id', Article._meta.db_table)})\n-\n     def test_get_primary_key_column(self):\n         with connection.cursor() as cursor:\n             primary_key_column = connection.introspection.get_primary_key_column(cursor, Article._meta.db_table)\ndiff --git a/tests/schema/tests.py b/tests/schema/tests.py\n--- a/tests/schema/tests.py\n+++ b/tests/schema/tests.py\n@@ -119,9 +119,6 @@ def column_classes(self, model):\n         for name, (type, desc) in columns.items():\n             if isinstance(type, tuple):\n                 columns[name] = (type[0], desc)\n-        # SQLite also doesn't error properly\n-        if not columns:\n-            raise DatabaseError(\"Table does not exist (empty pragma)\")\n         return columns\n \n     def get_primary_key(self, table):\n",
  "problem_statement": "SQLite schema introspection should use PRAGMA instead of parsing to retrieve foreign keys\nDescription\n\t\nThe SQLite backend's DatabaseIntrospection.get_relations uses a complex combination of regexes to extract foreign key constraints from DDL while ​PRAGMA foreign_key_list works just fine as ​_get_foreign_key_constraints.\n",
  "hints_text": "",
  "created_at": "2021-11-14T00:34:23Z",
  "version": "4.1",
  "FAIL_TO_PASS": "[\"test_m2m (schema.tests.SchemaTests)\", \"test_m2m_create (schema.tests.SchemaTests)\", \"test_m2m_custom (schema.tests.SchemaTests)\", \"test_m2m_db_constraint (schema.tests.SchemaTests)\", \"test_m2m_db_constraint_custom (schema.tests.SchemaTests)\", \"test_m2m_db_constraint_inherited (schema.tests.SchemaTests)\", \"test_m2m_inherited (schema.tests.SchemaTests)\", \"test_m2m_repoint (schema.tests.SchemaTests)\", \"test_m2m_repoint_custom (schema.tests.SchemaTests)\", \"test_m2m_repoint_inherited (schema.tests.SchemaTests)\"]",
  "PASS_TO_PASS": "[\"test_bigautofield (introspection.tests.IntrospectionTests)\", \"test_django_table_names (introspection.tests.IntrospectionTests)\", \"test_django_table_names_retval_type (introspection.tests.IntrospectionTests)\", \"test_get_constraints (introspection.tests.IntrospectionTests)\", \"test_get_constraints_index_types (introspection.tests.IntrospectionTests)\", \"Indexes have the 'orders' key with a list of 'ASC'/'DESC' values.\", \"test_get_constraints_unique_indexes_orders (introspection.tests.IntrospectionTests)\", \"test_get_primary_key_column (introspection.tests.IntrospectionTests)\", \"test_get_relations (introspection.tests.IntrospectionTests)\", \"test_get_table_description_col_lengths (introspection.tests.IntrospectionTests)\", \"test_get_table_description_names (introspection.tests.IntrospectionTests)\", \"test_get_table_description_nullable (introspection.tests.IntrospectionTests)\", \"test_get_table_description_types (introspection.tests.IntrospectionTests)\", \"test_installed_models (introspection.tests.IntrospectionTests)\", \"test_sequence_list (introspection.tests.IntrospectionTests)\", \"test_smallautofield (introspection.tests.IntrospectionTests)\", \"test_table_names (introspection.tests.IntrospectionTests)\", \"test_table_names_with_views (introspection.tests.IntrospectionTests)\", \"test_unmanaged_through_model (introspection.tests.IntrospectionTests)\", \"effective_default() should be used for DateField, DateTimeField, and\", \"Tests adding fields to models\", \"Tests binary fields get a sane default (#22851)\", \"test_add_field_db_collation (schema.tests.SchemaTests)\", \"test_add_field_default_dropped (schema.tests.SchemaTests)\", \"test_add_field_default_nullable (schema.tests.SchemaTests)\", \"Tests adding fields to models with a default that is not directly\", \"Adding a field and removing it removes all deferred sql referring to it.\", \"Tests adding fields to models with a temporary default\", \"Tests adding fields to models with a temporary default where\", \"#23987 - effective_default() should be used as the field default when\", \"Regression test for #23009.\", \"test_add_foreign_key_quoted_db_table (schema.tests.SchemaTests)\", \"test_add_foreign_object (schema.tests.SchemaTests)\", \"Tests index addition and removal\", \"test_add_textfield_default_nullable (schema.tests.SchemaTests)\", \"test_add_textfield_unhashable_default (schema.tests.SchemaTests)\", \"Tests simple altering of fields\", \"test_alter_auto_field_quoted_db_column (schema.tests.SchemaTests)\", \"test_alter_auto_field_to_char_field (schema.tests.SchemaTests)\", \"test_alter_auto_field_to_integer_field (schema.tests.SchemaTests)\", \"Converting an implicit PK to BigAutoField(primary_key=True) should keep\", \"Converting an implicit PK to SmallAutoField(primary_key=True) should\", \"#24307 - Should skip an alter statement on databases with\", \"test_alter_db_table_case (schema.tests.SchemaTests)\", \"test_alter_field_add_index_to_integerfield (schema.tests.SchemaTests)\", \"test_alter_field_db_collation (schema.tests.SchemaTests)\", \"test_alter_field_default_dropped (schema.tests.SchemaTests)\", \"No queries are performed when changing field attributes that don't\", \"test_alter_field_fk_keeps_index (schema.tests.SchemaTests)\", \"test_alter_field_fk_to_o2o (schema.tests.SchemaTests)\", \"test_alter_field_o2o_keeps_unique (schema.tests.SchemaTests)\", \"test_alter_field_o2o_to_fk (schema.tests.SchemaTests)\", \"test_alter_field_type_and_db_collation (schema.tests.SchemaTests)\", \"Tests altering of FKs\", \"#25492 - Altering a foreign key's structure and data in the same\", \"#24163 - Tests altering of ForeignKey to OneToOneField\", \"Should be able to convert an implicit \\\"id\\\" field to an explicit \\\"id\\\"\", \"Should be able to rename an IntegerField(primary_key=True) to\", \"test_alter_not_unique_field_to_primary_key (schema.tests.SchemaTests)\", \"#23609 - Tests handling of default values when altering from NULL to NOT NULL.\", \"Changing a field type shouldn't affect the not null status.\", \"#24163 - Tests altering of OneToOneField to ForeignKey\", \"Changing the primary key field name of a model with a self-referential\", \"test_alter_primary_key_quoted_db_table (schema.tests.SchemaTests)\", \"Should be able to rename an SmallIntegerField(primary_key=True) to\", \"test_alter_text_field (schema.tests.SchemaTests)\", \"#25002 - Test conversion of text field to date field.\", \"#25002 - Test conversion of text field to datetime field.\", \"test_alter_text_field_to_not_null_with_default_value (schema.tests.SchemaTests)\", \"#25002 - Test conversion of text field to time field.\", \"#24447 - Tests adding a FK constraint for an existing column\", \"test_char_field_pk_to_auto_field (schema.tests.SchemaTests)\", \"test_char_field_with_db_index_to_fk (schema.tests.SchemaTests)\", \"Tests creating/deleting CHECK constraints\", \"test_ci_cs_db_collation (schema.tests.SchemaTests)\", \"test_composite_func_index (schema.tests.SchemaTests)\", \"test_composite_func_index_field_and_expression (schema.tests.SchemaTests)\", \"test_composite_func_unique_constraint (schema.tests.SchemaTests)\", \"Ensures transaction is correctly closed when an error occurs\", \"Tests creating models with index_together already defined\", \"Tries creating a model's table, and then deleting it.\", \"Tries creating a model's table, and then deleting it when it has a\", \"test_db_collation_charfield (schema.tests.SchemaTests)\", \"test_db_collation_textfield (schema.tests.SchemaTests)\", \"Tests renaming of the table\", \"Creating tables out of FK order, then repointing, works\", \"The db_constraint parameter is respected\", \"Creating a FK to a proxy model creates database constraints.\", \"Regression test for #21497.\", \"test_func_index (schema.tests.SchemaTests)\", \"test_func_index_calc (schema.tests.SchemaTests)\", \"test_func_index_cast (schema.tests.SchemaTests)\", \"test_func_index_collate (schema.tests.SchemaTests)\", \"test_func_index_collate_f_ordered (schema.tests.SchemaTests)\", \"test_func_index_f (schema.tests.SchemaTests)\", \"test_func_index_f_decimalfield (schema.tests.SchemaTests)\", \"test_func_index_invalid_topmost_expressions (schema.tests.SchemaTests)\", \"test_func_index_json_key_transform (schema.tests.SchemaTests)\", \"test_func_index_json_key_transform_cast (schema.tests.SchemaTests)\", \"test_func_index_lookups (schema.tests.SchemaTests)\", \"test_func_index_multiple_wrapper_references (schema.tests.SchemaTests)\", \"test_func_index_nondeterministic (schema.tests.SchemaTests)\", \"test_func_index_nonexistent_field (schema.tests.SchemaTests)\", \"test_func_unique_constraint (schema.tests.SchemaTests)\", \"test_func_unique_constraint_collate (schema.tests.SchemaTests)\", \"test_func_unique_constraint_lookups (schema.tests.SchemaTests)\", \"test_func_unique_constraint_nondeterministic (schema.tests.SchemaTests)\", \"test_func_unique_constraint_nonexistent_field (schema.tests.SchemaTests)\", \"test_func_unique_constraint_partial (schema.tests.SchemaTests)\", \"Tests removing and adding index_together constraints on a model.\", \"Tests removing and adding index_together constraints that include\", \"Tests creation/altering of indexes\", \"test_m2m_create_custom (schema.tests.SchemaTests)\", \"test_m2m_create_inherited (schema.tests.SchemaTests)\", \"test_m2m_create_through (schema.tests.SchemaTests)\", \"test_m2m_create_through_custom (schema.tests.SchemaTests)\", \"test_m2m_create_through_inherited (schema.tests.SchemaTests)\", \"test_m2m_rename_field_in_target_model (schema.tests.SchemaTests)\", \"test_m2m_through_alter (schema.tests.SchemaTests)\", \"test_m2m_through_alter_custom (schema.tests.SchemaTests)\", \"test_m2m_through_alter_inherited (schema.tests.SchemaTests)\", \"Table names are stripped of their namespace/schema before being used to\", \"When a primary key that's pointed to by a ForeignKey with\", \"Indexes defined with ordering (ASC/DESC) defined on column\", \"Tests altering of the primary key\", \"Foreign keys without database level constraint don't prevent the field\", \"Foreign keys without database level constraint don't prevent the table\", \"#23065 - Constraint names must be quoted if they contain capital letters.\", \"Changing db_index to False doesn't remove indexes from Meta.indexes.\", \"test_remove_field_check_does_not_remove_meta_constraints (schema.tests.SchemaTests)\", \"test_remove_field_unique_does_not_remove_meta_constraints (schema.tests.SchemaTests)\", \"test_remove_index_together_does_not_remove_meta_indexes (schema.tests.SchemaTests)\", \"test_remove_unique_together_does_not_remove_meta_constraints (schema.tests.SchemaTests)\", \"Renaming a field shouldn't affect the not null status.\", \"test_rename_referenced_field (schema.tests.SchemaTests)\", \"test_rename_table_renames_deferred_sql_references (schema.tests.SchemaTests)\", \"test_text_field_with_db_index (schema.tests.SchemaTests)\", \"test_text_field_with_db_index_to_fk (schema.tests.SchemaTests)\", \"Tests removing and adding unique constraints to a single column.\", \"test_unique_constraint (schema.tests.SchemaTests)\", \"test_unique_constraint_field_and_expression (schema.tests.SchemaTests)\", \"test_unique_name_quoting (schema.tests.SchemaTests)\", \"Tests removing and adding unique_together constraints on a model.\", \"Tests removing and adding unique_together constraints that include\"]",
  "environment_setup_commit": "647480166bfe7532e8c471fef0146e3a17e6c0c9",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.715410",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}