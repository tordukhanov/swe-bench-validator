{
  "repo": "pytest-dev/pytest",
  "instance_id": "pytest-dev__pytest-10442",
  "base_commit": "646a46e5f4b1f1ae5a06dcbc91fcdebfc235a28a",
  "patch": "diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -335,15 +335,26 @@ def cleanup_candidates(root: Path, prefix: str, keep: int) -> Iterator[Path]:\n             yield path\n \n \n+def cleanup_dead_symlink(root: Path):\n+    for left_dir in root.iterdir():\n+        if left_dir.is_symlink():\n+            if not left_dir.resolve().exists():\n+                left_dir.unlink()\n+\n+\n def cleanup_numbered_dir(\n     root: Path, prefix: str, keep: int, consider_lock_dead_if_created_before: float\n ) -> None:\n     \"\"\"Cleanup for lock driven numbered directories.\"\"\"\n+    if not root.exists():\n+        return\n     for path in cleanup_candidates(root, prefix, keep):\n         try_cleanup(path, consider_lock_dead_if_created_before)\n     for path in root.glob(\"garbage-*\"):\n         try_cleanup(path, consider_lock_dead_if_created_before)\n \n+    cleanup_dead_symlink(root)\n+\n \n def make_numbered_dir_with_cleanup(\n     root: Path,\n@@ -357,8 +368,10 @@ def make_numbered_dir_with_cleanup(\n     for i in range(10):\n         try:\n             p = make_numbered_dir(root, prefix, mode)\n-            lock_path = create_cleanup_lock(p)\n-            register_cleanup_lock_removal(lock_path)\n+            # Only lock the current dir when keep is not 0\n+            if keep != 0:\n+                lock_path = create_cleanup_lock(p)\n+                register_cleanup_lock_removal(lock_path)\n         except Exception as exc:\n             e = exc\n         else:\ndiff --git a/src/_pytest/tmpdir.py b/src/_pytest/tmpdir.py\n--- a/src/_pytest/tmpdir.py\n+++ b/src/_pytest/tmpdir.py\n@@ -4,16 +4,30 @@\n import sys\n import tempfile\n from pathlib import Path\n+from shutil import rmtree\n+from typing import Generator\n from typing import Optional\n+from typing import TYPE_CHECKING\n+from typing import Union\n+\n+if TYPE_CHECKING:\n+    from typing_extensions import Literal\n+\n+    RetentionType = Literal[\"all\", \"failed\", \"none\"]\n+\n \n import attr\n+from _pytest.config.argparsing import Parser\n \n from .pathlib import LOCK_TIMEOUT\n from .pathlib import make_numbered_dir\n from .pathlib import make_numbered_dir_with_cleanup\n from .pathlib import rm_rf\n+from .pathlib import cleanup_dead_symlink\n from _pytest.compat import final\n from _pytest.config import Config\n+from _pytest.config import ExitCode\n+from _pytest.config import hookimpl\n from _pytest.deprecated import check_ispytest\n from _pytest.fixtures import fixture\n from _pytest.fixtures import FixtureRequest\n@@ -31,10 +45,14 @@ class TempPathFactory:\n     _given_basetemp = attr.ib(type=Optional[Path])\n     _trace = attr.ib()\n     _basetemp = attr.ib(type=Optional[Path])\n+    _retention_count = attr.ib(type=int)\n+    _retention_policy = attr.ib(type=\"RetentionType\")\n \n     def __init__(\n         self,\n         given_basetemp: Optional[Path],\n+        retention_count: int,\n+        retention_policy: \"RetentionType\",\n         trace,\n         basetemp: Optional[Path] = None,\n         *,\n@@ -49,6 +67,8 @@ def __init__(\n             # Path.absolute() exists, but it is not public (see https://bugs.python.org/issue25012).\n             self._given_basetemp = Path(os.path.abspath(str(given_basetemp)))\n         self._trace = trace\n+        self._retention_count = retention_count\n+        self._retention_policy = retention_policy\n         self._basetemp = basetemp\n \n     @classmethod\n@@ -63,9 +83,23 @@ def from_config(\n         :meta private:\n         \"\"\"\n         check_ispytest(_ispytest)\n+        count = int(config.getini(\"tmp_path_retention_count\"))\n+        if count < 0:\n+            raise ValueError(\n+                f\"tmp_path_retention_count must be >= 0. Current input: {count}.\"\n+            )\n+\n+        policy = config.getini(\"tmp_path_retention_policy\")\n+        if policy not in (\"all\", \"failed\", \"none\"):\n+            raise ValueError(\n+                f\"tmp_path_retention_policy must be either all, failed, none. Current intput: {policy}.\"\n+            )\n+\n         return cls(\n             given_basetemp=config.option.basetemp,\n             trace=config.trace.get(\"tmpdir\"),\n+            retention_count=count,\n+            retention_policy=policy,\n             _ispytest=True,\n         )\n \n@@ -146,10 +180,13 @@ def getbasetemp(self) -> Path:\n                         )\n                     if (rootdir_stat.st_mode & 0o077) != 0:\n                         os.chmod(rootdir, rootdir_stat.st_mode & ~0o077)\n+            keep = self._retention_count\n+            if self._retention_policy == \"none\":\n+                keep = 0\n             basetemp = make_numbered_dir_with_cleanup(\n                 prefix=\"pytest-\",\n                 root=rootdir,\n-                keep=3,\n+                keep=keep,\n                 lock_timeout=LOCK_TIMEOUT,\n                 mode=0o700,\n             )\n@@ -184,6 +221,21 @@ def pytest_configure(config: Config) -> None:\n     mp.setattr(config, \"_tmp_path_factory\", _tmp_path_factory, raising=False)\n \n \n+def pytest_addoption(parser: Parser) -> None:\n+    parser.addini(\n+        \"tmp_path_retention_count\",\n+        help=\"How many sessions should we keep the `tmp_path` directories, according to `tmp_path_retention_policy`.\",\n+        default=3,\n+    )\n+\n+    parser.addini(\n+        \"tmp_path_retention_policy\",\n+        help=\"Controls which directories created by the `tmp_path` fixture are kept around, based on test outcome. \"\n+        \"(all/failed/none)\",\n+        default=\"failed\",\n+    )\n+\n+\n @fixture(scope=\"session\")\n def tmp_path_factory(request: FixtureRequest) -> TempPathFactory:\n     \"\"\"Return a :class:`pytest.TempPathFactory` instance for the test session.\"\"\"\n@@ -200,7 +252,9 @@ def _mk_tmp(request: FixtureRequest, factory: TempPathFactory) -> Path:\n \n \n @fixture\n-def tmp_path(request: FixtureRequest, tmp_path_factory: TempPathFactory) -> Path:\n+def tmp_path(\n+    request: FixtureRequest, tmp_path_factory: TempPathFactory\n+) -> Generator[Path, None, None]:\n     \"\"\"Return a temporary directory path object which is unique to each test\n     function invocation, created as a sub directory of the base temporary\n     directory.\n@@ -213,4 +267,46 @@ def tmp_path(request: FixtureRequest, tmp_path_factory: TempPathFactory) -> Path\n     The returned object is a :class:`pathlib.Path` object.\n     \"\"\"\n \n-    return _mk_tmp(request, tmp_path_factory)\n+    path = _mk_tmp(request, tmp_path_factory)\n+    yield path\n+\n+    # Remove the tmpdir if the policy is \"failed\" and the test passed.\n+    tmp_path_factory: TempPathFactory = request.session.config._tmp_path_factory  # type: ignore\n+    policy = tmp_path_factory._retention_policy\n+    if policy == \"failed\" and request.node._tmp_path_result_call.passed:\n+        # We do a \"best effort\" to remove files, but it might not be possible due to some leaked resource,\n+        # permissions, etc, in which case we ignore it.\n+        rmtree(path, ignore_errors=True)\n+\n+    # remove dead symlink\n+    basetemp = tmp_path_factory._basetemp\n+    if basetemp is None:\n+        return\n+    cleanup_dead_symlink(basetemp)\n+\n+\n+def pytest_sessionfinish(session, exitstatus: Union[int, ExitCode]):\n+    \"\"\"After each session, remove base directory if all the tests passed,\n+    the policy is \"failed\", and the basetemp is not specified by a user.\n+    \"\"\"\n+    tmp_path_factory: TempPathFactory = session.config._tmp_path_factory\n+    if tmp_path_factory._basetemp is None:\n+        return\n+    policy = tmp_path_factory._retention_policy\n+    if (\n+        exitstatus == 0\n+        and policy == \"failed\"\n+        and tmp_path_factory._given_basetemp is None\n+    ):\n+        passed_dir = tmp_path_factory._basetemp\n+        if passed_dir.exists():\n+            # We do a \"best effort\" to remove files, but it might not be possible due to some leaked resource,\n+            # permissions, etc, in which case we ignore it.\n+            rmtree(passed_dir, ignore_errors=True)\n+\n+\n+@hookimpl(tryfirst=True, hookwrapper=True)\n+def pytest_runtest_makereport(item, call):\n+    outcome = yield\n+    result = outcome.get_result()\n+    setattr(item, \"_tmp_path_result_\" + result.when, result)\n",
  "test_patch": "diff --git a/testing/test_tmpdir.py b/testing/test_tmpdir.py\n--- a/testing/test_tmpdir.py\n+++ b/testing/test_tmpdir.py\n@@ -42,6 +42,14 @@ def trace(self):\n     def get(self, key):\n         return lambda *k: None\n \n+    def getini(self, name):\n+        if name == \"tmp_path_retention_count\":\n+            return 3\n+        elif name == \"tmp_path_retention_policy\":\n+            return \"failed\"\n+        else:\n+            assert False\n+\n     @property\n     def option(self):\n         return self\n@@ -84,6 +92,53 @@ def test_1(tmp_path):\n         assert mytemp.exists()\n         assert not mytemp.joinpath(\"hello\").exists()\n \n+    def test_policy_failed_removes_only_passed_dir(self, pytester: Pytester) -> None:\n+        p = pytester.makepyfile(\n+            \"\"\"\n+            def test_1(tmp_path):\n+                assert 0 == 0\n+            def test_2(tmp_path):\n+                assert 0 == 1\n+        \"\"\"\n+        )\n+\n+        pytester.inline_run(p)\n+        root = pytester._test_tmproot\n+\n+        for child in root.iterdir():\n+            base_dir = list(\n+                filter(lambda x: x.is_dir() and not x.is_symlink(), child.iterdir())\n+            )\n+            assert len(base_dir) == 1\n+            test_dir = list(\n+                filter(\n+                    lambda x: x.is_dir() and not x.is_symlink(), base_dir[0].iterdir()\n+                )\n+            )\n+            # Check only the failed one remains\n+            assert len(test_dir) == 1\n+            assert test_dir[0].name == \"test_20\"\n+\n+    def test_policy_failed_removes_basedir_when_all_passed(\n+        self, pytester: Pytester\n+    ) -> None:\n+        p = pytester.makepyfile(\n+            \"\"\"\n+            def test_1(tmp_path):\n+                assert 0 == 0\n+        \"\"\"\n+        )\n+\n+        pytester.inline_run(p)\n+        root = pytester._test_tmproot\n+        for child in root.iterdir():\n+            # This symlink will be deleted by cleanup_numbered_dir **after**\n+            # the test finishes because it's triggered by atexit.\n+            # So it has to be ignored here.\n+            base_dir = filter(lambda x: not x.is_symlink(), child.iterdir())\n+            # Check the base dir itself is gone\n+            assert len(list(base_dir)) == 0\n+\n \n testdata = [\n     (\"mypath\", True),\n@@ -275,12 +330,12 @@ def test_lock_register_cleanup_removal(self, tmp_path: Path) -> None:\n \n         assert not lock.exists()\n \n-    def _do_cleanup(self, tmp_path: Path) -> None:\n+    def _do_cleanup(self, tmp_path: Path, keep: int = 2) -> None:\n         self.test_make(tmp_path)\n         cleanup_numbered_dir(\n             root=tmp_path,\n             prefix=self.PREFIX,\n-            keep=2,\n+            keep=keep,\n             consider_lock_dead_if_created_before=0,\n         )\n \n@@ -289,6 +344,11 @@ def test_cleanup_keep(self, tmp_path):\n         a, b = (x for x in tmp_path.iterdir() if not x.is_symlink())\n         print(a, b)\n \n+    def test_cleanup_keep_0(self, tmp_path: Path):\n+        self._do_cleanup(tmp_path, 0)\n+        dir_num = len(list(tmp_path.iterdir()))\n+        assert dir_num == 0\n+\n     def test_cleanup_locked(self, tmp_path):\n         p = make_numbered_dir(root=tmp_path, prefix=self.PREFIX)\n \n@@ -446,7 +506,7 @@ def test_tmp_path_factory_create_directory_with_safe_permissions(\n     \"\"\"Verify that pytest creates directories under /tmp with private permissions.\"\"\"\n     # Use the test's tmp_path as the system temproot (/tmp).\n     monkeypatch.setenv(\"PYTEST_DEBUG_TEMPROOT\", str(tmp_path))\n-    tmp_factory = TempPathFactory(None, lambda *args: None, _ispytest=True)\n+    tmp_factory = TempPathFactory(None, 3, \"failed\", lambda *args: None, _ispytest=True)\n     basetemp = tmp_factory.getbasetemp()\n \n     # No world-readable permissions.\n@@ -466,14 +526,14 @@ def test_tmp_path_factory_fixes_up_world_readable_permissions(\n     \"\"\"\n     # Use the test's tmp_path as the system temproot (/tmp).\n     monkeypatch.setenv(\"PYTEST_DEBUG_TEMPROOT\", str(tmp_path))\n-    tmp_factory = TempPathFactory(None, lambda *args: None, _ispytest=True)\n+    tmp_factory = TempPathFactory(None, 3, \"failed\", lambda *args: None, _ispytest=True)\n     basetemp = tmp_factory.getbasetemp()\n \n     # Before - simulate bad perms.\n     os.chmod(basetemp.parent, 0o777)\n     assert (basetemp.parent.stat().st_mode & 0o077) != 0\n \n-    tmp_factory = TempPathFactory(None, lambda *args: None, _ispytest=True)\n+    tmp_factory = TempPathFactory(None, 3, \"failed\", lambda *args: None, _ispytest=True)\n     basetemp = tmp_factory.getbasetemp()\n \n     # After - fixed.\n",
  "problem_statement": "Keep temporary directory for failing tests only\nCurrently pytest will keep the last 3 _root_ temporary directories for each testing session, for all tests.\r\n\r\nThis proposal is to change this behavior to only keep the directories for failed tests, instead of for all tests. This would save significant disk space for test suites which manipulate large amounts of data in the temporary directories.\r\n\r\nThe behavior of keeping the last 3 root temporary directories would be kept unchanged.\r\n\r\n\r\nFrom: https://github.com/pytest-dev/pytest/issues/8036#issuecomment-742567384\r\n\r\nEDIT: after some discussion, the full proposal is defined in https://github.com/pytest-dev/pytest/issues/8141#issuecomment-1278960826.\n",
  "hints_text": "note, this should be a opt in via config, potentially by naming a policy, as dropping everything passed by default changes the debug-ability when  one wants to compare passed stuff to failed stuff\n> note, this should be a opt in via config, potentially by naming a policy, as dropping everything passed by default changes the debug-ability when one wants to compare passed stuff to failed stuff\r\n\r\nOh really? I haven't thought about that use case.\r\n\r\nWhat should be the name of the option? How about `temp_dir_retention_policy=failed|all|none`, defaulting to `all`?\nLet's think a bit more about what variants we want, then we can pick a name \nthanks. this seems like it would be a really cool addition!\n> Let's think a bit more about what variants we want, then we can pick a name\r\n\r\nFair enough.\r\n\r\nThe ones I thought were:\r\n\r\n* Keep directories for all tests (current behavior)\r\n* Keep directories for failed tests\r\n* Never keep any directories\r\n\r\nOther use cases come to mind?\nnothing yet, however i haven't yet put my thoughts onto having `tmp_dir` as session and module/package scope fixture yet\n> however i haven't yet put my thoughts onto having tmp_dir as session and module/package scope fixture yet\r\n\r\nNot sure I follow... this proposal is not about changing the scope of the tmpdir fixture, just configuring how often/when it deletes old temporary directories... or am I missing something?\nThe proposal is only about the policy but for finding a good name im thinking about a future change /feature \nFor those that need it, I adjusted https://github.com/pytest-dev/pytest/blob/28e8c8582ea947704655a3c3f2d57184831336fd/src/_pytest/tmpdir.py#L25\r\n\r\nand I think this gives some control to acheive the desired effect in different circumstances.\r\n\r\n<details>\r\n\r\n\r\n```python\r\nimport pytest\r\nimport re\r\nimport shutil\r\nimport os\r\n\r\n\r\ncleanup_tmp_path_on_success = os.environ.get(\"PYTEST_CLEANUP_TMP_PATH_ON_SUCCESS\", \"true\")\r\ncleanup_tmp_path_on_success = cleanup_tmp_path_on_success.lower()\r\nif cleanup_tmp_path_on_success in [\"1\", \"true\"]:\r\n    cleanup_tmp_path_on_success = True\r\nelse:\r\n    cleanup_tmp_path_on_success = False\r\n\r\n@pytest.hookimpl(tryfirst=True, hookwrapper=True)\r\ndef pytest_runtest_makereport(item, call):\r\n    # execute all other hooks to obtain the report object\r\n    outcome = yield\r\n    rep = outcome.get_result()\r\n\r\n    # set a report attribute for each phase of a call, which can\r\n    # be \"setup\", \"call\", \"teardown\"\r\n\r\n    setattr(item, \"rep_\" + rep.when, rep)\r\n\r\ndef _mk_tmp(request, factory):\r\n    name = request.node.name\r\n    name = re.sub(r\"[\\W]\", \"_\", name)\r\n    MAXVAL = 30\r\n    name = name[:MAXVAL]\r\n    return factory.mktemp(name, numbered=True)\r\n\r\n@pytest.fixture\r\ndef tmp_path(request, tmp_path_factory):\r\n    from pathlib import Path\r\n    import tempfile\r\n    path = _mk_tmp(request, tmp_path_factory)\r\n    yield path\r\n    if cleanup_tmp_path_on_success:\r\n        if request.node.rep_setup.failed:\r\n            # If things failed during setup, just cleanup, the main test\r\n            # likely didn't create anything usefil\r\n            shutil.rmtree(path)\r\n        elif request.node.rep_setup.passed and request.node.rep_call.passed:\r\n            shutil.rmtree(path)\r\n```\r\n\r\n</details>\nIs this still considered to be implemented? If so, can we get things going?\r\nOnce the naming discussion settles, I can contribute if needed.\nIt has not advanced I'm afraid.\r\n\r\nMy proposal:\r\n\r\n```markdown\r\n**Config option**: `tmp_path_retention_count`\r\n\r\nHow many sessions should we keep the `tmp_path` directories, according to `tmp_path_retention_policy`.\r\n\r\nDefault: 3\r\n\r\n**Config option**: `tmp_path_retention_policy`\r\n\r\nControls which directories created by the `tmp_path` fixture are kept around, based on test outcome.\r\n\r\nOne of:\r\n\r\n* `all`: retains directories for all tests, regardless of the outcome.\r\n* `failed`: retains directories only for tests with outcome `error` or `failed`.\r\n* `none`: directories are always removed after each test ends, regardless of the outcome.\r\n\r\nDefault: `failed`\r\n```\nThank you. IMHO, it sounds good.\r\nJust to make sure, does `tmp_path_retention_count` apply to both `all` and `failed`?\r\n\r\nSo are we good with the configuration naming or still waiting for something?\n> Just to make sure, does tmp_path_retention_count apply to both all and failed?\r\n\r\nYes. 👍 \r\n\r\n> So are we good with the configuration naming or still waiting for something?\r\n\r\nI think we should wait for other maintainers to manifest if we should go forward with this or not. cc @RonnyPfannschmidt @bluetech @The-Compiler @asottile \nproposal seems fine, I'd love to be more aggressive and set the default to `failed` personally\nSeems fine to me!\ni strongly prefer the `all` option as default as its what allows debugging the most easy\nI don't really see the value of all, seems rare-to-never that you'd debug a _passing_ test\nits occasionally very helpful to diff folders of passed and failed parameters and most of the time the cost of just cleaning it up together later is not that big\r\n\r\nalso sometimes the pass is a surprise \r\nso why eagerly cleanup unless you have a painfully expensive \"dump\"\r\n\nI'd wager almost none of our users even know about pytest persisting temp until they run out of disk \n@asottile i concede, thanks for reminding me, now going on the principle of least surprise lets indeed migrate towards only keeping failures as the starting point\nOK, updated the proposal text to change the default to `failed`\nNow we just need a volunteer to implement it. :grin: \nWow it has been so fast!\n\n> Now we just need a volunteer to implement it. :grin: \n\nOk I got this.",
  "created_at": "2022-10-27T13:16:54Z",
  "version": "7.2",
  "FAIL_TO_PASS": "[\"testing/test_tmpdir.py::TestNumberedDir::test_cleanup_keep_0\", \"testing/test_tmpdir.py::test_tmp_path_factory_create_directory_with_safe_permissions\", \"testing/test_tmpdir.py::test_tmp_path_factory_fixes_up_world_readable_permissions\", \"testing/test_tmpdir.py::TestConfigTmpPath::test_policy_failed_removes_only_passed_dir\", \"testing/test_tmpdir.py::TestConfigTmpPath::test_policy_failed_removes_basedir_when_all_passed\"]",
  "PASS_TO_PASS": "[\"testing/test_tmpdir.py::TestTmpPathHandler::test_mktemp\", \"testing/test_tmpdir.py::TestTmpPathHandler::test_tmppath_relative_basetemp_absolute\", \"testing/test_tmpdir.py::test_get_user_uid_not_found\", \"testing/test_tmpdir.py::TestNumberedDir::test_make\", \"testing/test_tmpdir.py::TestNumberedDir::test_cleanup_lock_create\", \"testing/test_tmpdir.py::TestNumberedDir::test_lock_register_cleanup_removal\", \"testing/test_tmpdir.py::TestNumberedDir::test_cleanup_keep\", \"testing/test_tmpdir.py::TestNumberedDir::test_cleanup_locked\", \"testing/test_tmpdir.py::TestNumberedDir::test_cleanup_ignores_symlink\", \"testing/test_tmpdir.py::TestNumberedDir::test_removal_accepts_lock\", \"testing/test_tmpdir.py::TestRmRf::test_rm_rf\", \"testing/test_tmpdir.py::TestRmRf::test_rm_rf_with_read_only_file\", \"testing/test_tmpdir.py::TestRmRf::test_rm_rf_with_read_only_directory\", \"testing/test_tmpdir.py::TestRmRf::test_on_rm_rf_error\", \"testing/test_tmpdir.py::test_tmp_path_factory_handles_invalid_dir_characters\", \"testing/test_tmpdir.py::test_tmp_path_fixture\", \"testing/test_tmpdir.py::TestConfigTmpPath::test_getbasetemp_custom_removes_old\", \"testing/test_tmpdir.py::test_mktemp[mypath-True]\", \"testing/test_tmpdir.py::test_mktemp[/mypath1-False]\", \"testing/test_tmpdir.py::test_mktemp[./mypath1-True]\", \"testing/test_tmpdir.py::test_mktemp[../mypath3-False]\", \"testing/test_tmpdir.py::test_mktemp[../../mypath4-False]\", \"testing/test_tmpdir.py::test_mktemp[mypath5/..-False]\", \"testing/test_tmpdir.py::test_mktemp[mypath6/../mypath6-True]\", \"testing/test_tmpdir.py::test_mktemp[mypath7/../mypath7/..-False]\", \"testing/test_tmpdir.py::test_tmp_path_always_is_realpath\", \"testing/test_tmpdir.py::test_tmp_path_too_long_on_parametrization\", \"testing/test_tmpdir.py::test_tmp_path_factory\", \"testing/test_tmpdir.py::test_tmp_path_fallback_tox_env\", \"testing/test_tmpdir.py::test_tmp_path_fallback_uid_not_found\", \"testing/test_tmpdir.py::test_basetemp_with_read_only_files\"]",
  "environment_setup_commit": "572b5657d7ca557593418ce0319fabff88800c73",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.922109",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}