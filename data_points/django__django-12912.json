{
  "repo": "django/django",
  "instance_id": "django__django-12912",
  "base_commit": "42c08ee46539ef44f8658ebb1cbefb408e0d03fe",
  "patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -390,7 +390,7 @@ def rewrite_cols(self, annotation, col_cnt):\n             else:\n                 # Reuse aliases of expressions already selected in subquery.\n                 for col_alias, selected_annotation in self.annotation_select.items():\n-                    if selected_annotation == expr:\n+                    if selected_annotation is expr:\n                         new_expr = Ref(col_alias, expr)\n                         break\n                 else:\n",
  "test_patch": "diff --git a/tests/aggregation/test_filter_argument.py b/tests/aggregation/test_filter_argument.py\n--- a/tests/aggregation/test_filter_argument.py\n+++ b/tests/aggregation/test_filter_argument.py\n@@ -2,7 +2,8 @@\n from decimal import Decimal\n \n from django.db.models import (\n-    Avg, Case, Count, F, OuterRef, Q, StdDev, Subquery, Sum, Variance, When,\n+    Avg, Case, Count, Exists, F, Max, OuterRef, Q, StdDev, Subquery, Sum,\n+    Variance, When,\n )\n from django.test import TestCase\n from django.test.utils import Approximate\n@@ -120,3 +121,23 @@ def test_filtered_aggregate_ref_subquery_annotation(self):\n             cnt=Count('pk', filter=Q(earliest_book_year=2008)),\n         )\n         self.assertEqual(aggs['cnt'], 2)\n+\n+    def test_filtered_aggregate_ref_multiple_subquery_annotation(self):\n+        aggregate = Book.objects.values('publisher').annotate(\n+            has_authors=Exists(\n+                Book.authors.through.objects.filter(book=OuterRef('pk')),\n+            ),\n+            authors_have_other_books=Exists(\n+                Book.objects.filter(\n+                    authors__in=Author.objects.filter(\n+                        book_contact_set=OuterRef(OuterRef('pk')),\n+                    )\n+                ).exclude(pk=OuterRef('pk')),\n+            ),\n+        ).aggregate(\n+            max_rating=Max(\n+                'rating',\n+                filter=Q(has_authors=True, authors_have_other_books=False),\n+            )\n+        )\n+        self.assertEqual(aggregate, {'max_rating': 4.5})\n",
  "problem_statement": "Alias used in aggregate filtering is incorrect.\nDescription\n\t\nWith the following queryset:\nIndicatorValue.objects\n.values(\"freight\")\n.annotate(\n\tloading_time=Min(\"datetime\", filter=Q(type=IndicatorValue.TYPE_FREIGHT_CREATED)) - Max(\"datetime\", filter=Q(type=IndicatorValue.TYPE_FREIGHT_COMPLETED)),\n\thas_top_loading=Exists(OrderItemResult.objects.order_by().filter(order_line__order__freight=OuterRef(\"freight\"), loading_arm__loading_type=LoadingArm.LOADING_TYPE_TOP, ).values('pk')),\n\thas_bottom_loading=Exists(OrderItemResult.objects.order_by().filter(order_line__order__freight=OuterRef(\"freight\"), loading_arm__loading_type=LoadingArm.LOADING_TYPE_BOTTOM, ).values('pk'))\n)\n.aggregate(\n\ttop_min=Min(\"loading_time\", filter=Q(has_top_loading=True, has_bottom_loading=False))\n)\nI get the following SQL generated for the aggregate (notice that both alias used are the same in the SQL, whereas they are not in the queryset):\nMIN(\"loading_time\") FILTER (WHERE (\"has_top_loading\" = false AND \"has_top_loading\" = true))\nThe full SQL generated is:\nSELECT MIN(\"loading_time\") FILTER (WHERE (\"has_top_loading\" = false AND \"has_top_loading\" = true)) FROM (SELECT \"indicators_indicatorvalue\".\"freight_id\" AS Col1, (MIN(\"indicators_indicatorvalue\".\"datetime\") FILTER (WHERE \"indicators_indicatorvalue\".\"type\" = \\'freight_created\\') - MAX(\"indicators_indicatorvalue\".\"datetime\") FILTER (WHERE \"indicators_indicatorvalue\".\"type\" = \\'freight_completed\\')) AS \"loading_time\", EXISTS(SELECT U0.\"id\" FROM \"orders_orderitemresult\" U0 INNER JOIN \"loading_terminal_loadingarm\" U1 ON (U0.\"loading_arm_id\" = U1.\"id\") INNER JOIN \"orders_orderitem\" U2 ON (U0.\"order_line_id\" = U2.\"id\") INNER JOIN \"orders_order\" U3 ON (U2.\"order_id\" = U3.\"id\") WHERE (U1.\"loading_type\" = \\'TOP\\' AND U3.\"freight_id\" = \"indicators_indicatorvalue\".\"freight_id\")) AS \"has_top_loading\", EXISTS(SELECT U0.\"id\" FROM \"orders_orderitemresult\" U0 INNER JOIN \"loading_terminal_loadingarm\" U1 ON (U0.\"loading_arm_id\" = U1.\"id\") INNER JOIN \"orders_orderitem\" U2 ON (U0.\"order_line_id\" = U2.\"id\") INNER JOIN \"orders_order\" U3 ON (U2.\"order_id\" = U3.\"id\") WHERE (U1.\"loading_type\" = \\'BOTTOM\\' AND U3.\"freight_id\" = \"indicators_indicatorvalue\".\"freight_id\")) AS \"has_bottom_loading\" FROM \"indicators_indicatorvalue\" WHERE \"indicators_indicatorvalue\".\"deleted\" IS NULL GROUP BY \"indicators_indicatorvalue\".\"freight_id\", \"has_top_loading\", \"has_bottom_loading\") subquery\nIt works fine with Django 2.2 (which does not use alias there if I'm not mistaken).\n",
  "hints_text": "Thank you for your report. Did you manage to reproduce against Django 3.0.5 as well? If it's the case could you try reducing your model set and queryset interactions to a minimal that still trigger the issue. That'll help tremendously in reproducing the regression and ensure it gets addressed in a timely manner. Thanks!\nThanks for this ticket. Regression in 691def10a0197d83d2d108bd9043b0916d0f09b4. Reproduced at 46fe506445666d8097945f0c1e8be11cfd644b28.\nReplying to Simon Charette: Thank you for your report. Did you manage to reproduce against Django 3.0.5 as well? If it's the case could you try reducing your model set and queryset interactions to a minimal that still trigger the issue. That'll help tremendously in reproducing the regression and ensure it gets addressed in a timely manner. Thanks! I tried to reduce it as much as I could in my context without having to try with whole new models. Do you still need me to do that as felixxm apparently was able to reproduce it? Thanks.",
  "created_at": "2020-05-14T04:21:52Z",
  "version": "3.2",
  "FAIL_TO_PASS": "[\"test_filtered_aggregate_ref_multiple_subquery_annotation (aggregation.test_filter_argument.FilteredAggregateTests)\"]",
  "PASS_TO_PASS": "[\"test_case_aggregate (aggregation.test_filter_argument.FilteredAggregateTests)\", \"test_double_filtered_aggregates (aggregation.test_filter_argument.FilteredAggregateTests)\", \"test_excluded_aggregates (aggregation.test_filter_argument.FilteredAggregateTests)\", \"test_filtered_aggregate_on_annotate (aggregation.test_filter_argument.FilteredAggregateTests)\", \"test_filtered_aggregate_ref_annotation (aggregation.test_filter_argument.FilteredAggregateTests)\", \"test_filtered_aggregate_ref_subquery_annotation (aggregation.test_filter_argument.FilteredAggregateTests)\", \"test_filtered_aggregates (aggregation.test_filter_argument.FilteredAggregateTests)\", \"test_filtered_numerical_aggregates (aggregation.test_filter_argument.FilteredAggregateTests)\", \"test_filtered_reused_subquery (aggregation.test_filter_argument.FilteredAggregateTests)\", \"test_plain_annotate (aggregation.test_filter_argument.FilteredAggregateTests)\", \"test_related_aggregates_m2m (aggregation.test_filter_argument.FilteredAggregateTests)\", \"test_related_aggregates_m2m_and_fk (aggregation.test_filter_argument.FilteredAggregateTests)\", \"test_sum_star_exception (aggregation.test_filter_argument.FilteredAggregateTests)\"]",
  "environment_setup_commit": "65dfb06a1ab56c238cc80f5e1c31f61210c4577d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.638211",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}