{
  "repo": "sphinx-doc/sphinx",
  "instance_id": "sphinx-doc__sphinx-9997",
  "base_commit": "31ed71dfb335f46c97ba227cbfc34172eeb71f1f",
  "patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -83,7 +83,8 @@ class ModuleEntry(NamedTuple):\n def type_to_xref(target: str, env: BuildEnvironment = None, suppress_prefix: bool = False\n                  ) -> addnodes.pending_xref:\n     \"\"\"Convert a type string to a cross reference node.\"\"\"\n-    if target == 'None':\n+    if target == 'None' or target.startswith('typing.'):\n+        # typing module provides non-class types.  Obj reference is good to refer them.\n         reftype = 'obj'\n     else:\n         reftype = 'class'\n@@ -104,6 +105,8 @@ def type_to_xref(target: str, env: BuildEnvironment = None, suppress_prefix: boo\n         text = target.split('.')[-1]\n     elif suppress_prefix:\n         text = target.split('.')[-1]\n+    elif target.startswith('typing.'):\n+        text = target[7:]\n     else:\n         text = target\n \n@@ -203,10 +206,16 @@ def unparse(node: ast.AST) -> List[Node]:\n             return result\n         else:\n             if sys.version_info < (3, 8):\n-                if isinstance(node, ast.Ellipsis):\n+                if isinstance(node, ast.Bytes):\n+                    return [addnodes.desc_sig_literal_string('', repr(node.s))]\n+                elif isinstance(node, ast.Ellipsis):\n                     return [addnodes.desc_sig_punctuation('', \"...\")]\n                 elif isinstance(node, ast.NameConstant):\n                     return [nodes.Text(node.value)]\n+                elif isinstance(node, ast.Num):\n+                    return [addnodes.desc_sig_literal_string('', repr(node.n))]\n+                elif isinstance(node, ast.Str):\n+                    return [addnodes.desc_sig_literal_string('', repr(node.s))]\n \n             raise SyntaxError  # unsupported syntax\n \n@@ -1481,7 +1490,7 @@ def istyping(s: str) -> bool:\n         return None\n     elif node.get('reftype') in ('class', 'obj') and node.get('reftarget') == 'None':\n         return contnode\n-    elif node.get('reftype') in ('class', 'exc'):\n+    elif node.get('reftype') in ('class', 'obj', 'exc'):\n         reftarget = node.get('reftarget')\n         if inspect.isclass(getattr(builtins, reftarget, None)):\n             # built-in class\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -753,6 +753,11 @@ def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n     :param unqualified_typehints: If enabled, show annotations as unqualified\n                                   (ex. io.StringIO -> StringIO)\n     \"\"\"\n+    if unqualified_typehints:\n+        mode = 'smart'\n+    else:\n+        mode = 'fully-qualified'\n+\n     args = []\n     last_kind = None\n     for param in sig.parameters.values():\n@@ -775,7 +780,7 @@ def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n \n         if show_annotation and param.annotation is not param.empty:\n             arg.write(': ')\n-            arg.write(stringify_annotation(param.annotation, unqualified_typehints))\n+            arg.write(stringify_annotation(param.annotation, mode))\n         if param.default is not param.empty:\n             if show_annotation and param.annotation is not param.empty:\n                 arg.write(' = ')\n@@ -795,7 +800,7 @@ def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n             show_return_annotation is False):\n         return '(%s)' % ', '.join(args)\n     else:\n-        annotation = stringify_annotation(sig.return_annotation, unqualified_typehints)\n+        annotation = stringify_annotation(sig.return_annotation, mode)\n         return '(%s) -> %s' % (', '.join(args), annotation)\n \n \ndiff --git a/sphinx/util/typing.py b/sphinx/util/typing.py\n--- a/sphinx/util/typing.py\n+++ b/sphinx/util/typing.py\n@@ -299,18 +299,25 @@ def _restify_py36(cls: Optional[Type]) -> str:\n             return ':py:obj:`%s.%s`' % (cls.__module__, qualname)\n \n \n-def stringify(annotation: Any, smartref: bool = False) -> str:\n+def stringify(annotation: Any, mode: str = 'fully-qualified-except-typing') -> str:\n     \"\"\"Stringify type annotation object.\n \n-    :param smartref: If true, add \"~\" prefix to the result to remove the leading\n-                     module and class names from the reference text\n+    :param mode: Specify a method how annotations will be stringified.\n+\n+                 'fully-qualified-except-typing'\n+                     Show the module name and qualified name of the annotation except\n+                     the \"typing\" module.\n+                 'smart'\n+                     Show the name of the annotation.\n+                 'fully-qualified'\n+                     Show the module name and qualified name of the annotation.\n     \"\"\"\n     from sphinx.util import inspect  # lazy loading\n \n-    if smartref:\n-        prefix = '~'\n+    if mode == 'smart':\n+        modprefix = '~'\n     else:\n-        prefix = ''\n+        modprefix = ''\n \n     if isinstance(annotation, str):\n         if annotation.startswith(\"'\") and annotation.endswith(\"'\"):\n@@ -319,14 +326,15 @@ def stringify(annotation: Any, smartref: bool = False) -> str:\n         else:\n             return annotation\n     elif isinstance(annotation, TypeVar):\n-        if annotation.__module__ == 'typing':\n+        if (annotation.__module__ == 'typing' and\n+                mode in ('fully-qualified-except-typing', 'smart')):\n             return annotation.__name__\n         else:\n-            return prefix + '.'.join([annotation.__module__, annotation.__name__])\n+            return modprefix + '.'.join([annotation.__module__, annotation.__name__])\n     elif inspect.isNewType(annotation):\n         if sys.version_info > (3, 10):\n             # newtypes have correct module info since Python 3.10+\n-            return prefix + '%s.%s' % (annotation.__module__, annotation.__name__)\n+            return modprefix + '%s.%s' % (annotation.__module__, annotation.__name__)\n         else:\n             return annotation.__name__\n     elif not annotation:\n@@ -334,7 +342,7 @@ def stringify(annotation: Any, smartref: bool = False) -> str:\n     elif annotation is NoneType:\n         return 'None'\n     elif annotation in INVALID_BUILTIN_CLASSES:\n-        return prefix + INVALID_BUILTIN_CLASSES[annotation]\n+        return modprefix + INVALID_BUILTIN_CLASSES[annotation]\n     elif str(annotation).startswith('typing.Annotated'):  # for py310+\n         pass\n     elif (getattr(annotation, '__module__', None) == 'builtins' and\n@@ -347,12 +355,12 @@ def stringify(annotation: Any, smartref: bool = False) -> str:\n         return '...'\n \n     if sys.version_info >= (3, 7):  # py37+\n-        return _stringify_py37(annotation, smartref)\n+        return _stringify_py37(annotation, mode)\n     else:\n-        return _stringify_py36(annotation, smartref)\n+        return _stringify_py36(annotation, mode)\n \n \n-def _stringify_py37(annotation: Any, smartref: bool = False) -> str:\n+def _stringify_py37(annotation: Any, mode: str = 'fully-qualified-except-typing') -> str:\n     \"\"\"stringify() for py37+.\"\"\"\n     module = getattr(annotation, '__module__', None)\n     modprefix = ''\n@@ -364,19 +372,21 @@ def _stringify_py37(annotation: Any, smartref: bool = False) -> str:\n         elif getattr(annotation, '__qualname__', None):\n             qualname = annotation.__qualname__\n         else:\n-            qualname = stringify(annotation.__origin__)  # ex. Union\n+            qualname = stringify(annotation.__origin__).replace('typing.', '')  # ex. Union\n \n-        if smartref:\n+        if mode == 'smart':\n             modprefix = '~%s.' % module\n+        elif mode == 'fully-qualified':\n+            modprefix = '%s.' % module\n     elif hasattr(annotation, '__qualname__'):\n-        if smartref:\n+        if mode == 'smart':\n             modprefix = '~%s.' % module\n         else:\n             modprefix = '%s.' % module\n         qualname = annotation.__qualname__\n     elif hasattr(annotation, '__origin__'):\n         # instantiated generic provided by a user\n-        qualname = stringify(annotation.__origin__, smartref)\n+        qualname = stringify(annotation.__origin__, mode)\n     elif UnionType and isinstance(annotation, UnionType):  # types.Union (for py3.10+)\n         qualname = 'types.Union'\n     else:\n@@ -391,13 +401,13 @@ def _stringify_py37(annotation: Any, smartref: bool = False) -> str:\n         elif qualname in ('Optional', 'Union'):\n             if len(annotation.__args__) > 1 and annotation.__args__[-1] is NoneType:\n                 if len(annotation.__args__) > 2:\n-                    args = ', '.join(stringify(a, smartref) for a in annotation.__args__[:-1])\n+                    args = ', '.join(stringify(a, mode) for a in annotation.__args__[:-1])\n                     return '%sOptional[%sUnion[%s]]' % (modprefix, modprefix, args)\n                 else:\n                     return '%sOptional[%s]' % (modprefix,\n-                                               stringify(annotation.__args__[0], smartref))\n+                                               stringify(annotation.__args__[0], mode))\n             else:\n-                args = ', '.join(stringify(a, smartref) for a in annotation.__args__)\n+                args = ', '.join(stringify(a, mode) for a in annotation.__args__)\n                 return '%sUnion[%s]' % (modprefix, args)\n         elif qualname == 'types.Union':\n             if len(annotation.__args__) > 1 and None in annotation.__args__:\n@@ -406,25 +416,25 @@ def _stringify_py37(annotation: Any, smartref: bool = False) -> str:\n             else:\n                 return ' | '.join(stringify(a) for a in annotation.__args__)\n         elif qualname == 'Callable':\n-            args = ', '.join(stringify(a, smartref) for a in annotation.__args__[:-1])\n-            returns = stringify(annotation.__args__[-1], smartref)\n+            args = ', '.join(stringify(a, mode) for a in annotation.__args__[:-1])\n+            returns = stringify(annotation.__args__[-1], mode)\n             return '%s%s[[%s], %s]' % (modprefix, qualname, args, returns)\n         elif qualname == 'Literal':\n             args = ', '.join(repr(a) for a in annotation.__args__)\n             return '%s%s[%s]' % (modprefix, qualname, args)\n         elif str(annotation).startswith('typing.Annotated'):  # for py39+\n-            return stringify(annotation.__args__[0], smartref)\n+            return stringify(annotation.__args__[0], mode)\n         elif all(is_system_TypeVar(a) for a in annotation.__args__):\n             # Suppress arguments if all system defined TypeVars (ex. Dict[KT, VT])\n             return modprefix + qualname\n         else:\n-            args = ', '.join(stringify(a, smartref) for a in annotation.__args__)\n+            args = ', '.join(stringify(a, mode) for a in annotation.__args__)\n             return '%s%s[%s]' % (modprefix, qualname, args)\n \n     return modprefix + qualname\n \n \n-def _stringify_py36(annotation: Any, smartref: bool = False) -> str:\n+def _stringify_py36(annotation: Any, mode: str = 'fully-qualified-except-typing') -> str:\n     \"\"\"stringify() for py36.\"\"\"\n     module = getattr(annotation, '__module__', None)\n     modprefix = ''\n@@ -440,10 +450,12 @@ def _stringify_py36(annotation: Any, smartref: bool = False) -> str:\n         else:\n             qualname = repr(annotation).replace('typing.', '')\n \n-        if smartref:\n+        if mode == 'smart':\n             modprefix = '~%s.' % module\n+        elif mode == 'fully-qualified':\n+            modprefix = '%s.' % module\n     elif hasattr(annotation, '__qualname__'):\n-        if smartref:\n+        if mode == 'smart':\n             modprefix = '~%s.' % module\n         else:\n             modprefix = '%s.' % module\n@@ -455,7 +467,7 @@ def _stringify_py36(annotation: Any, smartref: bool = False) -> str:\n             not hasattr(annotation, '__tuple_params__')):  # for Python 3.6\n         params = annotation.__args__\n         if params:\n-            param_str = ', '.join(stringify(p, smartref) for p in params)\n+            param_str = ', '.join(stringify(p, mode) for p in params)\n             return '%s%s[%s]' % (modprefix, qualname, param_str)\n         else:\n             return modprefix + qualname\n@@ -466,12 +478,12 @@ def _stringify_py36(annotation: Any, smartref: bool = False) -> str:\n         elif annotation.__origin__ == Generator:  # type: ignore\n             params = annotation.__args__  # type: ignore\n         else:  # typing.Callable\n-            args = ', '.join(stringify(arg, smartref) for arg\n+            args = ', '.join(stringify(arg, mode) for arg\n                              in annotation.__args__[:-1])  # type: ignore\n             result = stringify(annotation.__args__[-1])  # type: ignore\n             return '%s%s[[%s], %s]' % (modprefix, qualname, args, result)\n         if params is not None:\n-            param_str = ', '.join(stringify(p, smartref) for p in params)\n+            param_str = ', '.join(stringify(p, mode) for p in params)\n             return '%s%s[%s]' % (modprefix, qualname, param_str)\n     elif (hasattr(annotation, '__origin__') and\n           annotation.__origin__ is typing.Union):\n@@ -479,12 +491,12 @@ def _stringify_py36(annotation: Any, smartref: bool = False) -> str:\n         if params is not None:\n             if len(params) > 1 and params[-1] is NoneType:\n                 if len(params) > 2:\n-                    param_str = \", \".join(stringify(p, smartref) for p in params[:-1])\n+                    param_str = \", \".join(stringify(p, mode) for p in params[:-1])\n                     return '%sOptional[%sUnion[%s]]' % (modprefix, modprefix, param_str)\n                 else:\n-                    return '%sOptional[%s]' % (modprefix, stringify(params[0]))\n+                    return '%sOptional[%s]' % (modprefix, stringify(params[0], mode))\n             else:\n-                param_str = ', '.join(stringify(p, smartref) for p in params)\n+                param_str = ', '.join(stringify(p, mode) for p in params)\n                 return '%sUnion[%s]' % (modprefix, param_str)\n \n     return modprefix + qualname\n",
  "test_patch": "diff --git a/tests/test_domain_py.py b/tests/test_domain_py.py\n--- a/tests/test_domain_py.py\n+++ b/tests/test_domain_py.py\n@@ -348,6 +348,17 @@ def test_parse_annotation(app):\n     assert_node(doctree, ([pending_xref, \"None\"],))\n     assert_node(doctree[0], pending_xref, refdomain=\"py\", reftype=\"obj\", reftarget=\"None\")\n \n+    # Literal type makes an object-reference (not a class reference)\n+    doctree = _parse_annotation(\"typing.Literal['a', 'b']\", app.env)\n+    assert_node(doctree, ([pending_xref, \"Literal\"],\n+                          [desc_sig_punctuation, \"[\"],\n+                          [desc_sig_literal_string, \"'a'\"],\n+                          [desc_sig_punctuation, \",\"],\n+                          desc_sig_space,\n+                          [desc_sig_literal_string, \"'b'\"],\n+                          [desc_sig_punctuation, \"]\"]))\n+    assert_node(doctree[0], pending_xref, refdomain=\"py\", reftype=\"obj\", reftarget=\"typing.Literal\")\n+\n \n def test_parse_annotation_suppress(app):\n     doctree = _parse_annotation(\"~typing.Dict[str, str]\", app.env)\n@@ -358,7 +369,7 @@ def test_parse_annotation_suppress(app):\n                           desc_sig_space,\n                           [pending_xref, \"str\"],\n                           [desc_sig_punctuation, \"]\"]))\n-    assert_node(doctree[0], pending_xref, refdomain=\"py\", reftype=\"class\", reftarget=\"typing.Dict\")\n+    assert_node(doctree[0], pending_xref, refdomain=\"py\", reftype=\"obj\", reftarget=\"typing.Dict\")\n \n \n @pytest.mark.skipif(sys.version_info < (3, 8), reason='python 3.8+ is required.')\n@@ -373,7 +384,7 @@ def test_parse_annotation_Literal(app):\n                           [desc_sig_punctuation, \"]\"]))\n \n     doctree = _parse_annotation(\"typing.Literal[0, 1, 'abc']\", app.env)\n-    assert_node(doctree, ([pending_xref, \"typing.Literal\"],\n+    assert_node(doctree, ([pending_xref, \"Literal\"],\n                           [desc_sig_punctuation, \"[\"],\n                           [desc_sig_literal_number, \"0\"],\n                           [desc_sig_punctuation, \",\"],\ndiff --git a/tests/test_ext_autodoc_autofunction.py b/tests/test_ext_autodoc_autofunction.py\n--- a/tests/test_ext_autodoc_autofunction.py\n+++ b/tests/test_ext_autodoc_autofunction.py\n@@ -162,7 +162,7 @@ def test_wrapped_function_contextmanager(app):\n     actual = do_autodoc(app, 'function', 'target.wrappedfunction.feeling_good')\n     assert list(actual) == [\n         '',\n-        '.. py:function:: feeling_good(x: int, y: int) -> Generator',\n+        '.. py:function:: feeling_good(x: int, y: int) -> typing.Generator',\n         '   :module: target.wrappedfunction',\n         '',\n         \"   You'll feel better in this context!\",\ndiff --git a/tests/test_ext_autodoc_automodule.py b/tests/test_ext_autodoc_automodule.py\n--- a/tests/test_ext_autodoc_automodule.py\n+++ b/tests/test_ext_autodoc_automodule.py\n@@ -130,4 +130,4 @@ def test_subclass_of_mocked_object(app):\n \n     options = {'members': None}\n     actual = do_autodoc(app, 'module', 'target.need_mocks', options)\n-    assert '.. py:class:: Inherited(*args: Any, **kwargs: Any)' in actual\n+    assert '.. py:class:: Inherited(*args: typing.Any, **kwargs: typing.Any)' in actual\ndiff --git a/tests/test_ext_autodoc_configs.py b/tests/test_ext_autodoc_configs.py\n--- a/tests/test_ext_autodoc_configs.py\n+++ b/tests/test_ext_autodoc_configs.py\n@@ -612,7 +612,7 @@ def test_autodoc_typehints_signature(app):\n         '   :type: int',\n         '',\n         '',\n-        '.. py:class:: Math(s: str, o: Optional[Any] = None)',\n+        '.. py:class:: Math(s: str, o: typing.Optional[typing.Any] = None)',\n         '   :module: target.typehints',\n         '',\n         '',\n@@ -677,7 +677,8 @@ def test_autodoc_typehints_signature(app):\n         '   :module: target.typehints',\n         '',\n         '',\n-        '.. py:function:: tuple_args(x: Tuple[int, Union[int, str]]) -> Tuple[int, int]',\n+        '.. py:function:: tuple_args(x: typing.Tuple[int, typing.Union[int, str]]) '\n+        '-> typing.Tuple[int, int]',\n         '   :module: target.typehints',\n         '',\n     ]\n@@ -1145,11 +1146,6 @@ def test_autodoc_typehints_description_and_type_aliases(app):\n @pytest.mark.sphinx('html', testroot='ext-autodoc',\n                     confoverrides={'autodoc_typehints_format': \"short\"})\n def test_autodoc_typehints_format_short(app):\n-    if sys.version_info < (3, 7):\n-        Any = 'Any'\n-    else:\n-        Any = '~typing.Any'\n-\n     options = {\"members\": None,\n                \"undoc-members\": None}\n     actual = do_autodoc(app, 'module', 'target.typehints', options)\n@@ -1163,7 +1159,7 @@ def test_autodoc_typehints_format_short(app):\n         '   :type: int',\n         '',\n         '',\n-        '.. py:class:: Math(s: str, o: ~typing.Optional[%s] = None)' % Any,\n+        '.. py:class:: Math(s: str, o: ~typing.Optional[~typing.Any] = None)',\n         '   :module: target.typehints',\n         '',\n         '',\ndiff --git a/tests/test_ext_autodoc_preserve_defaults.py b/tests/test_ext_autodoc_preserve_defaults.py\n--- a/tests/test_ext_autodoc_preserve_defaults.py\n+++ b/tests/test_ext_autodoc_preserve_defaults.py\n@@ -36,15 +36,15 @@ def test_preserve_defaults(app):\n         '   docstring',\n         '',\n         '',\n-        '   .. py:method:: Class.meth(name: str = CONSTANT, sentinel: Any = SENTINEL, '\n-        'now: datetime.datetime = datetime.now(), color: int = %s) -> None' % color,\n+        '   .. py:method:: Class.meth(name: str = CONSTANT, sentinel: typing.Any = '\n+        'SENTINEL, now: datetime.datetime = datetime.now(), color: int = %s) -> None' % color,\n         '      :module: target.preserve_defaults',\n         '',\n         '      docstring',\n         '',\n         '',\n-        '.. py:function:: foo(name: str = CONSTANT, sentinel: Any = SENTINEL, now: '\n-        'datetime.datetime = datetime.now(), color: int = %s) -> None' % color,\n+        '.. py:function:: foo(name: str = CONSTANT, sentinel: typing.Any = SENTINEL, '\n+        'now: datetime.datetime = datetime.now(), color: int = %s) -> None' % color,\n         '   :module: target.preserve_defaults',\n         '',\n         '   docstring',\ndiff --git a/tests/test_util_inspect.py b/tests/test_util_inspect.py\n--- a/tests/test_util_inspect.py\n+++ b/tests/test_util_inspect.py\n@@ -157,21 +157,24 @@ def test_signature_annotations():\n \n     # Generic types with concrete parameters\n     sig = inspect.signature(f1)\n-    assert stringify_signature(sig) == '(x: List[int]) -> List[int]'\n+    assert stringify_signature(sig) == '(x: typing.List[int]) -> typing.List[int]'\n \n     # TypeVars and generic types with TypeVars\n     sig = inspect.signature(f2)\n     if sys.version_info < (3, 7):\n-        assert stringify_signature(sig) == '(x: List[T], y: List[T_co], z: T) -> List[T_contra]'\n+        assert stringify_signature(sig) == ('(x: typing.List[typing.T],'\n+                                            ' y: typing.List[typing.T_co],'\n+                                            ' z: typing.T'\n+                                            ') -> typing.List[typing.T_contra]')\n     else:\n-        assert stringify_signature(sig) == ('(x: List[tests.typing_test_data.T],'\n-                                            ' y: List[tests.typing_test_data.T_co],'\n+        assert stringify_signature(sig) == ('(x: typing.List[tests.typing_test_data.T],'\n+                                            ' y: typing.List[tests.typing_test_data.T_co],'\n                                             ' z: tests.typing_test_data.T'\n-                                            ') -> List[tests.typing_test_data.T_contra]')\n+                                            ') -> typing.List[tests.typing_test_data.T_contra]')\n \n     # Union types\n     sig = inspect.signature(f3)\n-    assert stringify_signature(sig) == '(x: Union[str, numbers.Integral]) -> None'\n+    assert stringify_signature(sig) == '(x: typing.Union[str, numbers.Integral]) -> None'\n \n     # Quoted annotations\n     sig = inspect.signature(f4)\n@@ -187,18 +190,18 @@ def test_signature_annotations():\n \n     # Space around '=' for defaults\n     sig = inspect.signature(f7)\n-    assert stringify_signature(sig) == '(x: Optional[int] = None, y: dict = {}) -> None'\n+    assert stringify_signature(sig) == '(x: typing.Optional[int] = None, y: dict = {}) -> None'\n \n     # Callable types\n     sig = inspect.signature(f8)\n-    assert stringify_signature(sig) == '(x: Callable[[int, str], int]) -> None'\n+    assert stringify_signature(sig) == '(x: typing.Callable[[int, str], int]) -> None'\n \n     sig = inspect.signature(f9)\n-    assert stringify_signature(sig) == '(x: Callable) -> None'\n+    assert stringify_signature(sig) == '(x: typing.Callable) -> None'\n \n     # Tuple types\n     sig = inspect.signature(f10)\n-    assert stringify_signature(sig) == '(x: Tuple[int, str], y: Tuple[int, ...]) -> None'\n+    assert stringify_signature(sig) == '(x: typing.Tuple[int, str], y: typing.Tuple[int, ...]) -> None'\n \n     # Instance annotations\n     sig = inspect.signature(f11)\n@@ -206,24 +209,24 @@ def test_signature_annotations():\n \n     # tuple with more than two items\n     sig = inspect.signature(f12)\n-    assert stringify_signature(sig) == '() -> Tuple[int, str, int]'\n+    assert stringify_signature(sig) == '() -> typing.Tuple[int, str, int]'\n \n     # optional\n     sig = inspect.signature(f13)\n-    assert stringify_signature(sig) == '() -> Optional[str]'\n+    assert stringify_signature(sig) == '() -> typing.Optional[str]'\n \n     # optional union\n     sig = inspect.signature(f20)\n-    assert stringify_signature(sig) in ('() -> Optional[Union[int, str]]',\n-                                        '() -> Optional[Union[str, int]]')\n+    assert stringify_signature(sig) in ('() -> typing.Optional[typing.Union[int, str]]',\n+                                        '() -> typing.Optional[typing.Union[str, int]]')\n \n     # Any\n     sig = inspect.signature(f14)\n-    assert stringify_signature(sig) == '() -> Any'\n+    assert stringify_signature(sig) == '() -> typing.Any'\n \n     # ForwardRef\n     sig = inspect.signature(f15)\n-    assert stringify_signature(sig) == '(x: Unknown, y: int) -> Any'\n+    assert stringify_signature(sig) == '(x: Unknown, y: int) -> typing.Any'\n \n     # keyword only arguments (1)\n     sig = inspect.signature(f16)\n@@ -234,7 +237,8 @@ def test_signature_annotations():\n     assert stringify_signature(sig) == '(*, arg3, arg4)'\n \n     sig = inspect.signature(f18)\n-    assert stringify_signature(sig) == '(self, arg1: Union[int, Tuple] = 10) -> List[Dict]'\n+    assert stringify_signature(sig) == ('(self, arg1: typing.Union[int, typing.Tuple] = 10) -> '\n+                                        'typing.List[typing.Dict]')\n \n     # annotations for variadic and keyword parameters\n     sig = inspect.signature(f19)\n@@ -246,10 +250,10 @@ def test_signature_annotations():\n \n     # type hints by string\n     sig = inspect.signature(Node.children)\n-    assert stringify_signature(sig) == '(self) -> List[tests.typing_test_data.Node]'\n+    assert stringify_signature(sig) == '(self) -> typing.List[tests.typing_test_data.Node]'\n \n     sig = inspect.signature(Node.__init__)\n-    assert stringify_signature(sig) == '(self, parent: Optional[tests.typing_test_data.Node]) -> None'\n+    assert stringify_signature(sig) == '(self, parent: typing.Optional[tests.typing_test_data.Node]) -> None'\n \n     # show_annotation is False\n     sig = inspect.signature(f7)\n@@ -257,7 +261,7 @@ def test_signature_annotations():\n \n     # show_return_annotation is False\n     sig = inspect.signature(f7)\n-    assert stringify_signature(sig, show_return_annotation=False) == '(x: Optional[int] = None, y: dict = {})'\n+    assert stringify_signature(sig, show_return_annotation=False) == '(x: typing.Optional[int] = None, y: dict = {})'\n \n     # unqualified_typehints is True\n     sig = inspect.signature(f7)\ndiff --git a/tests/test_util_typing.py b/tests/test_util_typing.py\n--- a/tests/test_util_typing.py\n+++ b/tests/test_util_typing.py\n@@ -178,156 +178,181 @@ def test_restify_mock():\n \n \n def test_stringify():\n-    assert stringify(int, False) == \"int\"\n-    assert stringify(int, True) == \"int\"\n+    assert stringify(int) == \"int\"\n+    assert stringify(int, \"smart\") == \"int\"\n \n-    assert stringify(str, False) == \"str\"\n-    assert stringify(str, True) == \"str\"\n+    assert stringify(str) == \"str\"\n+    assert stringify(str, \"smart\") == \"str\"\n \n-    assert stringify(None, False) == \"None\"\n-    assert stringify(None, True) == \"None\"\n+    assert stringify(None) == \"None\"\n+    assert stringify(None, \"smart\") == \"None\"\n \n-    assert stringify(Integral, False) == \"numbers.Integral\"\n-    assert stringify(Integral, True) == \"~numbers.Integral\"\n+    assert stringify(Integral) == \"numbers.Integral\"\n+    assert stringify(Integral, \"smart\") == \"~numbers.Integral\"\n \n-    assert stringify(Struct, False) == \"struct.Struct\"\n-    assert stringify(Struct, True) == \"~struct.Struct\"\n+    assert stringify(Struct) == \"struct.Struct\"\n+    assert stringify(Struct, \"smart\") == \"~struct.Struct\"\n \n-    assert stringify(TracebackType, False) == \"types.TracebackType\"\n-    assert stringify(TracebackType, True) == \"~types.TracebackType\"\n+    assert stringify(TracebackType) == \"types.TracebackType\"\n+    assert stringify(TracebackType, \"smart\") == \"~types.TracebackType\"\n \n-    assert stringify(Any, False) == \"Any\"\n-    assert stringify(Any, True) == \"~typing.Any\"\n+    assert stringify(Any) == \"Any\"\n+    assert stringify(Any, \"fully-qualified\") == \"typing.Any\"\n+    assert stringify(Any, \"smart\") == \"~typing.Any\"\n \n \n def test_stringify_type_hints_containers():\n-    assert stringify(List, False) == \"List\"\n-    assert stringify(List, True) == \"~typing.List\"\n+    assert stringify(List) == \"List\"\n+    assert stringify(List, \"fully-qualified\") == \"typing.List\"\n+    assert stringify(List, \"smart\") == \"~typing.List\"\n \n-    assert stringify(Dict, False) == \"Dict\"\n-    assert stringify(Dict, True) == \"~typing.Dict\"\n+    assert stringify(Dict) == \"Dict\"\n+    assert stringify(Dict, \"fully-qualified\") == \"typing.Dict\"\n+    assert stringify(Dict, \"smart\") == \"~typing.Dict\"\n \n-    assert stringify(List[int], False) == \"List[int]\"\n-    assert stringify(List[int], True) == \"~typing.List[int]\"\n+    assert stringify(List[int]) == \"List[int]\"\n+    assert stringify(List[int], \"fully-qualified\") == \"typing.List[int]\"\n+    assert stringify(List[int], \"smart\") == \"~typing.List[int]\"\n \n-    assert stringify(List[str], False) == \"List[str]\"\n-    assert stringify(List[str], True) == \"~typing.List[str]\"\n+    assert stringify(List[str]) == \"List[str]\"\n+    assert stringify(List[str], \"fully-qualified\") == \"typing.List[str]\"\n+    assert stringify(List[str], \"smart\") == \"~typing.List[str]\"\n \n-    assert stringify(Dict[str, float], False) == \"Dict[str, float]\"\n-    assert stringify(Dict[str, float], True) == \"~typing.Dict[str, float]\"\n+    assert stringify(Dict[str, float]) == \"Dict[str, float]\"\n+    assert stringify(Dict[str, float], \"fully-qualified\") == \"typing.Dict[str, float]\"\n+    assert stringify(Dict[str, float], \"smart\") == \"~typing.Dict[str, float]\"\n \n-    assert stringify(Tuple[str, str, str], False) == \"Tuple[str, str, str]\"\n-    assert stringify(Tuple[str, str, str], True) == \"~typing.Tuple[str, str, str]\"\n+    assert stringify(Tuple[str, str, str]) == \"Tuple[str, str, str]\"\n+    assert stringify(Tuple[str, str, str], \"fully-qualified\") == \"typing.Tuple[str, str, str]\"\n+    assert stringify(Tuple[str, str, str], \"smart\") == \"~typing.Tuple[str, str, str]\"\n \n-    assert stringify(Tuple[str, ...], False) == \"Tuple[str, ...]\"\n-    assert stringify(Tuple[str, ...], True) == \"~typing.Tuple[str, ...]\"\n+    assert stringify(Tuple[str, ...]) == \"Tuple[str, ...]\"\n+    assert stringify(Tuple[str, ...], \"fully-qualified\") == \"typing.Tuple[str, ...]\"\n+    assert stringify(Tuple[str, ...], \"smart\") == \"~typing.Tuple[str, ...]\"\n \n-    assert stringify(Tuple[()], False) == \"Tuple[()]\"\n-    assert stringify(Tuple[()], True) == \"~typing.Tuple[()]\"\n+    assert stringify(Tuple[()]) == \"Tuple[()]\"\n+    assert stringify(Tuple[()], \"fully-qualified\") == \"typing.Tuple[()]\"\n+    assert stringify(Tuple[()], \"smart\") == \"~typing.Tuple[()]\"\n \n-    assert stringify(List[Dict[str, Tuple]], False) == \"List[Dict[str, Tuple]]\"\n-    assert stringify(List[Dict[str, Tuple]], True) == \"~typing.List[~typing.Dict[str, ~typing.Tuple]]\"\n+    assert stringify(List[Dict[str, Tuple]]) == \"List[Dict[str, Tuple]]\"\n+    assert stringify(List[Dict[str, Tuple]], \"fully-qualified\") == \"typing.List[typing.Dict[str, typing.Tuple]]\"\n+    assert stringify(List[Dict[str, Tuple]], \"smart\") == \"~typing.List[~typing.Dict[str, ~typing.Tuple]]\"\n \n-    assert stringify(MyList[Tuple[int, int]], False) == \"tests.test_util_typing.MyList[Tuple[int, int]]\"\n-    assert stringify(MyList[Tuple[int, int]], True) == \"~tests.test_util_typing.MyList[~typing.Tuple[int, int]]\"\n+    assert stringify(MyList[Tuple[int, int]]) == \"tests.test_util_typing.MyList[Tuple[int, int]]\"\n+    assert stringify(MyList[Tuple[int, int]], \"fully-qualified\") == \"tests.test_util_typing.MyList[typing.Tuple[int, int]]\"\n+    assert stringify(MyList[Tuple[int, int]], \"smart\") == \"~tests.test_util_typing.MyList[~typing.Tuple[int, int]]\"\n \n-    assert stringify(Generator[None, None, None], False) == \"Generator[None, None, None]\"\n-    assert stringify(Generator[None, None, None], True) == \"~typing.Generator[None, None, None]\"\n+    assert stringify(Generator[None, None, None]) == \"Generator[None, None, None]\"\n+    assert stringify(Generator[None, None, None], \"fully-qualified\") == \"typing.Generator[None, None, None]\"\n+    assert stringify(Generator[None, None, None], \"smart\") == \"~typing.Generator[None, None, None]\"\n \n \n @pytest.mark.skipif(sys.version_info < (3, 9), reason='python 3.9+ is required.')\n def test_stringify_type_hints_pep_585():\n-    assert stringify(list[int], False) == \"list[int]\"\n-    assert stringify(list[int], True) == \"list[int]\"\n+    assert stringify(list[int]) == \"list[int]\"\n+    assert stringify(list[int], \"smart\") == \"list[int]\"\n \n-    assert stringify(list[str], False) == \"list[str]\"\n-    assert stringify(list[str], True) == \"list[str]\"\n+    assert stringify(list[str]) == \"list[str]\"\n+    assert stringify(list[str], \"smart\") == \"list[str]\"\n \n-    assert stringify(dict[str, float], False) == \"dict[str, float]\"\n-    assert stringify(dict[str, float], True) == \"dict[str, float]\"\n+    assert stringify(dict[str, float]) == \"dict[str, float]\"\n+    assert stringify(dict[str, float], \"smart\") == \"dict[str, float]\"\n \n-    assert stringify(tuple[str, str, str], False) == \"tuple[str, str, str]\"\n-    assert stringify(tuple[str, str, str], True) == \"tuple[str, str, str]\"\n+    assert stringify(tuple[str, str, str]) == \"tuple[str, str, str]\"\n+    assert stringify(tuple[str, str, str], \"smart\") == \"tuple[str, str, str]\"\n \n-    assert stringify(tuple[str, ...], False) == \"tuple[str, ...]\"\n-    assert stringify(tuple[str, ...], True) == \"tuple[str, ...]\"\n+    assert stringify(tuple[str, ...]) == \"tuple[str, ...]\"\n+    assert stringify(tuple[str, ...], \"smart\") == \"tuple[str, ...]\"\n \n-    assert stringify(tuple[()], False) == \"tuple[()]\"\n-    assert stringify(tuple[()], True) == \"tuple[()]\"\n+    assert stringify(tuple[()]) == \"tuple[()]\"\n+    assert stringify(tuple[()], \"smart\") == \"tuple[()]\"\n \n-    assert stringify(list[dict[str, tuple]], False) == \"list[dict[str, tuple]]\"\n-    assert stringify(list[dict[str, tuple]], True) == \"list[dict[str, tuple]]\"\n+    assert stringify(list[dict[str, tuple]]) == \"list[dict[str, tuple]]\"\n+    assert stringify(list[dict[str, tuple]], \"smart\") == \"list[dict[str, tuple]]\"\n \n-    assert stringify(type[int], False) == \"type[int]\"\n-    assert stringify(type[int], True) == \"type[int]\"\n+    assert stringify(type[int]) == \"type[int]\"\n+    assert stringify(type[int], \"smart\") == \"type[int]\"\n \n \n @pytest.mark.skipif(sys.version_info < (3, 9), reason='python 3.9+ is required.')\n def test_stringify_Annotated():\n     from typing import Annotated  # type: ignore\n-    assert stringify(Annotated[str, \"foo\", \"bar\"], False) == \"str\"  # NOQA\n-    assert stringify(Annotated[str, \"foo\", \"bar\"], True) == \"str\"  # NOQA\n+    assert stringify(Annotated[str, \"foo\", \"bar\"]) == \"str\"  # NOQA\n+    assert stringify(Annotated[str, \"foo\", \"bar\"], \"smart\") == \"str\"  # NOQA\n \n \n def test_stringify_type_hints_string():\n-    assert stringify(\"int\", False) == \"int\"\n-    assert stringify(\"int\", True) == \"int\"\n+    assert stringify(\"int\") == \"int\"\n+    assert stringify(\"int\", \"smart\") == \"int\"\n \n-    assert stringify(\"str\", False) == \"str\"\n-    assert stringify(\"str\", True) == \"str\"\n+    assert stringify(\"str\") == \"str\"\n+    assert stringify(\"str\", \"smart\") == \"str\"\n \n-    assert stringify(List[\"int\"], False) == \"List[int]\"\n-    assert stringify(List[\"int\"], True) == \"~typing.List[int]\"\n+    assert stringify(List[\"int\"]) == \"List[int]\"\n+    assert stringify(List[\"int\"], \"smart\") == \"~typing.List[int]\"\n \n-    assert stringify(\"Tuple[str]\", False) == \"Tuple[str]\"\n-    assert stringify(\"Tuple[str]\", True) == \"Tuple[str]\"\n+    assert stringify(\"Tuple[str]\") == \"Tuple[str]\"\n+    assert stringify(\"Tuple[str]\", \"smart\") == \"Tuple[str]\"\n \n-    assert stringify(\"unknown\", False) == \"unknown\"\n-    assert stringify(\"unknown\", True) == \"unknown\"\n+    assert stringify(\"unknown\") == \"unknown\"\n+    assert stringify(\"unknown\", \"smart\") == \"unknown\"\n \n \n def test_stringify_type_hints_Callable():\n-    assert stringify(Callable, False) == \"Callable\"\n-    assert stringify(Callable, True) == \"~typing.Callable\"\n+    assert stringify(Callable) == \"Callable\"\n+    assert stringify(Callable, \"fully-qualified\") == \"typing.Callable\"\n+    assert stringify(Callable, \"smart\") == \"~typing.Callable\"\n \n     if sys.version_info >= (3, 7):\n-        assert stringify(Callable[[str], int], False) == \"Callable[[str], int]\"\n-        assert stringify(Callable[[str], int], True) == \"~typing.Callable[[str], int]\"\n+        assert stringify(Callable[[str], int]) == \"Callable[[str], int]\"\n+        assert stringify(Callable[[str], int], \"fully-qualified\") == \"typing.Callable[[str], int]\"\n+        assert stringify(Callable[[str], int], \"smart\") == \"~typing.Callable[[str], int]\"\n \n-        assert stringify(Callable[..., int], False) == \"Callable[[...], int]\"\n-        assert stringify(Callable[..., int], True) == \"~typing.Callable[[...], int]\"\n+        assert stringify(Callable[..., int]) == \"Callable[[...], int]\"\n+        assert stringify(Callable[..., int], \"fully-qualified\") == \"typing.Callable[[...], int]\"\n+        assert stringify(Callable[..., int], \"smart\") == \"~typing.Callable[[...], int]\"\n     else:\n-        assert stringify(Callable[[str], int], False) == \"Callable[str, int]\"\n-        assert stringify(Callable[[str], int], True) == \"~typing.Callable[str, int]\"\n+        assert stringify(Callable[[str], int]) == \"Callable[str, int]\"\n+        assert stringify(Callable[[str], int], \"fully-qualified\") == \"typing.Callable[str, int]\"\n+        assert stringify(Callable[[str], int], \"smart\") == \"~typing.Callable[str, int]\"\n \n-        assert stringify(Callable[..., int], False) == \"Callable[..., int]\"\n-        assert stringify(Callable[..., int], True) == \"~typing.Callable[..., int]\"\n+        assert stringify(Callable[..., int]) == \"Callable[..., int]\"\n+        assert stringify(Callable[..., int], \"fully-qualified\") == \"typing.Callable[..., int]\"\n+        assert stringify(Callable[..., int], \"smart\") == \"~typing.Callable[..., int]\"\n \n \n def test_stringify_type_hints_Union():\n-    assert stringify(Optional[int], False) == \"Optional[int]\"\n-    assert stringify(Optional[int], True) == \"~typing.Optional[int]\"\n+    assert stringify(Optional[int]) == \"Optional[int]\"\n+    assert stringify(Optional[int], \"fully-qualified\") == \"typing.Optional[int]\"\n+    assert stringify(Optional[int], \"smart\") == \"~typing.Optional[int]\"\n \n-    assert stringify(Union[str, None], False) == \"Optional[str]\"\n-    assert stringify(Union[str, None], True) == \"~typing.Optional[str]\"\n+    assert stringify(Union[str, None]) == \"Optional[str]\"\n+    assert stringify(Union[str, None], \"fully-qualified\") == \"typing.Optional[str]\"\n+    assert stringify(Union[str, None], \"smart\") == \"~typing.Optional[str]\"\n \n-    assert stringify(Union[int, str], False) == \"Union[int, str]\"\n-    assert stringify(Union[int, str], True) == \"~typing.Union[int, str]\"\n+    assert stringify(Union[int, str]) == \"Union[int, str]\"\n+    assert stringify(Union[int, str], \"fully-qualified\") == \"typing.Union[int, str]\"\n+    assert stringify(Union[int, str], \"smart\") == \"~typing.Union[int, str]\"\n \n     if sys.version_info >= (3, 7):\n-        assert stringify(Union[int, Integral], False) == \"Union[int, numbers.Integral]\"\n-        assert stringify(Union[int, Integral], True) == \"~typing.Union[int, ~numbers.Integral]\"\n+        assert stringify(Union[int, Integral]) == \"Union[int, numbers.Integral]\"\n+        assert stringify(Union[int, Integral], \"fully-qualified\") == \"typing.Union[int, numbers.Integral]\"\n+        assert stringify(Union[int, Integral], \"smart\") == \"~typing.Union[int, ~numbers.Integral]\"\n \n-        assert (stringify(Union[MyClass1, MyClass2], False) ==\n+        assert (stringify(Union[MyClass1, MyClass2]) ==\n                 \"Union[tests.test_util_typing.MyClass1, tests.test_util_typing.<MyClass2>]\")\n-        assert (stringify(Union[MyClass1, MyClass2], True) ==\n+        assert (stringify(Union[MyClass1, MyClass2], \"fully-qualified\") ==\n+                \"typing.Union[tests.test_util_typing.MyClass1, tests.test_util_typing.<MyClass2>]\")\n+        assert (stringify(Union[MyClass1, MyClass2], \"smart\") ==\n                 \"~typing.Union[~tests.test_util_typing.MyClass1, ~tests.test_util_typing.<MyClass2>]\")\n     else:\n-        assert stringify(Union[int, Integral], False) == \"numbers.Integral\"\n-        assert stringify(Union[int, Integral], True) == \"~numbers.Integral\"\n+        assert stringify(Union[int, Integral]) == \"numbers.Integral\"\n+        assert stringify(Union[int, Integral], \"fully-qualified\") == \"numbers.Integral\"\n+        assert stringify(Union[int, Integral], \"smart\") == \"~numbers.Integral\"\n \n-        assert stringify(Union[MyClass1, MyClass2], False) == \"tests.test_util_typing.MyClass1\"\n-        assert stringify(Union[MyClass1, MyClass2], True) == \"~tests.test_util_typing.MyClass1\"\n+        assert stringify(Union[MyClass1, MyClass2]) == \"tests.test_util_typing.MyClass1\"\n+        assert stringify(Union[MyClass1, MyClass2], \"fully-qualified\") == \"tests.test_util_typing.MyClass1\"\n+        assert stringify(Union[MyClass1, MyClass2], \"smart\") == \"~tests.test_util_typing.MyClass1\"\n \n \n def test_stringify_type_hints_typevars():\n@@ -336,83 +361,84 @@ def test_stringify_type_hints_typevars():\n     T_contra = TypeVar('T_contra', contravariant=True)\n \n     if sys.version_info < (3, 7):\n-        assert stringify(T, False) == \"T\"\n-        assert stringify(T, True) == \"T\"\n+        assert stringify(T) == \"T\"\n+        assert stringify(T, \"smart\") == \"T\"\n \n-        assert stringify(T_co, False) == \"T_co\"\n-        assert stringify(T_co, True) == \"T_co\"\n+        assert stringify(T_co) == \"T_co\"\n+        assert stringify(T_co, \"smart\") == \"T_co\"\n \n-        assert stringify(T_contra, False) == \"T_contra\"\n-        assert stringify(T_contra, True) == \"T_contra\"\n+        assert stringify(T_contra) == \"T_contra\"\n+        assert stringify(T_contra, \"smart\") == \"T_contra\"\n \n-        assert stringify(List[T], False) == \"List[T]\"\n-        assert stringify(List[T], True) == \"~typing.List[T]\"\n+        assert stringify(List[T]) == \"List[T]\"\n+        assert stringify(List[T], \"smart\") == \"~typing.List[T]\"\n     else:\n-        assert stringify(T, False) == \"tests.test_util_typing.T\"\n-        assert stringify(T, True) == \"~tests.test_util_typing.T\"\n+        assert stringify(T) == \"tests.test_util_typing.T\"\n+        assert stringify(T, \"smart\") == \"~tests.test_util_typing.T\"\n \n-        assert stringify(T_co, False) == \"tests.test_util_typing.T_co\"\n-        assert stringify(T_co, True) == \"~tests.test_util_typing.T_co\"\n+        assert stringify(T_co) == \"tests.test_util_typing.T_co\"\n+        assert stringify(T_co, \"smart\") == \"~tests.test_util_typing.T_co\"\n \n-        assert stringify(T_contra, False) == \"tests.test_util_typing.T_contra\"\n-        assert stringify(T_contra, True) == \"~tests.test_util_typing.T_contra\"\n+        assert stringify(T_contra) == \"tests.test_util_typing.T_contra\"\n+        assert stringify(T_contra, \"smart\") == \"~tests.test_util_typing.T_contra\"\n \n-        assert stringify(List[T], False) == \"List[tests.test_util_typing.T]\"\n-        assert stringify(List[T], True) == \"~typing.List[~tests.test_util_typing.T]\"\n+        assert stringify(List[T]) == \"List[tests.test_util_typing.T]\"\n+        assert stringify(List[T], \"smart\") == \"~typing.List[~tests.test_util_typing.T]\"\n \n     if sys.version_info >= (3, 10):\n-        assert stringify(MyInt, False) == \"tests.test_util_typing.MyInt\"\n-        assert stringify(MyInt, True) == \"~tests.test_util_typing.MyInt\"\n+        assert stringify(MyInt) == \"tests.test_util_typing.MyInt\"\n+        assert stringify(MyInt, \"smart\") == \"~tests.test_util_typing.MyInt\"\n     else:\n-        assert stringify(MyInt, False) == \"MyInt\"\n-        assert stringify(MyInt, True) == \"MyInt\"\n+        assert stringify(MyInt) == \"MyInt\"\n+        assert stringify(MyInt, \"smart\") == \"MyInt\"\n \n \n def test_stringify_type_hints_custom_class():\n-    assert stringify(MyClass1, False) == \"tests.test_util_typing.MyClass1\"\n-    assert stringify(MyClass1, True) == \"~tests.test_util_typing.MyClass1\"\n+    assert stringify(MyClass1) == \"tests.test_util_typing.MyClass1\"\n+    assert stringify(MyClass1, \"smart\") == \"~tests.test_util_typing.MyClass1\"\n \n-    assert stringify(MyClass2, False) == \"tests.test_util_typing.<MyClass2>\"\n-    assert stringify(MyClass2, True) == \"~tests.test_util_typing.<MyClass2>\"\n+    assert stringify(MyClass2) == \"tests.test_util_typing.<MyClass2>\"\n+    assert stringify(MyClass2, \"smart\") == \"~tests.test_util_typing.<MyClass2>\"\n \n \n def test_stringify_type_hints_alias():\n     MyStr = str\n     MyTuple = Tuple[str, str]\n \n-    assert stringify(MyStr, False) == \"str\"\n-    assert stringify(MyStr, True) == \"str\"\n+    assert stringify(MyStr) == \"str\"\n+    assert stringify(MyStr, \"smart\") == \"str\"\n \n-    assert stringify(MyTuple, False) == \"Tuple[str, str]\"  # type: ignore\n-    assert stringify(MyTuple, True) == \"~typing.Tuple[str, str]\"  # type: ignore\n+    assert stringify(MyTuple) == \"Tuple[str, str]\"  # type: ignore\n+    assert stringify(MyTuple, \"smart\") == \"~typing.Tuple[str, str]\"  # type: ignore\n \n \n @pytest.mark.skipif(sys.version_info < (3, 8), reason='python 3.8+ is required.')\n def test_stringify_type_Literal():\n     from typing import Literal  # type: ignore\n-    assert stringify(Literal[1, \"2\", \"\\r\"], False) == \"Literal[1, '2', '\\\\r']\"\n-    assert stringify(Literal[1, \"2\", \"\\r\"], True) == \"~typing.Literal[1, '2', '\\\\r']\"\n+    assert stringify(Literal[1, \"2\", \"\\r\"]) == \"Literal[1, '2', '\\\\r']\"\n+    assert stringify(Literal[1, \"2\", \"\\r\"], \"fully-qualified\") == \"typing.Literal[1, '2', '\\\\r']\"\n+    assert stringify(Literal[1, \"2\", \"\\r\"], \"smart\") == \"~typing.Literal[1, '2', '\\\\r']\"\n \n \n @pytest.mark.skipif(sys.version_info < (3, 10), reason='python 3.10+ is required.')\n def test_stringify_type_union_operator():\n-    assert stringify(int | None, False) == \"int | None\"  # type: ignore\n-    assert stringify(int | None, True) == \"int | None\"  # type: ignore\n+    assert stringify(int | None) == \"int | None\"  # type: ignore\n+    assert stringify(int | None, \"smart\") == \"int | None\"  # type: ignore\n \n-    assert stringify(int | str, False) == \"int | str\"  # type: ignore\n-    assert stringify(int | str, True) == \"int | str\"  # type: ignore\n+    assert stringify(int | str) == \"int | str\"  # type: ignore\n+    assert stringify(int | str, \"smart\") == \"int | str\"  # type: ignore\n \n-    assert stringify(int | str | None, False) == \"int | str | None\"  # type: ignore\n-    assert stringify(int | str | None, True) == \"int | str | None\"  # type: ignore\n+    assert stringify(int | str | None) == \"int | str | None\"  # type: ignore\n+    assert stringify(int | str | None, \"smart\") == \"int | str | None\"  # type: ignore\n \n \n def test_stringify_broken_type_hints():\n-    assert stringify(BrokenType, False) == 'tests.test_util_typing.BrokenType'\n-    assert stringify(BrokenType, True) == '~tests.test_util_typing.BrokenType'\n+    assert stringify(BrokenType) == 'tests.test_util_typing.BrokenType'\n+    assert stringify(BrokenType, \"smart\") == '~tests.test_util_typing.BrokenType'\n \n \n def test_stringify_mock():\n     with mock(['unknown']):\n         import unknown\n-        assert stringify(unknown.secret.Class, False) == 'unknown.secret.Class'\n-        assert stringify(unknown.secret.Class, True) == 'unknown.secret.Class'\n+        assert stringify(unknown.secret.Class) == 'unknown.secret.Class'\n+        assert stringify(unknown.secret.Class, \"smart\") == 'unknown.secret.Class'\n",
  "problem_statement": "autodoc typehints do not create link for parametrized types\n**Describe the bug**\r\n\r\nautodoc typehints normally generate a link to the hinted type, but do not do so for parametrized types.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n```\r\n$ cat >project.py <<EOF\r\nfrom typing import Literal\r\n\r\ndef func(x: Literal[\"a\", \"b\"], y: int):\r\n    \"\"\"\r\n    :param x: The x.\r\n    :param y: The y.\r\n    \"\"\"\r\nEOF\r\nsphinx-apidoc . -o . -F -A me -V 0.0 --extensions sphinx.ext.intersphinx\r\nPYTHONPATH=. make O=-Dautodoc_typehints=description html\r\n```\r\nand open _build/html/project.html\r\n\r\n**Expected behavior**\r\n`Literal` (in the parameter description) should link to typing.Literal in CPython's docs, just like `int` does.\r\n\r\n**Your project**\r\nN/A\r\n\r\n**Screenshots**\r\n![s](https://user-images.githubusercontent.com/1322974/117574897-ab1e0900-b0df-11eb-8813-266fc5c744af.png)\r\n\r\n**Environment info**\r\n- OS: linux\r\n- Python version: 3.9.4\r\n- Sphinx version: 4.0.0\r\n- Sphinx extensions: intersphinx, autodoc\r\n- Extra tools: N/A\r\n\r\n**Additional context**\r\nN/A\r\n\n",
  "hints_text": "Duplicated with #9195? Closing.\nOh, sorry. I understood these are different topic. Reopened now.\nThe issue seems to be stemming from https://github.com/sphinx-doc/sphinx/blob/80fbbb8462f075644e229c9d00293d4afde7adf2/sphinx/ext/autodoc/typehints.py#L33 -- since the types coming from typing are \"stringified\" and not being passed through intersphinx.\nI guess the fix here is to pass these through `typing.restify` instead?\n>I guess the fix here is to pass these through typing.restify instead?\r\n\r\nNo, it will generate incorrect mark-ups:\r\n\r\n```\r\n.. py:function:: func(x: :py:class:`Literal`\\[\"a\", \"b\"], y: :py:class:`int`)\r\n```\r\n",
  "created_at": "2021-12-20T16:29:37Z",
  "version": "4.4",
  "FAIL_TO_PASS": "[\"tests/test_domain_py.py::test_parse_annotation\", \"tests/test_domain_py.py::test_parse_annotation_suppress\", \"tests/test_domain_py.py::test_parse_annotation_Literal\", \"tests/test_ext_autodoc_autofunction.py::test_wrapped_function_contextmanager\", \"tests/test_ext_autodoc_automodule.py::test_subclass_of_mocked_object\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_signature\", \"tests/test_ext_autodoc_preserve_defaults.py::test_preserve_defaults\", \"tests/test_util_inspect.py::test_signature_annotations\", \"tests/test_util_typing.py::test_stringify\", \"tests/test_util_typing.py::test_stringify_type_hints_containers\", \"tests/test_util_typing.py::test_stringify_type_hints_Callable\", \"tests/test_util_typing.py::test_stringify_type_hints_Union\", \"tests/test_util_typing.py::test_stringify_type_Literal\"]",
  "PASS_TO_PASS": "[\"tests/test_domain_py.py::test_function_signatures\", \"tests/test_domain_py.py::test_domain_py_xrefs\", \"tests/test_domain_py.py::test_domain_py_xrefs_abbreviations\", \"tests/test_domain_py.py::test_domain_py_objects\", \"tests/test_domain_py.py::test_resolve_xref_for_properties\", \"tests/test_domain_py.py::test_domain_py_find_obj\", \"tests/test_domain_py.py::test_domain_py_canonical\", \"tests/test_domain_py.py::test_get_full_qualified_name\", \"tests/test_domain_py.py::test_pyfunction_signature\", \"tests/test_domain_py.py::test_pyfunction_signature_full\", \"tests/test_domain_py.py::test_pyfunction_signature_full_py38\", \"tests/test_domain_py.py::test_pyfunction_with_number_literals\", \"tests/test_domain_py.py::test_pyfunction_with_union_type_operator\", \"tests/test_domain_py.py::test_optional_pyfunction_signature\", \"tests/test_domain_py.py::test_pyexception_signature\", \"tests/test_domain_py.py::test_pydata_signature\", \"tests/test_domain_py.py::test_pydata_signature_old\", \"tests/test_domain_py.py::test_pydata_with_union_type_operator\", \"tests/test_domain_py.py::test_pyobject_prefix\", \"tests/test_domain_py.py::test_pydata\", \"tests/test_domain_py.py::test_pyfunction\", \"tests/test_domain_py.py::test_pyclass_options\", \"tests/test_domain_py.py::test_pymethod_options\", \"tests/test_domain_py.py::test_pyclassmethod\", \"tests/test_domain_py.py::test_pystaticmethod\", \"tests/test_domain_py.py::test_pyattribute\", \"tests/test_domain_py.py::test_pyproperty\", \"tests/test_domain_py.py::test_pydecorator_signature\", \"tests/test_domain_py.py::test_pydecoratormethod_signature\", \"tests/test_domain_py.py::test_canonical\", \"tests/test_domain_py.py::test_canonical_definition_overrides\", \"tests/test_domain_py.py::test_canonical_definition_skip\", \"tests/test_domain_py.py::test_canonical_duplicated\", \"tests/test_domain_py.py::test_info_field_list\", \"tests/test_domain_py.py::test_info_field_list_piped_type\", \"tests/test_domain_py.py::test_info_field_list_Literal\", \"tests/test_domain_py.py::test_info_field_list_var\", \"tests/test_domain_py.py::test_type_field\", \"tests/test_domain_py.py::test_module_index\", \"tests/test_domain_py.py::test_module_index_submodule\", \"tests/test_domain_py.py::test_module_index_not_collapsed\", \"tests/test_domain_py.py::test_modindex_common_prefix\", \"tests/test_domain_py.py::test_noindexentry\", \"tests/test_domain_py.py::test_python_python_use_unqualified_type_names\", \"tests/test_domain_py.py::test_python_python_use_unqualified_type_names_disabled\", \"tests/test_domain_py.py::test_warn_missing_reference\", \"tests/test_ext_autodoc_autofunction.py::test_classes\", \"tests/test_ext_autodoc_autofunction.py::test_callable\", \"tests/test_ext_autodoc_autofunction.py::test_method\", \"tests/test_ext_autodoc_autofunction.py::test_builtin_function\", \"tests/test_ext_autodoc_autofunction.py::test_methoddescriptor\", \"tests/test_ext_autodoc_autofunction.py::test_decorated\", \"tests/test_ext_autodoc_autofunction.py::test_singledispatch\", \"tests/test_ext_autodoc_autofunction.py::test_cfunction\", \"tests/test_ext_autodoc_autofunction.py::test_wrapped_function\", \"tests/test_ext_autodoc_autofunction.py::test_coroutine\", \"tests/test_ext_autodoc_autofunction.py::test_synchronized_coroutine\", \"tests/test_ext_autodoc_autofunction.py::test_async_generator\", \"tests/test_ext_autodoc_automodule.py::test_empty_all\", \"tests/test_ext_autodoc_automodule.py::test_automodule\", \"tests/test_ext_autodoc_automodule.py::test_automodule_undoc_members\", \"tests/test_ext_autodoc_automodule.py::test_automodule_special_members\", \"tests/test_ext_autodoc_configs.py::test_autoclass_content_class\", \"tests/test_ext_autodoc_configs.py::test_autoclass_content_init\", \"tests/test_ext_autodoc_configs.py::test_autodoc_class_signature_mixed\", \"tests/test_ext_autodoc_configs.py::test_autodoc_class_signature_separated_init\", \"tests/test_ext_autodoc_configs.py::test_autodoc_class_signature_separated_new\", \"tests/test_ext_autodoc_configs.py::test_autoclass_content_both\", \"tests/test_ext_autodoc_configs.py::test_autodoc_inherit_docstrings\", \"tests/test_ext_autodoc_configs.py::test_autodoc_docstring_signature\", \"tests/test_ext_autodoc_configs.py::test_autoclass_content_and_docstring_signature_class\", \"tests/test_ext_autodoc_configs.py::test_autoclass_content_and_docstring_signature_init\", \"tests/test_ext_autodoc_configs.py::test_autoclass_content_and_docstring_signature_both\", \"tests/test_ext_autodoc_configs.py::test_mocked_module_imports\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_none\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_none_for_overload\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_description\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_description_no_undoc\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_description_with_documented_init\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_description_with_documented_init_no_undoc\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_description_for_invalid_node\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_both\", \"tests/test_ext_autodoc_configs.py::test_autodoc_type_aliases\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_description_and_type_aliases\", \"tests/test_ext_autodoc_configs.py::test_autodoc_typehints_format_short\", \"tests/test_ext_autodoc_configs.py::test_autodoc_default_options\", \"tests/test_ext_autodoc_configs.py::test_autodoc_default_options_with_values\", \"tests/test_util_inspect.py::test_TypeAliasNamespace\", \"tests/test_util_inspect.py::test_signature\", \"tests/test_util_inspect.py::test_signature_partial\", \"tests/test_util_inspect.py::test_signature_methods\", \"tests/test_util_inspect.py::test_signature_partialmethod\", \"tests/test_util_inspect.py::test_signature_annotations_py38\", \"tests/test_util_inspect.py::test_signature_from_str_basic\", \"tests/test_util_inspect.py::test_signature_from_str_default_values\", \"tests/test_util_inspect.py::test_signature_from_str_annotations\", \"tests/test_util_inspect.py::test_signature_from_str_complex_annotations\", \"tests/test_util_inspect.py::test_signature_from_str_kwonly_args\", \"tests/test_util_inspect.py::test_signature_from_str_positionaly_only_args\", \"tests/test_util_inspect.py::test_signature_from_str_invalid\", \"tests/test_util_inspect.py::test_signature_from_ast\", \"tests/test_util_inspect.py::test_safe_getattr_with_default\", \"tests/test_util_inspect.py::test_safe_getattr_with_exception\", \"tests/test_util_inspect.py::test_safe_getattr_with_property_exception\", \"tests/test_util_inspect.py::test_safe_getattr_with___dict___override\", \"tests/test_util_inspect.py::test_dictionary_sorting\", \"tests/test_util_inspect.py::test_set_sorting\", \"tests/test_util_inspect.py::test_set_sorting_fallback\", \"tests/test_util_inspect.py::test_frozenset_sorting\", \"tests/test_util_inspect.py::test_frozenset_sorting_fallback\", \"tests/test_util_inspect.py::test_dict_customtype\", \"tests/test_util_inspect.py::test_object_description_enum\", \"tests/test_util_inspect.py::test_getslots\", \"tests/test_util_inspect.py::test_isclassmethod\", \"tests/test_util_inspect.py::test_isstaticmethod\", \"tests/test_util_inspect.py::test_iscoroutinefunction\", \"tests/test_util_inspect.py::test_isfunction\", \"tests/test_util_inspect.py::test_isbuiltin\", \"tests/test_util_inspect.py::test_isdescriptor\", \"tests/test_util_inspect.py::test_isattributedescriptor\", \"tests/test_util_inspect.py::test_isproperty\", \"tests/test_util_inspect.py::test_isgenericalias\", \"tests/test_util_inspect.py::test_unpartial\", \"tests/test_util_inspect.py::test_getdoc_inherited_classmethod\", \"tests/test_util_inspect.py::test_getdoc_inherited_decorated_method\", \"tests/test_util_inspect.py::test_is_builtin_class_method\", \"tests/test_util_typing.py::test_restify\", \"tests/test_util_typing.py::test_restify_type_hints_containers\", \"tests/test_util_typing.py::test_restify_type_hints_Callable\", \"tests/test_util_typing.py::test_restify_type_hints_Union\", \"tests/test_util_typing.py::test_restify_type_hints_typevars\", \"tests/test_util_typing.py::test_restify_type_hints_custom_class\", \"tests/test_util_typing.py::test_restify_type_hints_alias\", \"tests/test_util_typing.py::test_restify_type_ForwardRef\", \"tests/test_util_typing.py::test_restify_type_Literal\", \"tests/test_util_typing.py::test_restify_pep_585\", \"tests/test_util_typing.py::test_restify_broken_type_hints\", \"tests/test_util_typing.py::test_restify_mock\", \"tests/test_util_typing.py::test_stringify_type_hints_pep_585\", \"tests/test_util_typing.py::test_stringify_Annotated\", \"tests/test_util_typing.py::test_stringify_type_hints_string\", \"tests/test_util_typing.py::test_stringify_type_hints_typevars\", \"tests/test_util_typing.py::test_stringify_type_hints_custom_class\", \"tests/test_util_typing.py::test_stringify_type_hints_alias\", \"tests/test_util_typing.py::test_stringify_broken_type_hints\", \"tests/test_util_typing.py::test_stringify_mock\"]",
  "environment_setup_commit": "0938c193ea6f56dbb930bfb323602bc4e2b7b9c6",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.071132",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}