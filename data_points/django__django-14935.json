{
  "repo": "django/django",
  "instance_id": "django__django-14935",
  "base_commit": "0f3e1a54bfa19f034f88bf3c25c67402d19e906c",
  "patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -880,6 +880,12 @@ def _generate_added_field(self, app_label, model_name, field_name):\n                 field.default = self.questioner.ask_auto_now_add_addition(field_name, model_name)\n             else:\n                 field.default = self.questioner.ask_not_null_addition(field_name, model_name)\n+        if (\n+            field.unique and\n+            field.default is not models.NOT_PROVIDED and\n+            callable(field.default)\n+        ):\n+            self.questioner.ask_unique_callable_default_addition(field_name, model_name)\n         self.add_operation(\n             app_label,\n             operations.AddField(\ndiff --git a/django/db/migrations/questioner.py b/django/db/migrations/questioner.py\n--- a/django/db/migrations/questioner.py\n+++ b/django/db/migrations/questioner.py\n@@ -6,6 +6,7 @@\n from django.apps import apps\n from django.db.models import NOT_PROVIDED\n from django.utils import timezone\n+from django.utils.version import get_docs_version\n \n from .loader import MigrationLoader\n \n@@ -79,6 +80,11 @@ def ask_auto_now_add_addition(self, field_name, model_name):\n         # None means quit\n         return None\n \n+    def ask_unique_callable_default_addition(self, field_name, model_name):\n+        \"\"\"Adding a unique field with a callable default.\"\"\"\n+        # None means continue.\n+        return None\n+\n \n class InteractiveMigrationQuestioner(MigrationQuestioner):\n \n@@ -229,6 +235,27 @@ def ask_auto_now_add_addition(self, field_name, model_name):\n                 return self._ask_default(default='timezone.now')\n         return None\n \n+    def ask_unique_callable_default_addition(self, field_name, model_name):\n+        \"\"\"Adding a unique field with a callable default.\"\"\"\n+        if not self.dry_run:\n+            version = get_docs_version()\n+            choice = self._choice_input(\n+                f'Callable default on unique field {model_name}.{field_name} '\n+                f'will not generate unique values upon migrating.\\n'\n+                f'Please choose how to proceed:\\n',\n+                [\n+                    f'Continue making this migration as the first step in '\n+                    f'writing a manual migration to generate unique values '\n+                    f'described here: '\n+                    f'https://docs.djangoproject.com/en/{version}/howto/'\n+                    f'writing-migrations/#migrations-that-add-unique-fields.',\n+                    'Quit and edit field options in models.py.',\n+                ],\n+            )\n+            if choice == 2:\n+                sys.exit(3)\n+        return None\n+\n \n class NonInteractiveMigrationQuestioner(MigrationQuestioner):\n \n",
  "test_patch": "diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -17,6 +17,8 @@\n from django.db.migrations.recorder import MigrationRecorder\n from django.test import TestCase, override_settings, skipUnlessDBFeature\n from django.test.utils import captured_stdout\n+from django.utils import timezone\n+from django.utils.version import get_docs_version\n \n from .models import UnicodeModel, UnserializableModel\n from .routers import TestRouter\n@@ -1870,6 +1872,57 @@ class Meta:\n                 with self.assertRaises(SystemExit):\n                     call_command('makemigrations', 'migrations', interactive=True)\n \n+    def test_makemigrations_interactive_unique_callable_default_addition(self):\n+        \"\"\"\n+        makemigrations prompts the user when adding a unique field with\n+        a callable default.\n+        \"\"\"\n+        class Book(models.Model):\n+            created = models.DateTimeField(unique=True, default=timezone.now)\n+\n+            class Meta:\n+                app_label = 'migrations'\n+\n+        version = get_docs_version()\n+        input_msg = (\n+            f'Callable default on unique field book.created will not generate '\n+            f'unique values upon migrating.\\n'\n+            f'Please choose how to proceed:\\n\\n'\n+            f' 1) Continue making this migration as the first step in writing '\n+            f'a manual migration to generate unique values described here: '\n+            f'https://docs.djangoproject.com/en/{version}/howto/'\n+            f'writing-migrations/#migrations-that-add-unique-fields.\\n'\n+            f' 2) Quit and edit field options in models.py.\\n'\n+        )\n+        with self.temporary_migration_module(module='migrations.test_migrations'):\n+            # 2 - quit.\n+            with mock.patch('builtins.input', return_value='2'):\n+                with captured_stdout() as out, self.assertRaises(SystemExit):\n+                    call_command('makemigrations', 'migrations', interactive=True)\n+            out_value = out.getvalue()\n+            self.assertIn(input_msg, out_value)\n+            self.assertNotIn('Add field created to book', out_value)\n+            # 1 - continue.\n+            with mock.patch('builtins.input', return_value='1'):\n+                with captured_stdout() as out:\n+                    call_command('makemigrations', 'migrations', interactive=True)\n+            out_value = out.getvalue()\n+            self.assertIn(input_msg, out_value)\n+            self.assertIn('Add field created to book', out_value)\n+\n+    def test_makemigrations_non_interactive_unique_callable_default_addition(self):\n+        class Book(models.Model):\n+            created = models.DateTimeField(unique=True, default=timezone.now)\n+\n+            class Meta:\n+                app_label = 'migrations'\n+\n+        with self.temporary_migration_module(module='migrations.test_migrations'):\n+            with captured_stdout() as out:\n+                call_command('makemigrations', 'migrations', interactive=False)\n+            out_value = out.getvalue()\n+            self.assertIn('Add field created to book', out_value)\n+\n \n class SquashMigrationsTests(MigrationTestBase):\n     \"\"\"\n",
  "problem_statement": "Add makemigrations warning for unique fields with callable defaults\nDescription\n\t\nCallables on properties for ModelFields are used for various reasons. One use case is to autocreate random file names or user passwords if not present.\nThe migration seems to call them only once because after the migration every \"Buchung\" has the same wlan_password.\nMy Model:\ndef random_wlan_key():\n\treturn ''.join(random.SystemRandom().choice(\"1234567890abcdefghkmnpqrstuvwxyz\") for i in range(9))\nclass Buchung(models.Model):\n\t[...]\n\twlan_passwort = models.CharField(max_length=10, default=random_wlan_key)\nThe generated migration:\n# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\nfrom django.db import models, migrations\nimport main.models\nclass Migration(migrations.Migration):\n\tdependencies = [\n\t\t('main', '0001_initial'),\n\t]\n\toperations = [\n\t\tmigrations.AddField(\n\t\t\tmodel_name='buchung',\n\t\t\tname='wlan_passwort',\n\t\t\tfield=models.CharField(default=main.models.random_wlan_key, max_length=10),\n\t\t\tpreserve_default=True,\n\t\t),\n\t]\n",
  "hints_text": "Hi, I can reproduce this indeed. At this point, I'm not sure if this behavior is by design or not. If not, we should definitely fix this and if it is, we should document it. Thanks.\nHi, thanks for your time. I would argue that this behavior is not intended as best practice to create fields like \"created_at\" fields is to assign a callable. Calling it only once during a migration is killing dynamic behavior. What if the default value of this field is dependent on another one? regards Tom\nI wouldn't consider this a bug as the default value is nothing that is enforced on database level but inside Django. If you want to have random values per row, you need to add a ​RunPython operation that updates the value per row.\nThis is exactly as designed; when creating columns databases only take a single argument for the DEFAULT clause, so we can only provide a single value, so we only call a callable once. If you want unique values per row, you'll need to populate them in RunPython as Markush2010 suggests.\nI do indeed want unique values per row, and will populate them myself, but, in that case, I don't want Django setting the default and having me wonder down the line why the rows for which I didn't specify a value have a default of 2014-06-24. The correct behavior there would be to ignore the default completely, since there's no reasonable use case where it's supposed to call the callable once and use it for all the columns.\nCallables on properties for ModelFields are used for various reasons. One use case is to autocreate UUIDs (​https://docs.djangoproject.com/en/dev/ref/models/fields/#django.db.models.UUIDField). My Models: import uuid class AbstractUUIDModel(models.Model): [...] uuid = models.UUIDField(default=uuid.uuid4, editable=False, max_length=32, help_text='Universally unique identifier', unique=True, verbose_name='UUID') class Meta: abstract = True class Company(AbstractUUIDModel): pass The generated migration: # -*- coding: utf-8 -*- from __future__ import unicode_literals from django.db import models, migrations import main.models import uuid class Migration(migrations.Migration): dependencies = [ ('main', '0001_initial'), ] operations = [ migrations.AddField( model_name='company', name='uuid', field=models.UUIDField(default=uuid.uuid4, editable=False, max_length=32, help_text='Universally unique identifier', unique=True, verbose_name='UUID'), preserve_default=True, ), ] Results: django.db.utils.IntegrityError: could not create unique index \"company_company_uuid_key\" DETAIL: Key (uuid)=(1ba0e330-9786-4928-b89d-b1fbef72b9c1) is duplicated. Based on the ​documentation, you should add the default=uuid.uuid4 on the models.UUIDField. However, you cannot do this with the current way migrations work. Django currently tries to generate the same UUID for each instance that is created. In this instance (Django 1.8 isn't released yet), you will run into issues: import uuid from django.db import models class MyUUIDModel(models.Model): id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False) # other fields If default is set to a callable, I believe that it is implied that the result should be dynamically generated in Python/Django. If the functionality is to stay as stated in the result of this ticket, I would have to hand-code this migration for each app that previously existed to first create a nullable UUIDField with no default, then create a data migration to add distinct UUIDs to the Company, then write a migrations.AlterField migration to set null=False. The alternative might be to consider creating a special case for the UUIDField to allow for non-duplicated UUIDs to be created during migrations. From what I can take away, it has been stated that you cannot add/alter a field with a default=callable, null=False, unique=True without writing a custom migration. It would be much easier if migrations followed the same standards as the ​django.db.models.fields.Field.get_default() method. Currently, we have to hand-code the following migration to avoid the failure for every app which utilizes the AbstractUUIDModel, which I feel violates the DRY principle: # -*- coding: utf-8 -*- from __future__ import unicode_literals from django.db import models, migrations import uuid def generate_uuid(apps, schema_editor): Company = apps.get_model('company', 'Company') for company in Company.objects.all().iterator(): company.uuid = uuid.uuid4() company.save() class Migration(migrations.Migration): dependencies = [ ('main', '0001_initial'), ] operations = [ migrations.AddField( model_name='company', name='uuid', field=models.UUIDField(editable=False, max_length=32, help_text='Universally unique identifier', null=True, verbose_name='UUID'), preserve_default=False, ), migrations.RunPython( generate_uuid, ), migrations.AlterField( model_name='company', name='uuid', field=models.UUIDField(editable=False, max_length=32, help_text='Universally unique identifier', unique=True, verbose_name='UUID'), preserve_default=True, ) ]\nI just ran into the same issue (trying to set default UUIDs on an UUID field). Using per-row callables as default value in migrations would be very useful, although it should probably be specified in an explicit way.\nI also ran into this problem with a UUID field. I would have thought that this is a sufficiently common use case to be catered for in core. But core devs feel that the onus is on people to write custom 3-step migrations each time, then makemigrations should at least show a warning. I'd imagine that in most cases, a single value for all rows is not what the user is expecting. If makemigrations sees unique=True on the field then it knows that the migration will fail.\nIt seems reasonable to me that makemigrations should, at the very least, issue a warning when it finds a field with a default which is callable and unique==True, and probably for all callable defaults when the field is being added. I'm re-opening on that basis, hope that's OK with other devs. I think an ideal solution is that the warning should reference some shortcut/info for implementing the needed migration.\nThe warning could point to this documentation: ​https://docs.djangoproject.com/en/dev/howto/writing-migrations/#migrations-that-add-unique-fields\nHello, I'm still running this issue on Django five years later, is there any hope to see this issue fixed ? I don't understand why default id with primary key (so is unique too) doesn't have the same issue. Default values are normally used only when we are not providing a value (or providing None value), so I don't understand why when I specify a value, Django just uses it instead of replace it with default value. What I'm missing ? If needed here my example: api/models.py : class Model Test(models.Model): id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False) name = models.CharField(max_length=100) api/fixtures/initial_data.json : { \"model\": \"api.Test\", \"pk\": \"724ea599-10a2-49a1-be2f-c1fcb04d003e\", \"fields\": { \"name\": \"Test 1\" } }, { \"model\": \"api.Test\", \"pk\": \"6bcb72f0-099b-416d-8b2c-fcd0bef76cbf\", \"fields\": { \"name\": \"Test 2\" } } python manage.py loaddata initial_data django.db.utils.IntegrityError: Problem installing fixture 'api/fixtures/initial_data.json': Could not load api.Test(pk=724ea599-10a2-49a1-be2f-c1fcb04d003e): UNIQUE constraint failed: api_test.id Thanks in advance Max EDIT: oh my bad it's not the same issue (here it's about makemigrations / migrate instead of loaddata fixture in my case). Create a dedicated issue here : https://code.djangoproject.com/ticket/31531#ticket",
  "created_at": "2021-10-04T18:51:49Z",
  "version": "4.1",
  "FAIL_TO_PASS": "[\"makemigrations prompts the user when adding a unique field with\"]",
  "PASS_TO_PASS": "[\"test_makemigrations_app_name_specified_as_label (migrations.test_commands.AppLabelErrorTests)\", \"test_makemigrations_nonexistent_app_label (migrations.test_commands.AppLabelErrorTests)\", \"test_migrate_app_name_specified_as_label (migrations.test_commands.AppLabelErrorTests)\", \"test_migrate_nonexistent_app_label (migrations.test_commands.AppLabelErrorTests)\", \"test_showmigrations_app_name_specified_as_label (migrations.test_commands.AppLabelErrorTests)\", \"test_showmigrations_nonexistent_app_label (migrations.test_commands.AppLabelErrorTests)\", \"test_sqlmigrate_app_name_specified_as_label (migrations.test_commands.AppLabelErrorTests)\", \"test_sqlmigrate_nonexistent_app_label (migrations.test_commands.AppLabelErrorTests)\", \"test_squashmigrations_app_name_specified_as_label (migrations.test_commands.AppLabelErrorTests)\", \"test_squashmigrations_nonexistent_app_label (migrations.test_commands.AppLabelErrorTests)\", \"--squashed-name specifies the new migration's name.\", \"--squashed-name also works if a start migration is omitted.\", \"test_squashmigrations_initial_attribute (migrations.test_commands.SquashMigrationsTests)\", \"squashmigrations doesn't accept a starting migration after the ending migration.\", \"squashmigrations optimizes operations.\", \"squashmigrations squashes migrations.\", \"squashmigrations accepts a starting migration.\", \"squashmigrations --no-optimize doesn't optimize operations.\", \"test_failing_migration (migrations.test_commands.MakeMigrationsTests)\", \"test_files_content (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations respects --dry-run option when fixing migration\", \"`makemigrations --merge --dry-run` writes the merge migration file to\", \"test_makemigrations_auto_merge_name (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations prompts the user when adding auto_now_add to an existing\", \"test_makemigrations_auto_now_add_interactive_quit (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations --check should exit with a non-zero status when\", \"makemigrations exits if it detects a conflict.\", \"The history consistency checks in makemigrations respect\", \"test_makemigrations_default_merge_name (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations raises a nice error when migrations are disabled for an\", \"`makemigrations --dry-run` should not ask for defaults.\", \"Allow `makemigrations --dry-run` to output the migrations file to\", \"test_makemigrations_empty_connections (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations properly constructs an empty migration.\", \"makemigrations exits if no app is specified with 'empty' mode.\", \"makemigrations properly merges the conflicting migrations with --noinput.\", \"makemigrations should raise InconsistentMigrationHistory exception if\", \"test_makemigrations_inconsistent_history_db_failure (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations enters interactive mode and merges properly.\", \"The user is prompted to merge by default if there are conflicts and\", \"makemigrations messages when adding a NOT NULL field in interactive\", \"makemigrations messages when changing a NULL field to NOT NULL in\", \"makemigrations enters and exits interactive mode properly.\", \"makemigrations --merge does not output any operations from apps that\", \"makemigrations exits if in merge mode with no conflicts.\", \"makemigrations should print the relative paths to the migrations unless\", \"makemigrations prints the absolute path if os.path.relpath() raises a\", \"makemigrations announces the migration at the default verbosity level.\", \"test_makemigrations_migrations_modules_nonexistent_toplevel_package (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations creates migrations when specifying a custom location\", \"makemigrations should detect initial is needed on empty migration\", \"makemigrations exits when there are no changes to an app.\", \"makemigrations exits when there are no changes and no apps are specified.\", \"makemigrations fails to merge migrations with no common ancestor.\", \"Migration directories without an __init__.py file are allowed.\", \"makemigrations adds and removes a possible field rename in\", \"makemigrations adds and removes a possible model rename in\", \"Non-interactive makemigrations fails when a default is missing on a\", \"test_makemigrations_non_interactive_unique_callable_default_addition (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations should recognize number-only migrations (0001.py).\", \"makemigrations does not create a merge for an unspecified app even if\", \"makemigrations does not raise a CommandError when an unspecified app\", \"makemigrations --name generate a custom migration name.\", \"test_makemigrations_with_invalid_custom_name (migrations.test_commands.MakeMigrationsTests)\", \"test_ambiguous_prefix (migrations.test_commands.MigrateTests)\", \"test_app_without_migrations (migrations.test_commands.MigrateTests)\", \"Tests basic usage of the migrate command.\", \"test_migrate_backward_to_squashed_migration (migrations.test_commands.MigrateTests)\", \"test_migrate_check (migrations.test_commands.MigrateTests)\", \"test_migrate_check_plan (migrations.test_commands.MigrateTests)\", \"migrate exits if it detects a conflict.\", \"--fake-initial only works if all tables created in the initial\", \"test_migrate_fake_initial_case_insensitive (migrations.test_commands.MigrateTests)\", \"Split initial migrations can be faked with --fake-initial.\", \"Running migrate with some migrations applied before their dependencies\", \"`Migration.initial = False` skips fake-initial detection.\", \"test_migrate_not_reflected_changes (migrations.test_commands.MigrateTests)\", \"Migrating to a squashed migration specified by name should succeed\", \"Tests migrate --plan output.\", \"Running a single squashed migration should record all of the original\", \"Running migrate for a squashed migration should record as run\", \"Running migrate --run-syncdb with an app_label only creates tables for\", \"test_migrate_syncdb_app_with_migrations (migrations.test_commands.MigrateTests)\", \"For an app without migrations, editor.execute() is used for executing\", \"test_migrate_with_system_checks (migrations.test_commands.MigrateTests)\", \"test_migrations_no_operations (migrations.test_commands.MigrateTests)\", \"Assuming you have 3 apps, `A`, `B`, and `C`, such that:\", \"showmigrations --list  displays migrations and whether or not they're\", \"test_showmigrations_list_squashed (migrations.test_commands.MigrateTests)\", \"test_showmigrations_no_migrations (migrations.test_commands.MigrateTests)\", \"Tests --plan output of showmigrations command\", \"test_showmigrations_plan_app_label_no_migrations (migrations.test_commands.MigrateTests)\", \"`showmigrations --plan app_label` output with multiple app_labels.\", \"Tests --plan output of showmigrations command without migrations\", \"`showmigrations --plan app_label` output with a single app_label.\", \"Tests --plan output of showmigrations command with squashed migrations.\", \"test_showmigrations_unmigrated_app (migrations.test_commands.MigrateTests)\", \"test_sqlmigrate_ambiguous_prefix_squashed_migrations (migrations.test_commands.MigrateTests)\", \"sqlmigrate outputs reverse looking SQL.\", \"Transaction wrappers aren't shown for non-atomic migrations.\", \"Transaction wrappers aren't shown for databases that don't support\", \"sqlmigrate outputs forward looking SQL.\", \"test_sqlmigrate_replaced_migration (migrations.test_commands.MigrateTests)\", \"test_sqlmigrate_squashed_migration (migrations.test_commands.MigrateTests)\", \"test_unknown_prefix (migrations.test_commands.MigrateTests)\"]",
  "environment_setup_commit": "647480166bfe7532e8c471fef0146e3a17e6c0c9",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.709164",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}