{
  "repo": "django/django",
  "instance_id": "django__django-11354",
  "base_commit": "a9c6ab03560424ed7dff24849c8ddaa3e1eae62e",
  "patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -699,6 +699,16 @@ def as_sql(self, compiler, connection):\n     def get_group_by_cols(self, alias=None):\n         return [self]\n \n+    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+        # Resolve parents fields used in raw SQL.\n+        for parent in query.model._meta.get_parent_list():\n+            for parent_field in parent._meta.local_fields:\n+                _, column_name = parent_field.get_attname_column()\n+                if column_name.lower() in self.sql.lower():\n+                    query.resolve_ref(parent_field.name, allow_joins, reuse, summarize)\n+                    break\n+        return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)\n+\n \n class Star(Expression):\n     def __repr__(self):\n",
  "test_patch": "diff --git a/tests/annotations/models.py b/tests/annotations/models.py\n--- a/tests/annotations/models.py\n+++ b/tests/annotations/models.py\n@@ -38,6 +38,7 @@ class Store(models.Model):\n     books = models.ManyToManyField(Book)\n     original_opening = models.DateTimeField()\n     friday_night_closing = models.TimeField()\n+    area = models.IntegerField(null=True, db_column='surface')\n \n     def __str__(self):\n         return self.name\ndiff --git a/tests/annotations/tests.py b/tests/annotations/tests.py\n--- a/tests/annotations/tests.py\n+++ b/tests/annotations/tests.py\n@@ -405,6 +405,28 @@ def test_order_by_aggregate(self):\n             lambda a: (a['age'], a['age_count'])\n         )\n \n+    def test_raw_sql_with_inherited_field(self):\n+        DepartmentStore.objects.create(\n+            name='Angus & Robinson',\n+            original_opening=datetime.date(2014, 3, 8),\n+            friday_night_closing=datetime.time(21),\n+            chain='Westfield',\n+            area=123,\n+        )\n+        tests = (\n+            ('name', 'Angus & Robinson'),\n+            ('surface', 123),\n+            (\"case when name='Angus & Robinson' then chain else name end\", 'Westfield'),\n+        )\n+        for sql, expected_result in tests:\n+            with self.subTest(sql=sql):\n+                self.assertSequenceEqual(\n+                    DepartmentStore.objects.annotate(\n+                        annotation=RawSQL(sql, ()),\n+                    ).values_list('annotation', flat=True),\n+                    [expected_result],\n+                )\n+\n     def test_annotate_exists(self):\n         authors = Author.objects.annotate(c=Count('id')).filter(c__gt=1)\n         self.assertFalse(authors.exists())\n",
  "problem_statement": "QuerySet.count() does not with work raw sql annotations on inherited model fields\nDescription\n\t\nConsider these models\nclass BaseItem(models.Model):\n\ttitle = models.CharField(max_length=32)\nclass Item(BaseItem):\n\tpass\nIf I use a RawSQL annotation of Item's queryset that includes one of the fields defined in BaseItem and call .count() on annotated queryset, it fails with the error:\ndjango.db.utils.OperationalError: (1054, \"Unknown column 'title' in 'field list'\") (MySQL 5.7)\ncode to reproduce the bug with given models:\nqueryset = Item.objects.all()\nqueryset = queryset.annotate(title2=RawSQL(\"title\", ()))\nqueryset.count() # crashes\nI have tracked down what causes this bug. Query.get_aggregation method drops INNER JOIN required to select the title field. Specifically, this code drops it:\n\t\t\tif not inner_query.distinct:\n\t\t\t\t# If the inner query uses default select and it has some\n\t\t\t\t# aggregate annotations, then we must make sure the inner\n\t\t\t\t# query is grouped by the main model's primary key. However,\n\t\t\t\t# clearing the select clause can alter results if distinct is\n\t\t\t\t# used.\n\t\t\t\tif inner_query.default_cols and has_existing_annotations:\n\t\t\t\t\tinner_query.group_by = [self.model._meta.pk.get_col(inner_query.get_initial_alias())]\n\t\t\t\tinner_query.default_cols = False\nCode is taken from Django 1.8 but 1.11 looks the same.\ndefault_cols is set to False and the INNER JOIN is dropped. Quick fix is to add a condition for setting default_cols to False:\n\t\t\tif not inner_query.distinct:\n\t\t\t\t# If the inner query uses default select and it has some\n\t\t\t\t# aggregate annotations, then we must make sure the inner\n\t\t\t\t# query is grouped by the main model's primary key. However,\n\t\t\t\t# clearing the select clause can alter results if distinct is\n\t\t\t\t# used.\n\t\t\t\tif inner_query.default_cols and has_existing_annotations:\n\t\t\t\t\tinner_query.group_by = [self.model._meta.pk.get_col(inner_query.get_initial_alias())]\n\t\t\t\tif not has_existing_annotations:\n\t\t\t\t\tinner_query.default_cols = False\nI don't know if it could be done in a nicer way. I was able to reproduce this in 1.8.18 and 1.11.0\n",
  "hints_text": "I'm attaching a test for Django's test suite that I wrote quickly to reproduce this.\nHi, â€‹PR To finding the inherited columns, thought two approaches: a- try to parse the columns from raw sql with using a convert function which returns a list from sql string. (with regex pattern maybe) b- if the query contains a column that comes from the inherited model, take this field name with get_fields() - get_fields(include_parents=False) I chose b. I hoped to find a property that contains whether the model is inherited. Is this possible? Because of that, it performs every time.",
  "created_at": "2019-05-11T12:43:07Z",
  "version": "3.0",
  "FAIL_TO_PASS": "[\"test_raw_sql_with_inherited_field (annotations.tests.NonAggregateAnnotationTestCase)\"]",
  "PASS_TO_PASS": "[\"test_aggregate_over_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_annotate_exists (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_annotate_with_aggregation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_annotation_filter_with_subquery (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_annotation_in_f_grouped_by_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_annotation_reverse_m2m (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_annotation_with_m2m (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_arguments_must_be_expressions (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_basic_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_basic_f_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_boolean_value_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_chaining_annotation_filter_with_m2m (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_column_field_ordering (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_column_field_ordering_with_deferred (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_combined_annotation_commutative (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_custom_functions (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_custom_functions_can_ref_other_functions (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_decimal_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_defer_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_empty_expression_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_filter_agg_with_double_f (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_filter_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_filter_annotation_with_double_f (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_filter_annotation_with_f (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_filter_decimal_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_filter_wrong_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_joined_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_mixed_type_annotation_date_interval (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_mixed_type_annotation_numbers (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_mti_annotations (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_null_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_order_by_aggregate (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_order_by_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_update_with_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_values_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_values_with_pk_annotation (annotations.tests.NonAggregateAnnotationTestCase)\"]",
  "environment_setup_commit": "419a78300f7cd27611196e1e464d50fd0385ff27",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.569333",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}