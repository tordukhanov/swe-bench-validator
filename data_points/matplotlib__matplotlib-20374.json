{
  "repo": "matplotlib/matplotlib",
  "instance_id": "matplotlib__matplotlib-20374",
  "base_commit": "d385b2caa8fae238fafd7d2a6ba493703b100b8c",
  "patch": "diff --git a/lib/matplotlib/sphinxext/plot_directive.py b/lib/matplotlib/sphinxext/plot_directive.py\n--- a/lib/matplotlib/sphinxext/plot_directive.py\n+++ b/lib/matplotlib/sphinxext/plot_directive.py\n@@ -429,14 +429,26 @@ def filenames(self):\n         return [self.filename(fmt) for fmt in self.formats]\n \n \n-def out_of_date(original, derived):\n+def out_of_date(original, derived, includes=None):\n     \"\"\"\n-    Return whether *derived* is out-of-date relative to *original*, both of\n-    which are full file paths.\n+    Return whether *derived* is out-of-date relative to *original* or any of\n+    the RST files included in it using the RST include directive (*includes*).\n+    *derived* and *original* are full paths, and *includes* is optionally a\n+    list of full paths which may have been included in the *original*.\n     \"\"\"\n-    return (not os.path.exists(derived) or\n-            (os.path.exists(original) and\n-             os.stat(derived).st_mtime < os.stat(original).st_mtime))\n+    if not os.path.exists(derived):\n+        return True\n+\n+    if includes is None:\n+        includes = []\n+    files_to_check = [original, *includes]\n+\n+    def out_of_date_one(original, derived_mtime):\n+        return (os.path.exists(original) and\n+                derived_mtime < os.stat(original).st_mtime)\n+\n+    derived_mtime = os.stat(derived).st_mtime\n+    return any(out_of_date_one(f, derived_mtime) for f in files_to_check)\n \n \n class PlotError(RuntimeError):\n@@ -532,7 +544,8 @@ def get_plot_formats(config):\n \n def render_figures(code, code_path, output_dir, output_base, context,\n                    function_name, config, context_reset=False,\n-                   close_figs=False):\n+                   close_figs=False,\n+                   code_includes=None):\n     \"\"\"\n     Run a pyplot script and save the images in *output_dir*.\n \n@@ -549,7 +562,8 @@ def render_figures(code, code_path, output_dir, output_base, context,\n     all_exists = True\n     img = ImageFile(output_base, output_dir)\n     for format, dpi in formats:\n-        if out_of_date(code_path, img.filename(format)):\n+        if context or out_of_date(code_path, img.filename(format),\n+                                  includes=code_includes):\n             all_exists = False\n             break\n         img.formats.append(format)\n@@ -569,7 +583,8 @@ def render_figures(code, code_path, output_dir, output_base, context,\n             else:\n                 img = ImageFile('%s_%02d' % (output_base, j), output_dir)\n             for fmt, dpi in formats:\n-                if out_of_date(code_path, img.filename(fmt)):\n+                if context or out_of_date(code_path, img.filename(fmt),\n+                                          includes=code_includes):\n                     all_exists = False\n                     break\n                 img.formats.append(fmt)\n@@ -742,6 +757,25 @@ def run(arguments, content, options, state_machine, state, lineno):\n         build_dir_link = build_dir\n     source_link = dest_dir_link + '/' + output_base + source_ext\n \n+    # get list of included rst files so that the output is updated when any\n+    # plots in the included files change. These attributes are modified by the\n+    # include directive (see the docutils.parsers.rst.directives.misc module).\n+    try:\n+        source_file_includes = [os.path.join(os.getcwd(), t[0])\n+                                for t in state.document.include_log]\n+    except AttributeError:\n+        # the document.include_log attribute only exists in docutils >=0.17,\n+        # before that we need to inspect the state machine\n+        possible_sources = {os.path.join(setup.confdir, t[0])\n+                            for t in state_machine.input_lines.items}\n+        source_file_includes = [f for f in possible_sources\n+                                if os.path.isfile(f)]\n+    # remove the source file itself from the includes\n+    try:\n+        source_file_includes.remove(source_file_name)\n+    except ValueError:\n+        pass\n+\n     # make figures\n     try:\n         results = render_figures(code,\n@@ -752,7 +786,8 @@ def run(arguments, content, options, state_machine, state, lineno):\n                                  function_name,\n                                  config,\n                                  context_reset=context_opt == 'reset',\n-                                 close_figs=context_opt == 'close-figs')\n+                                 close_figs=context_opt == 'close-figs',\n+                                 code_includes=source_file_includes)\n         errors = []\n     except PlotError as err:\n         reporter = state.memo.reporter\n",
  "test_patch": "diff --git a/lib/matplotlib/tests/test_sphinxext.py b/lib/matplotlib/tests/test_sphinxext.py\n--- a/lib/matplotlib/tests/test_sphinxext.py\n+++ b/lib/matplotlib/tests/test_sphinxext.py\n@@ -3,6 +3,7 @@\n import filecmp\n import os\n from pathlib import Path\n+import shutil\n from subprocess import Popen, PIPE\n import sys\n \n@@ -13,27 +14,21 @@\n \n \n def test_tinypages(tmpdir):\n-    tmp_path = Path(tmpdir)\n-    html_dir = tmp_path / 'html'\n-    doctree_dir = tmp_path / 'doctrees'\n-    # Build the pages with warnings turned into errors\n-    cmd = [sys.executable, '-msphinx', '-W', '-b', 'html',\n-           '-d', str(doctree_dir),\n-           str(Path(__file__).parent / 'tinypages'), str(html_dir)]\n-    proc = Popen(cmd, stdout=PIPE, stderr=PIPE, universal_newlines=True,\n-                 env={**os.environ, \"MPLBACKEND\": \"\"})\n-    out, err = proc.communicate()\n+    source_dir = Path(tmpdir) / 'src'\n+    shutil.copytree(Path(__file__).parent / 'tinypages', source_dir)\n+    html_dir = source_dir / '_build' / 'html'\n+    doctree_dir = source_dir / 'doctrees'\n \n-    assert proc.returncode == 0, \\\n-        f\"sphinx build failed with stdout:\\n{out}\\nstderr:\\n{err}\\n\"\n-    if err:\n-        pytest.fail(f\"sphinx build emitted the following warnings:\\n{err}\")\n-\n-    assert html_dir.is_dir()\n+    # Build the pages with warnings turned into errors\n+    build_sphinx_html(source_dir, doctree_dir, html_dir)\n \n     def plot_file(num):\n         return html_dir / f'some_plots-{num}.png'\n \n+    def plot_directive_file(num):\n+        # This is always next to the doctree dir.\n+        return doctree_dir.parent / 'plot_directive' / f'some_plots-{num}.png'\n+\n     range_10, range_6, range_4 = [plot_file(i) for i in range(1, 4)]\n     # Plot 5 is range(6) plot\n     assert filecmp.cmp(range_6, plot_file(5))\n@@ -48,6 +43,7 @@ def plot_file(num):\n     assert filecmp.cmp(range_4, plot_file(13))\n     # Plot 14 has included source\n     html_contents = (html_dir / 'some_plots.html').read_bytes()\n+\n     assert b'# Only a comment' in html_contents\n     # check plot defined in external file.\n     assert filecmp.cmp(range_4, html_dir / 'range4.png')\n@@ -62,3 +58,45 @@ def plot_file(num):\n     assert b'plot-directive my-class my-other-class' in html_contents\n     # check that the multi-image caption is applied twice\n     assert html_contents.count(b'This caption applies to both plots.') == 2\n+    # Plot 21 is range(6) plot via an include directive. But because some of\n+    # the previous plots are repeated, the argument to plot_file() is only 17.\n+    assert filecmp.cmp(range_6, plot_file(17))\n+\n+    # Modify the included plot\n+    contents = (source_dir / 'included_plot_21.rst').read_text()\n+    contents = contents.replace('plt.plot(range(6))', 'plt.plot(range(4))')\n+    (source_dir / 'included_plot_21.rst').write_text(contents)\n+    # Build the pages again and check that the modified file was updated\n+    modification_times = [plot_directive_file(i).stat().st_mtime\n+                          for i in (1, 2, 3, 5)]\n+    build_sphinx_html(source_dir, doctree_dir, html_dir)\n+    assert filecmp.cmp(range_4, plot_file(17))\n+    # Check that the plots in the plot_directive folder weren't changed.\n+    # (plot_directive_file(1) won't be modified, but it will be copied to html/\n+    # upon compilation, so plot_file(1) will be modified)\n+    assert plot_directive_file(1).stat().st_mtime == modification_times[0]\n+    assert plot_directive_file(2).stat().st_mtime == modification_times[1]\n+    assert plot_directive_file(3).stat().st_mtime == modification_times[2]\n+    assert filecmp.cmp(range_10, plot_file(1))\n+    assert filecmp.cmp(range_6, plot_file(2))\n+    assert filecmp.cmp(range_4, plot_file(3))\n+    # Make sure that figures marked with context are re-created (but that the\n+    # contents are the same)\n+    assert plot_directive_file(5).stat().st_mtime > modification_times[3]\n+    assert filecmp.cmp(range_6, plot_file(5))\n+\n+\n+def build_sphinx_html(source_dir, doctree_dir, html_dir):\n+    # Build the pages with warnings turned into errors\n+    cmd = [sys.executable, '-msphinx', '-W', '-b', 'html',\n+           '-d', str(doctree_dir), str(source_dir), str(html_dir)]\n+    proc = Popen(cmd, stdout=PIPE, stderr=PIPE, universal_newlines=True,\n+                 env={**os.environ, \"MPLBACKEND\": \"\"})\n+    out, err = proc.communicate()\n+\n+    assert proc.returncode == 0, \\\n+        f\"sphinx build failed with stdout:\\n{out}\\nstderr:\\n{err}\\n\"\n+    if err:\n+        pytest.fail(f\"sphinx build emitted the following warnings:\\n{err}\")\n+\n+    assert html_dir.is_dir()\ndiff --git a/lib/matplotlib/tests/tinypages/included_plot_21.rst b/lib/matplotlib/tests/tinypages/included_plot_21.rst\nnew file mode 100644\n--- /dev/null\n+++ b/lib/matplotlib/tests/tinypages/included_plot_21.rst\n@@ -0,0 +1,6 @@\n+Plot 21 has length 6\n+\n+.. plot::\n+\n+    plt.plot(range(6))\n+\ndiff --git a/lib/matplotlib/tests/tinypages/some_plots.rst b/lib/matplotlib/tests/tinypages/some_plots.rst\n--- a/lib/matplotlib/tests/tinypages/some_plots.rst\n+++ b/lib/matplotlib/tests/tinypages/some_plots.rst\n@@ -166,3 +166,8 @@ scenario:\n \n    plt.figure()\n    plt.plot(range(4))\n+ \n+Plot 21 is generated via an include directive:\n+\n+.. include:: included_plot_21.rst\n+\n",
  "problem_statement": "plot_directive is confused by include directives, part 2 (context option)\n### Bug summary\r\n\r\nWhenever a file `b.rst` is included in `a.rst` via the RST `include` directive, Sphinx rebuilds the `a.html` page; but in plot_directive, `a.rst` is not considered 'out of date' (as judged by the `out_of_date()` function), because the modification time of `a.rst` was not changed.\r\n\r\nThis discrepancy is part of the reason why #17860 exists; and while working on it (at PR #20374) I discovered also that figures with the `:context:` option set will get confused. A specific example is shown below. It's quite hard to encounter in real life but it is directly relevant to matplotlib's tests as there is a very similar construct in plots 6-9 of matplotlib's `test_sphinxext.py`.\r\n\r\n### Code for reproduction\r\n\r\n**conf.py**\r\n```python\r\nextensions = ['matplotlib.sphinxext.plot_directive']\r\nexclude_patterns = ['_build']\r\n```\r\n\r\n**index.rst**\r\n```rst\r\nIndex\r\n=====\r\n\r\n.. toctree::\r\n   \r\n   a\r\n   b\r\n```\r\n\r\n**a.rst**\r\n```rst\r\nFile A\r\n======\r\n\r\nIt's important that the first plot produces an image, and also sets a variable\r\nvia ``:context:``.\r\n\r\n\r\n.. plot::\r\n   :context:\r\n\r\n   plt.plot(range(2))\r\n   a = 1  \r\n\r\nThe second plot must not use ``:context:``. It doesn't necessarily have to\r\nproduce an image. The important thing is that it must close the figure from the\r\nprevious plot, so that the third plot doesn't actually produce an image (if\r\nfigures aren't closed, then the third plot will reuse the same image from the\r\nfirst plot).\r\n\r\n.. plot::\r\n\r\n   plt.plot(range(3))\r\n\r\nThe third plot must try to use a variable previously saved in `:context:`` and\r\nmust not produce an image.\r\n\r\n\r\n.. plot::\r\n   :context:\r\n\r\n   assert a == 1\r\n\r\nLastly we include another file.\r\n\r\n.. include:: b.rst\r\n```\r\n\r\n**b.rst**\r\n```rst\r\nFile B\r\n======\r\n\r\nThis can be anything.\r\n```\r\n\r\n\r\n### Steps to reproduce\r\n\r\n1. Put the four files above in a directory and `cd` into it.\r\n2. Build the docs the first time using `sphinx-build -b html . ./_build/html`.\r\n3. Modify `b.rst` in any way.\r\n4. Build the docs again.\r\n\r\n### Actual outcome\r\n\r\nThe third plot in `a.rst` throws an error.\r\n\r\n```\r\n/Users/yongrenjie/test/rst/a.rst:21: WARNING: Exception occurred in plotting a-3\r\n from /Users/yongrenjie/test/rst/a.rst:\r\nTraceback (most recent call last):\r\n  File \"/Users/yongrenjie/progs/matplotlib/lib/matplotlib/sphinxext/plot_directive.py\", line 497, in _run_code\r\n    exec(code, ns)\r\n  File \"<string>\", line 1, in <module>\r\nNameError: name 'a' is not defined\r\n```\r\n\r\nThe reason for this, as suggested above, is because of the `out_of_date()` function. When `sphinx-build` is invoked again, Sphinx decides that both `a.rst` and `b.rst` must be recompiled. Now:\r\n\r\n - Plot 1 is not considered out of date, because the image file already exists and `a.rst` was not modified. So the code is never run and `a` is never saved to the context.\r\n - Plot 2 is there to ensure that figures are closed prior to Plot 3, so that Plot 3 never generates an image file.\r\n - Plot 3 is considered out of date, because there is no image file that corresponds to it. Thus it is run again, and doesn't see `a` in the context, hence the warning.\r\n\r\n### Expected outcome\r\n\r\nThere shouldn't be any errors.\r\n\r\nOne easy way to accomplish this is to make sure that Sphinx re-runs all code snippets which are context-dependent, whenever a file is recompiled. That is, if a plot directive has :context: on, then the code should always be considered out of date regardless of the file modification times.\r\n\r\nThis will lead to some excessive regeneration of plots whenever included files are modified. For example, in the above code, whenever `b.rst` is modified, Plots 1 and 3 will always be re-created, even if `a.rst` is untouched. But IMO this is more sensible behaviour than the current bug. It would also be in line with what happens if *any* part of `a.rst` is modified, including the text outside the plot directives: all the plots in `a.rst` would be re-created.\r\n\r\nThis doesn't change the case where neither `a.rst` nor `b.rst` are modified, because in that case Sphinx will never attempt to recompile either file and plot_directive will never be called.\n",
  "hints_text": "I should say that I'm happy to fix this in the PR I'm working on (#20374), I'm just detailing this as a separate issue for good measure!",
  "created_at": "2021-06-06T01:19:36Z",
  "version": "3.4",
  "FAIL_TO_PASS": "[\"lib/matplotlib/tests/test_sphinxext.py::test_tinypages\"]",
  "PASS_TO_PASS": "[]",
  "environment_setup_commit": "f93c0a3dcb82feed0262d758626c90d4002685f3",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.789137",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}