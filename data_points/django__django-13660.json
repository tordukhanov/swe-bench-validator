{
  "repo": "django/django",
  "instance_id": "django__django-13660",
  "base_commit": "50c3ac6fa9b7c8a94a6d1dc87edf775e3bc4d575",
  "patch": "diff --git a/django/core/management/commands/shell.py b/django/core/management/commands/shell.py\n--- a/django/core/management/commands/shell.py\n+++ b/django/core/management/commands/shell.py\n@@ -84,13 +84,13 @@ def python(self, options):\n     def handle(self, **options):\n         # Execute the command and exit.\n         if options['command']:\n-            exec(options['command'])\n+            exec(options['command'], globals())\n             return\n \n         # Execute stdin if it has anything to read and exit.\n         # Not supported on Windows due to select.select() limitations.\n         if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n-            exec(sys.stdin.read())\n+            exec(sys.stdin.read(), globals())\n             return\n \n         available_shells = [options['interface']] if options['interface'] else self.shells\n",
  "test_patch": "diff --git a/tests/shell/tests.py b/tests/shell/tests.py\n--- a/tests/shell/tests.py\n+++ b/tests/shell/tests.py\n@@ -9,6 +9,13 @@\n \n \n class ShellCommandTestCase(SimpleTestCase):\n+    script_globals = 'print(\"__name__\" in globals())'\n+    script_with_inline_function = (\n+        'import django\\n'\n+        'def f():\\n'\n+        '    print(django.__version__)\\n'\n+        'f()'\n+    )\n \n     def test_command_option(self):\n         with self.assertLogs('test', 'INFO') as cm:\n@@ -21,6 +28,16 @@ def test_command_option(self):\n             )\n         self.assertEqual(cm.records[0].getMessage(), __version__)\n \n+    def test_command_option_globals(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_globals)\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    def test_command_option_inline_function_call(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_with_inline_function)\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n     @unittest.skipIf(sys.platform == 'win32', \"Windows select() doesn't support file descriptors.\")\n     @mock.patch('django.core.management.commands.shell.select')\n     def test_stdin_read(self, select):\n@@ -30,6 +47,30 @@ def test_stdin_read(self, select):\n             call_command('shell')\n         self.assertEqual(stdout.getvalue().strip(), '100')\n \n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')  # [1]\n+    def test_stdin_read_globals(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_globals)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')  # [1]\n+    def test_stdin_read_inline_function_call(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_with_inline_function)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n     @mock.patch('django.core.management.commands.shell.select.select')  # [1]\n     @mock.patch.dict('sys.modules', {'IPython': None})\n     def test_shell_with_ipython_not_installed(self, select):\n",
  "problem_statement": "shell command crashes when passing (with -c) the python code with functions.\nDescription\n\t\nThe examples below use Python 3.7 and Django 2.2.16, but I checked that the code is the same on master and works the same in Python 3.8.\nHere's how ​python -c works:\n$ python -c <<EOF \" \nimport django\ndef f():\n\t\tprint(django.__version__)\nf()\"\nEOF\n2.2.16\nHere's how ​python -m django shell -c works (paths shortened for clarify):\n$ python -m django shell -c <<EOF \"\nimport django\ndef f():\n\t\tprint(django.__version__)\nf()\"\nEOF\nTraceback (most recent call last):\n File \"{sys.base_prefix}/lib/python3.7/runpy.py\", line 193, in _run_module_as_main\n\t\"__main__\", mod_spec)\n File \"{sys.base_prefix}/lib/python3.7/runpy.py\", line 85, in _run_code\n\texec(code, run_globals)\n File \"{sys.prefix}/lib/python3.7/site-packages/django/__main__.py\", line 9, in <module>\n\tmanagement.execute_from_command_line()\n File \"{sys.prefix}/lib/python3.7/site-packages/django/core/management/__init__.py\", line 381, in execute_from_command_line\n\tutility.execute()\n File \"{sys.prefix}/lib/python3.7/site-packages/django/core/management/__init__.py\", line 375, in execute\n\tself.fetch_command(subcommand).run_from_argv(self.argv)\n File \"{sys.prefix}/lib/python3.7/site-packages/django/core/management/base.py\", line 323, in run_from_argv\n\tself.execute(*args, **cmd_options)\n File \"{sys.prefix}/lib/python3.7/site-packages/django/core/management/base.py\", line 364, in execute\n\toutput = self.handle(*args, **options)\n File \"{sys.prefix}/lib/python3.7/site-packages/django/core/management/commands/shell.py\", line 86, in handle\n\texec(options['command'])\n File \"<string>\", line 5, in <module>\n File \"<string>\", line 4, in f\nNameError: name 'django' is not defined\nThe problem is in the ​usage of ​exec:\n\tdef handle(self, **options):\n\t\t# Execute the command and exit.\n\t\tif options['command']:\n\t\t\texec(options['command'])\n\t\t\treturn\n\t\t# Execute stdin if it has anything to read and exit.\n\t\t# Not supported on Windows due to select.select() limitations.\n\t\tif sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n\t\t\texec(sys.stdin.read())\n\t\t\treturn\nexec should be passed a dictionary containing a minimal set of globals. This can be done by just passing a new, empty dictionary as the second argument of exec.\n",
  "hints_text": "​PR includes tests and documents the new feature in the release notes (but not in the main docs since it seems more like a bug fix than a new feature to me).",
  "created_at": "2020-11-09T22:43:32Z",
  "version": "3.2",
  "FAIL_TO_PASS": "[\"test_command_option_inline_function_call (shell.tests.ShellCommandTestCase)\", \"test_stdin_read_inline_function_call (shell.tests.ShellCommandTestCase)\"]",
  "PASS_TO_PASS": "[\"test_command_option (shell.tests.ShellCommandTestCase)\", \"test_command_option_globals (shell.tests.ShellCommandTestCase)\", \"test_shell_with_bpython_not_installed (shell.tests.ShellCommandTestCase)\", \"test_shell_with_ipython_not_installed (shell.tests.ShellCommandTestCase)\", \"test_stdin_read (shell.tests.ShellCommandTestCase)\", \"test_stdin_read_globals (shell.tests.ShellCommandTestCase)\"]",
  "environment_setup_commit": "65dfb06a1ab56c238cc80f5e1c31f61210c4577d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.665232",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}