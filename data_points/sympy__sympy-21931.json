{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-21931",
  "base_commit": "8cb334cf8b0d8f9be490fecf578aca408069b671",
  "patch": "diff --git a/sympy/calculus/singularities.py b/sympy/calculus/singularities.py\n--- a/sympy/calculus/singularities.py\n+++ b/sympy/calculus/singularities.py\n@@ -73,13 +73,13 @@ def singularities(expression, symbol, domain=None):\n     >>> singularities(x**2 + x + 1, x)\n     EmptySet\n     >>> singularities(1/(x + 1), x)\n-    FiniteSet(-1)\n+    {-1}\n     >>> singularities(1/(y**2 + 1), y)\n-    FiniteSet(I, -I)\n+    {-I, I}\n     >>> singularities(1/(y**3 + 1), y)\n-    FiniteSet(-1, 1/2 - sqrt(3)*I/2, 1/2 + sqrt(3)*I/2)\n+    {-1, 1/2 - sqrt(3)*I/2, 1/2 + sqrt(3)*I/2}\n     >>> singularities(log(x), x)\n-    FiniteSet(0)\n+    {0}\n \n     \"\"\"\n     from sympy.functions.elementary.exponential import log\ndiff --git a/sympy/calculus/util.py b/sympy/calculus/util.py\n--- a/sympy/calculus/util.py\n+++ b/sympy/calculus/util.py\n@@ -735,7 +735,7 @@ def stationary_points(f, symbol, domain=S.Reals):\n               2                                2\n \n     >>> stationary_points(sin(x),x, Interval(0, 4*pi))\n-    FiniteSet(pi/2, 3*pi/2, 5*pi/2, 7*pi/2)\n+    {pi/2, 3*pi/2, 5*pi/2, 7*pi/2}\n \n     \"\"\"\n     from sympy import solveset, diff\n@@ -1492,7 +1492,7 @@ def intersection(self, other):\n         EmptySet\n \n         >>> AccumBounds(1, 4).intersection(FiniteSet(1, 2, 5))\n-        FiniteSet(1, 2)\n+        {1, 2}\n \n         \"\"\"\n         if not isinstance(other, (AccumBounds, FiniteSet)):\ndiff --git a/sympy/categories/baseclasses.py b/sympy/categories/baseclasses.py\n--- a/sympy/categories/baseclasses.py\n+++ b/sympy/categories/baseclasses.py\n@@ -522,7 +522,7 @@ def objects(self):\n         >>> B = Object(\"B\")\n         >>> K = Category(\"K\", FiniteSet(A, B))\n         >>> K.objects\n-        Class(FiniteSet(Object(\"A\"), Object(\"B\")))\n+        Class({Object(\"A\"), Object(\"B\")})\n \n         \"\"\"\n         return self.args[1]\n@@ -727,7 +727,7 @@ def __new__(cls, *args):\n         True\n         >>> d = Diagram([f, g], {g * f: \"unique\"})\n         >>> d.conclusions[g * f]\n-        FiniteSet(unique)\n+        {unique}\n \n         \"\"\"\n         premises = {}\n@@ -859,7 +859,7 @@ def objects(self):\n         >>> g = NamedMorphism(B, C, \"g\")\n         >>> d = Diagram([f, g])\n         >>> d.objects\n-        FiniteSet(Object(\"A\"), Object(\"B\"), Object(\"C\"))\n+        {Object(\"A\"), Object(\"B\"), Object(\"C\")}\n \n         \"\"\"\n         return self.args[2]\ndiff --git a/sympy/combinatorics/partitions.py b/sympy/combinatorics/partitions.py\n--- a/sympy/combinatorics/partitions.py\n+++ b/sympy/combinatorics/partitions.py\n@@ -40,7 +40,7 @@ def __new__(cls, *partition):\n         >>> from sympy.combinatorics.partitions import Partition\n         >>> a = Partition([1, 2], [3])\n         >>> a\n-        Partition(FiniteSet(1, 2), FiniteSet(3))\n+        Partition({3}, {1, 2})\n         >>> a.partition\n         [[1, 2], [3]]\n         >>> len(a)\n@@ -51,7 +51,7 @@ def __new__(cls, *partition):\n         Creating Partition from Python sets:\n \n         >>> Partition({1, 2, 3}, {4, 5})\n-        Partition(FiniteSet(1, 2, 3), FiniteSet(4, 5))\n+        Partition({4, 5}, {1, 2, 3})\n \n         Creating Partition from SymPy finite sets:\n \n@@ -59,7 +59,7 @@ def __new__(cls, *partition):\n         >>> a = FiniteSet(1, 2, 3)\n         >>> b = FiniteSet(4, 5)\n         >>> Partition(a, b)\n-        Partition(FiniteSet(1, 2, 3), FiniteSet(4, 5))\n+        Partition({4, 5}, {1, 2, 3})\n         \"\"\"\n         args = []\n         dups = False\n@@ -105,7 +105,7 @@ def sort_key(self, order=None):\n         >>> d = Partition(list(range(4)))\n         >>> l = [d, b, a + 1, a, c]\n         >>> l.sort(key=default_sort_key); l\n-        [Partition(FiniteSet(1, 2)), Partition(FiniteSet(1), FiniteSet(2)), Partition(FiniteSet(1, x)), Partition(FiniteSet(3, 4)), Partition(FiniteSet(0, 1, 2, 3))]\n+        [Partition({1, 2}), Partition({1}, {2}), Partition({1, x}), Partition({3, 4}), Partition({0, 1, 2, 3})]\n         \"\"\"\n         if order is None:\n             members = self.members\n@@ -251,7 +251,7 @@ def RGS(self):\n         >>> a.RGS\n         (0, 0, 1, 2, 2)\n         >>> a + 1\n-        Partition(FiniteSet(1, 2), FiniteSet(3), FiniteSet(4), FiniteSet(5))\n+        Partition({3}, {4}, {5}, {1, 2})\n         >>> _.RGS\n         (0, 0, 1, 2, 3)\n         \"\"\"\n@@ -282,12 +282,12 @@ def from_rgs(self, rgs, elements):\n \n         >>> from sympy.combinatorics.partitions import Partition\n         >>> Partition.from_rgs([0, 1, 2, 0, 1], list('abcde'))\n-        Partition(FiniteSet(c), FiniteSet(a, d), FiniteSet(b, e))\n+        Partition({c}, {a, d}, {b, e})\n         >>> Partition.from_rgs([0, 1, 2, 0, 1], list('cbead'))\n-        Partition(FiniteSet(e), FiniteSet(a, c), FiniteSet(b, d))\n+        Partition({e}, {a, c}, {b, d})\n         >>> a = Partition([1, 4], [2], [3, 5])\n         >>> Partition.from_rgs(a.RGS, a.members)\n-        Partition(FiniteSet(1, 4), FiniteSet(2), FiniteSet(3, 5))\n+        Partition({2}, {1, 4}, {3, 5})\n         \"\"\"\n         if len(rgs) != len(elements):\n             raise ValueError('mismatch in rgs and element lengths')\ndiff --git a/sympy/combinatorics/polyhedron.py b/sympy/combinatorics/polyhedron.py\n--- a/sympy/combinatorics/polyhedron.py\n+++ b/sympy/combinatorics/polyhedron.py\n@@ -52,9 +52,9 @@ def __new__(cls, corners, faces=[], pgroup=[]):\n \n             >>> from sympy.combinatorics.polyhedron import Polyhedron\n             >>> Polyhedron(list('abc'), [(1, 2, 0)]).faces\n-            FiniteSet((0, 1, 2))\n+            {(0, 1, 2)}\n             >>> Polyhedron(list('abc'), [(1, 0, 2)]).faces\n-            FiniteSet((0, 1, 2))\n+            {(0, 1, 2)}\n \n         The allowed transformations are entered as allowable permutations\n         of the vertices for the polyhedron. Instance of Permutations\n@@ -98,7 +98,7 @@ def __new__(cls, corners, faces=[], pgroup=[]):\n         >>> tetra.size\n         4\n         >>> tetra.edges\n-        FiniteSet((0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3))\n+        {(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)}\n         >>> tetra.corners\n         (w, x, y, z)\n \n@@ -371,7 +371,7 @@ def __new__(cls, corners, faces=[], pgroup=[]):\n \n         >>> from sympy.combinatorics.polyhedron import cube\n         >>> cube.edges\n-        FiniteSet((0, 1), (0, 3), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (3, 7), (4, 5), (4, 7), (5, 6), (6, 7))\n+        {(0, 1), (0, 3), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (3, 7), (4, 5), (4, 7), (5, 6), (6, 7)}\n \n         If you want to use letters or other names for the corners you\n         can still use the pre-calculated faces:\n@@ -498,7 +498,7 @@ def edges(self):\n         >>> corners = (a, b, c)\n         >>> faces = [(0, 1, 2)]\n         >>> Polyhedron(corners, faces).edges\n-        FiniteSet((0, 1), (0, 2), (1, 2))\n+        {(0, 1), (0, 2), (1, 2)}\n \n         \"\"\"\n         if self._edges is None:\ndiff --git a/sympy/core/function.py b/sympy/core/function.py\n--- a/sympy/core/function.py\n+++ b/sympy/core/function.py\n@@ -231,9 +231,9 @@ def nargs(self):\n         corresponding set will be returned:\n \n         >>> Function('f', nargs=1).nargs\n-        FiniteSet(1)\n+        {1}\n         >>> Function('f', nargs=(2, 1)).nargs\n-        FiniteSet(1, 2)\n+        {1, 2}\n \n         The undefined function, after application, also has the nargs\n         attribute; the actual number of arguments is always available by\n@@ -1003,7 +1003,7 @@ class WildFunction(Function, AtomicExpr):  # type: ignore\n \n     >>> F = WildFunction('F', nargs=2)\n     >>> F.nargs\n-    FiniteSet(2)\n+    {2}\n     >>> f(x).match(F)\n     >>> f(x, y).match(F)\n     {F_: f(x, y)}\n@@ -1014,7 +1014,7 @@ class WildFunction(Function, AtomicExpr):  # type: ignore\n \n     >>> F = WildFunction('F', nargs=(1, 2))\n     >>> F.nargs\n-    FiniteSet(1, 2)\n+    {1, 2}\n     >>> f(x).match(F)\n     {F_: f(x)}\n     >>> f(x, y).match(F)\ndiff --git a/sympy/logic/boolalg.py b/sympy/logic/boolalg.py\n--- a/sympy/logic/boolalg.py\n+++ b/sympy/logic/boolalg.py\n@@ -141,7 +141,7 @@ def as_set(self):\n         >>> from sympy import Symbol, Eq, Or, And\n         >>> x = Symbol('x', real=True)\n         >>> Eq(x, 0).as_set()\n-        FiniteSet(0)\n+        {0}\n         >>> (x > 0).as_set()\n         Interval.open(0, oo)\n         >>> And(-2 < x, x < 2).as_set()\ndiff --git a/sympy/printing/str.py b/sympy/printing/str.py\n--- a/sympy/printing/str.py\n+++ b/sympy/printing/str.py\n@@ -7,6 +7,7 @@\n from sympy.core import S, Rational, Pow, Basic, Mul, Number\n from sympy.core.mul import _keep_coeff\n from sympy.core.function import _coeff_isneg\n+from sympy.sets.sets import FiniteSet\n from .printer import Printer, print_function\n from sympy.printing.precedence import precedence, PRECEDENCE\n \n@@ -796,6 +797,20 @@ def _print_set(self, s):\n             return \"set()\"\n         return '{%s}' % args\n \n+    def _print_FiniteSet(self, s):\n+        items = sorted(s, key=default_sort_key)\n+\n+        args = ', '.join(self._print(item) for item in items)\n+        if any(item.has(FiniteSet) for item in items):\n+            return 'FiniteSet({})'.format(args)\n+        return '{{{}}}'.format(args)\n+\n+    def _print_Partition(self, s):\n+        items = sorted(s, key=default_sort_key)\n+\n+        args = ', '.join(self._print(arg) for arg in items)\n+        return 'Partition({})'.format(args)\n+\n     def _print_frozenset(self, s):\n         if not s:\n             return \"frozenset()\"\ndiff --git a/sympy/sets/conditionset.py b/sympy/sets/conditionset.py\n--- a/sympy/sets/conditionset.py\n+++ b/sympy/sets/conditionset.py\n@@ -60,7 +60,7 @@ class ConditionSet(Set):\n \n     >>> c = ConditionSet(x, x < 1, {x, z})\n     >>> c.subs(x, y)\n-    ConditionSet(x, x < 1, FiniteSet(y, z))\n+    ConditionSet(x, x < 1, {y, z})\n \n     To check if ``pi`` is in ``c`` use:\n \ndiff --git a/sympy/sets/fancysets.py b/sympy/sets/fancysets.py\n--- a/sympy/sets/fancysets.py\n+++ b/sympy/sets/fancysets.py\n@@ -306,7 +306,7 @@ class ImageSet(Set):\n     False\n \n     >>> FiniteSet(0, 1, 2, 3, 4, 5, 6, 7, 9, 10).intersect(squares)\n-    FiniteSet(1, 4, 9)\n+    {1, 4, 9}\n \n     >>> square_iterable = iter(squares)\n     >>> for i in range(4):\n@@ -328,7 +328,7 @@ class ImageSet(Set):\n     >>> solutions = ImageSet(Lambda(n, n*pi), S.Integers) # solutions of sin(x) = 0\n     >>> dom = Interval(-1, 1)\n     >>> dom.intersect(solutions)\n-    FiniteSet(0)\n+    {0}\n \n     See Also\n     ========\n@@ -1021,7 +1021,7 @@ def normalize_theta_set(theta):\n     >>> normalize_theta_set(Interval(-3*pi/2, -pi/2))\n     Interval(pi/2, 3*pi/2)\n     >>> normalize_theta_set(FiniteSet(0, pi, 3*pi))\n-    FiniteSet(0, pi)\n+    {0, pi}\n \n     \"\"\"\n     from sympy.functions.elementary.trigonometric import _pi_coeff as coeff\n@@ -1300,7 +1300,7 @@ def from_real(cls, sets):\n         >>> from sympy import Interval, ComplexRegion\n         >>> unit = Interval(0,1)\n         >>> ComplexRegion.from_real(unit)\n-        CartesianComplexRegion(ProductSet(Interval(0, 1), FiniteSet(0)))\n+        CartesianComplexRegion(ProductSet(Interval(0, 1), {0}))\n \n         \"\"\"\n         if not sets.is_subset(S.Reals):\ndiff --git a/sympy/sets/powerset.py b/sympy/sets/powerset.py\n--- a/sympy/sets/powerset.py\n+++ b/sympy/sets/powerset.py\n@@ -41,7 +41,7 @@ class PowerSet(Set):\n     A power set of a finite set:\n \n     >>> PowerSet(FiniteSet(1, 2, 3))\n-    PowerSet(FiniteSet(1, 2, 3))\n+    PowerSet({1, 2, 3})\n \n     A power set of an empty set:\n \n@@ -58,9 +58,7 @@ class PowerSet(Set):\n     Evaluating the power set of a finite set to its explicit form:\n \n     >>> PowerSet(FiniteSet(1, 2, 3)).rewrite(FiniteSet)\n-    FiniteSet(FiniteSet(1), FiniteSet(1, 2), FiniteSet(1, 3),\n-            FiniteSet(1, 2, 3), FiniteSet(2), FiniteSet(2, 3),\n-            FiniteSet(3), EmptySet)\n+    FiniteSet(EmptySet, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3})\n \n     References\n     ==========\ndiff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -101,7 +101,7 @@ def union(self, other):\n         >>> Interval(0, 1) + Interval(2, 3)\n         Union(Interval(0, 1), Interval(2, 3))\n         >>> Interval(1, 2, True, True) + FiniteSet(2, 3)\n-        Union(FiniteSet(3), Interval.Lopen(1, 2))\n+        Union({3}, Interval.Lopen(1, 2))\n \n         Similarly it is possible to use the '-' operator for set differences:\n \n@@ -492,7 +492,7 @@ def powerset(self):\n \n         >>> A = EmptySet\n         >>> A.powerset()\n-        FiniteSet(EmptySet)\n+        {EmptySet}\n \n         A power set of a finite set:\n \n@@ -558,9 +558,9 @@ def boundary(self):\n \n         >>> from sympy import Interval\n         >>> Interval(0, 1).boundary\n-        FiniteSet(0, 1)\n+        {0, 1}\n         >>> Interval(0, 1, True, False).boundary\n-        FiniteSet(0, 1)\n+        {0, 1}\n         \"\"\"\n         return self._boundary\n \n@@ -711,7 +711,7 @@ class ProductSet(Set):\n     >>> from sympy import Interval, FiniteSet, ProductSet\n     >>> I = Interval(0, 5); S = FiniteSet(1, 2, 3)\n     >>> ProductSet(I, S)\n-    ProductSet(Interval(0, 5), FiniteSet(1, 2, 3))\n+    ProductSet(Interval(0, 5), {1, 2, 3})\n \n     >>> (2, 2) in ProductSet(I, S)\n     True\n@@ -1546,7 +1546,7 @@ class Complement(Set):\n \n     >>> from sympy import Complement, FiniteSet\n     >>> Complement(FiniteSet(0, 1, 2), FiniteSet(1))\n-    FiniteSet(0, 2)\n+    {0, 2}\n \n     See Also\n     =========\n@@ -1748,18 +1748,18 @@ class FiniteSet(Set):\n \n     >>> from sympy import FiniteSet\n     >>> FiniteSet(1, 2, 3, 4)\n-    FiniteSet(1, 2, 3, 4)\n+    {1, 2, 3, 4}\n     >>> 3 in FiniteSet(1, 2, 3, 4)\n     True\n \n     >>> members = [1, 2, 3, 4]\n     >>> f = FiniteSet(*members)\n     >>> f\n-    FiniteSet(1, 2, 3, 4)\n+    {1, 2, 3, 4}\n     >>> f - FiniteSet(2)\n-    FiniteSet(1, 3, 4)\n+    {1, 3, 4}\n     >>> f + FiniteSet(2, 5)\n-    FiniteSet(1, 2, 3, 4, 5)\n+    {1, 2, 3, 4, 5}\n \n     References\n     ==========\n@@ -1979,7 +1979,7 @@ class SymmetricDifference(Set):\n \n     >>> from sympy import SymmetricDifference, FiniteSet\n     >>> SymmetricDifference(FiniteSet(1, 2, 3), FiniteSet(3, 4, 5))\n-    FiniteSet(1, 2, 4, 5)\n+    {1, 2, 4, 5}\n \n     See Also\n     ========\n@@ -2050,14 +2050,14 @@ class DisjointUnion(Set):\n     >>> A = FiniteSet(1, 2, 3)\n     >>> B = Interval(0, 5)\n     >>> DisjointUnion(A, B)\n-    DisjointUnion(FiniteSet(1, 2, 3), Interval(0, 5))\n+    DisjointUnion({1, 2, 3}, Interval(0, 5))\n     >>> DisjointUnion(A, B).rewrite(Union)\n-    Union(ProductSet(FiniteSet(1, 2, 3), FiniteSet(0)), ProductSet(Interval(0, 5), FiniteSet(1)))\n+    Union(ProductSet({1, 2, 3}, {0}), ProductSet(Interval(0, 5), {1}))\n     >>> C = FiniteSet(Symbol('x'), Symbol('y'), Symbol('z'))\n     >>> DisjointUnion(C, C)\n-    DisjointUnion(FiniteSet(x, y, z), FiniteSet(x, y, z))\n+    DisjointUnion({x, y, z}, {x, y, z})\n     >>> DisjointUnion(C, C).rewrite(Union)\n-    ProductSet(FiniteSet(x, y, z), FiniteSet(0, 1))\n+    ProductSet({x, y, z}, {0, 1})\n \n     References\n     ==========\ndiff --git a/sympy/solvers/inequalities.py b/sympy/solvers/inequalities.py\n--- a/sympy/solvers/inequalities.py\n+++ b/sympy/solvers/inequalities.py\n@@ -28,13 +28,13 @@ def solve_poly_inequality(poly, rel):\n     >>> from sympy.solvers.inequalities import solve_poly_inequality\n \n     >>> solve_poly_inequality(Poly(x, x, domain='ZZ'), '==')\n-    [FiniteSet(0)]\n+    [{0}]\n \n     >>> solve_poly_inequality(Poly(x**2 - 1, x, domain='ZZ'), '!=')\n     [Interval.open(-oo, -1), Interval.open(-1, 1), Interval.open(1, oo)]\n \n     >>> solve_poly_inequality(Poly(x**2 - 1, x, domain='ZZ'), '==')\n-    [FiniteSet(-1), FiniteSet(1)]\n+    [{-1}, {1}]\n \n     See Also\n     ========\n@@ -140,7 +140,7 @@ def solve_rational_inequalities(eqs):\n     >>> solve_rational_inequalities([[\n     ... ((Poly(-x + 1), Poly(1, x)), '>='),\n     ... ((Poly(-x + 1), Poly(1, x)), '<=')]])\n-    FiniteSet(1)\n+    {1}\n \n     >>> solve_rational_inequalities([[\n     ... ((Poly(x), Poly(1, x)), '!='),\ndiff --git a/sympy/solvers/solveset.py b/sympy/solvers/solveset.py\n--- a/sympy/solvers/solveset.py\n+++ b/sympy/solvers/solveset.py\n@@ -144,14 +144,14 @@ def _invert(f_x, y, x, domain=S.Complexes):\n     >>> invert_complex(exp(x), y, x)\n     (x, ImageSet(Lambda(_n, I*(2*_n*pi + arg(y)) + log(Abs(y))), Integers))\n     >>> invert_real(exp(x), y, x)\n-    (x, Intersection(FiniteSet(log(y)), Reals))\n+    (x, Intersection({log(y)}, Reals))\n \n     When does exp(x) == 1?\n \n     >>> invert_complex(exp(x), 1, x)\n     (x, ImageSet(Lambda(_n, 2*_n*I*pi), Integers))\n     >>> invert_real(exp(x), 1, x)\n-    (x, FiniteSet(0))\n+    (x, {0})\n \n     See Also\n     ========\n@@ -914,7 +914,7 @@ def solve_decomposition(f, symbol, domain):\n     >>> x = Symbol('x')\n     >>> f1 = exp(2*x) - 3*exp(x) + 2\n     >>> sd(f1, x, S.Reals)\n-    FiniteSet(0, log(2))\n+    {0, log(2)}\n     >>> f2 = sin(x)**2 + 2*sin(x) + 1\n     >>> pprint(sd(f2, x, S.Reals), use_unicode=False)\n               3*pi\n@@ -1492,11 +1492,11 @@ def _solve_exponential(lhs, rhs, symbol, domain):\n     >>> solve_expo(2**x + 3**x - 5**x, 0, x, S.Reals)  # not solvable\n     ConditionSet(x, Eq(2**x + 3**x - 5**x, 0), Reals)\n     >>> solve_expo(a**x - b**x, 0, x, S.Reals)  # solvable but incorrect assumptions\n-    ConditionSet(x, (a > 0) & (b > 0), FiniteSet(0))\n+    ConditionSet(x, (a > 0) & (b > 0), {0})\n     >>> solve_expo(3**(2*x) - 2**(x + 3), 0, x, S.Reals)\n-    FiniteSet(-3*log(2)/(-2*log(3) + log(2)))\n+    {-3*log(2)/(-2*log(3) + log(2))}\n     >>> solve_expo(2**x - 4**x, 0, x, S.Reals)\n-    FiniteSet(0)\n+    {0}\n \n     * Proof of correctness of the method\n \n@@ -1654,7 +1654,7 @@ def _solve_logarithm(lhs, rhs, symbol, domain):\n     >>> x = symbols('x')\n     >>> f = log(x - 3) + log(x + 3)\n     >>> solve_log(f, 0, x, S.Reals)\n-    FiniteSet(sqrt(10), -sqrt(10))\n+    {-sqrt(10), sqrt(10)}\n \n     * Proof of correctness\n \n@@ -1900,7 +1900,7 @@ def _transolve(f, symbol, domain):\n     >>> from sympy import symbols, S, pprint\n     >>> x = symbols('x', real=True) # assumption added\n     >>> transolve(5**(x - 3) - 3**(2*x + 1), x, S.Reals)\n-    FiniteSet(-(log(3) + 3*log(5))/(-log(5) + 2*log(3)))\n+    {-(log(3) + 3*log(5))/(-log(5) + 2*log(3))}\n \n     How ``_transolve`` works\n     ========================\n@@ -2142,9 +2142,9 @@ def solveset(f, symbol=None, domain=S.Complexes):\n     >>> R = S.Reals\n     >>> x = Symbol('x')\n     >>> solveset(exp(x) - 1, x, R)\n-    FiniteSet(0)\n+    {0}\n     >>> solveset_real(exp(x) - 1, x)\n-    FiniteSet(0)\n+    {0}\n \n     The solution is unaffected by assumptions on the symbol:\n \n@@ -2673,7 +2673,7 @@ def linsolve(system, *symbols):\n     [6],\n     [9]])\n     >>> linsolve((A, b), [x, y, z])\n-    FiniteSet((-1, 2, 0))\n+    {(-1, 2, 0)}\n \n     * Parametric Solution: In case the system is underdetermined, the\n       function will return a parametric solution in terms of the given\n@@ -2684,20 +2684,20 @@ def linsolve(system, *symbols):\n     >>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n     >>> b = Matrix([3, 6, 9])\n     >>> linsolve((A, b), x, y, z)\n-    FiniteSet((z - 1, 2 - 2*z, z))\n+    {(z - 1, 2 - 2*z, z)}\n \n     If no symbols are given, internally generated symbols will be used.\n     The `tau0` in the 3rd position indicates (as before) that the 3rd\n     variable -- whatever it's named -- can take on any value:\n \n     >>> linsolve((A, b))\n-    FiniteSet((tau0 - 1, 2 - 2*tau0, tau0))\n+    {(tau0 - 1, 2 - 2*tau0, tau0)}\n \n     * List of Equations as input\n \n     >>> Eqns = [3*x + 2*y - z - 1, 2*x - 2*y + 4*z + 2, - x + y/2 - z]\n     >>> linsolve(Eqns, x, y, z)\n-    FiniteSet((1, -2, -2))\n+    {(1, -2, -2)}\n \n     * Augmented Matrix as input\n \n@@ -2708,21 +2708,21 @@ def linsolve(system, *symbols):\n     [2, 6,  8, 3],\n     [6, 8, 18, 5]])\n     >>> linsolve(aug, x, y, z)\n-    FiniteSet((3/10, 2/5, 0))\n+    {(3/10, 2/5, 0)}\n \n     * Solve for symbolic coefficients\n \n     >>> a, b, c, d, e, f = symbols('a, b, c, d, e, f')\n     >>> eqns = [a*x + b*y - c, d*x + e*y - f]\n     >>> linsolve(eqns, x, y)\n-    FiniteSet(((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d)))\n+    {((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d))}\n \n     * A degenerate system returns solution as set of given\n       symbols.\n \n     >>> system = Matrix(([0, 0, 0], [0, 0, 0], [0, 0, 0]))\n     >>> linsolve(system, x, y)\n-    FiniteSet((x, y))\n+    {(x, y)}\n \n     * For an empty system linsolve returns empty set\n \n@@ -2733,7 +2733,7 @@ def linsolve(system, *symbols):\n       is detected:\n \n     >>> linsolve([x*(1/x - 1), (y - 1)**2 - y**2 + 1], x, y)\n-    FiniteSet((1, 1))\n+    {(1, 1)}\n     >>> linsolve([x**2 - 1], x)\n     Traceback (most recent call last):\n     ...\n@@ -2906,33 +2906,33 @@ def substitution(system, symbols, result=[{}], known_symbols=[],\n     >>> x, y = symbols('x, y', real=True)\n     >>> from sympy.solvers.solveset import substitution\n     >>> substitution([x + y], [x], [{y: 1}], [y], set([]), [x, y])\n-    FiniteSet((-1, 1))\n+    {(-1, 1)}\n \n     * when you want soln should not satisfy eq `x + 1 = 0`\n \n     >>> substitution([x + y], [x], [{y: 1}], [y], set([x + 1]), [y, x])\n     EmptySet\n     >>> substitution([x + y], [x], [{y: 1}], [y], set([x - 1]), [y, x])\n-    FiniteSet((1, -1))\n+    {(1, -1)}\n     >>> substitution([x + y - 1, y - x**2 + 5], [x, y])\n-    FiniteSet((-3, 4), (2, -1))\n+    {(-3, 4), (2, -1)}\n \n     * Returns both real and complex solution\n \n     >>> x, y, z = symbols('x, y, z')\n     >>> from sympy import exp, sin\n     >>> substitution([exp(x) - sin(y), y**2 - 4], [x, y])\n-    FiniteSet((ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2),\n-            (ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2))\n+    {(ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2),\n+     (ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2)}\n \n     >>> eqs = [z**2 + exp(2*x) - sin(y), -3 + exp(-y)]\n     >>> substitution(eqs, [y, z])\n-    FiniteSet((-log(3), sqrt(-exp(2*x) - sin(log(3)))),\n-    (-log(3), -sqrt(-exp(2*x) - sin(log(3)))),\n-    (ImageSet(Lambda(_n, 2*_n*I*pi - log(3)), Integers),\n-       ImageSet(Lambda(_n, sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers)),\n-    (ImageSet(Lambda(_n, 2*_n*I*pi - log(3)), Integers),\n-       ImageSet(Lambda(_n, -sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers)))\n+    {(-log(3), -sqrt(-exp(2*x) - sin(log(3)))),\n+     (-log(3), sqrt(-exp(2*x) - sin(log(3)))),\n+     (ImageSet(Lambda(_n, 2*_n*I*pi - log(3)), Integers),\n+      ImageSet(Lambda(_n, -sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers)),\n+     (ImageSet(Lambda(_n, 2*_n*I*pi - log(3)), Integers),\n+      ImageSet(Lambda(_n, sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers))}\n \n     \"\"\"\n \n@@ -3527,7 +3527,7 @@ def nonlinsolve(system, *symbols):\n     >>> from sympy.solvers.solveset import nonlinsolve\n     >>> x, y, z = symbols('x, y, z', real=True)\n     >>> nonlinsolve([x*y - 1, 4*x**2 + y**2 - 5], [x, y])\n-    FiniteSet((-1, -1), (-1/2, -2), (1/2, 2), (1, 1))\n+    {(-1, -1), (-1/2, -2), (1/2, 2), (1, 1)}\n \n     1. Positive dimensional system and complements:\n \n@@ -3546,7 +3546,7 @@ def nonlinsolve(system, *symbols):\n     {(---, -d, -, {d} \\ {0}), (-, -d, ---, {d} \\ {0})}\n        d       d               d       d\n     >>> nonlinsolve([(x+y)**2 - 4, x + y - 2], [x, y])\n-    FiniteSet((2 - y, y))\n+    {(2 - y, y)}\n \n     2. If some of the equations are non-polynomial then `nonlinsolve`\n     will call the `substitution` function and return real and complex solutions,\n@@ -3554,9 +3554,8 @@ def nonlinsolve(system, *symbols):\n \n     >>> from sympy import exp, sin\n     >>> nonlinsolve([exp(x) - sin(y), y**2 - 4], [x, y])\n-    FiniteSet((ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2),\n-            (ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2))\n-\n+    {(ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2),\n+     (ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2)}\n \n     3. If system is non-linear polynomial and zero-dimensional then it\n     returns both solution (real and complex solutions, if present) using\n@@ -3564,7 +3563,7 @@ def nonlinsolve(system, *symbols):\n \n     >>> from sympy import sqrt\n     >>> nonlinsolve([x**2 - 2*y**2 -2, x*y - 2], [x, y])\n-    FiniteSet((-2, -1), (2, 1), (-sqrt(2)*I, sqrt(2)*I), (sqrt(2)*I, -sqrt(2)*I))\n+    {(-2, -1), (2, 1), (-sqrt(2)*I, sqrt(2)*I), (sqrt(2)*I, -sqrt(2)*I)}\n \n     4. `nonlinsolve` can solve some linear (zero or positive dimensional)\n     system (because it uses the `groebner` function to get the\n@@ -3573,7 +3572,7 @@ def nonlinsolve(system, *symbols):\n     `nonlinsolve`, because `linsolve` is better for general linear systems.\n \n     >>> nonlinsolve([x + 2*y -z - 3, x - y - 4*z + 9 , y + z - 4], [x, y, z])\n-    FiniteSet((3*z - 5, 4 - z, z))\n+    {(3*z - 5, 4 - z, z)}\n \n     5. System having polynomial equations and only real solution is\n     solved using `solve_poly_system`:\n@@ -3581,11 +3580,11 @@ def nonlinsolve(system, *symbols):\n     >>> e1 = sqrt(x**2 + y**2) - 10\n     >>> e2 = sqrt(y**2 + (-x + 10)**2) - 3\n     >>> nonlinsolve((e1, e2), (x, y))\n-    FiniteSet((191/20, -3*sqrt(391)/20), (191/20, 3*sqrt(391)/20))\n+    {(191/20, -3*sqrt(391)/20), (191/20, 3*sqrt(391)/20)}\n     >>> nonlinsolve([x**2 + 2/y - 2, x + y - 3], [x, y])\n-    FiniteSet((1, 2), (1 - sqrt(5), 2 + sqrt(5)), (1 + sqrt(5), 2 - sqrt(5)))\n+    {(1, 2), (1 - sqrt(5), 2 + sqrt(5)), (1 + sqrt(5), 2 - sqrt(5))}\n     >>> nonlinsolve([x**2 + 2/y - 2, x + y - 3], [y, x])\n-    FiniteSet((2, 1), (2 - sqrt(5), 1 + sqrt(5)), (2 + sqrt(5), 1 - sqrt(5)))\n+    {(2, 1), (2 - sqrt(5), 1 + sqrt(5)), (2 + sqrt(5), 1 - sqrt(5))}\n \n     6. It is better to use symbols instead of Trigonometric Function or\n     Function (e.g. replace `sin(x)` with symbol, replace `f(x)` with symbol\ndiff --git a/sympy/stats/rv_interface.py b/sympy/stats/rv_interface.py\n--- a/sympy/stats/rv_interface.py\n+++ b/sympy/stats/rv_interface.py\n@@ -411,10 +411,10 @@ def median(X, evaluate=True, **kwargs):\n     >>> from sympy.stats import Normal, Die, median\n     >>> N = Normal('N', 3, 1)\n     >>> median(N)\n-    FiniteSet(3)\n+    {3}\n     >>> D = Die('D')\n     >>> median(D)\n-    FiniteSet(3, 4)\n+    {3, 4}\n \n     References\n     ==========\ndiff --git a/sympy/stats/stochastic_process_types.py b/sympy/stats/stochastic_process_types.py\n--- a/sympy/stats/stochastic_process_types.py\n+++ b/sympy/stats/stochastic_process_types.py\n@@ -816,7 +816,7 @@ class DiscreteMarkovChain(DiscreteTimeStochasticProcess, MarkovProcess):\n     >>> YS = DiscreteMarkovChain(\"Y\")\n \n     >>> Y.state_space\n-    FiniteSet(0, 1, 2)\n+    {0, 1, 2}\n     >>> Y.transition_probabilities\n     Matrix([\n     [0.5, 0.2, 0.3],\n@@ -1489,7 +1489,7 @@ class ContinuousMarkovChain(ContinuousTimeStochasticProcess, MarkovProcess):\n     >>> C.limiting_distribution()\n     Matrix([[1/2, 1/2]])\n     >>> C.state_space\n-    FiniteSet(0, 1)\n+    {0, 1}\n     >>> C.generator_matrix\n     Matrix([\n     [-1,  1],\n@@ -1613,7 +1613,7 @@ class BernoulliProcess(DiscreteTimeStochasticProcess):\n     >>> from sympy import Eq, Gt\n     >>> B = BernoulliProcess(\"B\", p=0.7, success=1, failure=0)\n     >>> B.state_space\n-    FiniteSet(0, 1)\n+    {0, 1}\n     >>> (B.p).round(2)\n     0.70\n     >>> B.success\ndiff --git a/sympy/vector/implicitregion.py b/sympy/vector/implicitregion.py\n--- a/sympy/vector/implicitregion.py\n+++ b/sympy/vector/implicitregion.py\n@@ -36,7 +36,7 @@ class ImplicitRegion(Basic):\n     >>> r.variables\n     (x, y, z)\n     >>> r.singular_points()\n-    FiniteSet((0, 0, 0))\n+    {(0, 0, 0)}\n     >>> r.regular_point()\n     (-10, -10, 200)\n \n@@ -288,7 +288,7 @@ def singular_points(self):\n         >>> from sympy.vector import ImplicitRegion\n         >>> I = ImplicitRegion((x, y), (y-1)**2 -x**3 + 2*x**2 -x)\n         >>> I.singular_points()\n-        FiniteSet((1, 1))\n+        {(1, 1)}\n \n         \"\"\"\n         eq_list = [self.equation]\n@@ -311,7 +311,7 @@ def multiplicity(self, point):\n         >>> from sympy.vector import ImplicitRegion\n         >>> I = ImplicitRegion((x, y, z), x**2 + y**3 - z**4)\n         >>> I.singular_points()\n-        FiniteSet((0, 0, 0))\n+        {(0, 0, 0)}\n         >>> I.multiplicity((0, 0, 0))\n         2\n \n",
  "test_patch": "diff --git a/sympy/printing/tests/test_str.py b/sympy/printing/tests/test_str.py\n--- a/sympy/printing/tests/test_str.py\n+++ b/sympy/printing/tests/test_str.py\n@@ -5,7 +5,8 @@\n     symbols, Wild, WildFunction, zeta, zoo, Dummy, Dict, Tuple, FiniteSet, factor,\n     subfactorial, true, false, Equivalent, Xor, Complement, SymmetricDifference,\n     AccumBounds, UnevaluatedExpr, Eq, Ne, Quaternion, Subs, MatrixSymbol, MatrixSlice,\n-    Q)\n+    Q,)\n+from sympy.combinatorics.partitions import Partition\n from sympy.core import Expr, Mul\n from sympy.core.parameters import _exp_is_pow\n from sympy.external import import_module\n@@ -892,13 +893,19 @@ def test_RandomDomain():\n \n def test_FiniteSet():\n     assert str(FiniteSet(*range(1, 51))) == (\n-        'FiniteSet(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,'\n+        '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,'\n         ' 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,'\n-        ' 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50)'\n+        ' 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50}'\n     )\n-    assert str(FiniteSet(*range(1, 6))) == 'FiniteSet(1, 2, 3, 4, 5)'\n+    assert str(FiniteSet(*range(1, 6))) == '{1, 2, 3, 4, 5}'\n+    assert str(FiniteSet(*[x*y, x**2])) == '{x**2, x*y}'\n+    assert str(FiniteSet(FiniteSet(FiniteSet(x, y), 5), FiniteSet(x,y), 5)\n+               ) == 'FiniteSet(5, FiniteSet(5, {x, y}), {x, y})'\n \n \n+def test_Partition():\n+    assert str(Partition(FiniteSet(x, y), {z})) == 'Partition({z}, {x, y})'\n+\n def test_UniversalSet():\n     assert str(S.UniversalSet) == 'UniversalSet'\n \n@@ -1066,6 +1073,11 @@ def test_issue_14567():\n     assert factorial(Sum(-1, (x, 0, 0))) + y  # doesn't raise an error\n \n \n+def test_issue_21823():\n+    assert str(Partition([1, 2])) == 'Partition({1, 2})'\n+    assert str(Partition({1, 2})) == 'Partition({1, 2})'\n+\n+\n def test_issue_21119_21460():\n     ss = lambda x: str(S(x, evaluate=False))\n     assert ss('4/2') == '4/2'\n",
  "problem_statement": "nicer printing of Permutation (and others)\nPerhaps Partition's args print with FiniteSet because the args were made to be SymPy types. But the printing need not be so verbose. \r\n\r\n```python\r\n>>> Partition([1,2])\r\nPartition(FiniteSet(1, 2))\r\n>>> Partition({1,2})\r\nPartition(FiniteSet(1, 2))\r\n```\r\nPrinting of its (and other combinatoric funcs as pertinent) args can be done with lists, tuples or sets as community preferences dictate, e.g. `Partition([1,2])` or `Partition({1,2})`, the latter more suggestive that the parts of the Partition are subsets of the set from which they were taken.\nnicer printing of Permutation (and others)\nPerhaps Partition's args print with FiniteSet because the args were made to be SymPy types. But the printing need not be so verbose. \r\n\r\n```python\r\n>>> Partition([1,2])\r\nPartition(FiniteSet(1, 2))\r\n>>> Partition({1,2})\r\nPartition(FiniteSet(1, 2))\r\n```\r\nPrinting of its (and other combinatoric funcs as pertinent) args can be done with lists, tuples or sets as community preferences dictate, e.g. `Partition([1,2])` or `Partition({1,2})`, the latter more suggestive that the parts of the Partition are subsets of the set from which they were taken.\n",
  "hints_text": "Is it really necessary for FiniteSet to ever print as \"FiniteSet\" instead of using \"{...}\" with the str printer? The latter will create a Python set, which will be converted to a SymPy object when mixed with other SymPy operations. It's no different from printing numbers as `1` instead of `Integer(1)`.\nIs it really necessary for FiniteSet to ever print as \"FiniteSet\" instead of using \"{...}\" with the str printer? The latter will create a Python set, which will be converted to a SymPy object when mixed with other SymPy operations. It's no different from printing numbers as `1` instead of `Integer(1)`.",
  "created_at": "2021-08-23T08:02:01Z",
  "version": "1.9",
  "FAIL_TO_PASS": "[\"test_FiniteSet\", \"test_Partition\", \"test_issue_21823\"]",
  "PASS_TO_PASS": "[\"test_printmethod\", \"test_Abs\", \"test_Add\", \"test_Catalan\", \"test_ComplexInfinity\", \"test_Derivative\", \"test_dict\", \"test_Dict\", \"test_Dummy\", \"test_EulerGamma\", \"test_Exp\", \"test_factorial\", \"test_Function\", \"test_Geometry\", \"test_GoldenRatio\", \"test_TribonacciConstant\", \"test_ImaginaryUnit\", \"test_Infinity\", \"test_Integer\", \"test_Integral\", \"test_Interval\", \"test_AccumBounds\", \"test_Lambda\", \"test_Limit\", \"test_list\", \"test_Matrix_str\", \"test_Mul\", \"test_NaN\", \"test_NegativeInfinity\", \"test_Order\", \"test_Permutation_Cycle\", \"test_Pi\", \"test_Poly\", \"test_PolyRing\", \"test_FracField\", \"test_PolyElement\", \"test_FracElement\", \"test_GaussianInteger\", \"test_GaussianRational\", \"test_Pow\", \"test_sqrt\", \"test_Rational\", \"test_Float\", \"test_Relational\", \"test_AppliedBinaryRelation\", \"test_CRootOf\", \"test_RootSum\", \"test_GroebnerBasis\", \"test_set\", \"test_SparseMatrix\", \"test_Sum\", \"test_Symbol\", \"test_tuple\", \"test_Series_str\", \"test_MIMOSeries_str\", \"test_TransferFunction_str\", \"test_Parallel_str\", \"test_MIMOParallel_str\", \"test_Feedback_str\", \"test_MIMOFeedback_str\", \"test_TransferFunctionMatrix_str\", \"test_Quaternion_str_printer\", \"test_Quantity_str\", \"test_wild_str\", \"test_wild_matchpy\", \"test_zeta\", \"test_issue_3101\", \"test_issue_3103\", \"test_issue_4021\", \"test_sstrrepr\", \"test_infinity\", \"test_full_prec\", \"test_noncommutative\", \"test_empty_printer\", \"test_settings\", \"test_RandomDomain\", \"test_UniversalSet\", \"test_PrettyPoly\", \"test_categories\", \"test_Tr\", \"test_issue_6387\", \"test_MatMul_MatAdd\", \"test_MatrixSlice\", \"test_true_false\", \"test_Equivalent\", \"test_Xor\", \"test_Complement\", \"test_SymmetricDifference\", \"test_UnevaluatedExpr\", \"test_MatrixElement_printing\", \"test_MatrixSymbol_printing\", \"test_MatrixExpressions\", \"test_Subs_printing\", \"test_issue_15716\", \"test_str_special_matrices\", \"test_issue_14567\", \"test_issue_21119_21460\", \"test_Str\", \"test_diffgeom\", \"test_NDimArray\", \"test_Predicate\", \"test_AppliedPredicate\"]",
  "environment_setup_commit": "f9a6f50ec0c74d935c50a6e9c9b2cb0469570d91",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.147707",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}