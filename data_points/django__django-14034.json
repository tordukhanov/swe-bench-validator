{
  "repo": "django/django",
  "instance_id": "django__django-14034",
  "base_commit": "db1fc5cd3c5d36cdb5d0fe4404efd6623dd3e8fb",
  "patch": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -2,7 +2,7 @@\n \n from django.core.exceptions import ValidationError\n from django.forms.utils import flatatt, pretty_name\n-from django.forms.widgets import Textarea, TextInput\n+from django.forms.widgets import MultiWidget, Textarea, TextInput\n from django.utils.functional import cached_property\n from django.utils.html import conditional_escape, format_html, html_safe\n from django.utils.safestring import mark_safe\n@@ -233,7 +233,17 @@ def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\n         attrs = dict(attrs)  # Copy attrs to avoid modifying the argument.\n         if widget.use_required_attribute(self.initial) and self.field.required and self.form.use_required_attribute:\n-            attrs['required'] = True\n+            # MultiValueField has require_all_fields: if False, fall back\n+            # on subfields.\n+            if (\n+                hasattr(self.field, 'require_all_fields') and\n+                not self.field.require_all_fields and\n+                isinstance(self.field.widget, MultiWidget)\n+            ):\n+                for subfield, subwidget in zip(self.field.fields, widget.widgets):\n+                    subwidget.attrs['required'] = subwidget.use_required_attribute(self.initial) and subfield.required\n+            else:\n+                attrs['required'] = True\n         if self.field.disabled:\n             attrs['disabled'] = True\n         return attrs\n",
  "test_patch": "diff --git a/tests/forms_tests/field_tests/test_multivaluefield.py b/tests/forms_tests/field_tests/test_multivaluefield.py\n--- a/tests/forms_tests/field_tests/test_multivaluefield.py\n+++ b/tests/forms_tests/field_tests/test_multivaluefield.py\n@@ -10,6 +10,20 @@\n beatles = (('J', 'John'), ('P', 'Paul'), ('G', 'George'), ('R', 'Ringo'))\n \n \n+class PartiallyRequiredField(MultiValueField):\n+    def compress(self, data_list):\n+        return ','.join(data_list) if data_list else None\n+\n+\n+class PartiallyRequiredForm(Form):\n+    f = PartiallyRequiredField(\n+        fields=(CharField(required=True), CharField(required=False)),\n+        required=True,\n+        require_all_fields=False,\n+        widget=MultiWidget(widgets=[TextInput(), TextInput()]),\n+    )\n+\n+\n class ComplexMultiWidget(MultiWidget):\n     def __init__(self, attrs=None):\n         widgets = (\n@@ -172,3 +186,11 @@ def test_form_cleaned_data(self):\n         })\n         form.is_valid()\n         self.assertEqual(form.cleaned_data['field1'], 'some text,JP,2007-04-25 06:24:00')\n+\n+    def test_render_required_attributes(self):\n+        form = PartiallyRequiredForm({'f_0': 'Hello', 'f_1': ''})\n+        self.assertTrue(form.is_valid())\n+        self.assertInHTML('<input type=\"text\" name=\"f_0\" value=\"Hello\" required id=\"id_f_0\">', form.as_p())\n+        self.assertInHTML('<input type=\"text\" name=\"f_1\" id=\"id_f_1\">', form.as_p())\n+        form = PartiallyRequiredForm({'f_0': '', 'f_1': ''})\n+        self.assertFalse(form.is_valid())\n",
  "problem_statement": "MultiValueField ignores a required value of a sub field\nDescription\n\t \n\t\t(last modified by Takayuki Hirai)\n\t \nA field and a form definition:\nfrom django.forms import (\n\tForm,\n\tCharField,\n\tMultiValueField,\n\tMultiWidget,\n)\nclass MF(MultiValueField):\n\twidget = MultiWidget\n\tdef __init__(self):\n\t\tfields = [\n\t\t\tCharField(required=False),\n\t\t\tCharField(required=True),\n\t\t]\n\t\twidget = self.widget(widgets=[\n\t\t\tf.widget\n\t\t\tfor f in fields\n\t\t], attrs={})\n\t\tsuper(MF, self).__init__(\n\t\t\tfields=fields,\n\t\t\twidget=widget,\n\t\t\trequire_all_fields=False,\n\t\t\trequired=False,\n\t\t)\n\tdef compress(self, value):\n\t\treturn []\nclass F(Form):\n\tmf = MF()\nWhen the form is passed empty values for both sub fields, form.is_valid() == True.\nBut I expected is_valid() returns False, because one of the sub fields is set as required.\nf = F({\n\t'mf_0': '',\n\t'mf_1': '',\n})\nassert f.is_valid() == True # I expect this should return False\nOn the other hand, When one of its sub field is passed a non-empty value, form.is_valid() == False\nf = F({\n\t'mf_0': 'xxx',\n\t'mf_1': '',\n})\nassert f.is_valid() == Flase\nIf above behavior is not expected, please fix this problem.\n",
  "hints_text": "Why do you pass required=False in super(MF, self).__init__()? Removing that seems to resolve the issue.\nI tried to remove required=False, then both INPUT elements in HTML became required. <tr><th><label for=\"id_mf_0\">Mf:</label></th><td><input type=\"text\" name=\"mf_0\" required id=\"id_mf_0\" /> <input type=\"text\" name=\"mf_1\" required id=\"id_mf_1\" /></td></tr> Code: class MW(MultiWidget): def decompress(self, value): return [] class MF(MultiValueField): widget = MW def __init__(self): fields = [ CharField(required=False), CharField(required=True), ] widget = self.widget(widgets=[ f.widget for f in fields ], attrs={}) super(MF, self).__init__( fields=fields, widget=widget, require_all_fields=False, ) def compress(self, value): return []\nIf this is indeed an incorrect behavior (I'm not certain that there isn't some other way to achieve the use case), it might be that Bound.build_widget_attrs() incorrectly adds the required attribute for this case. I'm not sure what a fix would look like.\nI also bumped into this a while back during a project and promptly forgot about it. In my case I fixed it by overrriding render on the widget like so: def render(self, name, value, attrs=None): if self.is_localized: for widget in self.widgets: widget.is_localized = self.is_localized if not isinstance(value, list): value = self.decompress(value) output = [] final_attrs = self.build_attrs(attrs) id_ = final_attrs.get(\"id\") for i, widget in enumerate(self.widgets): try: widget_value = value[i] except IndexError: widget_value = None if id_: final_attrs = dict(final_attrs, id=\"%s_%s\" % (id_, i)) final_attrs[\"required\"] = widget.is_required # ADDED output.append(widget.render(name + \"_%s\" % i, widget_value, final_attrs)) return mark_safe(self.format_output(output)) Whether that is optimal however I doubt. As mentioned above seems like you'd need to fix it by descending into the build_attrs logic itself.\nPossible culprit? ​https://github.com/django/django/blob/b9cf764be62e77b4777b3a75ec256f6209a57671/django/forms/boundfield.py#L221 Does this method also need to account for the require_all_fields value on MultiValueField?\nAdding something like this certainly does cause some failures in test cases where the required string has been disappeared from the emitted HTML from MultiValueField tests. Looking into further isolating some better cases. def build_widget_attrs(self, attrs, widget=None): widget = widget or self.field.widget attrs = dict(attrs) # Copy attrs to avoid modifying the argument. if widget.use_required_attribute(self.initial) and self.field.required and self.form.use_required_attribute: if hasattr(self.field, 'require_all_fields'): if not widget.is_required and not self.field.require_all_fields: attrs['required'] = False else: attrs['required'] = True if self.field.disabled: attrs['disabled'] = True return attrs\nNope this was a red herring, seeing some other things though, will report... Replying to jhrr: Adding something like this certainly does cause some failures in test cases where the required string has been disappeared from the emitted HTML from MultiValueField tests. Looking into further isolating some better cases. def build_widget_attrs(self, attrs, widget=None): widget = widget or self.field.widget attrs = dict(attrs) # Copy attrs to avoid modifying the argument. if widget.use_required_attribute(self.initial) and self.field.required and self.form.use_required_attribute: if hasattr(self.field, 'require_all_fields'): if not widget.is_required and not self.field.require_all_fields: attrs['required'] = False else: attrs['required'] = True if self.field.disabled: attrs['disabled'] = True return attrs\nI've done some investigation into this. Here are some notes which explain the behaviour outlined in the ticket. is_valid() The ​clean method of MultiValueField is driving the validation behaviour explained in the original ticket. The example in the ticket shows required=False being set on the MultiValueField. When the fields are all blank (or two empty strings) the logic follows this if statement and therefore doesn't raise a validation error and return self.compress([]) if not value or isinstance(value, (list, tuple)): if not value or not [v for v in value if v not in self.empty_values]: if self.required: raise ValidationError(self.error_messages['required'], code='required') else: return self.compress([]) In the case where one of the fields has some data, it skips this if statement. The next section of clean loops over fields and therefore raises an error as one of them contains required=True Required attribute The notes above also explain that is the field is required=True (default setting) then whilst is_valid() gives the expected output both of the fields input html tags both become required. This is due to this piece of code in ​boundfield.py. This code looks at the field required status rather than subwidgets. Therefore all of the inputs for subwidgets are treated the same, irrespective of each subwidgets required attribute. I therefore think that the two areas above are where we should be looking at for a potential fix. However, I'm not quite sure what is intended to happen where some widgets are required and others are not. Some questions, appreciate thoughts. Should inputs have required html attributes (all, some, none) How should the help / validation text work. (e.g. 'this field is required')\nHi David, good work. I'll hazard an opinion. Required should work at two levels, rather than overriding from the parent. Required on the MWF should mean \"Can this set of sub-fields be skipped entirely?\". Assuming No to that, i.e. that the MWF is required, then the individual fields should respect their own required attributes. I imagine a Date + Time MWF where the Time is optional. (🤷‍♀️) In the limit, a required MWF with all optional sub-fields would be required in name only. That would be my first stab at the correct behaviour. It would be interesting to see what the existing tests say about that.\nI am experiencing this issue with the 2.2.10 LTS release too: class RowSelectorField(forms.fields.MultiValueField): def __init__(self, *args, **kwargs): choices = kwargs.pop('choice') fields = [forms.fields.ChoiceField(), forms.fields.IntegerField(required=False)] super(RowSelectorField, self).__init__(require_all_fields=False, fields=fields, *args, **kwargs) self.widget = RowSelectorWidget(choices=choices) def compress(self, values): return values all of the fields in HTML are set to required, even the integer field. I have noticed if I change the super call to: super(RowSelectorField, self).__init__(required=False, require_all_fields=False, fields=fields, *args, **kwargs) and in the MultiWidget I use: class RowSelectorWidget(forms.widgets.MultiWidget): def __init__(self, choices, attrs=None): choices.append((len(choices), _('custom'))) widgets = [forms.RadioSelect(choices=choices, attrs={'required': True}), forms.NumberInput(attrs={'required': False})] super(RowSelectorWidget, self).__init__(widgets, attrs) I do get the correct expected behaviour.\nHi Leon, thanks for your message. In your last example where you experience your expected behaviour both required and require_all_fields are set to false on the MVF. In this case I'd expect form.is_valid() to return True where none of the fields are completed even though the ChoiceField() is required. Is this the case and is this what you would expect to happen?\nGreetings, all. I think we need to take a step back. A form with every subfield empty on an optional MVF should pass validation, and it does, and there is a test in the suite for it. (The implication in the body of the ticket is not quite right.) So I suggest the linked patch avoid making changes to validation. The reporter wanted the field to be required in reality but didn't want to let required=True on the MVF because it made every subfield have the HTML required attribute. I suggest renaming the ticket to focus on this specific piece. I suggest we only handle what solves the reporter's use case: when the MVF is required but require_all_fields=False set the required attribute on the widget based on the subfield.\nHi all, I agree with Jacob. This doesn't seem to be an issue about whether a MVF is semantically valid or required - it's about a specific behavior which we can't currently achieve, at least not while using MVF. The docs state: When [require_all_fields] set to False, the Field.required attribute can be set to False for individual fields to make them optional. If no value is supplied for a required field, an incomplete validation error will be raised. But setting required=True on MVF level ignores the required attribute on subfields regarding the HTML attribute which in turn comes from the widget attrs.\nDavid's ​PR",
  "created_at": "2021-02-22T19:32:50Z",
  "version": "4.0",
  "FAIL_TO_PASS": "[\"test_render_required_attributes (forms_tests.field_tests.test_multivaluefield.MultiValueFieldTest)\"]",
  "PASS_TO_PASS": "[\"test_bad_choice (forms_tests.field_tests.test_multivaluefield.MultiValueFieldTest)\", \"test_clean (forms_tests.field_tests.test_multivaluefield.MultiValueFieldTest)\", \"test_clean_disabled_multivalue (forms_tests.field_tests.test_multivaluefield.MultiValueFieldTest)\", \"test_disabled_has_changed (forms_tests.field_tests.test_multivaluefield.MultiValueFieldTest)\", \"test_form_as_table (forms_tests.field_tests.test_multivaluefield.MultiValueFieldTest)\", \"test_form_as_table_data (forms_tests.field_tests.test_multivaluefield.MultiValueFieldTest)\", \"test_form_cleaned_data (forms_tests.field_tests.test_multivaluefield.MultiValueFieldTest)\", \"Test when the first widget's data has changed.\", \"Test when the last widget's data has changed. This ensures that it is\", \"test_has_changed_no_initial (forms_tests.field_tests.test_multivaluefield.MultiValueFieldTest)\", \"test_has_changed_same (forms_tests.field_tests.test_multivaluefield.MultiValueFieldTest)\", \"If insufficient data is provided, None is substituted.\"]",
  "environment_setup_commit": "475cffd1d64c690cdad16ede4d5e81985738ceb4",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.679113",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}