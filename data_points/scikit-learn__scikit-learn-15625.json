{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-15625",
  "base_commit": "e650a207efc9dd33556b1b9678b043f73a18aecb",
  "patch": "diff --git a/sklearn/metrics/_classification.py b/sklearn/metrics/_classification.py\n--- a/sklearn/metrics/_classification.py\n+++ b/sklearn/metrics/_classification.py\n@@ -193,8 +193,9 @@ def accuracy_score(y_true, y_pred, normalize=True, sample_weight=None):\n     return _weighted_sum(score, sample_weight, normalize)\n \n \n-def confusion_matrix(y_true, y_pred, labels=None, sample_weight=None):\n-    \"\"\"Compute confusion matrix to evaluate the accuracy of a classification\n+def confusion_matrix(y_true, y_pred, labels=None, sample_weight=None,\n+                     normalize=None):\n+    \"\"\"Compute confusion matrix to evaluate the accuracy of a classification.\n \n     By definition a confusion matrix :math:`C` is such that :math:`C_{i, j}`\n     is equal to the number of observations known to be in group :math:`i` and\n@@ -208,25 +209,30 @@ def confusion_matrix(y_true, y_pred, labels=None, sample_weight=None):\n \n     Parameters\n     ----------\n-    y_true : array, shape = [n_samples]\n+    y_true : array-like of shape (n_samples,)\n         Ground truth (correct) target values.\n \n-    y_pred : array, shape = [n_samples]\n+    y_pred : array-like of shape (n_samples,)\n         Estimated targets as returned by a classifier.\n \n-    labels : array, shape = [n_classes], optional\n+    labels : array-like of shape (n_classes), default=None\n         List of labels to index the matrix. This may be used to reorder\n         or select a subset of labels.\n-        If none is given, those that appear at least once\n+        If ``None`` is given, those that appear at least once\n         in ``y_true`` or ``y_pred`` are used in sorted order.\n \n     sample_weight : array-like of shape (n_samples,), default=None\n         Sample weights.\n \n+    normalize : {'true', 'pred', 'all'}, default=None\n+        Normalizes confusion matrix over the true (rows), predicted (columns)\n+        conditions or all the population. If None, confusion matrix will not be\n+        normalized.\n+\n     Returns\n     -------\n     C : ndarray of shape (n_classes, n_classes)\n-        Confusion matrix\n+        Confusion matrix.\n \n     References\n     ----------\n@@ -296,11 +302,20 @@ def confusion_matrix(y_true, y_pred, labels=None, sample_weight=None):\n     else:\n         dtype = np.float64\n \n-    CM = coo_matrix((sample_weight, (y_true, y_pred)),\n+    cm = coo_matrix((sample_weight, (y_true, y_pred)),\n                     shape=(n_labels, n_labels), dtype=dtype,\n                     ).toarray()\n \n-    return CM\n+    with np.errstate(all='ignore'):\n+        if normalize == 'true':\n+            cm = cm / cm.sum(axis=1, keepdims=True)\n+        elif normalize == 'pred':\n+            cm = cm / cm.sum(axis=0, keepdims=True)\n+        elif normalize == 'all':\n+            cm = cm / cm.sum()\n+        cm = np.nan_to_num(cm)\n+\n+    return cm\n \n \n def multilabel_confusion_matrix(y_true, y_pred, sample_weight=None,\ndiff --git a/sklearn/metrics/_plot/confusion_matrix.py b/sklearn/metrics/_plot/confusion_matrix.py\n--- a/sklearn/metrics/_plot/confusion_matrix.py\n+++ b/sklearn/metrics/_plot/confusion_matrix.py\n@@ -155,7 +155,7 @@ def plot_confusion_matrix(estimator, X, y_true, sample_weight=None,\n         Includes values in confusion matrix.\n \n     normalize : {'true', 'pred', 'all'}, default=None\n-        Normalizes confusion matrix over the true (rows), predicited (columns)\n+        Normalizes confusion matrix over the true (rows), predicted (columns)\n         conditions or all the population. If None, confusion matrix will not be\n         normalized.\n \n@@ -190,14 +190,7 @@ def plot_confusion_matrix(estimator, X, y_true, sample_weight=None,\n \n     y_pred = estimator.predict(X)\n     cm = confusion_matrix(y_true, y_pred, sample_weight=sample_weight,\n-                          labels=labels)\n-\n-    if normalize == 'true':\n-        cm = cm / cm.sum(axis=1, keepdims=True)\n-    elif normalize == 'pred':\n-        cm = cm / cm.sum(axis=0, keepdims=True)\n-    elif normalize == 'all':\n-        cm = cm / cm.sum()\n+                          labels=labels, normalize=normalize)\n \n     if display_labels is None:\n         if labels is None:\n",
  "test_patch": "diff --git a/sklearn/metrics/tests/test_classification.py b/sklearn/metrics/tests/test_classification.py\n--- a/sklearn/metrics/tests/test_classification.py\n+++ b/sklearn/metrics/tests/test_classification.py\n@@ -1,6 +1,8 @@\n \n from functools import partial\n from itertools import product\n+from itertools import chain\n+from itertools import permutations\n import warnings\n import re\n \n@@ -17,6 +19,7 @@\n from sklearn.utils._testing import assert_almost_equal\n from sklearn.utils._testing import assert_array_equal\n from sklearn.utils._testing import assert_array_almost_equal\n+from sklearn.utils._testing import assert_allclose\n from sklearn.utils._testing import assert_warns\n from sklearn.utils._testing import assert_warns_div0\n from sklearn.utils._testing import assert_no_warnings\n@@ -509,6 +512,39 @@ def test_multilabel_confusion_matrix_errors():\n                                     [[1, 2, 0], [1, 0, 2]])\n \n \n+@pytest.mark.parametrize(\n+    \"normalize, cm_dtype, expected_results\",\n+    [('true', 'f', 0.333333333),\n+     ('pred', 'f', 0.333333333),\n+     ('all', 'f', 0.1111111111),\n+     (None, 'i', 2)]\n+)\n+def test_confusion_matrix_normalize(normalize, cm_dtype, expected_results):\n+    y_test = [0, 1, 2] * 6\n+    y_pred = list(chain(*permutations([0, 1, 2])))\n+    cm = confusion_matrix(y_test, y_pred, normalize=normalize)\n+    assert_allclose(cm, expected_results)\n+    assert cm.dtype.kind == cm_dtype\n+\n+\n+def test_confusion_matrix_normalize_single_class():\n+    y_test = [0, 0, 0, 0, 1, 1, 1, 1]\n+    y_pred = [0, 0, 0, 0, 0, 0, 0, 0]\n+\n+    cm_true = confusion_matrix(y_test, y_pred, normalize='true')\n+    assert cm_true.sum() == pytest.approx(2.0)\n+\n+    # additionally check that no warnings are raised due to a division by zero\n+    with pytest.warns(None) as rec:\n+        cm_pred = confusion_matrix(y_test, y_pred, normalize='pred')\n+    assert not rec\n+    assert cm_pred.sum() == pytest.approx(1.0)\n+\n+    with pytest.warns(None) as rec:\n+        cm_pred = confusion_matrix(y_pred, y_test, normalize='true')\n+    assert not rec\n+\n+\n def test_cohen_kappa():\n     # These label vectors reproduce the contingency matrix from Artstein and\n     # Poesio (2008), Table 1: np.array([[20, 20], [10, 50]]).\n",
  "problem_statement": "ENH: add normalize parameter to metrics.classification.confusion_matrix\nAllows to get a normalized confusion matrix directly from the function\r\ncall. I use `confusion_matrix` frequently and find the need to always\r\nnormalize the matrix manually maybe unnecessary.\r\n\r\nI am aware of the fact that other functions like `accuracy_score` already\r\nhave this exact functionality implemented, so probably the lack of the\r\n`normalize` parameter is intentional and I'm missing the why. But in case\r\nits not intentional you might find this contribution useful :).\r\n\n",
  "hints_text": "I'm okay with giving options. I think calling it precision/recall/accuracy\nis a bit misleading since they don't pertain off the diagonal of the\nmatrix. true vs pred might be better names. It's still not entirely clear\nto me that providing this facility is of great benefit to users.\n\nWith your proposal, you also need to implement tests to ensure that the function will work properly.",
  "created_at": "2019-11-14T16:30:49Z",
  "version": "0.22",
  "FAIL_TO_PASS": "[\"sklearn/metrics/tests/test_classification.py::test_confusion_matrix_normalize[true-f-0.333333333]\", \"sklearn/metrics/tests/test_classification.py::test_confusion_matrix_normalize[pred-f-0.333333333]\", \"sklearn/metrics/tests/test_classification.py::test_confusion_matrix_normalize[all-f-0.1111111111]\", \"sklearn/metrics/tests/test_classification.py::test_confusion_matrix_normalize[None-i-2]\", \"sklearn/metrics/tests/test_classification.py::test_confusion_matrix_normalize_single_class\"]",
  "PASS_TO_PASS": "[\"sklearn/metrics/tests/test_classification.py::test_classification_report_dictionary_output\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_accuracy_score_subset_accuracy\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_score_binary\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f_binary_single_class\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f_extra_labels\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f_ignored_labels\", \"sklearn/metrics/tests/test_classification.py::test_average_precision_score_score_non_binary_class\", \"sklearn/metrics/tests/test_classification.py::test_average_precision_score_duplicate_values\", \"sklearn/metrics/tests/test_classification.py::test_average_precision_score_tied_values\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_fscore_support_errors\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f_unused_pos_label\", \"sklearn/metrics/tests/test_classification.py::test_confusion_matrix_binary\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_confusion_matrix_binary\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_confusion_matrix_multiclass\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_confusion_matrix_multilabel\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_confusion_matrix_errors\", \"sklearn/metrics/tests/test_classification.py::test_cohen_kappa\", \"sklearn/metrics/tests/test_classification.py::test_matthews_corrcoef_nan\", \"sklearn/metrics/tests/test_classification.py::test_matthews_corrcoef_against_numpy_corrcoef\", \"sklearn/metrics/tests/test_classification.py::test_matthews_corrcoef_against_jurman\", \"sklearn/metrics/tests/test_classification.py::test_matthews_corrcoef\", \"sklearn/metrics/tests/test_classification.py::test_matthews_corrcoef_multiclass\", \"sklearn/metrics/tests/test_classification.py::test_matthews_corrcoef_overflow[100]\", \"sklearn/metrics/tests/test_classification.py::test_matthews_corrcoef_overflow[10000]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_score_multiclass\", \"sklearn/metrics/tests/test_classification.py::test_precision_refcall_f1_score_multilabel_unordered_labels[samples]\", \"sklearn/metrics/tests/test_classification.py::test_precision_refcall_f1_score_multilabel_unordered_labels[micro]\", \"sklearn/metrics/tests/test_classification.py::test_precision_refcall_f1_score_multilabel_unordered_labels[macro]\", \"sklearn/metrics/tests/test_classification.py::test_precision_refcall_f1_score_multilabel_unordered_labels[weighted]\", \"sklearn/metrics/tests/test_classification.py::test_precision_refcall_f1_score_multilabel_unordered_labels[None]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_score_binary_averaged\", \"sklearn/metrics/tests/test_classification.py::test_zero_precision_recall\", \"sklearn/metrics/tests/test_classification.py::test_confusion_matrix_multiclass_subset_labels\", \"sklearn/metrics/tests/test_classification.py::test_confusion_matrix_dtype\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_multiclass\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_multiclass_balanced\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_multiclass_with_label_detection\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_multiclass_with_digits\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_multiclass_with_string_label\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_multiclass_with_unicode_label\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_multiclass_with_long_string_label\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_labels_target_names_unequal_length\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_no_labels_target_names_unequal_length\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_classification_report\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_zero_one_loss_subset\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_hamming_loss\", \"sklearn/metrics/tests/test_classification.py::test_jaccard_score_validation\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_jaccard_score\", \"sklearn/metrics/tests/test_classification.py::test_multiclass_jaccard_score\", \"sklearn/metrics/tests/test_classification.py::test_average_binary_jaccard_score\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_score_multilabel_1\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_score_multilabel_2\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_score_with_an_empty_prediction[warn]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_score_with_an_empty_prediction[0]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_score_with_an_empty_prediction[1]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels[0-macro-1]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels[0-micro-1]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels[0-weighted-1]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels[0-samples-1]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels[1-macro-1]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels[1-micro-1]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels[1-weighted-1]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels[1-samples-1]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels_check_warnings[macro]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels_check_warnings[micro]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels_check_warnings[weighted]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels_check_warnings[samples]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels_average_none[0]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels_average_none[1]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels_average_none_warn\", \"sklearn/metrics/tests/test_classification.py::test_prf_warnings\", \"sklearn/metrics/tests/test_classification.py::test_prf_no_warnings_if_zero_division_set[0]\", \"sklearn/metrics/tests/test_classification.py::test_prf_no_warnings_if_zero_division_set[1]\", \"sklearn/metrics/tests/test_classification.py::test_recall_warnings[warn]\", \"sklearn/metrics/tests/test_classification.py::test_recall_warnings[0]\", \"sklearn/metrics/tests/test_classification.py::test_recall_warnings[1]\", \"sklearn/metrics/tests/test_classification.py::test_precision_warnings[warn]\", \"sklearn/metrics/tests/test_classification.py::test_precision_warnings[0]\", \"sklearn/metrics/tests/test_classification.py::test_precision_warnings[1]\", \"sklearn/metrics/tests/test_classification.py::test_fscore_warnings[warn]\", \"sklearn/metrics/tests/test_classification.py::test_fscore_warnings[0]\", \"sklearn/metrics/tests/test_classification.py::test_fscore_warnings[1]\", \"sklearn/metrics/tests/test_classification.py::test_prf_average_binary_data_non_binary\", \"sklearn/metrics/tests/test_classification.py::test__check_targets\", \"sklearn/metrics/tests/test_classification.py::test__check_targets_multiclass_with_both_y_true_and_y_pred_binary\", \"sklearn/metrics/tests/test_classification.py::test_hinge_loss_binary\", \"sklearn/metrics/tests/test_classification.py::test_hinge_loss_multiclass\", \"sklearn/metrics/tests/test_classification.py::test_hinge_loss_multiclass_missing_labels_with_labels_none\", \"sklearn/metrics/tests/test_classification.py::test_hinge_loss_multiclass_with_missing_labels\", \"sklearn/metrics/tests/test_classification.py::test_hinge_loss_multiclass_invariance_lists\", \"sklearn/metrics/tests/test_classification.py::test_log_loss\", \"sklearn/metrics/tests/test_classification.py::test_log_loss_pandas_input\", \"sklearn/metrics/tests/test_classification.py::test_brier_score_loss\", \"sklearn/metrics/tests/test_classification.py::test_balanced_accuracy_score_unseen\", \"sklearn/metrics/tests/test_classification.py::test_balanced_accuracy_score[y_true0-y_pred0]\", \"sklearn/metrics/tests/test_classification.py::test_balanced_accuracy_score[y_true1-y_pred1]\", \"sklearn/metrics/tests/test_classification.py::test_balanced_accuracy_score[y_true2-y_pred2]\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_jaccard_similarity_score_deprecation\"]",
  "environment_setup_commit": "7e85a6d1f038bbb932b36f18d75df6be937ed00d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.013961",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}