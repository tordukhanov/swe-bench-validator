{
  "repo": "django/django",
  "instance_id": "django__django-16411",
  "base_commit": "75500feecddcb27b6ab65c9057e7317024cef761",
  "patch": "diff --git a/django/contrib/staticfiles/storage.py b/django/contrib/staticfiles/storage.py\n--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -439,7 +439,7 @@ def stored_name(self, name):\n \n \n class ManifestFilesMixin(HashedFilesMixin):\n-    manifest_version = \"1.0\"  # the manifest format standard\n+    manifest_version = \"1.1\"  # the manifest format standard\n     manifest_name = \"staticfiles.json\"\n     manifest_strict = True\n     keep_intermediate_files = False\n@@ -449,7 +449,7 @@ def __init__(self, *args, manifest_storage=None, **kwargs):\n         if manifest_storage is None:\n             manifest_storage = self\n         self.manifest_storage = manifest_storage\n-        self.hashed_files = self.load_manifest()\n+        self.hashed_files, self.manifest_hash = self.load_manifest()\n \n     def read_manifest(self):\n         try:\n@@ -461,15 +461,15 @@ def read_manifest(self):\n     def load_manifest(self):\n         content = self.read_manifest()\n         if content is None:\n-            return {}\n+            return {}, \"\"\n         try:\n             stored = json.loads(content)\n         except json.JSONDecodeError:\n             pass\n         else:\n             version = stored.get(\"version\")\n-            if version == \"1.0\":\n-                return stored.get(\"paths\", {})\n+            if version in (\"1.0\", \"1.1\"):\n+                return stored.get(\"paths\", {}), stored.get(\"hash\", \"\")\n         raise ValueError(\n             \"Couldn't load manifest '%s' (version %s)\"\n             % (self.manifest_name, self.manifest_version)\n@@ -482,7 +482,14 @@ def post_process(self, *args, **kwargs):\n             self.save_manifest()\n \n     def save_manifest(self):\n-        payload = {\"paths\": self.hashed_files, \"version\": self.manifest_version}\n+        self.manifest_hash = self.file_hash(\n+            None, ContentFile(json.dumps(sorted(self.hashed_files.items())).encode())\n+        )\n+        payload = {\n+            \"paths\": self.hashed_files,\n+            \"version\": self.manifest_version,\n+            \"hash\": self.manifest_hash,\n+        }\n         if self.manifest_storage.exists(self.manifest_name):\n             self.manifest_storage.delete(self.manifest_name)\n         contents = json.dumps(payload).encode()\n",
  "test_patch": "diff --git a/tests/staticfiles_tests/project/documents/staticfiles_v1.json b/tests/staticfiles_tests/project/documents/staticfiles_v1.json\nnew file mode 100644\n--- /dev/null\n+++ b/tests/staticfiles_tests/project/documents/staticfiles_v1.json\n@@ -0,0 +1,6 @@\n+{\n+  \"version\": \"1.0\",\n+  \"paths\": {\n+    \"dummy.txt\": \"dummy.txt\"\n+  }\n+}\ndiff --git a/tests/staticfiles_tests/test_storage.py b/tests/staticfiles_tests/test_storage.py\n--- a/tests/staticfiles_tests/test_storage.py\n+++ b/tests/staticfiles_tests/test_storage.py\n@@ -436,7 +436,7 @@ def assertPostCondition(self):\n         # The in-memory version of the manifest matches the one on disk\n         # since a properly created manifest should cover all filenames.\n         if hashed_files:\n-            manifest = storage.staticfiles_storage.load_manifest()\n+            manifest, _ = storage.staticfiles_storage.load_manifest()\n             self.assertEqual(hashed_files, manifest)\n \n     def test_manifest_exists(self):\n@@ -463,7 +463,7 @@ def test_loaded_cache(self):\n \n     def test_parse_cache(self):\n         hashed_files = storage.staticfiles_storage.hashed_files\n-        manifest = storage.staticfiles_storage.load_manifest()\n+        manifest, _ = storage.staticfiles_storage.load_manifest()\n         self.assertEqual(hashed_files, manifest)\n \n     def test_clear_empties_manifest(self):\n@@ -476,7 +476,7 @@ def test_clear_empties_manifest(self):\n         hashed_files = storage.staticfiles_storage.hashed_files\n         self.assertIn(cleared_file_name, hashed_files)\n \n-        manifest_content = storage.staticfiles_storage.load_manifest()\n+        manifest_content, _ = storage.staticfiles_storage.load_manifest()\n         self.assertIn(cleared_file_name, manifest_content)\n \n         original_path = storage.staticfiles_storage.path(cleared_file_name)\n@@ -491,7 +491,7 @@ def test_clear_empties_manifest(self):\n         hashed_files = storage.staticfiles_storage.hashed_files\n         self.assertNotIn(cleared_file_name, hashed_files)\n \n-        manifest_content = storage.staticfiles_storage.load_manifest()\n+        manifest_content, _ = storage.staticfiles_storage.load_manifest()\n         self.assertNotIn(cleared_file_name, manifest_content)\n \n     def test_missing_entry(self):\n@@ -535,6 +535,29 @@ def test_intermediate_files(self):\n             2,\n         )\n \n+    def test_manifest_hash(self):\n+        # Collect the additional file.\n+        self.run_collectstatic()\n+\n+        _, manifest_hash_orig = storage.staticfiles_storage.load_manifest()\n+        self.assertNotEqual(manifest_hash_orig, \"\")\n+        self.assertEqual(storage.staticfiles_storage.manifest_hash, manifest_hash_orig)\n+        # Saving doesn't change the hash.\n+        storage.staticfiles_storage.save_manifest()\n+        self.assertEqual(storage.staticfiles_storage.manifest_hash, manifest_hash_orig)\n+        # Delete the original file from the app, collect with clear.\n+        os.unlink(self._clear_filename)\n+        self.run_collectstatic(clear=True)\n+        # Hash is changed.\n+        _, manifest_hash = storage.staticfiles_storage.load_manifest()\n+        self.assertNotEqual(manifest_hash, manifest_hash_orig)\n+\n+    def test_manifest_hash_v1(self):\n+        storage.staticfiles_storage.manifest_name = \"staticfiles_v1.json\"\n+        manifest_content, manifest_hash = storage.staticfiles_storage.load_manifest()\n+        self.assertEqual(manifest_hash, \"\")\n+        self.assertEqual(manifest_content, {\"dummy.txt\": \"dummy.txt\"})\n+\n \n @override_settings(STATICFILES_STORAGE=\"staticfiles_tests.storage.NoneHashStorage\")\n class TestCollectionNoneHashStorage(CollectionTestCase):\n",
  "problem_statement": "ManifestStaticFilesStorage should expose a \"hash\" of the manifest file.\nDescription\n\t\nIt would be great if ManifestFilesMixin could expose a manifest_hash that changes whenever *anything* in the manifest itself changes. This would allow SPAs (or applications enhanced with htmx/unpoly etc) to send along a header in responses ala X-Asset-Hash and allow them to perform a full reload if the header changes.\nI'll be opening a PR for discussion soon.\n",
  "hints_text": "",
  "created_at": "2022-12-29T16:26:31Z",
  "version": "4.2",
  "FAIL_TO_PASS": "[\"test_aggregating_modules (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_clear_empties_manifest (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_css_import_case_insensitive (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_css_source_map (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_css_source_map_sensitive (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_css_source_map_tabs (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"See #18050\", \"test_js_source_map (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_js_source_map_sensitive (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_js_source_map_trailing_whitespace (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_manifest_hash (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_manifest_hash_v1 (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_module_import (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_parse_cache (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_path_ignored_completely (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_path_with_fragment (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_path_with_querystring (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_path_with_querystring_and_fragment (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"post_processing behaves correctly.\", \"test_template_tag_absolute (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"Like test_template_tag_absolute, but for a file in STATIC_ROOT (#26249).\", \"test_template_tag_deep_relative (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_template_tag_relative (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_template_tag_return (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_template_tag_simple_content (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_template_tag_url (staticfiles_tests.test_storage.TestCollectionManifestStorage)\"]",
  "PASS_TO_PASS": "[\"test_read_manifest (staticfiles_tests.test_storage.TestCustomManifestStorage)\", \"test_read_manifest_nonexistent (staticfiles_tests.test_storage.TestCustomManifestStorage)\", \"test_save_manifest_create (staticfiles_tests.test_storage.TestCustomManifestStorage)\", \"test_save_manifest_override (staticfiles_tests.test_storage.TestCustomManifestStorage)\", \"test_hashed_name (staticfiles_tests.test_storage.TestCollectionNoneHashStorage)\", \"test_collectstatistic_no_post_process_replaced_paths (staticfiles_tests.test_storage.TestCollectionNoPostProcessReplacedPaths)\", \"test_collect_static_files_default_permissions (staticfiles_tests.test_storage.TestStaticFilePermissions)\", \"test_collect_static_files_permissions (staticfiles_tests.test_storage.TestStaticFilePermissions)\", \"test_collect_static_files_subclass_of_static_storage (staticfiles_tests.test_storage.TestStaticFilePermissions)\", \"With storage classes having several file extension patterns, only the\", \"test_template_tag_return (staticfiles_tests.test_storage.TestCollectionSimpleStorage)\", \"test_template_tag_simple_content (staticfiles_tests.test_storage.TestCollectionSimpleStorage)\", \"test_file_change_after_collectstatic (staticfiles_tests.test_storage.TestCollectionHashedFilesCache)\", \"test_import_loop (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_intermediate_files (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_loaded_cache (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_manifest_does_not_exist (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_manifest_does_not_ignore_permission_error (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_manifest_exists (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"test_missing_entry (staticfiles_tests.test_storage.TestCollectionManifestStorage)\", \"post_processing indicates the origin of the error when it fails.\"]",
  "environment_setup_commit": "0fbdb9784da915fce5dcc1fe82bac9b4785749e5",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.757957",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}