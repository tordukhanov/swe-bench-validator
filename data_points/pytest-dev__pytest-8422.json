{
  "repo": "pytest-dev/pytest",
  "instance_id": "pytest-dev__pytest-8422",
  "base_commit": "32ad70dea8fe2978e5f6025070278cc3796f4e47",
  "patch": "diff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py\n--- a/src/_pytest/python_api.py\n+++ b/src/_pytest/python_api.py\n@@ -72,6 +72,8 @@ def __ne__(self, actual) -> bool:\n         return not (actual == self)\n \n     def _approx_scalar(self, x) -> \"ApproxScalar\":\n+        if isinstance(x, Decimal):\n+            return ApproxDecimal(x, rel=self.rel, abs=self.abs, nan_ok=self.nan_ok)\n         return ApproxScalar(x, rel=self.rel, abs=self.abs, nan_ok=self.nan_ok)\n \n     def _yield_comparisons(self, actual):\n",
  "test_patch": "diff --git a/testing/python/approx.py b/testing/python/approx.py\n--- a/testing/python/approx.py\n+++ b/testing/python/approx.py\n@@ -313,6 +313,12 @@ def test_list(self):\n         assert approx(expected, rel=5e-7, abs=0) == actual\n         assert approx(expected, rel=5e-8, abs=0) != actual\n \n+    def test_list_decimal(self):\n+        actual = [Decimal(\"1.000001\"), Decimal(\"2.000001\")]\n+        expected = [Decimal(\"1\"), Decimal(\"2\")]\n+\n+        assert actual == approx(expected)\n+\n     def test_list_wrong_len(self):\n         assert [1, 2] != approx([1])\n         assert [1, 2] != approx([1, 2, 3])\n@@ -346,6 +352,14 @@ def test_dict(self):\n         assert approx(expected, rel=5e-7, abs=0) == actual\n         assert approx(expected, rel=5e-8, abs=0) != actual\n \n+    def test_dict_decimal(self):\n+        actual = {\"a\": Decimal(\"1.000001\"), \"b\": Decimal(\"2.000001\")}\n+        # Dictionaries became ordered in python3.6, so switch up the order here\n+        # to make sure it doesn't matter.\n+        expected = {\"b\": Decimal(\"2\"), \"a\": Decimal(\"1\")}\n+\n+        assert actual == approx(expected)\n+\n     def test_dict_wrong_len(self):\n         assert {\"a\": 1, \"b\": 2} != approx({\"a\": 1})\n         assert {\"a\": 1, \"b\": 2} != approx({\"a\": 1, \"c\": 2})\n",
  "problem_statement": "approx: Better handle Decimal in sequences and mappings\n<!--\r\nThanks for suggesting a feature!\r\n\r\nQuick check-list while suggesting features:\r\n-->\r\n\r\n#### What's the problem this feature will solve?\r\n\r\nRight now `approx` handles Decimal comparisons gracefully, thanks to https://github.com/pytest-dev/pytest/issues/3247. We can do this:\r\n```python\r\nclass TestApprox:\r\n    ...\r\n\r\n    def test_decimal(self):\r\n        within_1e6 = [\r\n            (Decimal(\"1.000001\"), Decimal(\"1.0\")),\r\n            (Decimal(\"-1.000001\"), Decimal(\"-1.0\")),\r\n        ]\r\n        for a, x in within_1e6:\r\n            assert a == approx(x)\r\n```\r\n\r\n`approx` also knows how to handle sequences and mappings:\r\n```python\r\nclass TestApprox:\r\n    ...\r\n\r\n    def test_list(self):\r\n        actual = [1 + 1e-7, 2 + 1e-8]\r\n        expected = [1, 2]\r\n\r\n        # Return false if any element is outside the tolerance.\r\n        assert actual == approx(expected, rel=5e-7, abs=0)\r\n        assert actual != approx(expected, rel=5e-8, abs=0)\r\n        assert approx(expected, rel=5e-7, abs=0) == actual\r\n        assert approx(expected, rel=5e-8, abs=0) != actual\r\n\r\n    ...\r\n\r\n    def test_dict(self):\r\n        actual = {\"a\": 1 + 1e-7, \"b\": 2 + 1e-8}\r\n        # Dictionaries became ordered in python3.6, so switch up the order here\r\n        # to make sure it doesn't matter.\r\n        expected = {\"b\": 2, \"a\": 1}\r\n\r\n        # Return false if any element is outside the tolerance.\r\n        assert actual == approx(expected, rel=5e-7, abs=0)\r\n        assert actual != approx(expected, rel=5e-8, abs=0)\r\n        assert approx(expected, rel=5e-7, abs=0) == actual\r\n        assert approx(expected, rel=5e-8, abs=0) != actual\r\n```\r\n\r\n`approx` doesn't handle Decimal within sequences and mappings:\r\n```python\r\nclass TestApprox:\r\n    ...\r\n\r\n    def test_list_decimal(self):\r\n        actual = [Decimal(\"1.000001\"), Decimal(\"2.000001\")]\r\n        expected = [Decimal(\"1\"), Decimal(\"2\")]\r\n\r\n        assert actual == approx(expected)\r\n\r\n    ...\r\n\r\n    def test_dict_decimal(self):\r\n        actual = {\"a\": Decimal(\"1.000001\"), \"b\": Decimal(\"2.000001\")}\r\n        # Dictionaries became ordered in python3.6, so switch up the order here\r\n        # to make sure it doesn't matter.\r\n        expected = {\"b\": Decimal(\"2\"), \"a\": Decimal(\"1\")}\r\n\r\n        assert actual == approx(expected)\r\n```\r\n\r\nBoth of these tests fail with `TypeError: unsupported operand type(s) for *: 'float' and 'decimal.Decimal'`\r\n\r\n#### Describe the solution you'd like\r\n<!-- A clear and concise description of what you want to happen. -->\r\n\r\nI would like these kind of tests to be passing :) A linked PR should be following shortly :eyes: \r\n\r\n<!-- Provide examples of real-world use cases that this would enable and how it solves the problem described above. -->\r\n\r\n#### Alternative Solutions\r\n<!-- Have you tried to workaround the problem using a pytest plugin or other tools? Or a different approach to solving this issue? Please elaborate here. -->\r\n\r\n#### Additional context\r\n<!-- Add any other context, links, etc. about the feature here. -->\r\n\n",
  "hints_text": "",
  "created_at": "2021-03-09T09:05:32Z",
  "version": "6.3",
  "FAIL_TO_PASS": "[\"testing/python/approx.py::TestApprox::test_list_decimal\", \"testing/python/approx.py::TestApprox::test_dict_decimal\"]",
  "PASS_TO_PASS": "[\"testing/python/approx.py::TestApprox::test_repr_string\", \"testing/python/approx.py::TestApprox::test_repr_complex_numbers\", \"testing/python/approx.py::TestApprox::test_operator_overloading\", \"testing/python/approx.py::TestApprox::test_exactly_equal\", \"testing/python/approx.py::TestApprox::test_opposite_sign\", \"testing/python/approx.py::TestApprox::test_zero_tolerance\", \"testing/python/approx.py::TestApprox::test_negative_tolerance[-1e+100-None]\", \"testing/python/approx.py::TestApprox::test_negative_tolerance[None--1e+100]\", \"testing/python/approx.py::TestApprox::test_negative_tolerance[1e+100--1e+100]\", \"testing/python/approx.py::TestApprox::test_negative_tolerance[-1e+100-1e+100]\", \"testing/python/approx.py::TestApprox::test_negative_tolerance[-1e+100--1e+100]\", \"testing/python/approx.py::TestApprox::test_inf_tolerance\", \"testing/python/approx.py::TestApprox::test_inf_tolerance_expecting_zero\", \"testing/python/approx.py::TestApprox::test_nan_tolerance\", \"testing/python/approx.py::TestApprox::test_reasonable_defaults\", \"testing/python/approx.py::TestApprox::test_default_tolerances\", \"testing/python/approx.py::TestApprox::test_custom_tolerances\", \"testing/python/approx.py::TestApprox::test_relative_tolerance\", \"testing/python/approx.py::TestApprox::test_absolute_tolerance\", \"testing/python/approx.py::TestApprox::test_expecting_zero\", \"testing/python/approx.py::TestApprox::test_expecting_inf\", \"testing/python/approx.py::TestApprox::test_expecting_nan\", \"testing/python/approx.py::TestApprox::test_int\", \"testing/python/approx.py::TestApprox::test_decimal\", \"testing/python/approx.py::TestApprox::test_fraction\", \"testing/python/approx.py::TestApprox::test_complex\", \"testing/python/approx.py::TestApprox::test_list\", \"testing/python/approx.py::TestApprox::test_list_wrong_len\", \"testing/python/approx.py::TestApprox::test_tuple\", \"testing/python/approx.py::TestApprox::test_tuple_wrong_len\", \"testing/python/approx.py::TestApprox::test_tuple_vs_other\", \"testing/python/approx.py::TestApprox::test_dict\", \"testing/python/approx.py::TestApprox::test_dict_wrong_len\", \"testing/python/approx.py::TestApprox::test_dict_nonnumeric\", \"testing/python/approx.py::TestApprox::test_dict_vs_other\", \"testing/python/approx.py::TestApprox::test_doctests\", \"testing/python/approx.py::TestApprox::test_expected_value_type_error[nested-list]\", \"testing/python/approx.py::TestApprox::test_expected_value_type_error[nested-dict]\", \"testing/python/approx.py::TestApprox::test_nonnumeric_okay_if_equal[None]\", \"testing/python/approx.py::TestApprox::test_nonnumeric_okay_if_equal[string]\", \"testing/python/approx.py::TestApprox::test_nonnumeric_okay_if_equal[nested-str]\", \"testing/python/approx.py::TestApprox::test_nonnumeric_okay_if_equal[dict-with-string]\", \"testing/python/approx.py::TestApprox::test_nonnumeric_false_if_unequal[string]\", \"testing/python/approx.py::TestApprox::test_nonnumeric_false_if_unequal[nested-str]\", \"testing/python/approx.py::TestApprox::test_nonnumeric_false_if_unequal[dict-with-string]\", \"testing/python/approx.py::TestApprox::test_nonnumeric_dict_repr\", \"testing/python/approx.py::TestApprox::test_nonnumeric_list_repr\", \"testing/python/approx.py::TestApprox::test_comparison_operator_type_error[<=]\", \"testing/python/approx.py::TestApprox::test_comparison_operator_type_error[<]\", \"testing/python/approx.py::TestApprox::test_comparison_operator_type_error[>=]\", \"testing/python/approx.py::TestApprox::test_comparison_operator_type_error[>]\", \"testing/python/approx.py::TestApprox::test_generic_sized_iterable_object\", \"testing/python/approx.py::TestApprox::test_unicode_plus_minus\"]",
  "environment_setup_commit": "634312b14a45db8d60d72016e01294284e3a18d4",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.942611",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}