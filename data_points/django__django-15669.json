{
  "repo": "django/django",
  "instance_id": "django__django-15669",
  "base_commit": "2a2bde52f31e09e95ce616e8e6bc0ffeb68f76c9",
  "patch": "diff --git a/django/core/management/commands/makemigrations.py b/django/core/management/commands/makemigrations.py\n--- a/django/core/management/commands/makemigrations.py\n+++ b/django/core/management/commands/makemigrations.py\n@@ -11,6 +11,8 @@\n from django.db.migrations import Migration\n from django.db.migrations.autodetector import MigrationAutodetector\n from django.db.migrations.loader import MigrationLoader\n+from django.db.migrations.migration import SwappableTuple\n+from django.db.migrations.optimizer import MigrationOptimizer\n from django.db.migrations.questioner import (\n     InteractiveMigrationQuestioner,\n     MigrationQuestioner,\n@@ -79,6 +81,15 @@ def add_arguments(self, parser):\n                 \"paths of generated migration files to stdout.\"\n             ),\n         )\n+        parser.add_argument(\n+            \"--update\",\n+            action=\"store_true\",\n+            dest=\"update\",\n+            help=(\n+                \"Merge model changes into the latest migration and optimize the \"\n+                \"resulting operations.\"\n+            ),\n+        )\n \n     @property\n     def log_output(self):\n@@ -101,6 +112,7 @@ def handle(self, *app_labels, **options):\n         self.include_header = options[\"include_header\"]\n         check_changes = options[\"check_changes\"]\n         self.scriptable = options[\"scriptable\"]\n+        self.update = options[\"update\"]\n         # If logs and prompts are diverted to stderr, remove the ERROR style.\n         if self.scriptable:\n             self.stderr.style_func = None\n@@ -236,11 +248,86 @@ def handle(self, *app_labels, **options):\n                 else:\n                     self.log(\"No changes detected\")\n         else:\n-            self.write_migration_files(changes)\n+            if self.update:\n+                self.write_to_last_migration_files(changes)\n+            else:\n+                self.write_migration_files(changes)\n             if check_changes:\n                 sys.exit(1)\n \n-    def write_migration_files(self, changes):\n+    def write_to_last_migration_files(self, changes):\n+        loader = MigrationLoader(connections[DEFAULT_DB_ALIAS])\n+        new_changes = {}\n+        update_previous_migration_paths = {}\n+        for app_label, app_migrations in changes.items():\n+            # Find last migration.\n+            leaf_migration_nodes = loader.graph.leaf_nodes(app=app_label)\n+            if len(leaf_migration_nodes) == 0:\n+                raise CommandError(\n+                    f\"App {app_label} has no migration, cannot update last migration.\"\n+                )\n+            leaf_migration_node = leaf_migration_nodes[0]\n+            # Multiple leaf nodes have already been checked earlier in command.\n+            leaf_migration = loader.graph.nodes[leaf_migration_node]\n+            # Updated migration cannot be a squash migration, a dependency of\n+            # another migration, and cannot be already applied.\n+            if leaf_migration.replaces:\n+                raise CommandError(\n+                    f\"Cannot update squash migration '{leaf_migration}'.\"\n+                )\n+            if leaf_migration_node in loader.applied_migrations:\n+                raise CommandError(\n+                    f\"Cannot update applied migration '{leaf_migration}'.\"\n+                )\n+            depending_migrations = [\n+                migration\n+                for migration in loader.disk_migrations.values()\n+                if leaf_migration_node in migration.dependencies\n+            ]\n+            if depending_migrations:\n+                formatted_migrations = \", \".join(\n+                    [f\"'{migration}'\" for migration in depending_migrations]\n+                )\n+                raise CommandError(\n+                    f\"Cannot update migration '{leaf_migration}' that migrations \"\n+                    f\"{formatted_migrations} depend on.\"\n+                )\n+            # Build new migration.\n+            for migration in app_migrations:\n+                leaf_migration.operations.extend(migration.operations)\n+\n+                for dependency in migration.dependencies:\n+                    if isinstance(dependency, SwappableTuple):\n+                        if settings.AUTH_USER_MODEL == dependency.setting:\n+                            leaf_migration.dependencies.append(\n+                                (\"__setting__\", \"AUTH_USER_MODEL\")\n+                            )\n+                        else:\n+                            leaf_migration.dependencies.append(dependency)\n+                    elif dependency[0] != migration.app_label:\n+                        leaf_migration.dependencies.append(dependency)\n+            # Optimize migration.\n+            optimizer = MigrationOptimizer()\n+            leaf_migration.operations = optimizer.optimize(\n+                leaf_migration.operations, app_label\n+            )\n+            # Update name.\n+            previous_migration_path = MigrationWriter(leaf_migration).path\n+            suggested_name = (\n+                leaf_migration.name[:4] + \"_\" + leaf_migration.suggest_name()\n+            )\n+            if leaf_migration.name == suggested_name:\n+                new_name = leaf_migration.name + \"_updated\"\n+            else:\n+                new_name = suggested_name\n+            leaf_migration.name = new_name\n+            # Register overridden migration.\n+            new_changes[app_label] = [leaf_migration]\n+            update_previous_migration_paths[app_label] = previous_migration_path\n+\n+        self.write_migration_files(new_changes, update_previous_migration_paths)\n+\n+    def write_migration_files(self, changes, update_previous_migration_paths=None):\n         \"\"\"\n         Take a changes dict and write them out as migration files.\n         \"\"\"\n@@ -254,12 +341,7 @@ def write_migration_files(self, changes):\n                 if self.verbosity >= 1:\n                     # Display a relative path if it's below the current working\n                     # directory, or an absolute path otherwise.\n-                    try:\n-                        migration_string = os.path.relpath(writer.path)\n-                    except ValueError:\n-                        migration_string = writer.path\n-                    if migration_string.startswith(\"..\"):\n-                        migration_string = writer.path\n+                    migration_string = self.get_relative_path(writer.path)\n                     self.log(\"  %s\\n\" % self.style.MIGRATE_LABEL(migration_string))\n                     for operation in migration.operations:\n                         self.log(\"    - %s\" % operation.describe())\n@@ -279,6 +361,22 @@ def write_migration_files(self, changes):\n                     with open(writer.path, \"w\", encoding=\"utf-8\") as fh:\n                         fh.write(migration_string)\n                         self.written_files.append(writer.path)\n+                    if update_previous_migration_paths:\n+                        prev_path = update_previous_migration_paths[app_label]\n+                        rel_prev_path = self.get_relative_path(prev_path)\n+                        if writer.needs_manual_porting:\n+                            migration_path = self.get_relative_path(writer.path)\n+                            self.log(\n+                                self.style.WARNING(\n+                                    f\"Updated migration {migration_path} requires \"\n+                                    f\"manual porting.\\n\"\n+                                    f\"Previous migration {rel_prev_path} was kept and \"\n+                                    f\"must be deleted after porting functions manually.\"\n+                                )\n+                            )\n+                        else:\n+                            os.remove(prev_path)\n+                            self.log(f\"Deleted {rel_prev_path}\")\n                 elif self.verbosity == 3:\n                     # Alternatively, makemigrations --dry-run --verbosity 3\n                     # will log the migrations rather than saving the file to\n@@ -291,6 +389,16 @@ def write_migration_files(self, changes):\n                     self.log(writer.as_string())\n         run_formatters(self.written_files)\n \n+    @staticmethod\n+    def get_relative_path(path):\n+        try:\n+            migration_string = os.path.relpath(path)\n+        except ValueError:\n+            migration_string = path\n+        if migration_string.startswith(\"..\"):\n+            migration_string = path\n+        return migration_string\n+\n     def handle_merge(self, loader, conflicts):\n         \"\"\"\n         Handles merging together conflicted migrations interactively,\n",
  "test_patch": "diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -2584,6 +2584,108 @@ def test_makemigrations_continues_number_sequence_after_squash(self):\n             out_value = out.getvalue()\n             self.assertIn(\"0003_auto\", out_value)\n \n+    def test_makemigrations_update(self):\n+        with self.temporary_migration_module(\n+            module=\"migrations.test_migrations\"\n+        ) as migration_dir:\n+            migration_file = os.path.join(migration_dir, \"0002_second.py\")\n+            with open(migration_file) as fp:\n+                initial_content = fp.read()\n+\n+            with captured_stdout() as out:\n+                call_command(\"makemigrations\", \"migrations\", update=True)\n+            self.assertFalse(\n+                any(\n+                    filename.startswith(\"0003\")\n+                    for filename in os.listdir(migration_dir)\n+                )\n+            )\n+            self.assertIs(os.path.exists(migration_file), False)\n+            new_migration_file = os.path.join(\n+                migration_dir,\n+                \"0002_delete_tribble_author_rating_modelwithcustombase_and_more.py\",\n+            )\n+            with open(new_migration_file) as fp:\n+                self.assertNotEqual(initial_content, fp.read())\n+            self.assertIn(f\"Deleted {migration_file}\", out.getvalue())\n+\n+    def test_makemigrations_update_existing_name(self):\n+        with self.temporary_migration_module(\n+            module=\"migrations.test_auto_now_add\"\n+        ) as migration_dir:\n+            migration_file = os.path.join(migration_dir, \"0001_initial.py\")\n+            with open(migration_file) as fp:\n+                initial_content = fp.read()\n+\n+            with captured_stdout() as out:\n+                call_command(\"makemigrations\", \"migrations\", update=True)\n+            self.assertIs(os.path.exists(migration_file), False)\n+            new_migration_file = os.path.join(\n+                migration_dir,\n+                \"0001_initial_updated.py\",\n+            )\n+            with open(new_migration_file) as fp:\n+                self.assertNotEqual(initial_content, fp.read())\n+            self.assertIn(f\"Deleted {migration_file}\", out.getvalue())\n+\n+    def test_makemigrations_update_applied_migration(self):\n+        recorder = MigrationRecorder(connection)\n+        recorder.record_applied(\"migrations\", \"0001_initial\")\n+        recorder.record_applied(\"migrations\", \"0002_second\")\n+        with self.temporary_migration_module(module=\"migrations.test_migrations\"):\n+            msg = \"Cannot update applied migration 'migrations.0002_second'.\"\n+            with self.assertRaisesMessage(CommandError, msg):\n+                call_command(\"makemigrations\", \"migrations\", update=True)\n+\n+    def test_makemigrations_update_no_migration(self):\n+        with self.temporary_migration_module(module=\"migrations.test_migrations_empty\"):\n+            msg = \"App migrations has no migration, cannot update last migration.\"\n+            with self.assertRaisesMessage(CommandError, msg):\n+                call_command(\"makemigrations\", \"migrations\", update=True)\n+\n+    def test_makemigrations_update_squash_migration(self):\n+        with self.temporary_migration_module(\n+            module=\"migrations.test_migrations_squashed\"\n+        ):\n+            msg = \"Cannot update squash migration 'migrations.0001_squashed_0002'.\"\n+            with self.assertRaisesMessage(CommandError, msg):\n+                call_command(\"makemigrations\", \"migrations\", update=True)\n+\n+    def test_makemigrations_update_manual_porting(self):\n+        with self.temporary_migration_module(\n+            module=\"migrations.test_migrations_plan\"\n+        ) as migration_dir:\n+            with captured_stdout() as out:\n+                call_command(\"makemigrations\", \"migrations\", update=True)\n+            # Previous migration exists.\n+            previous_migration_file = os.path.join(migration_dir, \"0005_fifth.py\")\n+            self.assertIs(os.path.exists(previous_migration_file), True)\n+            # New updated migration exists.\n+            files = [f for f in os.listdir(migration_dir) if f.startswith(\"0005_auto\")]\n+            updated_migration_file = os.path.join(migration_dir, files[0])\n+            self.assertIs(os.path.exists(updated_migration_file), True)\n+            self.assertIn(\n+                f\"Updated migration {updated_migration_file} requires manual porting.\\n\"\n+                f\"Previous migration {previous_migration_file} was kept and must be \"\n+                f\"deleted after porting functions manually.\",\n+                out.getvalue(),\n+            )\n+\n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"migrations.migrations_test_apps.alter_fk.author_app\",\n+            \"migrations.migrations_test_apps.alter_fk.book_app\",\n+        ]\n+    )\n+    def test_makemigrations_update_dependency_migration(self):\n+        with self.temporary_migration_module(app_label=\"book_app\"):\n+            msg = (\n+                \"Cannot update migration 'book_app.0001_initial' that migrations \"\n+                \"'author_app.0002_alter_id' depend on.\"\n+            )\n+            with self.assertRaisesMessage(CommandError, msg):\n+                call_command(\"makemigrations\", \"book_app\", update=True)\n+\n \n class SquashMigrationsTests(MigrationTestBase):\n     \"\"\"\n",
  "problem_statement": "Create --update flag for makemigrations management command, mimicking South's one.\nDescription\n\t\nWhen I was developing with South I was able to use the --update flag for the schemamigration management command (​http://south.readthedocs.org/en/latest/commands.html#schemamigration) to refine the latest migration.\nThis was very convenient for iterative development. Could we have an equivalent of the --update flag for Django>=1.7 makemigrations?\n(I've taken it from ​http://stackoverflow.com/questions/30487909/what-is-the-equivalent-of-souths-schemamigration-update-for-django-1-7)\n",
  "hints_text": "Andrew, could you offer your view.\nIt's certainly possible, though more complicated than before in South because of the multi-app nature of makemigrations - but also easier because of the ease of programatically parsing and writing migration files. What this would be, in essence, is something that runs makemigrations and glues the first migration it makes for each app to the most recent one that already exists. The pain points I forsee are: Migration files that have custom code (RunPython especially, but also any non-standard operation class) cannot be round-tripped through the parser and then out through the writer, so they could not be appended onto. Dependencies would have to be checked to make sure this merging of the new migrations into old does not cause dependency loops. It will occasionally have to just make new migrations anyway - it's more asking for a \"best effort\" attempt to make things work. That said, I think it's not too complicated, and shares enough of these challenges with squashing (it's basically squashing the new migrations makemigrations creates into the last ones of the existing set), that we should aim to do it at some point.\nHello, I tried to tackle this ticket as I believe it would still be a pretty useful addition to makemigrations. During development, I often see developers struggle with the manual steps to re-generate a migration while they are still iterating on their approach. Here is the approach I've taken ​https://github.com/django/django/pull/15669 I tried to keep the implementation rather straightforward. The main drawback I see is that it will add a new edge case when one updates a migration that has already been applied. This will create a bit of confusion, as it will become more tedious to undo the updated migration, since the reverse operations will try to undo things that weren't initially applied.",
  "created_at": "2022-05-06T20:12:26Z",
  "version": "4.2",
  "FAIL_TO_PASS": "[\"test_makemigrations_update (migrations.test_commands.MakeMigrationsTests)\", \"test_makemigrations_update_applied_migration (migrations.test_commands.MakeMigrationsTests)\", \"test_makemigrations_update_dependency_migration (migrations.test_commands.MakeMigrationsTests)\", \"test_makemigrations_update_existing_name (migrations.test_commands.MakeMigrationsTests)\", \"test_makemigrations_update_manual_porting (migrations.test_commands.MakeMigrationsTests)\", \"test_makemigrations_update_no_migration (migrations.test_commands.MakeMigrationsTests)\", \"test_makemigrations_update_squash_migration (migrations.test_commands.MakeMigrationsTests)\"]",
  "PASS_TO_PASS": "[\"test_makemigrations_app_name_specified_as_label (migrations.test_commands.AppLabelErrorTests)\", \"test_makemigrations_nonexistent_app_label (migrations.test_commands.AppLabelErrorTests)\", \"test_migrate_app_name_specified_as_label (migrations.test_commands.AppLabelErrorTests)\", \"test_migrate_nonexistent_app_label (migrations.test_commands.AppLabelErrorTests)\", \"test_optimizemigration_app_name_specified_as_label (migrations.test_commands.AppLabelErrorTests)\", \"test_optimizemigration_nonexistent_app_label (migrations.test_commands.AppLabelErrorTests)\", \"test_showmigrations_app_name_specified_as_label (migrations.test_commands.AppLabelErrorTests)\", \"test_showmigrations_nonexistent_app_label (migrations.test_commands.AppLabelErrorTests)\", \"test_sqlmigrate_app_name_specified_as_label (migrations.test_commands.AppLabelErrorTests)\", \"test_sqlmigrate_nonexistent_app_label (migrations.test_commands.AppLabelErrorTests)\", \"test_squashmigrations_app_name_specified_as_label (migrations.test_commands.AppLabelErrorTests)\", \"test_squashmigrations_nonexistent_app_label (migrations.test_commands.AppLabelErrorTests)\", \"test_ambigious_prefix (migrations.test_commands.OptimizeMigrationTests)\", \"test_app_without_migrations (migrations.test_commands.OptimizeMigrationTests)\", \"test_creates_replace_migration_manual_porting (migrations.test_commands.OptimizeMigrationTests)\", \"test_fails_squash_migration_manual_porting (migrations.test_commands.OptimizeMigrationTests)\", \"test_no_optimization_possible (migrations.test_commands.OptimizeMigrationTests)\", \"test_optimization (migrations.test_commands.OptimizeMigrationTests)\", \"test_optimization_no_verbosity (migrations.test_commands.OptimizeMigrationTests)\", \"test_optimizemigration_check (migrations.test_commands.OptimizeMigrationTests)\", \"test_unknown_prefix (migrations.test_commands.OptimizeMigrationTests)\", \"test_ambiguous_prefix (migrations.test_commands.MigrateTests)\", \"test_app_without_migrations (migrations.test_commands.MigrateTests)\", \"Tests basic usage of the migrate command.\", \"test_migrate_backward_to_squashed_migration (migrations.test_commands.MigrateTests)\", \"test_migrate_check (migrations.test_commands.MigrateTests)\", \"test_migrate_check_plan (migrations.test_commands.MigrateTests)\", \"migrate exits if it detects a conflict.\", \"--fake-initial only works if all tables created in the initial\", \"test_migrate_fake_initial_case_insensitive (migrations.test_commands.MigrateTests)\", \"Split initial migrations can be faked with --fake-initial.\", \"Running migrate with some migrations applied before their dependencies\", \"`Migration.initial = False` skips fake-initial detection.\", \"test_migrate_not_reflected_changes (migrations.test_commands.MigrateTests)\", \"Migrating to a squashed migration specified by name should succeed\", \"Tests migrate --plan output.\", \"With prune=True, references to migration files deleted from the\", \"Running a single squashed migration should record all of the original\", \"Running migrate for a squashed migration should record as run\", \"Running migrate --run-syncdb with an app_label only creates tables for\", \"test_migrate_syncdb_app_with_migrations (migrations.test_commands.MigrateTests)\", \"For an app without migrations, editor.execute() is used for executing\", \"test_migrate_with_system_checks (migrations.test_commands.MigrateTests)\", \"test_prune_deleted_squashed_migrations_in_replaces (migrations.test_commands.MigrateTests)\", \"test_prune_no_app_label (migrations.test_commands.MigrateTests)\", \"test_prune_no_migrations_to_prune (migrations.test_commands.MigrateTests)\", \"Assuming you have 3 apps, `A`, `B`, and `C`, such that:\", \"showmigrations --list  displays migrations and whether or not they're\", \"test_showmigrations_list_squashed (migrations.test_commands.MigrateTests)\", \"test_showmigrations_no_migrations (migrations.test_commands.MigrateTests)\", \"Tests --plan output of showmigrations command\", \"test_showmigrations_plan_app_label_no_migrations (migrations.test_commands.MigrateTests)\", \"`showmigrations --plan app_label` output with multiple app_labels.\", \"Tests --plan output of showmigrations command without migrations\", \"`showmigrations --plan app_label` output with a single app_label.\", \"Tests --plan output of showmigrations command with squashed migrations.\", \"test_showmigrations_unmigrated_app (migrations.test_commands.MigrateTests)\", \"test_sqlmigrate_ambiguous_prefix_squashed_migrations (migrations.test_commands.MigrateTests)\", \"sqlmigrate outputs reverse looking SQL.\", \"Transaction wrappers aren't shown for non-atomic migrations.\", \"Transaction wrappers aren't shown for databases that don't support\", \"sqlmigrate outputs forward looking SQL.\", \"test_sqlmigrate_no_operations (migrations.test_commands.MigrateTests)\", \"test_sqlmigrate_noop (migrations.test_commands.MigrateTests)\", \"test_sqlmigrate_replaced_migration (migrations.test_commands.MigrateTests)\", \"test_sqlmigrate_squashed_migration (migrations.test_commands.MigrateTests)\", \"test_sqlmigrate_unrepresentable (migrations.test_commands.MigrateTests)\", \"test_unknown_prefix (migrations.test_commands.MigrateTests)\", \"test_squashed_name_exists (migrations.test_commands.SquashMigrationsTests)\", \"--squashed-name specifies the new migration's name.\", \"--squashed-name also works if a start migration is omitted.\", \"test_squashmigrations_initial_attribute (migrations.test_commands.SquashMigrationsTests)\", \"squashmigrations doesn't accept a starting migration after the ending migration.\", \"test_squashmigrations_manual_porting (migrations.test_commands.SquashMigrationsTests)\", \"squashmigrations optimizes operations.\", \"squashmigrations squashes migrations.\", \"squashmigrations accepts a starting migration.\", \"squashmigrations --no-optimize doesn't optimize operations.\", \"test_failing_migration (migrations.test_commands.MakeMigrationsTests)\", \"test_files_content (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations respects --dry-run option when fixing migration\", \"`makemigrations --merge --dry-run` writes the merge migration file to\", \"test_makemigrations_auto_merge_name (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations prompts the user when adding auto_now_add to an existing\", \"test_makemigrations_auto_now_add_interactive_quit (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations --check should exit with a non-zero status when\", \"makemigrations exits if it detects a conflict.\", \"The history consistency checks in makemigrations respect\", \"test_makemigrations_continues_number_sequence_after_squash (migrations.test_commands.MakeMigrationsTests)\", \"test_makemigrations_default_merge_name (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations raises a nice error when migrations are disabled for an\", \"`makemigrations --dry-run` should not ask for defaults.\", \"Allow `makemigrations --dry-run` to output the migrations file to\", \"test_makemigrations_empty_connections (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations properly constructs an empty migration.\", \"makemigrations exits if no app is specified with 'empty' mode.\", \"test_makemigrations_field_rename_interactive (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations properly merges the conflicting migrations with --noinput.\", \"makemigrations should raise InconsistentMigrationHistory exception if\", \"test_makemigrations_inconsistent_history_db_failure (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations enters interactive mode and merges properly.\", \"The user is prompted to merge by default if there are conflicts and\", \"makemigrations messages when adding a NOT NULL field in interactive\", \"makemigrations messages when changing a NULL field to NOT NULL in\", \"makemigrations enters and exits interactive mode properly.\", \"makemigrations prompts the user when adding a unique field with\", \"makemigrations --merge does not output any operations from apps that\", \"makemigrations exits if in merge mode with no conflicts.\", \"makemigrations should print the relative paths to the migrations unless\", \"makemigrations prints the absolute path if os.path.relpath() raises a\", \"makemigrations announces the migration at the default verbosity level.\", \"test_makemigrations_migrations_modules_nonexistent_toplevel_package (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations creates migrations when specifying a custom location\", \"test_makemigrations_model_rename_interactive (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations should detect initial is needed on empty migration\", \"makemigrations exits when there are no changes to an app.\", \"makemigrations exits when there are no changes and no apps are specified.\", \"makemigrations fails to merge migrations with no common ancestor.\", \"Migration directories without an __init__.py file are allowed.\", \"Non-interactive makemigrations fails when a default is missing on a\", \"makemigrations adds and removes a possible field rename in\", \"makemigrations adds and removes a possible model rename in\", \"test_makemigrations_non_interactive_unique_callable_default_addition (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations should recognize number-only migrations (0001.py).\", \"With scriptable=True, log output is diverted to stderr, and only the\", \"test_makemigrations_scriptable_merge (migrations.test_commands.MakeMigrationsTests)\", \"makemigrations does not create a merge for an unspecified app even if\", \"makemigrations does not raise a CommandError when an unspecified app\", \"makemigrations --name generate a custom migration name.\", \"test_makemigrations_with_invalid_custom_name (migrations.test_commands.MakeMigrationsTests)\"]",
  "environment_setup_commit": "0fbdb9784da915fce5dcc1fe82bac9b4785749e5",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.737019",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}