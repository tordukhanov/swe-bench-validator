{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-12227",
  "base_commit": "d60497958f6dea7f5e25bc41e9107a6a63694d01",
  "patch": "diff --git a/sympy/core/numbers.py b/sympy/core/numbers.py\n--- a/sympy/core/numbers.py\n+++ b/sympy/core/numbers.py\n@@ -3,6 +3,7 @@\n import decimal\n import fractions\n import math\n+import warnings\n import re as regex\n from collections import defaultdict\n \n@@ -27,6 +28,8 @@\n from sympy.utilities.misc import debug, filldedent\n from .evaluate import global_evaluate\n \n+from sympy.utilities.exceptions import SymPyDeprecationWarning\n+\n rnd = mlib.round_nearest\n \n _LOG2 = math.log(2)\n@@ -768,7 +771,20 @@ class Float(Number):\n \n     is_Float = True\n \n-    def __new__(cls, num, prec=None):\n+    def __new__(cls, num, dps=None, prec=None, precision=None):\n+        if prec is not None:\n+            SymPyDeprecationWarning(\n+                            feature=\"Using 'prec=XX' to denote decimal precision\",\n+                            useinstead=\"'dps=XX' to denote decimal and 'precision=XX' \"\\\n+                                              \"for binary precision\",\n+                            value=\"This is an effort to improve functionality \"\\\n+                                       \"of Float class. \").warn()\n+            dps = prec\n+\n+        if dps is not None and precision is not None:\n+            raise ValueError('Both decimal and binary precision supplied. '\n+                             'Supply only one. ')\n+\n         if isinstance(num, string_types):\n             num = num.replace(' ', '')\n             if num.startswith('.') and len(num) > 1:\n@@ -784,11 +800,12 @@ def __new__(cls, num, prec=None):\n         elif num is S.NegativeInfinity:\n             num = '-inf'\n         elif isinstance(num, mpmath.mpf):\n-            if prec == None:\n-                prec = num.context.dps\n+            if precision is None:\n+                if dps is None:\n+                    precision = num.context.prec\n             num = num._mpf_\n \n-        if prec is None:\n+        if dps is None and precision is None:\n             dps = 15\n             if isinstance(num, Float):\n                 return num\n@@ -803,7 +820,8 @@ def __new__(cls, num, prec=None):\n                     if num.is_Integer and isint:\n                         dps = max(dps, len(str(num).lstrip('-')))\n                     dps = max(15, dps)\n-        elif prec == '':\n+                    precision = mlib.libmpf.dps_to_prec(dps)\n+        elif precision == '' and dps is None or precision is None and dps == '':\n             if not isinstance(num, string_types):\n                 raise ValueError('The null string can only be used when '\n                 'the number to Float is passed as a string or an integer.')\n@@ -818,20 +836,26 @@ def __new__(cls, num, prec=None):\n                     num, dps = _decimal_to_Rational_prec(Num)\n                     if num.is_Integer and isint:\n                         dps = max(dps, len(str(num).lstrip('-')))\n+                        precision = mlib.libmpf.dps_to_prec(dps)\n                     ok = True\n             if ok is None:\n                 raise ValueError('string-float not recognized: %s' % num)\n-        else:\n-            dps = prec\n \n-        prec = mlib.libmpf.dps_to_prec(dps)\n+        # decimal precision(dps) is set and maybe binary precision(precision)\n+        # as well.From here on binary precision is used to compute the Float.\n+        # Hence, if supplied use binary precision else translate from decimal\n+        # precision.\n+\n+        if precision is None or precision == '':\n+            precision = mlib.libmpf.dps_to_prec(dps)\n+\n         if isinstance(num, float):\n-            _mpf_ = mlib.from_float(num, prec, rnd)\n+            _mpf_ = mlib.from_float(num, precision, rnd)\n         elif isinstance(num, string_types):\n-            _mpf_ = mlib.from_str(num, prec, rnd)\n+            _mpf_ = mlib.from_str(num, precision, rnd)\n         elif isinstance(num, decimal.Decimal):\n             if num.is_finite():\n-                _mpf_ = mlib.from_str(str(num), prec, rnd)\n+                _mpf_ = mlib.from_str(str(num), precision, rnd)\n             elif num.is_nan():\n                 _mpf_ = _mpf_nan\n             elif num.is_infinite():\n@@ -842,7 +866,7 @@ def __new__(cls, num, prec=None):\n             else:\n                 raise ValueError(\"unexpected decimal value %s\" % str(num))\n         elif isinstance(num, Rational):\n-            _mpf_ = mlib.from_rational(num.p, num.q, prec, rnd)\n+            _mpf_ = mlib.from_rational(num.p, num.q, precision, rnd)\n         elif isinstance(num, tuple) and len(num) in (3, 4):\n             if type(num[1]) is str:\n                 # it's a hexadecimal (coming from a pickled object)\n@@ -853,13 +877,13 @@ def __new__(cls, num, prec=None):\n             else:\n                 if len(num) == 4:\n                     # handle normalization hack\n-                    return Float._new(num, prec)\n+                    return Float._new(num, precision)\n                 else:\n-                    return (S.NegativeOne**num[0]*num[1]*S(2)**num[2]).evalf(prec)\n+                    return (S.NegativeOne**num[0]*num[1]*S(2)**num[2]).evalf(precision)\n         elif isinstance(num, Float):\n             _mpf_ = num._mpf_\n-            if prec < num._prec:\n-                _mpf_ = mpf_norm(_mpf_, prec)\n+            if precision < num._prec:\n+                _mpf_ = mpf_norm(_mpf_, precision)\n         else:\n             # XXX: We lose precision here.\n             _mpf_ = mpmath.mpf(num)._mpf_\n@@ -872,7 +896,7 @@ def __new__(cls, num, prec=None):\n \n         obj = Expr.__new__(cls)\n         obj._mpf_ = _mpf_\n-        obj._prec = prec\n+        obj._prec = precision\n         return obj\n \n     @classmethod\ndiff --git a/sympy/printing/repr.py b/sympy/printing/repr.py\n--- a/sympy/printing/repr.py\n+++ b/sympy/printing/repr.py\n@@ -135,9 +135,8 @@ def _print_Fraction(self, expr):\n         return 'Fraction(%s, %s)' % (self._print(expr.numerator), self._print(expr.denominator))\n \n     def _print_Float(self, expr):\n-        dps = prec_to_dps(expr._prec)\n         r = mlib.to_str(expr._mpf_, repr_dps(expr._prec))\n-        return \"%s('%s', prec=%i)\" % (expr.__class__.__name__, r, dps)\n+        return \"%s('%s', precision=%i)\" % (expr.__class__.__name__, r, expr._prec)\n \n     def _print_Sum2(self, expr):\n         return \"Sum2(%s, (%s, %s, %s))\" % (self._print(expr.f), self._print(expr.i),\n",
  "test_patch": "diff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py\n--- a/sympy/core/tests/test_numbers.py\n+++ b/sympy/core/tests/test_numbers.py\n@@ -487,14 +487,34 @@ def teq(a):\n     assert Float(decimal.Decimal('-Infinity')) == S.NegativeInfinity\n \n     assert '{0:.3f}'.format(Float(4.236622)) == '4.237'\n-    assert '{0:.35f}'.format(Float(pi.n(40), 40)) == '3.14159265358979323846264338327950288'\n+    assert '{0:.35f}'.format(Float(pi.n(40), 40)) == \\\n+        '3.14159265358979323846264338327950288'\n \n     assert Float(oo) == Float('+inf')\n     assert Float(-oo) == Float('-inf')\n \n     # unicode\n-    assert Float(u'0.73908513321516064100000000') == Float('0.73908513321516064100000000')\n-    assert Float(u'0.73908513321516064100000000', 28) == Float('0.73908513321516064100000000', 28)\n+    assert Float(u'0.73908513321516064100000000') == \\\n+        Float('0.73908513321516064100000000')\n+    assert Float(u'0.73908513321516064100000000', 28) == \\\n+        Float('0.73908513321516064100000000', 28)\n+\n+    # binary precision\n+    # Decimal value 0.1 cannot be expressed precisely as a base 2 fraction\n+    a = Float(S(1)/10, dps=15)\n+    b = Float(S(1)/10, dps=16)\n+    p = Float(S(1)/10, precision=53)\n+    q = Float(S(1)/10, precision=54)\n+    assert a._mpf_ == p._mpf_\n+    assert not a._mpf_ == q._mpf_\n+    assert not b._mpf_ == q._mpf_\n+\n+    # Precision specifying errors\n+    raises(ValueError, lambda: Float(\"1.23\", dps=3, precision=10))\n+    raises(ValueError, lambda: Float(\"1.23\", dps=\"\", precision=10))\n+    raises(ValueError, lambda: Float(\"1.23\", dps=3, precision=\"\"))\n+    raises(ValueError, lambda: Float(\"1.23\", dps=\"\", precision=\"\"))\n+\n \n @conserve_mpmath_dps\n def test_float_mpf():\ndiff --git a/sympy/printing/tests/test_repr.py b/sympy/printing/tests/test_repr.py\n--- a/sympy/printing/tests/test_repr.py\n+++ b/sympy/printing/tests/test_repr.py\n@@ -101,12 +101,23 @@ def test_Rational():\n \n \n def test_Float():\n-    sT(Float('1.23', prec=3), \"Float('1.22998', prec=3)\")\n-    sT(Float('1.23456789', prec=9), \"Float('1.23456788994', prec=9)\")\n-    sT(Float('1.234567890123456789', prec=19),\n-       \"Float('1.234567890123456789013', prec=19)\")\n-    sT(Float(\n-        '0.60038617995049726', 15), \"Float('0.60038617995049726', prec=15)\")\n+    sT(Float('1.23', dps=3), \"Float('1.22998', precision=13)\")\n+    sT(Float('1.23456789', dps=9), \"Float('1.23456788994', precision=33)\")\n+    sT(Float('1.234567890123456789', dps=19),\n+       \"Float('1.234567890123456789013', precision=66)\")\n+    sT(Float('0.60038617995049726', dps=15),\n+       \"Float('0.60038617995049726', precision=53)\")\n+\n+    sT(Float('1.23', precision=13), \"Float('1.22998', precision=13)\")\n+    sT(Float('1.23456789', precision=33),\n+       \"Float('1.23456788994', precision=33)\")\n+    sT(Float('1.234567890123456789', precision=66),\n+       \"Float('1.234567890123456789013', precision=66)\")\n+    sT(Float('0.60038617995049726', precision=53),\n+       \"Float('0.60038617995049726', precision=53)\")\n+\n+    sT(Float('0.60038617995049726', 15),\n+       \"Float('0.60038617995049726', precision=53)\")\n \n \n def test_Symbol():\ndiff --git a/sympy/printing/tests/test_str.py b/sympy/printing/tests/test_str.py\n--- a/sympy/printing/tests/test_str.py\n+++ b/sympy/printing/tests/test_str.py\n@@ -489,11 +489,11 @@ def test_Rational():\n \n \n def test_Float():\n-    # NOTE prec is the whole number of decimal digits\n-    assert str(Float('1.23', prec=1 + 2)) == '1.23'\n-    assert str(Float('1.23456789', prec=1 + 8)) == '1.23456789'\n+    # NOTE dps is the whole number of decimal digits\n+    assert str(Float('1.23', dps=1 + 2)) == '1.23'\n+    assert str(Float('1.23456789', dps=1 + 8)) == '1.23456789'\n     assert str(\n-        Float('1.234567890123456789', prec=1 + 18)) == '1.234567890123456789'\n+        Float('1.234567890123456789', dps=1 + 18)) == '1.234567890123456789'\n     assert str(pi.evalf(1 + 2)) == '3.14'\n     assert str(pi.evalf(1 + 14)) == '3.14159265358979'\n     assert str(pi.evalf(1 + 64)) == ('3.141592653589793238462643383279'\n",
  "problem_statement": "Float constructor should allow to set binary precision\nI discussed this in some other issues, but I don't think I've opened an issue for it. \r\n\r\nThe Float constructor only allows you to set the decimal precision. It then converts this to binary precision and saves that in `Float._prec`. \r\n\r\nThe problem here is that there are fewer decimal precisions than binary precisions. For example:\r\n\r\n```\r\nIn [9]: Float(1.0, 15)._prec\r\nOut[9]: 53\r\n\r\nIn [10]: Float(1.0, 16)._prec\r\nOut[10]: 56\r\n```\r\n\r\nSo for instance, if you had a float that used 54 binary digits, it would be difficult to create a Float from it. I'm not even sure if it's possible, since in the current constructor, the `prec` argument overrides the fourth argument of a tuple input. \r\n\r\nOne issue here is that everywhere else in theÂ Sympy and mpmath code, `prec` refers to binary precision and `dps` refers to decimal precision. But currently, the second argument to `Float` is called `prec`, but refers to the decimal precision. So ideally, it should be \r\n\r\n```\r\nFloat(s, dps=15, prec=53)\r\n```\r\n\r\nwhere `Float(s, prec=54)` would override the default value of `dps=15`, and calling both (even consistently), like `Float(s, dps=15, prec=54)` would be an error.\r\n\r\nSince the keyword argument name has to change, it would be a backwards compatibility break for anyone who calls Float like `Float(s, prec=20)`.  Ideally this would require a deprecation cycle, but it's not possible to detect if someone is calling `Float(s, prec=20)` meaning the old way (20 decimal digits) or the new way (20 binary digits). The good news is that `N` and `evalf` call this argument `n`, so there's no need to change things there. \n",
  "hints_text": "I'll work on this issue.\nWhat if `Float(s, prec='b54')` is treated to refer to binary precision and `Float(s, prec=54)` to 54 decimal digits.Would that be a decent workaround ?\nThat would make it more annoying for the user, who has to do `'b' + str(prec)`. The API I suggested above would match other functions (like RealField), and the mpmath API",
  "created_at": "2017-02-27T15:20:15Z",
  "version": "1.0",
  "FAIL_TO_PASS": "[\"test_Float\"]",
  "PASS_TO_PASS": "[\"test_integers_cache\", \"test_seterr\", \"test_mod\", \"test_divmod\", \"test_igcd\", \"test_ilcm\", \"test_igcdex\", \"test_Integer_new\", \"test_Rational_new\", \"test_Number_new\", \"test_float_mpf\", \"test_Float_default_to_highprec_from_str\", \"test_Float_eval\", \"test_Float_issue_2107\", \"test_Infinity\", \"test_Mul_Infinity_Zero\", \"test_Div_By_Zero\", \"test_NaN\", \"test_special_numbers\", \"test_powers\", \"test_integer_nthroot_overflow\", \"test_isqrt\", \"test_powers_Float\", \"test_abs1\", \"test_accept_int\", \"test_dont_accept_str\", \"test_int\", \"test_long\", \"test_real_bug\", \"test_pi_Pi\", \"test_no_len\", \"test_issue_3321\", \"test_issue_3692\", \"test_issue_3423\", \"test_issue_3449\", \"test_Integer_factors\", \"test_Rational_factors\", \"test_issue_4107\", \"test_IntegerInteger\", \"test_Rational_gcd_lcm_cofactors\", \"test_Float_gcd_lcm_cofactors\", \"test_issue_4611\", \"test_conversion_to_mpmath\", \"test_relational\", \"test_Integer_as_index\", \"test_Rational_int\", \"test_zoo\", \"test_issue_4122\", \"test_GoldenRatio_expand\", \"test_as_content_primitive\", \"test_hashing_sympy_integers\", \"test_issue_4172\", \"test_Catalan_EulerGamma_prec\", \"test_Float_eq\", \"test_int_NumberSymbols\", \"test_issue_6640\", \"test_issue_6349\", \"test_mpf_norm\", \"test_latex\", \"test_issue_7742\", \"test_Float_idempotence\", \"test_comp\", \"test_issue_9491\", \"test_issue_10063\", \"test_printmethod\", \"test_Function\", \"test_Geometry\", \"test_Singletons\", \"test_Integer\", \"test_list\", \"test_Matrix\", \"test_empty_Matrix\", \"test_Rational\", \"test_Symbol\", \"test_Symbol_two_assumptions\", \"test_Symbol_no_special_commutative_treatment\", \"test_Wild\", \"test_Dummy\", \"test_Dummy_from_Symbol\", \"test_tuple\", \"test_WildFunction\", \"test_settins\", \"test_PolyRing\", \"test_FracField\", \"test_PolyElement\", \"test_FracElement\", \"test_Abs\", \"test_Catalan\", \"test_ComplexInfinity\", \"test_Derivative\", \"test_dict\", \"test_Dict\", \"test_EulerGamma\", \"test_Exp\", \"test_factorial\", \"test_GoldenRatio\", \"test_ImaginaryUnit\", \"test_Integral\", \"test_Interval\", \"test_AccumBounds\", \"test_Lambda\", \"test_Limit\", \"test_Matrix_str\", \"test_NegativeInfinity\", \"test_Order\", \"test_Permutation_Cycle\", \"test_Pi\", \"test_Poly\", \"test_Pow\", \"test_Relational\", \"test_CRootOf\", \"test_RootSum\", \"test_GroebnerBasis\", \"test_set\", \"test_SparseMatrix\", \"test_Sum\", \"test_Unit\", \"test_wild_str\", \"test_zeta\", \"test_issue_3101\", \"test_issue_3103\", \"test_issue_4021\", \"test_sstrrepr\", \"test_infinity\", \"test_full_prec\", \"test_noncommutative\", \"test_empty_printer\", \"test_settings\", \"test_RandomDomain\", \"test_FiniteSet\", \"test_PrettyPoly\", \"test_categories\", \"test_Tr\", \"test_issue_6387\", \"test_MatMul_MatAdd\", \"test_MatrixSlice\", \"test_true_false\", \"test_Equivalent\", \"test_Xor\", \"test_Complement\", \"test_SymmetricDifference\"]",
  "environment_setup_commit": "50b81f9f6be151014501ffac44e5dc6b2416938f",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.076151",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}