{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-21379",
  "base_commit": "624217179aaf8d094e6ff75b7493ad1ee47599b0",
  "patch": "diff --git a/sympy/core/mod.py b/sympy/core/mod.py\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -40,6 +40,7 @@ def eval(cls, p, q):\n         from sympy.core.mul import Mul\n         from sympy.core.singleton import S\n         from sympy.core.exprtools import gcd_terms\n+        from sympy.polys.polyerrors import PolynomialError\n         from sympy.polys.polytools import gcd\n \n         def doit(p, q):\n@@ -166,10 +167,13 @@ def doit(p, q):\n         # XXX other possibilities?\n \n         # extract gcd; any further simplification should be done by the user\n-        G = gcd(p, q)\n-        if G != 1:\n-            p, q = [\n-                gcd_terms(i/G, clear=False, fraction=False) for i in (p, q)]\n+        try:\n+            G = gcd(p, q)\n+            if G != 1:\n+                p, q = [gcd_terms(i/G, clear=False, fraction=False)\n+                        for i in (p, q)]\n+        except PolynomialError:  # issue 21373\n+            G = S.One\n         pwas, qwas = p, q\n \n         # simplify terms\n",
  "test_patch": "diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1913,6 +1913,16 @@ def test_Mod():\n     assert Mod(x, y).rewrite(floor) == x - y*floor(x/y)\n     assert ((x - Mod(x, y))/y).rewrite(floor) == floor(x/y)\n \n+    # issue 21373\n+    from sympy.functions.elementary.trigonometric import sinh\n+    from sympy.functions.elementary.piecewise import Piecewise\n+\n+    x_r, y_r = symbols('x_r y_r', real=True)\n+    (Piecewise((x_r, y_r > x_r), (y_r, True)) / z) % 1\n+    expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z))\n+    expr.subs({1: 1.0})\n+    sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) * z ** -1.0).is_zero\n+\n \n def test_Mod_Pow():\n     # modular exponentiation\n",
  "problem_statement": "Unexpected `PolynomialError` when using simple `subs()` for particular expressions\nI am seeing weird behavior with `subs` for particular expressions with hyperbolic sinusoids with piecewise arguments. When applying `subs`, I obtain an unexpected `PolynomialError`. For context, I was umbrella-applying a casting from int to float of all int atoms for a bunch of random expressions before using a tensorflow lambdify to avoid potential tensorflow type errors. You can pretend the expression below has a `+ 1` at the end, but below is the MWE that I could produce.\r\n\r\nSee the expression below, and the conditions in which the exception arises.\r\n\r\nSympy version: 1.8.dev\r\n\r\n```python\r\nfrom sympy import *\r\nfrom sympy.core.cache import clear_cache\r\n\r\nx, y, z = symbols('x y z')\r\n\r\nclear_cache()\r\nexpr = exp(sinh(Piecewise((x, y > x), (y, True)) / z))\r\n# This works fine\r\nexpr.subs({1: 1.0})\r\n\r\nclear_cache()\r\nx, y, z = symbols('x y z', real=True)\r\nexpr = exp(sinh(Piecewise((x, y > x), (y, True)) / z))\r\n# This fails with \"PolynomialError: Piecewise generators do not make sense\"\r\nexpr.subs({1: 1.0})  # error\r\n# Now run it again (isympy...) w/o clearing cache and everything works as expected without error\r\nexpr.subs({1: 1.0})\r\n```\r\n\r\nI am not really sure where the issue is, but I think it has something to do with the order of assumptions in this specific type of expression. Here is what I found-\r\n\r\n- The error only (AFAIK) happens with `cosh` or `tanh` in place of `sinh`, otherwise it succeeds\r\n- The error goes away if removing the division by `z`\r\n- The error goes away if removing `exp` (but stays for most unary functions, `sin`, `log`, etc.)\r\n- The error only happens with real symbols for `x` and `y` (`z` does not have to be real)\r\n\r\nNot too sure how to debug this one.\n",
  "hints_text": "Some functions call `Mod` when evaluated. That does not work well with arguments involving `Piecewise` expressions. In particular, calling `gcd` will lead to `PolynomialError`. That error should be caught by something like this:\r\n```\r\n--- a/sympy/core/mod.py\r\n+++ b/sympy/core/mod.py\r\n@@ -40,6 +40,7 @@ def eval(cls, p, q):\r\n         from sympy.core.mul import Mul\r\n         from sympy.core.singleton import S\r\n         from sympy.core.exprtools import gcd_terms\r\n+        from sympy.polys.polyerrors import PolynomialError\r\n         from sympy.polys.polytools import gcd\r\n \r\n         def doit(p, q):\r\n@@ -166,10 +167,13 @@ def doit(p, q):\r\n         # XXX other possibilities?\r\n \r\n         # extract gcd; any further simplification should be done by the user\r\n-        G = gcd(p, q)\r\n-        if G != 1:\r\n-            p, q = [\r\n-                gcd_terms(i/G, clear=False, fraction=False) for i in (p, q)]\r\n+        try:\r\n+            G = gcd(p, q)\r\n+            if G != 1:\r\n+                p, q = [gcd_terms(i/G, clear=False, fraction=False)\r\n+                        for i in (p, q)]\r\n+        except PolynomialError:\r\n+            G = S.One\r\n         pwas, qwas = p, q\r\n \r\n         # simplify terms\r\n```\nI can't seem to reproduce the OP problem. One suggestion for debugging is to disable the cache e.g. `SYMPY_USE_CACHE=no` but if that makes the problem go away then I guess it's to do with caching somehow and I'm not sure how to debug...\r\n\r\nI can see what @jksuom is referring to:\r\n```python\r\nIn [2]: (Piecewise((x, y > x), (y, True)) / z) % 1\r\n---------------------------------------------------------------------------\r\nPolynomialError\r\n```\r\nThat should be fixed.\r\n\r\nAs an aside you might prefer to use `nfloat` rather than `expr.subs({1:1.0})`:\r\nhttps://docs.sympy.org/latest/modules/core.html#sympy.core.function.nfloat\n@oscarbenjamin My apologies - I missed a line in the post recreating the expression with real x/y/z. Here is the minimum code to reproduce (may require running w/o cache):\r\n```python\r\nfrom sympy import *\r\n\r\nx, y, z = symbols('x y z', real=True)\r\nexpr = exp(sinh(Piecewise((x, y > x), (y, True)) / z))\r\nexpr.subs({1: 1.0})\r\n```\r\n\r\nYour code minimally identifies the real problem, however. Thanks for pointing out `nfloat`, but this also induces the exact same error.\r\n\r\n\r\n@jksuom I can confirm that your patch fixes the issue on my end! I can put in a PR, and add the minimal test given by @oscarbenjamin, if you would like\nOkay I can reproduce it now.\r\n\r\nThe PR would be good thanks.\r\n\r\nI think that we also need to figure out what the caching issue is though. The error should be deterministic.\r\n\r\nI was suggesting `nfloat` not to fix this issue but because it's possibly a better way of doing what you suggested. I expect that tensorflow is more efficient with integer exponents than float exponents.\nThis is the full traceback:\r\n```python\r\nTraceback (most recent call last):\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/assumptions.py\", line 454, in getit\r\n    return self._assumptions[fact]\r\nKeyError: 'zero'\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"y.py\", line 5, in <module>\r\n    expr.subs({1: 1.0})\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/basic.py\", line 949, in subs\r\n    rv = rv._subs(old, new, **kwargs)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/cache.py\", line 72, in wrapper\r\n    retval = cfunc(*args, **kwargs)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/basic.py\", line 1063, in _subs\r\n    rv = fallback(self, old, new)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/basic.py\", line 1040, in fallback\r\n    rv = self.func(*args)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/cache.py\", line 72, in wrapper\r\n    retval = cfunc(*args, **kwargs)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/function.py\", line 473, in __new__\r\n    result = super().__new__(cls, *args, **options)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/cache.py\", line 72, in wrapper\r\n    retval = cfunc(*args, **kwargs)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/function.py\", line 285, in __new__\r\n    evaluated = cls.eval(*args)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/functions/elementary/exponential.py\", line 369, in eval\r\n    if arg.is_zero:\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/assumptions.py\", line 458, in getit\r\n    return _ask(fact, self)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/assumptions.py\", line 513, in _ask\r\n    _ask(pk, obj)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/assumptions.py\", line 513, in _ask\r\n    _ask(pk, obj)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/assumptions.py\", line 513, in _ask\r\n    _ask(pk, obj)\r\n  [Previous line repeated 2 more times]\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/assumptions.py\", line 501, in _ask\r\n    a = evaluate(obj)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/functions/elementary/hyperbolic.py\", line 251, in _eval_is_real\r\n    return (im%pi).is_zero\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/decorators.py\", line 266, in _func\r\n    return func(self, other)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/decorators.py\", line 136, in binary_op_wrapper\r\n    return func(self, other)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/expr.py\", line 280, in __mod__\r\n    return Mod(self, other)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/cache.py\", line 72, in wrapper\r\n    retval = cfunc(*args, **kwargs)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/function.py\", line 473, in __new__\r\n    result = super().__new__(cls, *args, **options)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/cache.py\", line 72, in wrapper\r\n    retval = cfunc(*args, **kwargs)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/function.py\", line 285, in __new__\r\n    evaluated = cls.eval(*args)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/mod.py\", line 169, in eval\r\n    G = gcd(p, q)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/polys/polytools.py\", line 5306, in gcd\r\n    (F, G), opt = parallel_poly_from_expr((f, g), *gens, **args)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/polys/polytools.py\", line 4340, in parallel_poly_from_expr\r\n    return _parallel_poly_from_expr(exprs, opt)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/polys/polytools.py\", line 4399, in _parallel_poly_from_expr\r\n    raise PolynomialError(\"Piecewise generators do not make sense\")\r\nsympy.polys.polyerrors.PolynomialError: Piecewise generators do not make sense\r\n```\r\nThe issue arises during a query in the old assumptions. The exponential function checks if its argument is zero here:\r\nhttps://github.com/sympy/sympy/blob/624217179aaf8d094e6ff75b7493ad1ee47599b0/sympy/functions/elementary/exponential.py#L369\r\nThat gives:\r\n```python\r\nIn [1]: x, y, z = symbols('x y z', real=True)\r\n\r\nIn [2]: sinh(Piecewise((x, y > x), (y, True)) * z**-1.0).is_zero\r\n---------------------------------------------------------------------------\r\nKeyError\r\n```\r\nBefore processing the assumptions query the value of the queried assumption is stored as `None` here:\r\nhttps://github.com/sympy/sympy/blob/624217179aaf8d094e6ff75b7493ad1ee47599b0/sympy/core/assumptions.py#L491-L493\r\nThat `None` remains there if an exception is raised during the query:\r\n```python\r\nIn [1]: x, y, z = symbols('x y z', real=True)\r\n\r\nIn [2]: S = sinh(Piecewise((x, y > x), (y, True)) * z**-1.0)\r\n\r\nIn [3]: S._assumptions\r\nOut[3]: {}\r\n\r\nIn [4]: try:\r\n   ...:     S.is_zero\r\n   ...: except Exception as e:\r\n   ...:     print(e)\r\n   ...: \r\nPiecewise generators do not make sense\r\n\r\nIn [5]: S._assumptions\r\nOut[5]: \r\n{'zero': None,\r\n 'extended_positive': None,\r\n 'extended_real': None,\r\n 'negative': None,\r\n 'commutative': True,\r\n 'extended_negative': None,\r\n 'positive': None,\r\n 'real': None}\r\n```\r\nA subsequent call to create the same expression returns the same object due to the cache and the object still has `None` is its assumptions dict:\r\n```python\r\nIn [6]: S2 = sinh(Piecewise((x, y > x), (y, True)) * z**-1.0)\r\n\r\nIn [7]: S2 is S\r\nOut[7]: True\r\n\r\nIn [8]: S2._assumptions\r\nOut[8]: \r\n{'zero': None,\r\n 'extended_positive': None,\r\n 'extended_real': None,\r\n 'negative': None,\r\n 'commutative': True,\r\n 'extended_negative': None,\r\n 'positive': None,\r\n 'real': None}\r\n\r\nIn [9]: S2.is_zero\r\n\r\nIn [10]: exp(sinh(Piecewise((x, y > x), (y, True)) * z**-1.0))\r\nOut[10]: \r\n     ⎛ -1.0 ⎛⎧x  for x < y⎞⎞\r\n sinh⎜z    ⋅⎜⎨            ⎟⎟\r\n     ⎝      ⎝⎩y  otherwise⎠⎠\r\nℯ  \r\n```\r\nSubsequent `is_zero` checks just return `None` from the assumptions dict without calling the handlers so they pass without raising.\r\n\r\nThe reason the `is_zero` handler raises first time around is due to the `sinh.is_real` handler which does this:\r\nhttps://github.com/sympy/sympy/blob/624217179aaf8d094e6ff75b7493ad1ee47599b0/sympy/functions/elementary/hyperbolic.py#L250-L251\r\nThe `%` leads to `Mod` with the Piecewise which calls `gcd` as @jksuom showed above.\r\n\r\nThere are a few separate issues here:\r\n\r\n1. The old assumptions system stores `None` when running a query but doesn't remove that `None` when an exception is raised.\r\n2. `Mod` calls `gcd` on the argument when it is a Piecewise and `gcd` without catching the possible exception..\r\n3. The `gcd` function raises an exception when given a `Piecewise`.\r\n\r\nThe fix suggested by @jksuom is for 2. which seems reasonable and I think we can merge a PR for that to fix using `Piecewise` with `Mod`.\r\n\r\nI wonder about 3. as well though. Should `gcd` with a `Piecewise` raise an exception? If so then maybe `Mod` shouldn't be calling `gcd` at all. Perhaps just something like `gcd_terms` or `factor_terms` should be used there.\r\n\r\nFor point 1. I think that really the best solution is not putting `None` into the assumptions dict at all as there are other ways that it can lead to non-deterministic behaviour. Removing that line leads to a lot of different examples of RecursionError though (personally I consider each of those to be a bug in the old assumptions system).\nI'll put a PR together. And, ah I see, yes you are right - good point (regarding TF float exponents).\r\n\r\nI cannot comment on 1 as I'm not really familiar with the assumptions systems. But, regarding 3, would this exception make more sense as a `NotImplementedError` in `gcd`? Consider the potential behavior where `gcd` is applied to each condition of a `Piecewise` expression:\r\n\r\n```python\r\nIn [1]: expr = Piecewise((x, x > 2), (2, True))\r\n\r\nIn [2]: expr\r\nOut[2]: \r\n⎧x  for x > 2\r\n⎨            \r\n⎩2  otherwise\r\n\r\nIn [3]: gcd(x, x)\r\nOut[3]: x\r\n\r\nIn [4]: gcd(2, x)\r\nOut[4]: 1\r\n\r\nIn [5]: gcd(expr, x)  # current behavior\r\nPolynomialError: Piecewise generators do not make sense\r\n\r\nIn [6]: gcd(expr, x)  # potential new behavior?\r\nOut[6]: \r\n⎧x  for x > 2\r\n⎨            \r\n⎩1  otherwise\r\n```\r\n\r\nThat would be what I expect from `gcd` here. For the `gcd` of two `Piecewise` expressions, this gets messier and I think would involve intersecting sets of conditions.",
  "created_at": "2021-04-24T19:49:52Z",
  "version": "1.9",
  "FAIL_TO_PASS": "[\"test_Mod\"]",
  "PASS_TO_PASS": "[\"test_bug1\", \"test_Symbol\", \"test_arit0\", \"test_div\", \"test_pow\", \"test_pow2\", \"test_pow3\", \"test_mod_pow\", \"test_pow_E\", \"test_pow_issue_3516\", \"test_pow_im\", \"test_real_mul\", \"test_ncmul\", \"test_mul_add_identity\", \"test_ncpow\", \"test_powerbug\", \"test_Mul_doesnt_expand_exp\", \"test_Mul_is_integer\", \"test_Add_Mul_is_integer\", \"test_Add_Mul_is_finite\", \"test_Mul_is_even_odd\", \"test_evenness_in_ternary_integer_product_with_even\", \"test_oddness_in_ternary_integer_product_with_even\", \"test_Mul_is_rational\", \"test_Add_is_rational\", \"test_Add_is_even_odd\", \"test_Mul_is_negative_positive\", \"test_Mul_is_negative_positive_2\", \"test_Mul_is_nonpositive_nonnegative\", \"test_Add_is_negative_positive\", \"test_Add_is_nonpositive_nonnegative\", \"test_Pow_is_integer\", \"test_Pow_is_real\", \"test_real_Pow\", \"test_Pow_is_finite\", \"test_Pow_is_even_odd\", \"test_Pow_is_negative_positive\", \"test_Pow_is_zero\", \"test_Pow_is_nonpositive_nonnegative\", \"test_Mul_is_imaginary_real\", \"test_Mul_hermitian_antihermitian\", \"test_Add_is_comparable\", \"test_Mul_is_comparable\", \"test_Pow_is_comparable\", \"test_Add_is_positive_2\", \"test_Add_is_irrational\", \"test_Mul_is_irrational\", \"test_issue_3531\", \"test_issue_3531b\", \"test_bug3\", \"test_suppressed_evaluation\", \"test_AssocOp_doit\", \"test_Add_Mul_Expr_args\", \"test_Add_as_coeff_mul\", \"test_Pow_as_coeff_mul_doesnt_expand\", \"test_issue_3514_18626\", \"test_make_args\", \"test_issue_5126\", \"test_Rational_as_content_primitive\", \"test_Add_as_content_primitive\", \"test_Mul_as_content_primitive\", \"test_Pow_as_content_primitive\", \"test_issue_5460\", \"test_product_irrational\", \"test_issue_5919\", \"test_Mod_Pow\", \"test_Mod_is_integer\", \"test_Mod_is_nonposneg\", \"test_issue_6001\", \"test_polar\", \"test_issue_6040\", \"test_issue_6082\", \"test_issue_6077\", \"test_mul_flatten_oo\", \"test_add_flatten\", \"test_issue_5160_6087_6089_6090\", \"test_float_int_round\", \"test_issue_6611a\", \"test_denest_add_mul\", \"test_mul_coeff\", \"test_mul_zero_detection\", \"test_Mul_with_zero_infinite\", \"test_Mul_does_not_cancel_infinities\", \"test_Mul_does_not_distribute_infinity\", \"test_issue_8247_8354\", \"test_Add_is_zero\", \"test_issue_14392\", \"test_divmod\", \"test__neg__\", \"test_issue_18507\", \"test_issue_17130\"]",
  "environment_setup_commit": "f9a6f50ec0c74d935c50a6e9c9b2cb0469570d91",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.143155",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}