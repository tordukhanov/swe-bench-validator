{
  "repo": "django/django",
  "instance_id": "django__django-11374",
  "base_commit": "1d25354fb5f87d35968cd78b53d9560fd75f5b1a",
  "patch": "diff --git a/django/utils/http.py b/django/utils/http.py\n--- a/django/utils/http.py\n+++ b/django/utils/http.py\n@@ -116,7 +116,7 @@ def urlencode(query, doseq=False):\n                 'Cannot encode None in a query string. Did you mean to pass '\n                 'an empty string or omit the value?'\n             )\n-        elif isinstance(value, (str, bytes)):\n+        elif isinstance(value, (str, bytes)) or not doseq:\n             query_val = value\n         else:\n             try:\n@@ -124,7 +124,7 @@ def urlencode(query, doseq=False):\n             except TypeError:\n                 query_val = value\n             else:\n-                # Consume generators and iterators, even when doseq=True, to\n+                # Consume generators and iterators, when doseq=True, to\n                 # work around https://bugs.python.org/issue31706.\n                 query_val = []\n                 for item in itr:\n",
  "test_patch": "diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -34,7 +34,20 @@ def test_dict(self):\n         ])\n \n     def test_dict_containing_sequence_not_doseq(self):\n-        self.assertEqual(urlencode({'a': [1, 2]}, doseq=False), 'a=%5B%271%27%2C+%272%27%5D')\n+        self.assertEqual(urlencode({'a': [1, 2]}, doseq=False), 'a=%5B1%2C+2%5D')\n+\n+    def test_dict_containing_tuple_not_doseq(self):\n+        self.assertEqual(urlencode({'a': (1, 2)}, doseq=False), 'a=%281%2C+2%29')\n+\n+    def test_custom_iterable_not_doseq(self):\n+        class IterableWithStr:\n+            def __str__(self):\n+                return 'custom'\n+\n+            def __iter__(self):\n+                yield from range(0, 3)\n+\n+        self.assertEqual(urlencode({'a': IterableWithStr()}, doseq=False), 'a=custom')\n \n     def test_dict_containing_sequence_doseq(self):\n         self.assertEqual(urlencode({'a': [1, 2]}, doseq=True), 'a=1&a=2')\n@@ -61,14 +74,11 @@ def test_dict_with_sequence_of_bytes(self):\n \n     def test_dict_with_bytearray(self):\n         self.assertEqual(urlencode({'a': bytearray(range(2))}, doseq=True), 'a=0&a=1')\n-        self.assertEqual(urlencode({'a': bytearray(range(2))}, doseq=False), 'a=%5B%270%27%2C+%271%27%5D')\n+        self.assertEqual(urlencode({'a': bytearray(range(2))}, doseq=False), 'a=bytearray%28b%27%5Cx00%5Cx01%27%29')\n \n     def test_generator(self):\n-        def gen():\n-            yield from range(2)\n-\n-        self.assertEqual(urlencode({'a': gen()}, doseq=True), 'a=0&a=1')\n-        self.assertEqual(urlencode({'a': gen()}, doseq=False), 'a=%5B%270%27%2C+%271%27%5D')\n+        self.assertEqual(urlencode({'a': range(2)}, doseq=True), 'a=0&a=1')\n+        self.assertEqual(urlencode({'a': range(2)}, doseq=False), 'a=range%280%2C+2%29')\n \n     def test_none(self):\n         with self.assertRaisesMessage(TypeError, self.cannot_encode_none_msg):\n",
  "problem_statement": "Unexpected behavior for django.utils.http.urlencode\nDescription\n\t\nThe function django.utils.http.urlencode has been changed to give unexpected result for tuple values (and other iterable objects) in the case when no iterations is expected:\n>>> django.utils.http.urlencode(dict(a=('a','b')), doseq=False)\n'a=%5B%27a%27%2C+%27b%27%5D'\nOne would expect the same as the standard library version (Note the first and last characters has been replaced by square brackets):\n>>> urllib.parse.urlencode(dict(a=('a', 'b')), doseq=False)\n'a=%28%27a%27%2C+%27b%27%29'\nIf the value is a list, the result if what one would expect:\n>>> django.utils.http.urlencode(dict(a=['a','b']), doseq=False)\n'a=%5B%27a%27%2C+%27b%27%5D'\n>>> urllib.parse.urlencode(dict(a=['a', 'b']), doseq=False)\n'a=%5B%27a%27%2C+%27b%27%5D'\nNote: This is a problem when one has objects that has a __str__ method defined, returning the value one would want to be in the urlencode result, but the object by coincidence is also iterable.\n",
  "hints_text": "",
  "created_at": "2019-05-16T13:42:34Z",
  "version": "3.0",
  "FAIL_TO_PASS": "[\"test_custom_iterable_not_doseq (utils_tests.test_http.URLEncodeTests)\", \"test_dict_containing_sequence_not_doseq (utils_tests.test_http.URLEncodeTests)\", \"test_dict_containing_tuple_not_doseq (utils_tests.test_http.URLEncodeTests)\", \"test_dict_with_bytearray (utils_tests.test_http.URLEncodeTests)\", \"test_generator (utils_tests.test_http.URLEncodeTests)\"]",
  "PASS_TO_PASS": "[\"test_parsing (utils_tests.test_http.ETagProcessingTests)\", \"test_quoting (utils_tests.test_http.ETagProcessingTests)\", \"test_input_too_large (utils_tests.test_http.Base36IntTests)\", \"test_invalid_literal (utils_tests.test_http.Base36IntTests)\", \"test_negative_input (utils_tests.test_http.Base36IntTests)\", \"test_roundtrip (utils_tests.test_http.Base36IntTests)\", \"test_to_base36_errors (utils_tests.test_http.Base36IntTests)\", \"test_to_int_errors (utils_tests.test_http.Base36IntTests)\", \"test_values (utils_tests.test_http.Base36IntTests)\", \"test_http_date (utils_tests.test_http.HttpDateProcessingTests)\", \"test_parsing_asctime (utils_tests.test_http.HttpDateProcessingTests)\", \"test_parsing_rfc1123 (utils_tests.test_http.HttpDateProcessingTests)\", \"test_parsing_rfc850 (utils_tests.test_http.HttpDateProcessingTests)\", \"test_parsing_year_less_than_70 (utils_tests.test_http.HttpDateProcessingTests)\", \"test (utils_tests.test_http.EscapeLeadingSlashesTests)\", \"test_dict (utils_tests.test_http.URLEncodeTests)\", \"test_dict_containing_empty_sequence_doseq (utils_tests.test_http.URLEncodeTests)\", \"test_dict_containing_sequence_doseq (utils_tests.test_http.URLEncodeTests)\", \"test_dict_with_bytes_values (utils_tests.test_http.URLEncodeTests)\", \"test_dict_with_sequence_of_bytes (utils_tests.test_http.URLEncodeTests)\", \"test_multivaluedict (utils_tests.test_http.URLEncodeTests)\", \"test_none (utils_tests.test_http.URLEncodeTests)\", \"test_none_in_generator (utils_tests.test_http.URLEncodeTests)\", \"test_none_in_sequence (utils_tests.test_http.URLEncodeTests)\", \"test_tuples (utils_tests.test_http.URLEncodeTests)\", \"test_roundtrip (utils_tests.test_http.URLSafeBase64Tests)\", \"test_bad (utils_tests.test_http.IsSameDomainTests)\", \"test_good (utils_tests.test_http.IsSameDomainTests)\", \"test_quote (utils_tests.test_http.URLQuoteTests)\", \"test_quote_plus (utils_tests.test_http.URLQuoteTests)\", \"test_unquote (utils_tests.test_http.URLQuoteTests)\", \"test_unquote_plus (utils_tests.test_http.URLQuoteTests)\", \"test_allowed_hosts_str (utils_tests.test_http.IsSafeURLTests)\", \"test_bad_urls (utils_tests.test_http.IsSafeURLTests)\", \"test_basic_auth (utils_tests.test_http.IsSafeURLTests)\", \"test_good_urls (utils_tests.test_http.IsSafeURLTests)\", \"test_no_allowed_hosts (utils_tests.test_http.IsSafeURLTests)\", \"test_secure_param_https_urls (utils_tests.test_http.IsSafeURLTests)\", \"test_secure_param_non_https_urls (utils_tests.test_http.IsSafeURLTests)\"]",
  "environment_setup_commit": "419a78300f7cd27611196e1e464d50fd0385ff27",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.570129",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}