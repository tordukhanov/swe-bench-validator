{
  "repo": "django/django",
  "instance_id": "django__django-16903",
  "base_commit": "1c4f5f314e2b0c77b3fa0c75f703218e7e06f4be",
  "patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -900,10 +900,12 @@ def save_base(\n \n     save_base.alters_data = True\n \n-    def _save_parents(self, cls, using, update_fields):\n+    def _save_parents(self, cls, using, update_fields, updated_parents=None):\n         \"\"\"Save all the parents of cls using values from self.\"\"\"\n         meta = cls._meta\n         inserted = False\n+        if updated_parents is None:\n+            updated_parents = {}\n         for parent, field in meta.parents.items():\n             # Make sure the link fields are synced between parent and self.\n             if (\n@@ -912,16 +914,23 @@ def _save_parents(self, cls, using, update_fields):\n                 and getattr(self, field.attname) is not None\n             ):\n                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n-            parent_inserted = self._save_parents(\n-                cls=parent, using=using, update_fields=update_fields\n-            )\n-            updated = self._save_table(\n-                cls=parent,\n-                using=using,\n-                update_fields=update_fields,\n-                force_insert=parent_inserted,\n-            )\n-            if not updated:\n+            if (parent_updated := updated_parents.get(parent)) is None:\n+                parent_inserted = self._save_parents(\n+                    cls=parent,\n+                    using=using,\n+                    update_fields=update_fields,\n+                    updated_parents=updated_parents,\n+                )\n+                updated = self._save_table(\n+                    cls=parent,\n+                    using=using,\n+                    update_fields=update_fields,\n+                    force_insert=parent_inserted,\n+                )\n+                if not updated:\n+                    inserted = True\n+                updated_parents[parent] = updated\n+            elif not parent_updated:\n                 inserted = True\n             # Set the parent's PK value to self.\n             if field:\n",
  "test_patch": "diff --git a/tests/model_inheritance/models.py b/tests/model_inheritance/models.py\n--- a/tests/model_inheritance/models.py\n+++ b/tests/model_inheritance/models.py\n@@ -186,3 +186,23 @@ class Child(Parent):\n \n class GrandChild(Child):\n     pass\n+\n+\n+class CommonAncestor(models.Model):\n+    id = models.IntegerField(primary_key=True, default=1)\n+\n+\n+class FirstParent(CommonAncestor):\n+    first_ancestor = models.OneToOneField(\n+        CommonAncestor, models.CASCADE, primary_key=True, parent_link=True\n+    )\n+\n+\n+class SecondParent(CommonAncestor):\n+    second_ancestor = models.OneToOneField(\n+        CommonAncestor, models.CASCADE, primary_key=True, parent_link=True\n+    )\n+\n+\n+class CommonChild(FirstParent, SecondParent):\n+    pass\ndiff --git a/tests/model_inheritance/tests.py b/tests/model_inheritance/tests.py\n--- a/tests/model_inheritance/tests.py\n+++ b/tests/model_inheritance/tests.py\n@@ -9,6 +9,7 @@\n from .models import (\n     Base,\n     Chef,\n+    CommonChild,\n     CommonInfo,\n     CustomSupplier,\n     GrandChild,\n@@ -149,6 +150,14 @@ def test_custompk_m2m(self):\n         # accidentally found).\n         self.assertSequenceEqual(s.titles.all(), [])\n \n+    def test_create_diamond_mti_default_pk(self):\n+        # 1 INSERT for each base.\n+        with self.assertNumQueries(4):\n+            common_child = CommonChild.objects.create()\n+        # 3 SELECTs for the parents, 1 UPDATE for the child.\n+        with self.assertNumQueries(4):\n+            common_child.save()\n+\n     def test_update_parent_filtering(self):\n         \"\"\"\n         Updating a field of a model subclass doesn't issue an UPDATE\n",
  "problem_statement": "Diamond inheritance causes duplicated PK error when creating an object, if the primary key field has a default.\nDescription\n\t\nHi, I'm not sure if this is a bug or an unsupported feature. But I looked into the django/db/models/base.py source code and now have a pretty good understanding of what is happening. \nMy business code uses a diamond shape inheritance to model different types of user posts: UserPost, ImagePost, VideoPost, and MixedContentPost. The inheritance goes like this: both ImagePost and VideoPost extend from UserPost, and the MixedContentPost inherits from ImagePost and VideoPost. All of them are concrete models\nI read the doc and expected it to work, similar to the example \nclass Piece(models.Model):\n\tpass\nclass Article(Piece):\n\tarticle_piece = models.OneToOneField(Piece, on_delete=models.CASCADE, parent_link=True)\n\t...\nclass Book(Piece):\n\tbook_piece = models.OneToOneField(Piece, on_delete=models.CASCADE, parent_link=True)\n\t...\nclass BookReview(Book, Article):\n\tpass\nHowever, I found out that the doc's example only works when these models use a primary key field that does not have a default. In my case, we are using a UUIDField as the primary key with a default of uuid4. Trying to create a BookReview in our case, causes a django.db.utils.IntegrityError: UNIQUE constraint failed error, because django tries to create the Piece object twice, with the same uuid.\nThe same behavior is found if I used a AutoField on Piece, with a custom default function, such as\nid = 99\ndef increment():\n\tglobal id\n\tid += 1\n\treturn id\nThis default function makes no sense in practice, but I just use it here to illustrate the root cause of the problem:\nThe _save_table method in db/models/base.py has a like this:\n\t\t# Skip an UPDATE when adding an instance and primary key has a default.\n\t\tif (\n\t\t\tnot raw\n\t\t\tand not force_insert\n\t\t\tand self._state.adding\n\t\t\tand meta.pk.default\n\t\t\tand meta.pk.default is not NOT_PROVIDED\n\t\t):\n\t\t\tforce_insert = True\nWhen a default is not present, which is the case of the documentation example, Django will first insert the first instance of the Piece object, and then for the second one, since force_insert is False, _save_table tries an update and goes through. Therefore there is not duplicate.\nHowever, if a default is present, then the second Piece becomes an insertion as well (because meta.pk.default and meta.pk.default is not NOT_PROVIDED, force_insert is True). This causes a duplication on the primary key.\nOn the other hand, _insert_parent does an in-order traversal calling _save_table on each node, so even in the no-default pk case, it is calling a redundant update on the root node after the insertion..\nSo which function is at fault? \nThe source code _save_table assumes that if you are calling it with a default pk then you can skip an update. This assumption looks weird to me: why only when there IS a default pk you can skip update? Why not just skip update as long as we know we are inserting? (via self._state.adding) Is it just to make it special so that AutoField works? If _save_table's responsibility is to try updating before inserting, except when the params force it to do an update or insert, then it shouldn't override that behavior by this self-assumeption within it.\nI think the solution is to simply move the check to save_base. And don't do this check in _save_parents.\nLike this:\n\tdef save_base(\n\t\tself,\n\t\traw=False,\n\t\tforce_insert=False,\n\t\tforce_update=False,\n\t\tusing=None,\n\t\tupdate_fields=None,\n\t):\n\t\t\"\"\"\n\t\tHandle the parts of saving which should be done only once per save,\n\t\tyet need to be done in raw saves, too. This includes some sanity\n\t\tchecks and signal sending.\n\t\tThe 'raw' argument is telling save_base not to save any parent\n\t\tmodels and not to do any changes to the values before save. This\n\t\tis used by fixture loading.\n\t\t\"\"\"\n\t\tusing = using or router.db_for_write(self.__class__, instance=self)\n\t\tassert not (force_insert and (force_update or update_fields))\n\t\tassert update_fields is None or update_fields\n\t\tcls = origin = self.__class__\n\t\t# Skip proxies, but keep the origin as the proxy model.\n\t\tif cls._meta.proxy:\n\t\t\tcls = cls._meta.concrete_model\n\t\tmeta = cls._meta\n\t\tif not meta.auto_created:\n\t\t\tpre_save.send(\n\t\t\t\tsender=origin,\n\t\t\t\tinstance=self,\n\t\t\t\traw=raw,\n\t\t\t\tusing=using,\n\t\t\t\tupdate_fields=update_fields,\n\t\t\t)\n\t\t# A transaction isn't needed if one query is issued.\n\t\tif meta.parents:\n\t\t\tcontext_manager = transaction.atomic(using=using, savepoint=False)\n\t\telse:\n\t\t\tcontext_manager = transaction.mark_for_rollback_on_error(using=using)\n\t\twith context_manager:\n\t\t\tparent_inserted = False\n\t\t\tif not raw:\n\t\t\t\tparent_inserted = self._save_parents(cls, using, update_fields)\n\t\t\t# Skip an UPDATE when adding an instance and primary key has a default.\n\t\t\tif (\n\t\t\t\tnot raw\n\t\t\t\tand not force_insert\n\t\t\t\tand self._state.adding\n\t\t\t\tand meta.pk.default\n\t\t\t\tand meta.pk.default is not NOT_PROVIDED\n\t\t\t):\n\t\t\t\tforce_insert = True\n\t\t\tupdated = self._save_table(\n\t\t\t\traw,\n\t\t\t\tcls,\n\t\t\t\tforce_insert or parent_inserted,\n\t\t\t\tforce_update,\n\t\t\t\tusing,\n\t\t\t\tupdate_fields,\n\t\t\t)\n\t\t# Store the database on which the object was saved\n\t\tself._state.db = using\n\t\t# Once saved, this is no longer a to-be-added instance.\n\t\tself._state.adding = False\n\t\t# Signal that the save is complete\n\t\tif not meta.auto_created:\n\t\t\tpost_save.send(\n\t\t\t\tsender=origin,\n\t\t\t\tinstance=self,\n\t\t\t\tcreated=(not updated),\n\t\t\t\tupdate_fields=update_fields,\n\t\t\t\traw=raw,\n\t\t\t\tusing=using,\n\t\t\t)\n\tsave_base.alters_data = True\nI have never contributed to Django before. If you think I'm right on this one I'll look into creating a PR.\n",
  "hints_text": "Is this project completely community supported? Is there a project lead I can discuss with to confirm my suspicion? Thank you. See this patch for my changes: ​https://github.com/kaleido-public/django/commit/70c00ccff35f039705eb0a748939d4c3d6dbe93a\nYou can create a pull request and see if any tests break.\nThanks for the report. I was able to reproduce this issue. This assumption looks weird to me: why only when there IS a default pk you can skip update? This is an optimization to skip UPDATE when inherited primary key has a default (see babd4126853e48594b61e8db71a83d7bdd929b9c and #29129). Why not just skip update as long as we know we are inserting? (via self._state.adding) As far as I'm aware, this would be contrary to the currently ​documented process. I think the solution is to simply move the check to save_base. And don't do this check in _save_parents. This breaks optimization added in babd4126853e48594b61e8db71a83d7bdd929b9c, see basic.tests.ModelInstanceCreationTests.test_save_parent_primary_with_default. Is this project completely community supported? Yes. Is there a project lead I can discuss with to confirm my suspicion? Thank you. No, we don't have a project lead. You can join the DevelopersMailingList and share your ideas. You can also interact on the ​Django forum and the #django-dev IRC channel.\nThank you for your detailed report. I haven't looked into the details of how this can be addressed but one thing is certain. When an instance of model class at the head of a diamond inheritance graph is saved the ORM knows that there isn't a reason to update involved tables/nodes more than once. In other words, creating a BookReview should only require 4 queries and not 6 and this issue predates babd4126853e48594b61e8db71a83d7bdd929b9c. I believe that's what we should focus on solving here as that will address this unfortunate collision while reducing the number of queries to a minimum. Test coverage for model diamond inheritance is limited given it's a rarely used feature and good core support for fields with Python generated defaults is also relatively recent so I'm not surprised we missed this relatively obscure edge case in #29129.\nAfter a quick investigation it seems like we simply don't have any tests covering diamond inheritance model saves. The only instance of diamond inheritance I could find in the test suite was ​in model_meta tests but this hierarchy of models exists solely for Option testing purposes. Here's what a tentative patch could look like for this issue, it seems to be passing the full suite on SQLite at least. django/db/models/base.py diff --git a/django/db/models/base.py b/django/db/models/base.py index 37f6a3dd58..d363a1ddeb 100644 a b def save_base(self, raw=False, force_insert=False, 823823 824824 save_base.alters_data = True 825825 826 def _save_parents(self, cls, using, update_fields): 826 def _save_parents(self, cls, using, update_fields, saved_parents=None): 827827 \"\"\"Save all the parents of cls using values from self.\"\"\" 828828 meta = cls._meta 829829 inserted = False 830 if saved_parents is None: 831 saved_parents = {} 830832 for parent, field in meta.parents.items(): 831833 # Make sure the link fields are synced between parent and self. 832834 if (field and getattr(self, parent._meta.pk.attname) is None and 833835 getattr(self, field.attname) is not None): 834836 setattr(self, parent._meta.pk.attname, getattr(self, field.attname)) 835 parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields) 836 updated = self._save_table( 837 cls=parent, using=using, update_fields=update_fields, 838 force_insert=parent_inserted, 839 ) 840 if not updated: 837 if (parent_updated := saved_parents.get(parent)) is None: 838 parent_inserted = self._save_parents( 839 cls=parent, using=using, update_fields=update_fields, saved_parents=saved_parents, 840 ) 841 updated = self._save_table( 842 cls=parent, using=using, update_fields=update_fields, 843 force_insert=parent_inserted, 844 ) 845 if not updated: 846 inserted = True 847 saved_parents[parent] = updated 848 elif not parent_updated: 841849 inserted = True 842850 # Set the parent's PK value to self. 843851 if field: tests/model_inheritance/models.py diff --git a/tests/model_inheritance/models.py b/tests/model_inheritance/models.py index fa37e121ea..99ce78a0f0 100644 a b class Child(Parent): 175175 176176class GrandChild(Child): 177177 pass 178 179 180# Diamond inheritance 181class CommonAncestor(models.Model): 182 pass 183 184 185class FirstParent(CommonAncestor): 186 first_ancestor = models.OneToOneField(CommonAncestor, models.CASCADE, primary_key=True, parent_link=True) 187 188 189class SecondParent(CommonAncestor): 190 second_ancestor = models.OneToOneField(CommonAncestor, models.CASCADE, primary_key=True, parent_link=True) 191 192 193class CommonChild(FirstParent, SecondParent): 194 pass tests/model_inheritance/tests.py diff --git a/tests/model_inheritance/tests.py b/tests/model_inheritance/tests.py index 550a297fb3..97fb3e4a78 100644 a b 77from django.test.utils import CaptureQueriesContext, isolate_apps 88 99from .models import ( 10 Base, Chef, CommonInfo, GrandChild, GrandParent, ItalianRestaurant, 10 Base, Chef, CommonInfo, CommonChild, GrandChild, GrandParent, ItalianRestaurant, 1111 MixinModel, Parent, ParkingLot, Place, Post, Restaurant, Student, SubBase, 1212 Supplier, Title, Worker, 1313) … … def b(): 150150 sql = query['sql'] 151151 self.assertIn('INSERT INTO', sql, sql) 152152 153 def test_create_diamond_mti(self): 154 with self.assertNumQueries(4): 155 common_child = CommonChild.objects.create() 156 with self.assertNumQueries(4): 157 common_child.save() 158 153159 def test_eq(self): 154160 # Equality doesn't transfer in multitable inheritance. 155161 self.assertNotEqual(Place(id=1), Restaurant(id=1))",
  "created_at": "2023-05-30T15:18:53Z",
  "version": "5.0",
  "FAIL_TO_PASS": "[\"test_create_diamond_mti_default_pk (model_inheritance.tests.ModelInheritanceTests.test_create_diamond_mti_default_pk)\"]",
  "PASS_TO_PASS": "[\"test_abstract_fk_related_name (model_inheritance.tests.InheritanceSameModelNameTests.test_abstract_fk_related_name)\", \"test_unique (model_inheritance.tests.InheritanceUniqueTests.test_unique)\", \"test_unique_together (model_inheritance.tests.InheritanceUniqueTests.test_unique_together)\", \"test_abstract (model_inheritance.tests.ModelInheritanceTests.test_abstract)\", \"test_abstract_parent_link (model_inheritance.tests.ModelInheritanceTests.test_abstract_parent_link)\", \"Creating a child with non-abstract parents only issues INSERTs.\", \"test_create_copy_with_inherited_m2m (model_inheritance.tests.ModelInheritanceTests.test_create_copy_with_inherited_m2m)\", \"test_custompk_m2m (model_inheritance.tests.ModelInheritanceTests.test_custompk_m2m)\", \"test_eq (model_inheritance.tests.ModelInheritanceTests.test_eq)\", \"test_inherited_ordering_pk_desc (model_inheritance.tests.ModelInheritanceTests.test_inherited_ordering_pk_desc)\", \"test_init_subclass (model_inheritance.tests.ModelInheritanceTests.test_init_subclass)\", \"test_meta_fields_and_ordering (model_inheritance.tests.ModelInheritanceTests.test_meta_fields_and_ordering)\", \"test_mixin_init (model_inheritance.tests.ModelInheritanceTests.test_mixin_init)\", \"test_model_with_distinct_accessors (model_inheritance.tests.ModelInheritanceTests.test_model_with_distinct_accessors)\", \"test_model_with_distinct_related_query_name (model_inheritance.tests.ModelInheritanceTests.test_model_with_distinct_related_query_name)\", \"test_queryset_class_getitem (model_inheritance.tests.ModelInheritanceTests.test_queryset_class_getitem)\", \"test_reverse_relation_for_different_hierarchy_tree (model_inheritance.tests.ModelInheritanceTests.test_reverse_relation_for_different_hierarchy_tree)\", \"test_set_name (model_inheritance.tests.ModelInheritanceTests.test_set_name)\", \"test_shadow_parent_attribute_with_field (model_inheritance.tests.ModelInheritanceTests.test_shadow_parent_attribute_with_field)\", \"test_shadow_parent_method_with_field (model_inheritance.tests.ModelInheritanceTests.test_shadow_parent_method_with_field)\", \"test_shadow_parent_property_with_field (model_inheritance.tests.ModelInheritanceTests.test_shadow_parent_property_with_field)\", \"Updating a field of a model subclass doesn't issue an UPDATE\", \"test_exclude_inherited_on_null (model_inheritance.tests.ModelInheritanceDataTests.test_exclude_inherited_on_null)\", \"test_filter_inherited_model (model_inheritance.tests.ModelInheritanceDataTests.test_filter_inherited_model)\", \"test_filter_inherited_on_null (model_inheritance.tests.ModelInheritanceDataTests.test_filter_inherited_on_null)\", \"test_filter_on_parent_returns_object_of_parent_type (model_inheritance.tests.ModelInheritanceDataTests.test_filter_on_parent_returns_object_of_parent_type)\", \"test_inherited_does_not_exist_exception (model_inheritance.tests.ModelInheritanceDataTests.test_inherited_does_not_exist_exception)\", \"test_inherited_multiple_objects_returned_exception (model_inheritance.tests.ModelInheritanceDataTests.test_inherited_multiple_objects_returned_exception)\", \"test_parent_cache_reuse (model_inheritance.tests.ModelInheritanceDataTests.test_parent_cache_reuse)\", \"test_parent_child_one_to_one_link (model_inheritance.tests.ModelInheritanceDataTests.test_parent_child_one_to_one_link)\", \"test_parent_child_one_to_one_link_on_nonrelated_objects (model_inheritance.tests.ModelInheritanceDataTests.test_parent_child_one_to_one_link_on_nonrelated_objects)\", \"test_parent_fields_available_for_filtering_in_child_model (model_inheritance.tests.ModelInheritanceDataTests.test_parent_fields_available_for_filtering_in_child_model)\", \"test_related_objects_for_inherited_models (model_inheritance.tests.ModelInheritanceDataTests.test_related_objects_for_inherited_models)\", \"#23370 - Should be able to defer child fields when using\", \"test_select_related_works_on_parent_model_fields (model_inheritance.tests.ModelInheritanceDataTests.test_select_related_works_on_parent_model_fields)\", \"test_update_inherited_model (model_inheritance.tests.ModelInheritanceDataTests.test_update_inherited_model)\", \"Update queries do not generate unnecessary queries (#18304).\", \"test_update_works_on_parent_and_child_models_at_once (model_inheritance.tests.ModelInheritanceDataTests.test_update_works_on_parent_and_child_models_at_once)\", \"test_values_works_on_parent_model_fields (model_inheritance.tests.ModelInheritanceDataTests.test_values_works_on_parent_model_fields)\"]",
  "environment_setup_commit": "4a72da71001f154ea60906a2f74898d32b7322a7",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.775503",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}