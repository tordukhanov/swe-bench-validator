{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-21370",
  "base_commit": "e5e0bfa9d08de736055f338f926327157149b019",
  "patch": "diff --git a/sympy/core/exprtools.py b/sympy/core/exprtools.py\n--- a/sympy/core/exprtools.py\n+++ b/sympy/core/exprtools.py\n@@ -363,7 +363,7 @@ def __init__(self, factors=None):  # Factors\n                     factors[q] = (factors[q] if q in factors else S.Zero) - factors[f]\n                     factors.pop(f)\n             if i:\n-                factors[I] = S.One*i\n+                factors[I] = factors.get(I, S.Zero) + i\n             if nc:\n                 factors[Mul(*nc, evaluate=False)] = S.One\n         else:\n@@ -388,9 +388,7 @@ def __init__(self, factors=None):  # Factors\n                         elif a is I:\n                             factors[I] = S.One\n                         elif a.is_Pow:\n-                            if S.NegativeOne not in factors:\n-                                factors[S.NegativeOne] = S.Zero\n-                            factors[S.NegativeOne] += a.exp\n+                            factors[a.base] = factors.get(a.base, S.Zero) + a.exp\n                         elif a == 1:\n                             factors[a] = S.One\n                         elif a == -1:\ndiff --git a/sympy/polys/numberfields.py b/sympy/polys/numberfields.py\n--- a/sympy/polys/numberfields.py\n+++ b/sympy/polys/numberfields.py\n@@ -14,6 +14,8 @@\n from sympy.functions.elementary.trigonometric import cos, sin\n from sympy.ntheory import sieve\n from sympy.ntheory.factor_ import divisors\n+from sympy.utilities.iterables import subsets\n+\n from sympy.polys.densetools import dup_eval\n from sympy.polys.domains import ZZ, QQ\n from sympy.polys.orthopolys import dup_chebyshevt\n@@ -48,39 +50,50 @@ def _choose_factor(factors, x, v, dom=QQ, prec=200, bound=5):\n     Return a factor having root ``v``\n     It is assumed that one of the factors has root ``v``.\n     \"\"\"\n+    from sympy.polys.polyutils import illegal\n+\n     if isinstance(factors[0], tuple):\n         factors = [f[0] for f in factors]\n     if len(factors) == 1:\n         return factors[0]\n \n-    points = {x:v}\n+    prec1 = 10\n+    points = {}\n     symbols = dom.symbols if hasattr(dom, 'symbols') else []\n-    t = QQ(1, 10)\n-\n-    for n in range(bound**len(symbols)):\n-        prec1 = 10\n-        n_temp = n\n-        for s in symbols:\n-            points[s] = n_temp % bound\n-            n_temp = n_temp // bound\n-\n-        while True:\n-            candidates = []\n-            eps = t**(prec1 // 2)\n-            for f in factors:\n-                if abs(f.as_expr().evalf(prec1, points)) < eps:\n-                    candidates.append(f)\n-            if candidates:\n-                factors = candidates\n-            if len(factors) == 1:\n-                return factors[0]\n-            if prec1 > prec:\n-                break\n-            prec1 *= 2\n+    while prec1 <= prec:\n+        # when dealing with non-Rational numbers we usually evaluate\n+        # with `subs` argument but we only need a ballpark evaluation\n+        xv = {x:v if not v.is_number else v.n(prec1)}\n+        fe = [f.as_expr().xreplace(xv) for f in factors]\n+\n+        # assign integers [0, n) to symbols (if any)\n+        for n in subsets(range(bound), k=len(symbols), repetition=True):\n+            for s, i in zip(symbols, n):\n+                points[s] = i\n+\n+            # evaluate the expression at these points\n+            candidates = [(abs(f.subs(points).n(prec1)), i)\n+                for i,f in enumerate(fe)]\n+\n+            # if we get invalid numbers (e.g. from division by zero)\n+            # we try again\n+            if any(i in illegal for i, _ in candidates):\n+                continue\n+\n+            # find the smallest two -- if they differ significantly\n+            # then we assume we have found the factor that becomes\n+            # 0 when v is substituted into it\n+            can = sorted(candidates)\n+            (a, ix), (b, _) = can[:2]\n+            if b > a * 10**6:  # XXX what to use?\n+                return factors[ix]\n+\n+        prec1 *= 2\n \n     raise NotImplementedError(\"multiple candidates for the minimal polynomial of %s\" % v)\n \n \n+\n def _separate_sq(p):\n     \"\"\"\n     helper function for ``_minimal_polynomial_sq``\n",
  "test_patch": "diff --git a/sympy/core/tests/test_exprtools.py b/sympy/core/tests/test_exprtools.py\n--- a/sympy/core/tests/test_exprtools.py\n+++ b/sympy/core/tests/test_exprtools.py\n@@ -56,6 +56,8 @@ def test_Factors():\n     assert Factors(-I)*I == Factors()\n     assert Factors({S.NegativeOne: S(3)})*Factors({S.NegativeOne: S.One, I: S(5)}) == \\\n         Factors(I)\n+    assert Factors(sqrt(I)*I) == Factors(I**(S(3)/2)) == Factors({I: S(3)/2})\n+    assert Factors({I: S(3)/2}).as_expr() == I**(S(3)/2)\n \n     assert Factors(S(2)**x).div(S(3)**x) == \\\n         (Factors({S(2): x}), Factors({S(3): x}))\ndiff --git a/sympy/polys/tests/test_numberfields.py b/sympy/polys/tests/test_numberfields.py\n--- a/sympy/polys/tests/test_numberfields.py\n+++ b/sympy/polys/tests/test_numberfields.py\n@@ -16,6 +16,7 @@\n     to_number_field,\n     AlgebraicNumber,\n     isolate, IntervalPrinter,\n+    _choose_factor,\n )\n \n from sympy.polys.partfrac import apart\n@@ -115,6 +116,13 @@ def test_minimal_polynomial():\n         sqrt(15)*I/28800000)**(1/3)))''')\n     assert minimal_polynomial(eq, x) == 8000*x**2 - 1\n \n+    ex = (sqrt(5)*sqrt(I)/(5*sqrt(1 + 125*I))\n+            + 25*sqrt(5)/(I**Q(5,2)*(1 + 125*I)**Q(3,2))\n+            + 3125*sqrt(5)/(I**Q(11,2)*(1 + 125*I)**Q(3,2))\n+            + 5*I*sqrt(1 - I/125))\n+    mp = minimal_polynomial(ex, x)\n+    assert mp == 25*x**4 + 5000*x**2 + 250016\n+\n     ex = 1 + sqrt(2) + sqrt(3)\n     mp = minimal_polynomial(ex, x)\n     assert mp == x**4 - 4*x**3 - 4*x**2 + 16*x - 8\n@@ -167,6 +175,22 @@ def test_minimal_polynomial():\n     minimal_polynomial(phi, x) == x**2 - x - 1\n \n \n+def test_minimal_polynomial_issue_19732():\n+    # https://github.com/sympy/sympy/issues/19732\n+    expr = (-280898097948878450887044002323982963174671632174995451265117559518123750720061943079105185551006003416773064305074191140286225850817291393988597615/(-488144716373031204149459129212782509078221364279079444636386844223983756114492222145074506571622290776245390771587888364089507840000000*sqrt(238368341569)*sqrt(S(11918417078450)/63568729\n+    - 24411360*sqrt(238368341569)/63568729) +\n+    238326799225996604451373809274348704114327860564921529846705817404208077866956345381951726531296652901169111729944612727047670549086208000000*sqrt(S(11918417078450)/63568729\n+        - 24411360*sqrt(238368341569)/63568729)) -\n+    180561807339168676696180573852937120123827201075968945871075967679148461189459480842956689723484024031016208588658753107/(-59358007109636562851035004992802812513575019937126272896569856090962677491318275291141463850327474176000000*sqrt(238368341569)*sqrt(S(11918417078450)/63568729\n+        - 24411360*sqrt(238368341569)/63568729) +\n+        28980348180319251787320809875930301310576055074938369007463004788921613896002936637780993064387310446267596800000*sqrt(S(11918417078450)/63568729\n+            - 24411360*sqrt(238368341569)/63568729)))\n+    poly = (2151288870990266634727173620565483054187142169311153766675688628985237817262915166497766867289157986631135400926544697981091151416655364879773546003475813114962656742744975460025956167152918469472166170500512008351638710934022160294849059721218824490226159355197136265032810944357335461128949781377875451881300105989490353140886315677977149440000000000000000000000*x**4\n+            - 5773274155644072033773937864114266313663195672820501581692669271302387257492905909558846459600429795784309388968498783843631580008547382703258503404023153694528041873101120067477617592651525155101107144042679962433039557235772239171616433004024998230222455940044709064078962397144550855715640331680262171410099614469231080995436488414164502751395405398078353242072696360734131090111239998110773292915337556205692674790561090109440000000000000*x**2\n+            + 211295968822207088328287206509522887719741955693091053353263782924470627623790749534705683380138972642560898936171035770539616881000369889020398551821767092685775598633794696371561234818461806577723412581353857653829324364446419444210520602157621008010129702779407422072249192199762604318993590841636967747488049176548615614290254356975376588506729604345612047361483789518445332415765213187893207704958013682516462853001964919444736320672860140355089)\n+    assert minimal_polynomial(expr, x) == poly\n+\n+\n def test_minimal_polynomial_hi_prec():\n     p = 1/sqrt(1 - 9*sqrt(2) + 7*sqrt(3) + Rational(1, 10)**30)\n     mp = minimal_polynomial(p, x)\n@@ -278,6 +302,12 @@ def test_minpoly_issue_7574():\n     assert minimal_polynomial(ex, x) == x + 1\n \n \n+def test_choose_factor():\n+    # Test that this does not enter an infinite loop:\n+    bad_factors = [Poly(x-2, x), Poly(x+2, x)]\n+    raises(NotImplementedError, lambda: _choose_factor(bad_factors, x, sqrt(3)))\n+\n+\n def test_primitive_element():\n     assert primitive_element([sqrt(2)], x) == (x**2 - 2, [1])\n     assert primitive_element(\n",
  "problem_statement": "minpoly fails for complicated algebraic number\nGiven\r\n```python\r\nres = Add(Mul(Integer(-1), Integer(180561807339168676696180573852937120123827201075968945871075967679148461189459480842956689723484024031016208588658753107), Pow(Add(Mul(Integer(-1), Integer(59358007109636562851035004992802812513575019937126272896569856090962677491318275291141463850327474176000000), Pow(Integer(238368341569), Rational(1, 2)), Pow(Add(Rational(11918417078450, 63568729), Mul(Integer(-1), Rational(24411360, 63568729), Pow(Integer(238368341569), Rational(1, 2)))), Rational(1, 2))), Mul(Integer(28980348180319251787320809875930301310576055074938369007463004788921613896002936637780993064387310446267596800000), Pow(Add(Rational(11918417078450, 63568729), Mul(Integer(-1), Rational(24411360, 63568729), Pow(Integer(238368341569), Rational(1, 2)))), Rational(1, 2)))), Integer(-1))), Mul(Rational(4147945765885450789314388167435907949934483691690666864020285258508371044738450436444552927847213645745267670947, 113381606935163686700437734397823369297496007026370882733475391347475983700388396552567644615375415301921585126967898490840378862984673089105656831541248000000), Pow(Integer(238368341569), Rational(1, 2)), Pow(Add(Rational(11918417078450, 63568729), Mul(Integer(-1), Rational(24411360, 63568729), Pow(Integer(238368341569), Rational(1, 2)))), Rational(-1, 2)), Add(Mul(Rational(91717984946399096916006871140088538821154865311861505541341432860053575049000000, 65987423134383642610502609363902432363342791121), Pow(Add(Float('187488.67982636558', precision=53), Mul(Integer(-1), Rational(24411360, 63568729), Pow(Integer(238368341569), Rational(1, 2)))), Rational(1, 2))), Integer(65987423134383642610502609363902432363342791121))))\r\n```\r\nI get:\r\n```\r\nIn [14]: minpoly(res)                                                                                                                          \r\n---------------------------------------------------------------------------\r\nNotImplementedError                       Traceback (most recent call last)\r\n<ipython-input-14-a3b1550cf0cb> in <module>\r\n----> 1 minpoly(res)\r\n\r\n~/current/sympy/sympy/sympy/polys/numberfields.py in minimal_polynomial(ex, x, compose, polys, domain)\r\n    670 \r\n    671     if compose:\r\n--> 672         result = _minpoly_compose(ex, x, domain)\r\n    673         result = result.primitive()[1]\r\n    674         c = result.coeff(x**degree(result, x))\r\n\r\n~/current/sympy/sympy/sympy/polys/numberfields.py in _minpoly_compose(ex, x, dom)\r\n    549 \r\n    550     if ex.is_Add:\r\n--> 551         res = _minpoly_add(x, dom, *ex.args)\r\n    552     elif ex.is_Mul:\r\n    553         f = Factors(ex).factors\r\n\r\n~/current/sympy/sympy/sympy/polys/numberfields.py in _minpoly_add(x, dom, *a)\r\n    361     returns ``minpoly(Add(*a), dom, x)``\r\n    362     \"\"\"\r\n--> 363     mp = _minpoly_op_algebraic_element(Add, a[0], a[1], x, dom)\r\n    364     p = a[0] + a[1]\r\n    365     for px in a[2:]:\r\n\r\n~/current/sympy/sympy/sympy/polys/numberfields.py in _minpoly_op_algebraic_element(op, ex1, ex2, x, dom, mp1, mp2)\r\n    278     r = Poly(r, x, domain=dom)\r\n    279     _, factors = r.factor_list()\r\n--> 280     res = _choose_factor(factors, x, op(ex1, ex2), dom)\r\n    281     return res.as_expr()\r\n    282 \r\n\r\n~/current/sympy/sympy/sympy/polys/numberfields.py in _choose_factor(factors, x, v, dom, prec, bound)\r\n     79             prec1 *= 2\r\n     80 \r\n---> 81     raise NotImplementedError(\"multiple candidates for the minimal polynomial of %s\" % v)\r\n     82 \r\n     83 \r\n\r\nNotImplementedError: multiple candidates for the minimal polynomial of -180561807339168676696180573852937120123827201075968945871075967679148461189459480842956689723484024031016208588658753107/(-59358007109636562851035004992802812513575019937126272896569856090962677491318275291141463850327474176000000*sqrt(238368341569)*sqrt(11918417078450/63568729 - 24411360*sqrt(238368341569)/63568729) + 28980348180319251787320809875930301310576055074938369007463004788921613896002936637780993064387310446267596800000*sqrt(11918417078450/63568729 - 24411360*sqrt(238368341569)/63568729)) + 4147945765885450789314388167435907949934483691690666864020285258508371044738450436444552927847213645745267670947*sqrt(238368341569)/(1718230558939414944958212067529897587678479820358393800041489414608007783126133298212707321630403291250688000000*sqrt(11918417078450/63568729 - 24411360*sqrt(238368341569)/63568729))\r\n> /Users/enojb/current/sympy/sympy/sympy/polys/numberfields.py(81)_choose_factor()\r\n     79             prec1 *= 2\r\n     80 \r\n---> 81     raise NotImplementedError(\"multiple candidates for the minimal polynomial of %s\" % v)\r\n     82 \r\n     83 \r\n```\n",
  "hints_text": "I don't think that `minpoly` can be expected to work reliably with expressions that contain Floats (`RR` is not \"exact\"). They could be first replaced by Rationals`. Maybe `minpoly` should do that automatically.\nIt isn't supposed to have floats. I messed up getting the srepr. This is it:\r\n```\r\nres = Add(Mul(Integer(-1), Integer(280898097948878450887044002323982963174671632174995451265117559518123750720061943079105185551006003416773064305074191140286225850817291393988597615), Pow(Add(Mul(Integer(-1), Integer(488144716373031204149459129212782509078221364279079444636386844223983756114492222145074506571622290776245390771587888364089507840000000), Pow(Integer(238368341569), Rational(1, 2)), Pow(Add(Rational(11918417078450, 63568729), Mul(Integer(-1), Rational(24411360, 63568729), Pow(Integer(238368341569), Rational(1, 2)))), Rational(1, 2))), Mul(Integer(238326799225996604451373809274348704114327860564921529846705817404208077866956345381951726531296652901169111729944612727047670549086208000000), Pow(Add(Rational(11918417078450, 63568729), Mul(Integer(-1), Rational(24411360, 63568729), Pow(Integer(238368341569), Rational(1, 2)))), Rational(1, 2)))), Integer(-1))), Mul(Integer(-1), Integer(180561807339168676696180573852937120123827201075968945871075967679148461189459480842956689723484024031016208588658753107), Pow(Add(Mul(Integer(-1), Integer(59358007109636562851035004992802812513575019937126272896569856090962677491318275291141463850327474176000000), Pow(Integer(238368341569), Rational(1, 2)), Pow(Add(Rational(11918417078450, 63568729), Mul(Integer(-1), Rational(24411360, 63568729), Pow(Integer(238368341569), Rational(1, 2)))), Rational(1, 2))), Mul(Integer(28980348180319251787320809875930301310576055074938369007463004788921613896002936637780993064387310446267596800000), Pow(Add(Rational(11918417078450, 63568729), Mul(Integer(-1), Rational(24411360, 63568729), Pow(Integer(238368341569), Rational(1, 2)))), Rational(1, 2)))), Integer(-1))))\r\n```\r\nThat gives\r\n```julia\r\nIn [7]: res.is_algebraic                                                                                               \r\nOut[7]: True\r\n\r\nIn [8]: minpoly(res)                                                                                                   \r\n---------------------------------------------------------------------------\r\nNotImplementedError                       Traceback (most recent call last)\r\n<ipython-input-8-a3b1550cf0cb> in <module>\r\n----> 1 minpoly(res)\r\n\r\n~/current/sympy/sympy/sympy/polys/numberfields.py in minimal_polynomial(ex, x, compose, polys, domain)\r\n    670 \r\n    671     if compose:\r\n--> 672         result = _minpoly_compose(ex, x, domain)\r\n    673         result = result.primitive()[1]\r\n    674         c = result.coeff(x**degree(result, x))\r\n\r\n~/current/sympy/sympy/sympy/polys/numberfields.py in _minpoly_compose(ex, x, dom)\r\n    549 \r\n    550     if ex.is_Add:\r\n--> 551         res = _minpoly_add(x, dom, *ex.args)\r\n    552     elif ex.is_Mul:\r\n    553         f = Factors(ex).factors\r\n\r\n~/current/sympy/sympy/sympy/polys/numberfields.py in _minpoly_add(x, dom, *a)\r\n    361     returns ``minpoly(Add(*a), dom, x)``\r\n    362     \"\"\"\r\n--> 363     mp = _minpoly_op_algebraic_element(Add, a[0], a[1], x, dom)\r\n    364     p = a[0] + a[1]\r\n    365     for px in a[2:]:\r\n\r\n~/current/sympy/sympy/sympy/polys/numberfields.py in _minpoly_op_algebraic_element(op, ex1, ex2, x, dom, mp1, mp2)\r\n    241     y = Dummy(str(x))\r\n    242     if mp1 is None:\r\n--> 243         mp1 = _minpoly_compose(ex1, x, dom)\r\n    244     if mp2 is None:\r\n    245         mp2 = _minpoly_compose(ex2, y, dom)\r\n\r\n~/current/sympy/sympy/sympy/polys/numberfields.py in _minpoly_compose(ex, x, dom)\r\n    562             nums = [base**(y.p*lcmdens // y.q) for base, y in r1.items()]\r\n    563             ex2 = Mul(*nums)\r\n--> 564             mp1 = minimal_polynomial(ex1, x)\r\n    565             # use the fact that in SymPy canonicalization products of integers\r\n    566             # raised to rational powers are organized in relatively prime\r\n\r\n~/current/sympy/sympy/sympy/polys/numberfields.py in minimal_polynomial(ex, x, compose, polys, domain)\r\n    670 \r\n    671     if compose:\r\n--> 672         result = _minpoly_compose(ex, x, domain)\r\n    673         result = result.primitive()[1]\r\n    674         c = result.coeff(x**degree(result, x))\r\n\r\n~/current/sympy/sympy/sympy/polys/numberfields.py in _minpoly_compose(ex, x, dom)\r\n    574             res = _minpoly_mul(x, dom, *ex.args)\r\n    575     elif ex.is_Pow:\r\n--> 576         res = _minpoly_pow(ex.base, ex.exp, x, dom)\r\n    577     elif ex.__class__ is sin:\r\n    578         res = _minpoly_sin(ex, x)\r\n\r\n~/current/sympy/sympy/sympy/polys/numberfields.py in _minpoly_pow(ex, pw, x, dom, mp)\r\n    336     pw = sympify(pw)\r\n    337     if not mp:\r\n--> 338         mp = _minpoly_compose(ex, x, dom)\r\n    339     if not pw.is_rational:\r\n    340         raise NotAlgebraic(\"%s doesn't seem to be an algebraic element\" % ex)\r\n\r\n~/current/sympy/sympy/sympy/polys/numberfields.py in _minpoly_compose(ex, x, dom)\r\n    549 \r\n    550     if ex.is_Add:\r\n--> 551         res = _minpoly_add(x, dom, *ex.args)\r\n    552     elif ex.is_Mul:\r\n    553         f = Factors(ex).factors\r\n\r\n~/current/sympy/sympy/sympy/polys/numberfields.py in _minpoly_add(x, dom, *a)\r\n    361     returns ``minpoly(Add(*a), dom, x)``\r\n    362     \"\"\"\r\n--> 363     mp = _minpoly_op_algebraic_element(Add, a[0], a[1], x, dom)\r\n    364     p = a[0] + a[1]\r\n    365     for px in a[2:]:\r\n\r\n~/current/sympy/sympy/sympy/polys/numberfields.py in _minpoly_op_algebraic_element(op, ex1, ex2, x, dom, mp1, mp2)\r\n    278     r = Poly(r, x, domain=dom)\r\n    279     _, factors = r.factor_list()\r\n--> 280     res = _choose_factor(factors, x, op(ex1, ex2), dom)\r\n    281     return res.as_expr()\r\n    282 \r\n\r\n~/current/sympy/sympy/sympy/polys/numberfields.py in _choose_factor(factors, x, v, dom, prec, bound)\r\n     79             prec1 *= 2\r\n     80 \r\n---> 81     raise NotImplementedError(\"multiple candidates for the minimal polynomial of %s\" % v)\r\n     82 \r\n     83 \r\n\r\nNotImplementedError: multiple candidates for the minimal polynomial of -488144716373031204149459129212782509078221364279079444636386844223983756114492222145074506571622290776245390771587888364089507840000000*sqrt(238368341569)*sqrt(11918417078450/63568729 - 24411360*sqrt(238368341569)/63568729) + 238326799225996604451373809274348704114327860564921529846705817404208077866956345381951726531296652901169111729944612727047670549086208000000*sqrt(11918417078450/63568729 - 24411360*sqrt(238368341569)/63568729)\r\n```\nComputing the minimal polynomial using Groebner bases gives a result:\r\n```python\r\n>>> p_groebner = minpoly(res, compose=False)\r\n```\r\nbut it seems to be incorrect:\r\n```python\r\n>>> N(res)\r\n-1.63818039957219e+39\r\n>>> list(map(N, real_roots(p_groebner)))\r\n[-27221879386.9438, -6.30292221711154e-16, 6.30292221711154e-16, 27221879386.9438]\r\n```\nExtending the precision of `_choose_factor` in `sympy/polys/numberfields.py` from `200` to `2000`\r\n\r\n```python\r\n[...]\r\ndef _choose_factor(factors, x, v, dom=QQ, prec=2000, bound=5):\r\n[...]\r\n```\r\nmakes the default method work:\r\n\r\n```python\r\n>>> p_compose = minpoly(res)\r\n>>> list(map(N, real_roots(p_compose)))\r\n[-1.63818039957219e+39, -6049.70941983707, 6049.70941983707, 1.63818039957219e+39]\r\n>>> N(res)\r\n-1.63818039957219e+39\r\n```\nThe problem is in the `_choose_factor` function:\r\nhttps://github.com/sympy/sympy/blob/fe44a9396123e7fbfa1401da5e9384ca073272be/sympy/polys/numberfields.py#L46\r\n\r\nThis loop exits because the precision gets too large:\r\nhttps://github.com/sympy/sympy/blob/fe44a9396123e7fbfa1401da5e9384ca073272be/sympy/polys/numberfields.py#L67-L81\r\n\r\nAt the point when it fails we have:\r\n```\r\nipdb> f.as_expr().evalf(2, points)                                                                                     \r\n-2.2e+511\r\nipdb> float(eps)                                                                                                       \r\n1e-160\r\nipdb> p prec1                                                                                                          \r\n320\r\nipdb> p prec                                                                                                           \r\n200\r\n```\r\nThe loop is trying to distinguish which of the polynomials in factors has the value from points as a root:\r\n```\r\nipdb> factors[0].as_expr().evalf(20, points)                                                                           \r\n-0.e+361\r\nipdb> factors[1].as_expr().evalf(20, points)                                                                           \r\n4.5659786618091374483e+572\r\nipdb> factors[2].as_expr().evalf(20, points)                                                                           \r\n4.5067149186395800394e+572\r\nipdb> factors[3].as_expr().evalf(20, points)                                                                           \r\n2.5048552185864658024e+501\r\n```\r\nThe problem is that we need to use about 600 digits of precision to say that `factors[1,2,3]` are giving non-zero.\r\n\r\nWith this diff\r\n```diff\r\ndiff --git a/sympy/polys/numberfields.py b/sympy/polys/numberfields.py\r\nindex d10f04eb1e..885034d0c0 100644\r\n--- a/sympy/polys/numberfields.py\r\n+++ b/sympy/polys/numberfields.py\r\n@@ -43,7 +43,7 @@\r\n \r\n \r\n \r\n-def _choose_factor(factors, x, v, dom=QQ, prec=200, bound=5):\r\n+def _choose_factor(factors, x, v, dom=QQ, prec=1000, bound=5):\r\n     \"\"\"\r\n     Return a factor having root ``v``\r\n     It is assumed that one of the factors has root ``v``.\r\n```\r\nwe can get\r\n```julia\r\nIn [9]: p = minpoly(res, x)                                                                                            \r\n\r\nIn [10]: p.subs(x, res).simplify()                                                                                     \r\nOut[10]: 0\r\n```\r\nObviously there needs to be some limit on the precision though so maybe there could be a better way...\n> Obviously there needs to be some limit on the precision\r\n\r\nwhy? under appropriate assumptions (maybe fulfilled when trying to compute a minimal polynomial?) there should be only one factor vanishing at the given value. But if the precision limit is really needed, it should be added as a parameter to the function `minimal_polynomial`, I think.\r\n\r\nbtw: i do not understand the role of the parameter `bound`. Could there be situations when the default value of `5` is not sufficient?\nThere needs to be a limit on the precision because otherwise the calculation can become very expensive or can hit an infinite loop.\r\n\r\nActually though I wonder why `eps` needs to be so small. Generally if evalf can compute 2 digits of precision then it can tell you whether something that is non-zero is non-zero. If `evalf(2)` incorrectly gives a non-zero result with precision then that's a bug in evalf that should be fixed.\r\n\r\nMaybe I've misunderstood the intent of the algorithm...\r\n\r\n> Could there be situations when the default value of `5` is not sufficient?\r\n\r\nNot sure. I haven't looked at this code before...\nThis seems to work:\r\n```diff\r\ndiff --git a/sympy/polys/numberfields.py b/sympy/polys/numberfields.py\r\nindex d10f04eb1e..d37f98a522 100644\r\n--- a/sympy/polys/numberfields.py\r\n+++ b/sympy/polys/numberfields.py\r\n@@ -58,25 +58,21 @@ def _choose_factor(factors, x, v, dom=QQ, prec=200, bound=5):\r\n     t = QQ(1, 10)\r\n \r\n     for n in range(bound**len(symbols)):\r\n-        prec1 = 10\r\n         n_temp = n\r\n         for s in symbols:\r\n             points[s] = n_temp % bound\r\n             n_temp = n_temp // bound\r\n \r\n-        while True:\r\n-            candidates = []\r\n-            eps = t**(prec1 // 2)\r\n-            for f in factors:\r\n-                if abs(f.as_expr().evalf(prec1, points)) < eps:\r\n-                    candidates.append(f)\r\n-            if candidates:\r\n-                factors = candidates\r\n-            if len(factors) == 1:\r\n-                return factors[0]\r\n-            if prec1 > prec:\r\n-                break\r\n-            prec1 *= 2\r\n+        def nonzero(f):\r\n+            n10 = abs(f.as_expr()).evalf(10, points)\r\n+            if n10._prec > 1:\r\n+                return n10 > 0\r\n+\r\n+        candidates = [f for f in factors if not nonzero(f)]\r\n+        if candidates:\r\n+            factors = candidates\r\n+        if len(factors) == 1:\r\n+            return factors[0]\r\n```\r\nIt should be possible to use `.evalf(2, ...)`. The fact that that doesn't work indicates a bug in evalf somewhere.\nThat looks good. The use of fixed `eps` does not make sense as it does not scale with the coefficients of `factors` and the root. I'm not sure under which conditions `_prec` will be 1 but it seems to be a good indication of a very small result.\n>        def nonzero(f):\r\n>            n10 = abs(f.as_expr()).evalf(10, points)\r\n>            if n10._prec > 1:\r\n>                return n10 > 0\r\n\r\nIs the missing return value intended if `n10._prec > 1` does not hold?\r\n\r\nThe parameter `prec` of `_choose_factor` is obsolete then. (It is never used inside numberfields.py)\n> Is the missing return value intended if `n10._prec > 1` does not hold?\r\n\r\nIt is. Perhaps it could be set explicitly to `return False` but this works anyway because `None` is falsey.\r\n\r\n> The parameter `prec` of `_choose_factor` is obsolete then. (It is never used inside numberfields.py)\r\n\r\nPerhaps it could be set to 10 and used by `evalf`.\r\n\r\n> I'm not sure under which conditions `_prec` will be 1 but it seems to be a good indication of a very small result.\r\n\r\nWe can get `_prec=1` from evalf for an expression that is identically zero:\r\n\r\n```julia\r\nIn [11]: z = cos(1)**2 + sin(1)**2 - 1\r\n\r\nIn [12]: z.evalf()\r\nOut[12]: -0.e-124\r\n\r\nIn [13]: z.evalf()._prec\r\nOut[13]: 1\r\n```\r\n\r\nI think a `_prec` of 1 basically means no correct digits.\n> > Is the missing return value intended if `n10._prec > 1` does not hold?\r\n> \r\n> It is. Perhaps it could be set explicitly to `return False` but this works anyway because `None` is falsey.\r\n\r\nIn that case I would propose the following implementation:\r\n\r\n    def nonzero(f):\r\n      n10 = abs(f.as_expr()).evalf(10, points)\r\n      return n10._prec > 1 and n10 > 0\r\n",
  "created_at": "2021-04-22T23:42:22Z",
  "version": "1.9",
  "FAIL_TO_PASS": "[\"test_Factors\", \"test_minimal_polynomial\", \"test_minimal_polynomial_issue_19732\"]",
  "PASS_TO_PASS": "[\"test_decompose_power\", \"test_Term\", \"test_gcd_terms\", \"test_factor_terms\", \"test_xreplace\", \"test_factor_nc\", \"test_issue_6360\", \"test_issue_7903\", \"test_issue_8263\", \"test_monotonic_sign\", \"test_minimal_polynomial_hi_prec\", \"test_minimal_polynomial_sq\", \"test_minpoly_compose\", \"test_minpoly_issue_7113\", \"test_minpoly_issue_7574\", \"test_choose_factor\", \"test_primitive_element\", \"test_field_isomorphism_pslq\", \"test_field_isomorphism\", \"test_to_number_field\", \"test_AlgebraicNumber\", \"test_to_algebraic_integer\", \"test_IntervalPrinter\", \"test_isolate\", \"test_minpoly_fraction_field\", \"test_minpoly_domain\", \"test_issue_14831\", \"test_issue_18248\", \"test_issue_13230\", \"test_issue_19760\"]",
  "environment_setup_commit": "f9a6f50ec0c74d935c50a6e9c9b2cb0469570d91",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.142924",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}