{
  "repo": "sphinx-doc/sphinx",
  "instance_id": "sphinx-doc__sphinx-11312",
  "base_commit": "5cf3dce36ec35c429724bf1312ece9faa0c8db39",
  "patch": "diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -350,38 +350,64 @@ def safe_getattr(obj: Any, name: str, *defargs: Any) -> Any:\n         raise AttributeError(name) from exc\n \n \n-def object_description(object: Any) -> str:\n-    \"\"\"A repr() implementation that returns text safe to use in reST context.\"\"\"\n-    if isinstance(object, dict):\n+def object_description(obj: Any, *, _seen: frozenset = frozenset()) -> str:\n+    \"\"\"A repr() implementation that returns text safe to use in reST context.\n+\n+    Maintains a set of 'seen' object IDs to detect and avoid infinite recursion.\n+    \"\"\"\n+    seen = _seen\n+    if isinstance(obj, dict):\n+        if id(obj) in seen:\n+            return 'dict(...)'\n+        seen |= {id(obj)}\n         try:\n-            sorted_keys = sorted(object)\n-        except Exception:\n-            pass  # Cannot sort dict keys, fall back to generic repr\n-        else:\n-            items = (\"%s: %s\" %\n-                     (object_description(key), object_description(object[key]))\n-                     for key in sorted_keys)\n-            return \"{%s}\" % \", \".join(items)\n-    elif isinstance(object, set):\n+            sorted_keys = sorted(obj)\n+        except TypeError:\n+            # Cannot sort dict keys, fall back to using descriptions as a sort key\n+            sorted_keys = sorted(obj, key=lambda k: object_description(k, _seen=seen))\n+\n+        items = ((object_description(key, _seen=seen),\n+                  object_description(obj[key], _seen=seen)) for key in sorted_keys)\n+        return '{%s}' % ', '.join(f'{key}: {value}' for (key, value) in items)\n+    elif isinstance(obj, set):\n+        if id(obj) in seen:\n+            return 'set(...)'\n+        seen |= {id(obj)}\n         try:\n-            sorted_values = sorted(object)\n+            sorted_values = sorted(obj)\n         except TypeError:\n-            pass  # Cannot sort set values, fall back to generic repr\n-        else:\n-            return \"{%s}\" % \", \".join(object_description(x) for x in sorted_values)\n-    elif isinstance(object, frozenset):\n+            # Cannot sort set values, fall back to using descriptions as a sort key\n+            sorted_values = sorted(obj, key=lambda x: object_description(x, _seen=seen))\n+        return '{%s}' % ', '.join(object_description(x, _seen=seen) for x in sorted_values)\n+    elif isinstance(obj, frozenset):\n+        if id(obj) in seen:\n+            return 'frozenset(...)'\n+        seen |= {id(obj)}\n         try:\n-            sorted_values = sorted(object)\n+            sorted_values = sorted(obj)\n         except TypeError:\n-            pass  # Cannot sort frozenset values, fall back to generic repr\n-        else:\n-            return \"frozenset({%s})\" % \", \".join(object_description(x)\n-                                                 for x in sorted_values)\n-    elif isinstance(object, enum.Enum):\n-        return f\"{object.__class__.__name__}.{object.name}\"\n+            # Cannot sort frozenset values, fall back to using descriptions as a sort key\n+            sorted_values = sorted(obj, key=lambda x: object_description(x, _seen=seen))\n+        return 'frozenset({%s})' % ', '.join(object_description(x, _seen=seen)\n+                                             for x in sorted_values)\n+    elif isinstance(obj, enum.Enum):\n+        return f'{obj.__class__.__name__}.{obj.name}'\n+    elif isinstance(obj, tuple):\n+        if id(obj) in seen:\n+            return 'tuple(...)'\n+        seen |= frozenset([id(obj)])\n+        return '(%s%s)' % (\n+            ', '.join(object_description(x, _seen=seen) for x in obj),\n+            ',' * (len(obj) == 1),\n+        )\n+    elif isinstance(obj, list):\n+        if id(obj) in seen:\n+            return 'list(...)'\n+        seen |= {id(obj)}\n+        return '[%s]' % ', '.join(object_description(x, _seen=seen) for x in obj)\n \n     try:\n-        s = repr(object)\n+        s = repr(obj)\n     except Exception as exc:\n         raise ValueError from exc\n     # Strip non-deterministic memory addresses such as\n",
  "test_patch": "diff --git a/tests/test_util_inspect.py b/tests/test_util_inspect.py\n--- a/tests/test_util_inspect.py\n+++ b/tests/test_util_inspect.py\n@@ -503,10 +503,32 @@ def test_set_sorting():\n     assert description == \"{'a', 'b', 'c', 'd', 'e', 'f', 'g'}\"\n \n \n+def test_set_sorting_enum():\n+    class MyEnum(enum.Enum):\n+        a = 1\n+        b = 2\n+        c = 3\n+\n+    set_ = set(MyEnum)\n+    description = inspect.object_description(set_)\n+    assert description == \"{MyEnum.a, MyEnum.b, MyEnum.c}\"\n+\n+\n def test_set_sorting_fallback():\n     set_ = {None, 1}\n     description = inspect.object_description(set_)\n-    assert description in (\"{1, None}\", \"{None, 1}\")\n+    assert description == \"{1, None}\"\n+\n+\n+def test_deterministic_nested_collection_descriptions():\n+    # sortable\n+    assert inspect.object_description([{1, 2, 3, 10}]) == \"[{1, 2, 3, 10}]\"\n+    assert inspect.object_description(({1, 2, 3, 10},)) == \"({1, 2, 3, 10},)\"\n+    # non-sortable (elements of varying datatype)\n+    assert inspect.object_description([{None, 1}]) == \"[{1, None}]\"\n+    assert inspect.object_description(({None, 1},)) == \"({1, None},)\"\n+    assert inspect.object_description([{None, 1, 'A'}]) == \"[{'A', 1, None}]\"\n+    assert inspect.object_description(({None, 1, 'A'},)) == \"({'A', 1, None},)\"\n \n \n def test_frozenset_sorting():\n@@ -518,7 +540,39 @@ def test_frozenset_sorting():\n def test_frozenset_sorting_fallback():\n     frozenset_ = frozenset((None, 1))\n     description = inspect.object_description(frozenset_)\n-    assert description in (\"frozenset({1, None})\", \"frozenset({None, 1})\")\n+    assert description == \"frozenset({1, None})\"\n+\n+\n+def test_nested_tuple_sorting():\n+    tuple_ = ({\"c\", \"b\", \"a\"},)  # nb. trailing comma\n+    description = inspect.object_description(tuple_)\n+    assert description == \"({'a', 'b', 'c'},)\"\n+\n+    tuple_ = ({\"c\", \"b\", \"a\"}, {\"f\", \"e\", \"d\"})\n+    description = inspect.object_description(tuple_)\n+    assert description == \"({'a', 'b', 'c'}, {'d', 'e', 'f'})\"\n+\n+\n+def test_recursive_collection_description():\n+    dict_a_, dict_b_ = {\"a\": 1}, {\"b\": 2}\n+    dict_a_[\"link\"], dict_b_[\"link\"] = dict_b_, dict_a_\n+    description_a, description_b = (\n+        inspect.object_description(dict_a_),\n+        inspect.object_description(dict_b_),\n+    )\n+    assert description_a == \"{'a': 1, 'link': {'b': 2, 'link': dict(...)}}\"\n+    assert description_b == \"{'b': 2, 'link': {'a': 1, 'link': dict(...)}}\"\n+\n+    list_c_, list_d_ = [1, 2, 3, 4], [5, 6, 7, 8]\n+    list_c_.append(list_d_)\n+    list_d_.append(list_c_)\n+    description_c, description_d = (\n+        inspect.object_description(list_c_),\n+        inspect.object_description(list_d_),\n+    )\n+\n+    assert description_c == \"[1, 2, 3, 4, [5, 6, 7, 8, list(...)]]\"\n+    assert description_d == \"[5, 6, 7, 8, [1, 2, 3, 4, list(...)]]\"\n \n \n def test_dict_customtype():\n",
  "problem_statement": "util.inspect.object_description: does not emit reliable ordering for a set nested within another collection\n### Describe the bug\r\n\r\n### Summary\r\nDifferences appear in some `sphinx` v5.3.0 generated `set` object descriptions for `alembic` v1.8.1, as demonstrated by [recent results visible on the Reproducible Builds diffoscope dashboard](https://tests.reproducible-builds.org/debian/rb-pkg/unstable/amd64/diffoscope-results/alembic.html).\r\n\r\nArguably it could make sense for code authors to intentionally write `set` elements in their code files in a way that does not correspond to their computed sort order -- as a means to communicate with human readers about abstract ideas that aren't relevant to computers at runtime, for example.\r\n\r\nHowever, the current behaviour does result in non-reproducible documentation output.\r\n\r\n### Details\r\nIn particular, the ordering of a class attribute with a value that contains a set-within-a-tuple seems unreliable across differing builds:\r\n\r\nhttps://github.com/sqlalchemy/alembic/blob/a968c9d2832173ee7d5dde50c7573f7b99424c38/alembic/ddl/impl.py#L90\r\n\r\n... is emitted variously as ...\r\n\r\n```\r\n<span·class=\"pre\">({'NUMERIC',</span>·<span·class=\"pre\">'DECIMAL'},)</span>\r\n```\r\n\r\n... or ...\r\n\r\n```\r\n<span·class=\"pre\">({'DECIMAL',</span>·<span·class=\"pre\">'NUMERIC'},)</span>\r\n```\r\n\r\ncc @lamby who has been [investigating a fix on the reproducible-builds mailing list](https://lists.reproducible-builds.org/pipermail/rb-general/2023-February/002862.html).\r\n\r\n### How to Reproduce\r\n\r\nIt is not yet clear to me exactly what circumstances cause the ordering of elements to vary - and it's OK not to proceed until that's figured out (maybe not a blocker, but it would be nice to have confidence about the cause).\r\n\r\nFrom searching around on previous issues while writing up this bugreport: I wonder if this could be an edge-case for / follow-up to #4834.\r\n\r\n### Environment Information\r\n\r\nAlthough these build log links are somewhat ephemeral, the system environment details for two builds that produce differing output are visible at:\r\n\r\n- https://tests.reproducible-builds.org/debian/rbuild/unstable/amd64/alembic_1.8.1-2.rbuild.log.gz\r\n- https://tests.reproducible-builds.org/debian/logs/unstable/amd64/alembic_1.8.1-2.build2.log.gz\r\n\r\n\r\n### Sphinx extensions\r\n\r\n```python\r\nhttps://github.com/sqlalchemy/alembic/blob/rel_1_8_1/docs/build/conf.py#L36-L42\r\n\r\n\r\nsphinx.ext.autodoc\r\nsphinx.ext.intersphinx\r\nchangelog\r\nsphinx_paramlinks\r\nsphinx_copybutton\r\n```\r\n\r\n\r\n### Additional context\r\n\r\n_No response_\n",
  "hints_text": "",
  "created_at": "2023-04-10T15:35:57Z",
  "version": "7.2",
  "FAIL_TO_PASS": "[\"tests/test_util_inspect.py::test_set_sorting_enum\", \"tests/test_util_inspect.py::test_deterministic_nested_collection_descriptions\", \"tests/test_util_inspect.py::test_nested_tuple_sorting\", \"tests/test_util_inspect.py::test_recursive_collection_description\"]",
  "PASS_TO_PASS": "[\"tests/test_util_inspect.py::test_TypeAliasForwardRef\", \"tests/test_util_inspect.py::test_TypeAliasNamespace\", \"tests/test_util_inspect.py::test_signature\", \"tests/test_util_inspect.py::test_signature_partial\", \"tests/test_util_inspect.py::test_signature_methods\", \"tests/test_util_inspect.py::test_signature_partialmethod\", \"tests/test_util_inspect.py::test_signature_annotations\", \"tests/test_util_inspect.py::test_signature_from_str_basic\", \"tests/test_util_inspect.py::test_signature_from_str_default_values\", \"tests/test_util_inspect.py::test_signature_from_str_annotations\", \"tests/test_util_inspect.py::test_signature_from_str_complex_annotations\", \"tests/test_util_inspect.py::test_signature_from_str_kwonly_args\", \"tests/test_util_inspect.py::test_signature_from_str_positionaly_only_args\", \"tests/test_util_inspect.py::test_signature_from_str_invalid\", \"tests/test_util_inspect.py::test_signature_from_ast\", \"tests/test_util_inspect.py::test_safe_getattr_with_default\", \"tests/test_util_inspect.py::test_safe_getattr_with_exception\", \"tests/test_util_inspect.py::test_safe_getattr_with_property_exception\", \"tests/test_util_inspect.py::test_safe_getattr_with___dict___override\", \"tests/test_util_inspect.py::test_dictionary_sorting\", \"tests/test_util_inspect.py::test_set_sorting\", \"tests/test_util_inspect.py::test_set_sorting_fallback\", \"tests/test_util_inspect.py::test_frozenset_sorting\", \"tests/test_util_inspect.py::test_frozenset_sorting_fallback\", \"tests/test_util_inspect.py::test_dict_customtype\", \"tests/test_util_inspect.py::test_object_description_enum\", \"tests/test_util_inspect.py::test_getslots\", \"tests/test_util_inspect.py::test_isclassmethod\", \"tests/test_util_inspect.py::test_isstaticmethod\", \"tests/test_util_inspect.py::test_iscoroutinefunction\", \"tests/test_util_inspect.py::test_isfunction\", \"tests/test_util_inspect.py::test_isbuiltin\", \"tests/test_util_inspect.py::test_isdescriptor\", \"tests/test_util_inspect.py::test_isattributedescriptor\", \"tests/test_util_inspect.py::test_isproperty\", \"tests/test_util_inspect.py::test_isgenericalias\", \"tests/test_util_inspect.py::test_unpartial\", \"tests/test_util_inspect.py::test_getdoc_inherited_classmethod\", \"tests/test_util_inspect.py::test_getdoc_inherited_decorated_method\", \"tests/test_util_inspect.py::test_is_builtin_class_method\"]",
  "environment_setup_commit": "7758e016231c3886e5a290c00fcb2c75d1f36c18",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.037041",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}