{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-18765",
  "base_commit": "8501526ca26a80ac1b7866a4c1678fcf0045e971",
  "patch": "diff --git a/sympy/matrices/expressions/hadamard.py b/sympy/matrices/expressions/hadamard.py\n--- a/sympy/matrices/expressions/hadamard.py\n+++ b/sympy/matrices/expressions/hadamard.py\n@@ -60,13 +60,16 @@ class HadamardProduct(MatrixExpr):\n     \"\"\"\n     is_HadamardProduct = True\n \n-    def __new__(cls, *args, **kwargs):\n+    def __new__(cls, *args, evaluate=False, **kwargs):\n         args = list(map(sympify, args))\n         check = kwargs.get('check', True)\n         if check:\n             validate(*args)\n \n-        return super(HadamardProduct, cls).__new__(cls, *args)\n+        obj = super(HadamardProduct, cls).__new__(cls, *args)\n+        if evaluate:\n+            obj = obj.doit(deep=False)\n+        return obj\n \n     @property\n     def shape(self):\ndiff --git a/sympy/matrices/expressions/matadd.py b/sympy/matrices/expressions/matadd.py\n--- a/sympy/matrices/expressions/matadd.py\n+++ b/sympy/matrices/expressions/matadd.py\n@@ -33,7 +33,7 @@ class MatAdd(MatrixExpr, Add):\n \n     identity = GenericZeroMatrix()\n \n-    def __new__(cls, *args, **kwargs):\n+    def __new__(cls, *args, evaluate=False, **kwargs):\n         if not args:\n             return cls.identity\n \n@@ -44,10 +44,17 @@ def __new__(cls, *args, **kwargs):\n         check = kwargs.get('check', False)\n \n         obj = Basic.__new__(cls, *args)\n+\n         if check:\n             if all(not isinstance(i, MatrixExpr) for i in args):\n                 return Add.fromiter(args)\n             validate(*args)\n+\n+        if evaluate:\n+            if all(not isinstance(i, MatrixExpr) for i in args):\n+                return Add(*args, evaluate=True)\n+            obj = canonicalize(obj)\n+\n         return obj\n \n     @property\ndiff --git a/sympy/matrices/expressions/matmul.py b/sympy/matrices/expressions/matmul.py\n--- a/sympy/matrices/expressions/matmul.py\n+++ b/sympy/matrices/expressions/matmul.py\n@@ -34,7 +34,7 @@ class MatMul(MatrixExpr, Mul):\n \n     identity = GenericIdentity()\n \n-    def __new__(cls, *args, **kwargs):\n+    def __new__(cls, *args, evaluate=False, **kwargs):\n         check = kwargs.get('check', True)\n \n         if not args:\n@@ -46,13 +46,19 @@ def __new__(cls, *args, **kwargs):\n         args = list(map(sympify, args))\n         obj = Basic.__new__(cls, *args)\n         factor, matrices = obj.as_coeff_matrices()\n+\n         if check:\n             validate(*matrices)\n+\n         if not matrices:\n             # Should it be\n             #\n             # return Basic.__neq__(cls, factor, GenericIdentity()) ?\n             return factor\n+\n+        if evaluate:\n+            return canonicalize(obj)\n+\n         return obj\n \n     @property\ndiff --git a/sympy/matrices/expressions/matpow.py b/sympy/matrices/expressions/matpow.py\n--- a/sympy/matrices/expressions/matpow.py\n+++ b/sympy/matrices/expressions/matpow.py\n@@ -10,12 +10,17 @@\n \n class MatPow(MatrixExpr):\n \n-    def __new__(cls, base, exp):\n+    def __new__(cls, base, exp, evaluate=False, **options):\n         base = _sympify(base)\n         if not base.is_Matrix:\n             raise TypeError(\"Function parameter should be a matrix\")\n         exp = _sympify(exp)\n-        return super(MatPow, cls).__new__(cls, base, exp)\n+\n+        obj = super(MatPow, cls).__new__(cls, base, exp)\n+        if evaluate:\n+            obj = obj.doit(deep=False)\n+\n+        return obj\n \n     @property\n     def base(self):\n",
  "test_patch": "diff --git a/sympy/matrices/expressions/tests/test_matadd.py b/sympy/matrices/expressions/tests/test_matadd.py\n--- a/sympy/matrices/expressions/tests/test_matadd.py\n+++ b/sympy/matrices/expressions/tests/test_matadd.py\n@@ -7,6 +7,9 @@\n X = MatrixSymbol('X', 2, 2)\n Y = MatrixSymbol('Y', 2, 2)\n \n+def test_evaluate():\n+    assert MatAdd(X, X, evaluate=True) == MatAdd(X, X).doit()\n+\n def test_sort_key():\n     assert MatAdd(Y, X).doit().args == (X, Y)\n \ndiff --git a/sympy/matrices/expressions/tests/test_matmul.py b/sympy/matrices/expressions/tests/test_matmul.py\n--- a/sympy/matrices/expressions/tests/test_matmul.py\n+++ b/sympy/matrices/expressions/tests/test_matmul.py\n@@ -19,6 +19,8 @@\n D = MatrixSymbol('D', n, n)\n E = MatrixSymbol('E', m, n)\n \n+def test_evaluate():\n+    assert MatMul(C, C, evaluate=True) == MatMul(C, C).doit()\n \n def test_adjoint():\n     assert adjoint(A*B) == Adjoint(B)*Adjoint(A)\n",
  "problem_statement": "Introduce 'evaluate' keyword argument in MatAdd and MatMul\n``MatAdd`` and ``MatMul`` are behaving differently from ``Add`` and ``Mul``.\r\n\r\nHere is an example:\r\n```python\r\n>>> from sympy import Add, MatAdd, Symbol, MatrixSymbol\r\n>>> x = Symbol('x')\r\n>>> Add(x, x, evaluate=True)\r\n2*x\r\n>>> Add(x, x, evaluate=False)\r\nx + x\r\n\r\n>> A = MatrixSymbol('A', 2,2)\r\n>>> MatAdd(A, A)\r\nA + A\r\n>>> MatAdd(A, A, evaluate=True)\r\nA + A\r\n```\r\n\r\nI believe it would be better to add ``evaluate`` option which canonicallizes the object, so that\r\n\r\n```python\r\n>>> MatAdd(A, A, evaluate=True)\r\n2*A\r\n```\n",
  "hints_text": "",
  "created_at": "2020-03-03T08:49:21Z",
  "version": "1.6",
  "FAIL_TO_PASS": "[\"test_evaluate\"]",
  "PASS_TO_PASS": "[\"test_sort_key\", \"test_matadd_sympify\", \"test_matadd_of_matrices\", \"test_doit_args\", \"test_generic_identity\", \"test_zero_matrix_add\", \"test_adjoint\", \"test_transpose\", \"test_factor_in_front\", \"test_remove_ids\", \"test_combine_powers\", \"test_any_zeros\", \"test_unpack\", \"test_only_squares\", \"test_determinant\", \"test_doit\", \"test_doit_drills_down\", \"test_doit_deep_false_still_canonical\", \"test_matmul_scalar_Matrix_doit\", \"test_matmul_sympify\", \"test_collapse_MatrixBase\", \"test_refine\", \"test_matmul_no_matrices\", \"test_matmul_args_cnc\", \"test_issue_12950\", \"test_construction_with_Mul\"]",
  "environment_setup_commit": "28b41c73c12b70d6ad9f6e45109a80649c4456da",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.127651",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}