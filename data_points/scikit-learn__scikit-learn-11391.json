{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-11391",
  "base_commit": "526aede6a762ac6646211057d00a13304fb115b6",
  "patch": "diff --git a/sklearn/impute.py b/sklearn/impute.py\n--- a/sklearn/impute.py\n+++ b/sklearn/impute.py\n@@ -40,6 +40,15 @@\n ]\n \n \n+def _check_inputs_dtype(X, missing_values):\n+    if (X.dtype.kind in (\"f\", \"i\", \"u\") and\n+            not isinstance(missing_values, numbers.Real)):\n+        raise ValueError(\"'X' and 'missing_values' types are expected to be\"\n+                         \" both numerical. Got X.dtype={} and \"\n+                         \" type(missing_values)={}.\"\n+                         .format(X.dtype, type(missing_values)))\n+\n+\n def _get_mask(X, value_to_mask):\n     \"\"\"Compute the boolean mask X == missing_values.\"\"\"\n     if value_to_mask is np.nan:\n@@ -51,7 +60,6 @@ def _get_mask(X, value_to_mask):\n         else:\n             # np.isnan does not work on object dtypes.\n             return _object_dtype_isnan(X)\n-\n     else:\n         # X == value_to_mask with object dytpes does not always perform\n         # element-wise for old versions of numpy\n@@ -183,6 +191,7 @@ def _validate_input(self, X):\n             else:\n                 raise ve\n \n+        _check_inputs_dtype(X, self.missing_values)\n         if X.dtype.kind not in (\"i\", \"u\", \"f\", \"O\"):\n             raise ValueError(\"SimpleImputer does not support data with dtype \"\n                              \"{0}. Please provide either a numeric array (with\"\n@@ -788,6 +797,7 @@ def _initial_imputation(self, X):\n \n         X = check_array(X, dtype=FLOAT_DTYPES, order=\"F\",\n                         force_all_finite=force_all_finite)\n+        _check_inputs_dtype(X, self.missing_values)\n \n         mask_missing_values = _get_mask(X, self.missing_values)\n         if self.initial_imputer_ is None:\n",
  "test_patch": "diff --git a/sklearn/tests/test_impute.py b/sklearn/tests/test_impute.py\n--- a/sklearn/tests/test_impute.py\n+++ b/sklearn/tests/test_impute.py\n@@ -705,3 +705,25 @@ def test_chained_imputer_additive_matrix():\n                              random_state=rng).fit(X_train)\n     X_test_est = imputer.transform(X_test)\n     assert_allclose(X_test_filled, X_test_est, atol=0.01)\n+\n+\n+@pytest.mark.parametrize(\"imputer_constructor\",\n+                         [SimpleImputer, ChainedImputer])\n+@pytest.mark.parametrize(\n+    \"imputer_missing_values, missing_value, err_msg\",\n+    [(\"NaN\", np.nan, \"Input contains NaN\"),\n+     (\"-1\", -1, \"types are expected to be both numerical.\")])\n+def test_inconsistent_dtype_X_missing_values(imputer_constructor,\n+                                             imputer_missing_values,\n+                                             missing_value,\n+                                             err_msg):\n+    # regression test for issue #11390. Comparison between incoherent dtype\n+    # for X and missing_values was not raising a proper error.\n+    rng = np.random.RandomState(42)\n+    X = rng.randn(10, 10)\n+    X[0, 0] = missing_value\n+\n+    imputer = imputer_constructor(missing_values=imputer_missing_values)\n+\n+    with pytest.raises(ValueError, match=err_msg):\n+        imputer.fit_transform(X)\n",
  "problem_statement": "Cryptic error in imputers due to missing checking in _get_mask\nBy working on the `MissingIndicator` it seems that there is a missing checking between `X` and `missing_values` dtype:\r\n\r\n```python\r\nimport numpy as np\r\nX = np.array([[1.6464405 , 2.145568  , 1.80829   , 1.6346495 , 1.2709644 ],\r\n              [1.3127615 , 2.675319  , 2.8906 , 2.1489816 , 0.8682183 ],\r\n              [0.5495741 , 1.7595388 , 0.06032264, 2.4868202 , 0.01408643]],\r\n             dtype=np.float32)\r\nfrom sklearn.impute import SimpleImputer\r\ntrans = SimpleImputer(missing_values=\"NaN\")\r\ntrans.fit_transform(X)\r\n```\r\n\r\n```\r\n/home/lemaitre/Documents/code/toolbox/scikit-learn/sklearn/impute.py:59: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\r\n  return np.equal(X, value_to_mask)\r\n/home/lemaitre/Documents/code/toolbox/scikit-learn/sklearn/impute.py:59: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\r\n  return np.equal(X, value_to_mask)\r\n---------------------------------------------------------------------------\r\nTypeError                                 Traceback (most recent call last)\r\n~/miniconda3/envs/dev/lib/python3.6/site-packages/numpy/core/fromnumeric.py in _wrapfunc(obj, method, *args, **kwds)\r\n     51     try:\r\n---> 52         return getattr(obj, method)(*args, **kwds)\r\n     53 \r\n\r\nTypeError: int() argument must be a string, a bytes-like object or a number, not 'NotImplementedType'\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTypeError                                 Traceback (most recent call last)\r\n<ipython-input-18-151141bb4b39> in <module>()\r\n----> 1 trans.fit_transform(X)\r\n\r\n~/Documents/code/toolbox/scikit-learn/sklearn/base.py in fit_transform(self, X, y, **fit_params)\r\n    457         if y is None:\r\n    458             # fit method of arity 1 (unsupervised transformation)\r\n--> 459             return self.fit(X, **fit_params).transform(X)\r\n    460         else:\r\n    461             # fit method of arity 2 (supervised transformation)\r\n\r\n~/Documents/code/toolbox/scikit-learn/sklearn/impute.py in transform(self, X)\r\n    417             mask = _get_mask(X, self.missing_values)\r\n    418             n_missing = np.sum(mask, axis=0)\r\n--> 419             values = np.repeat(valid_statistics, n_missing)\r\n    420             coordinates = np.where(mask.transpose())[::-1]\r\n    421 \r\n\r\n~/miniconda3/envs/dev/lib/python3.6/site-packages/numpy/core/fromnumeric.py in repeat(a, repeats, axis)\r\n    421 \r\n    422     \"\"\"\r\n--> 423     return _wrapfunc(a, 'repeat', repeats, axis=axis)\r\n    424 \r\n    425 \r\n\r\n~/miniconda3/envs/dev/lib/python3.6/site-packages/numpy/core/fromnumeric.py in _wrapfunc(obj, method, *args, **kwds)\r\n     60     # a downstream library like 'pandas'.\r\n     61     except (AttributeError, TypeError):\r\n---> 62         return _wrapit(obj, method, *args, **kwds)\r\n     63 \r\n     64 \r\n\r\n~/miniconda3/envs/dev/lib/python3.6/site-packages/numpy/core/fromnumeric.py in _wrapit(obj, method, *args, **kwds)\r\n     40     except AttributeError:\r\n     41         wrap = None\r\n---> 42     result = getattr(asarray(obj), method)(*args, **kwds)\r\n     43     if wrap:\r\n     44         if not isinstance(result, mu.ndarray):\r\n\r\nTypeError: int() argument must be a string, a bytes-like object or a number, not 'NotImplementedType'\r\n\r\n```\r\n\r\nIn short, `NotImplement` is raised by equal in case of numeric and string mixed dtype. We should put a check in `_get_mask` which is shared across classes.\n",
  "hints_text": "",
  "created_at": "2018-06-29T13:52:07Z",
  "version": "0.20",
  "FAIL_TO_PASS": "[\"sklearn/tests/test_impute.py::test_inconsistent_dtype_X_missing_values[-1--1-types\"]",
  "PASS_TO_PASS": "[\"sklearn/tests/test_impute.py::test_imputation_shape\", \"sklearn/tests/test_impute.py::test_imputation_error_invalid_strategy[const]\", \"sklearn/tests/test_impute.py::test_imputation_error_invalid_strategy[101]\", \"sklearn/tests/test_impute.py::test_imputation_error_invalid_strategy[None]\", \"sklearn/tests/test_impute.py::test_imputation_deletion_warning[mean]\", \"sklearn/tests/test_impute.py::test_imputation_deletion_warning[median]\", \"sklearn/tests/test_impute.py::test_imputation_deletion_warning[most_frequent]\", \"sklearn/tests/test_impute.py::test_imputation_mean_median\", \"sklearn/tests/test_impute.py::test_imputation_median_special_cases\", \"sklearn/tests/test_impute.py::test_imputation_mean_median_error_invalid_type[None-mean]\", \"sklearn/tests/test_impute.py::test_imputation_mean_median_error_invalid_type[None-median]\", \"sklearn/tests/test_impute.py::test_imputation_mean_median_error_invalid_type[object-mean]\", \"sklearn/tests/test_impute.py::test_imputation_mean_median_error_invalid_type[object-median]\", \"sklearn/tests/test_impute.py::test_imputation_mean_median_error_invalid_type[str-mean]\", \"sklearn/tests/test_impute.py::test_imputation_mean_median_error_invalid_type[str-median]\", \"sklearn/tests/test_impute.py::test_imputation_const_mostf_error_invalid_types[str-constant]\", \"sklearn/tests/test_impute.py::test_imputation_const_mostf_error_invalid_types[str-most_frequent]\", \"sklearn/tests/test_impute.py::test_imputation_const_mostf_error_invalid_types[dtype1-constant]\", \"sklearn/tests/test_impute.py::test_imputation_const_mostf_error_invalid_types[dtype1-most_frequent]\", \"sklearn/tests/test_impute.py::test_imputation_const_mostf_error_invalid_types[dtype2-constant]\", \"sklearn/tests/test_impute.py::test_imputation_const_mostf_error_invalid_types[dtype2-most_frequent]\", \"sklearn/tests/test_impute.py::test_imputation_most_frequent\", \"sklearn/tests/test_impute.py::test_imputation_most_frequent_objects[None]\", \"sklearn/tests/test_impute.py::test_imputation_most_frequent_objects[nan]\", \"sklearn/tests/test_impute.py::test_imputation_most_frequent_objects[NAN]\", \"sklearn/tests/test_impute.py::test_imputation_most_frequent_objects[]\", \"sklearn/tests/test_impute.py::test_imputation_most_frequent_objects[0]\", \"sklearn/tests/test_impute.py::test_imputation_most_frequent_pandas[object]\", \"sklearn/tests/test_impute.py::test_imputation_most_frequent_pandas[category]\", \"sklearn/tests/test_impute.py::test_imputation_constant_error_invalid_type[1-0]\", \"sklearn/tests/test_impute.py::test_imputation_constant_error_invalid_type[1.0-nan]\", \"sklearn/tests/test_impute.py::test_imputation_constant_integer\", \"sklearn/tests/test_impute.py::test_imputation_constant_float[csr_matrix]\", \"sklearn/tests/test_impute.py::test_imputation_constant_float[asarray]\", \"sklearn/tests/test_impute.py::test_imputation_constant_object[None]\", \"sklearn/tests/test_impute.py::test_imputation_constant_object[nan]\", \"sklearn/tests/test_impute.py::test_imputation_constant_object[NAN]\", \"sklearn/tests/test_impute.py::test_imputation_constant_object[]\", \"sklearn/tests/test_impute.py::test_imputation_constant_object[0]\", \"sklearn/tests/test_impute.py::test_imputation_constant_pandas[object]\", \"sklearn/tests/test_impute.py::test_imputation_constant_pandas[category]\", \"sklearn/tests/test_impute.py::test_imputation_pipeline_grid_search\", \"sklearn/tests/test_impute.py::test_imputation_copy\", \"sklearn/tests/test_impute.py::test_chained_imputer_rank_one\", \"sklearn/tests/test_impute.py::test_chained_imputer_imputation_order[random]\", \"sklearn/tests/test_impute.py::test_chained_imputer_imputation_order[roman]\", \"sklearn/tests/test_impute.py::test_chained_imputer_imputation_order[ascending]\", \"sklearn/tests/test_impute.py::test_chained_imputer_imputation_order[descending]\", \"sklearn/tests/test_impute.py::test_chained_imputer_imputation_order[arabic]\", \"sklearn/tests/test_impute.py::test_chained_imputer_predictors[predictor0]\", \"sklearn/tests/test_impute.py::test_chained_imputer_predictors[predictor1]\", \"sklearn/tests/test_impute.py::test_chained_imputer_predictors[predictor2]\", \"sklearn/tests/test_impute.py::test_chained_imputer_clip\", \"sklearn/tests/test_impute.py::test_chained_imputer_missing_at_transform[mean]\", \"sklearn/tests/test_impute.py::test_chained_imputer_missing_at_transform[median]\", \"sklearn/tests/test_impute.py::test_chained_imputer_missing_at_transform[most_frequent]\", \"sklearn/tests/test_impute.py::test_chained_imputer_transform_stochasticity\", \"sklearn/tests/test_impute.py::test_chained_imputer_no_missing\", \"sklearn/tests/test_impute.py::test_chained_imputer_transform_recovery[3]\", \"sklearn/tests/test_impute.py::test_chained_imputer_transform_recovery[5]\", \"sklearn/tests/test_impute.py::test_chained_imputer_additive_matrix\", \"sklearn/tests/test_impute.py::test_inconsistent_dtype_X_missing_values[NaN-nan-Input\"]",
  "environment_setup_commit": "55bf5d93e5674f13a1134d93a11fd0cd11aabcd1",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.962256",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}