{
  "repo": "pytest-dev/pytest",
  "instance_id": "pytest-dev__pytest-9911",
  "base_commit": "2ba8fd5bc50f293fea11a863c2b8c4dc3488762b",
  "patch": "diff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py\n--- a/src/_pytest/python_api.py\n+++ b/src/_pytest/python_api.py\n@@ -899,6 +899,12 @@ def raises(\n     \"\"\"\n     __tracebackhide__ = True\n \n+    if not expected_exception:\n+        raise ValueError(\n+            f\"Expected an exception type or a tuple of exception types, but got `{expected_exception!r}`. \"\n+            f\"Raising exceptions is already understood as failing the test, so you don't need \"\n+            f\"any special code to say 'this should never raise an exception'.\"\n+        )\n     if isinstance(expected_exception, type):\n         excepted_exceptions: Tuple[Type[E], ...] = (expected_exception,)\n     else:\n",
  "test_patch": "diff --git a/testing/python/raises.py b/testing/python/raises.py\n--- a/testing/python/raises.py\n+++ b/testing/python/raises.py\n@@ -19,6 +19,16 @@ def test_raises_function(self):\n         excinfo = pytest.raises(ValueError, int, \"hello\")\n         assert \"invalid literal\" in str(excinfo.value)\n \n+    def test_raises_does_not_allow_none(self):\n+        with pytest.raises(ValueError, match=\"Expected an exception type or\"):\n+            # We're testing that this invalid usage gives a helpful error,\n+            # so we can ignore Mypy telling us that None is invalid.\n+            pytest.raises(expected_exception=None)  # type: ignore\n+\n+    def test_raises_does_not_allow_empty_tuple(self):\n+        with pytest.raises(ValueError, match=\"Expected an exception type or\"):\n+            pytest.raises(expected_exception=())\n+\n     def test_raises_callable_no_exception(self) -> None:\n         class A:\n             def __call__(self):\n",
  "problem_statement": "Improved error when `()` (empty tuple) is passed to `pytest.raises()` or `pytest.warns()`\nWhen using `pytest.raises()` as a context manager, you can pass an exception type or tuple of exception types; it's then an error if no exception is raised or if the exception raised is not an instance of the expected type(s).  The same logic applies to `pytest.warns()`, which has a near-identical API.\r\n\r\nThe *problem* is that if you pass the empty tuple `()`, this will *always* result in an error: even if an exception is raised, it can't be an instance of `()`!  I think we should explicitly check tuple inputs, and raise a more helpful error message if they're empty.  For example:\r\n\r\n- \"Passing `expected_exception=()` is an error, because it's impossible to raise an exception which is not an instance of any type.  Raising exceptions is already understood as failing the test, so you don't need any special code to say 'this should never raise an exception'.\"  \r\n  (for bonus points, `pytest.raises(None)` should have the same message, with `=None` instead of `=()`)\r\n- The same logic, and same error message, applies to the `raises=` argument to `pytest.mark.xfail()`.\r\n- \"Passing `expected_warning=()` is an error, because it's impossible to emit a warning which is not an instance of any type.  To assert that no warnings are emitted, use <whatever we come up with for #9002>\n",
  "hints_text": "",
  "created_at": "2022-05-02T17:17:01Z",
  "version": "7.2",
  "FAIL_TO_PASS": "[\"testing/python/raises.py::TestRaises::test_raises_does_not_allow_none\", \"testing/python/raises.py::TestRaises::test_raises_does_not_allow_empty_tuple\"]",
  "PASS_TO_PASS": "[\"testing/python/raises.py::TestRaises::test_check_callable\", \"testing/python/raises.py::TestRaises::test_raises\", \"testing/python/raises.py::TestRaises::test_raises_function\", \"testing/python/raises.py::TestRaises::test_raises_callable_no_exception\", \"testing/python/raises.py::TestRaises::test_raises_falsey_type_error\", \"testing/python/raises.py::TestRaises::test_raises_repr_inflight\", \"testing/python/raises.py::TestRaises::test_noclass\", \"testing/python/raises.py::TestRaises::test_invalid_arguments_to_raises\", \"testing/python/raises.py::TestRaises::test_tuple\", \"testing/python/raises.py::TestRaises::test_no_raise_message\", \"testing/python/raises.py::TestRaises::test_raises_cyclic_reference[function]\", \"testing/python/raises.py::TestRaises::test_raises_cyclic_reference[function_match]\", \"testing/python/raises.py::TestRaises::test_raises_cyclic_reference[with]\", \"testing/python/raises.py::TestRaises::test_raises_match\", \"testing/python/raises.py::TestRaises::test_match_failure_string_quoting\", \"testing/python/raises.py::TestRaises::test_match_failure_exact_string_message\", \"testing/python/raises.py::TestRaises::test_raises_match_wrong_type\", \"testing/python/raises.py::TestRaises::test_raises_exception_looks_iterable\", \"testing/python/raises.py::TestRaises::test_raises_with_raising_dunder_class\", \"testing/python/raises.py::TestRaises::test_raises_context_manager_with_kwargs\", \"testing/python/raises.py::TestRaises::test_expected_exception_is_not_a_baseexception\", \"testing/python/raises.py::TestRaises::test_raises_as_contextmanager\", \"testing/python/raises.py::TestRaises::test_does_not_raise\", \"testing/python/raises.py::TestRaises::test_does_not_raise_does_raise\"]",
  "environment_setup_commit": "572b5657d7ca557593418ce0319fabff88800c73",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.948493",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}