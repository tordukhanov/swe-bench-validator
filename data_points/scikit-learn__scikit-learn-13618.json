{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-13618",
  "base_commit": "13981bdce97ab2dd49b6b8707f3f27b5c148b9c0",
  "patch": "diff --git a/examples/linear_model/plot_bayesian_ridge_curvefit.py b/examples/linear_model/plot_bayesian_ridge_curvefit.py\nnew file mode 100755\n--- /dev/null\n+++ b/examples/linear_model/plot_bayesian_ridge_curvefit.py\n@@ -0,0 +1,86 @@\n+\"\"\"\n+============================================\n+Curve Fitting with Bayesian Ridge Regression\n+============================================\n+\n+Computes a Bayesian Ridge Regression of Sinusoids.\n+\n+See :ref:`bayesian_ridge_regression` for more information on the regressor.\n+\n+In general, when fitting a curve with a polynomial by Bayesian ridge\n+regression, the selection of initial values of\n+the regularization parameters (alpha, lambda) may be important.\n+This is because the regularization parameters are determined by an iterative\n+procedure that depends on initial values.\n+\n+In this example, the sinusoid is approximated by a polynomial using different\n+pairs of initial values.\n+\n+When starting from the default values (alpha_init = 1.90, lambda_init = 1.),\n+the bias of the resulting curve is large, and the variance is small.\n+So, lambda_init should be relatively small (1.e-3) so as to reduce the bias.\n+\n+Also, by evaluating log marginal likelihood (L) of\n+these models, we can determine which one is better.\n+It can be concluded that the model with larger L is more likely.\n+\"\"\"\n+print(__doc__)\n+\n+# Author: Yoshihiro Uchida <nimbus1after2a1sun7shower@gmail.com>\n+\n+import numpy as np\n+import matplotlib.pyplot as plt\n+\n+from sklearn.linear_model import BayesianRidge\n+\n+\n+def func(x): return np.sin(2*np.pi*x)\n+\n+\n+# #############################################################################\n+# Generate sinusoidal data with noise\n+size = 25\n+rng = np.random.RandomState(1234)\n+x_train = rng.uniform(0., 1., size)\n+y_train = func(x_train) + rng.normal(scale=0.1, size=size)\n+x_test = np.linspace(0., 1., 100)\n+\n+\n+# #############################################################################\n+# Fit by cubic polynomial\n+n_order = 3\n+X_train = np.vander(x_train, n_order + 1, increasing=True)\n+X_test = np.vander(x_test, n_order + 1, increasing=True)\n+\n+# #############################################################################\n+# Plot the true and predicted curves with log marginal likelihood (L)\n+reg = BayesianRidge(tol=1e-6, fit_intercept=False, compute_score=True)\n+fig, axes = plt.subplots(1, 2, figsize=(8, 4))\n+for i, ax in enumerate(axes):\n+    # Bayesian ridge regression with different initial value pairs\n+    if i == 0:\n+        init = [1 / np.var(y_train), 1.]  # Default values\n+    elif i == 1:\n+        init = [1., 1e-3]\n+        reg.set_params(alpha_init=init[0], lambda_init=init[1])\n+    reg.fit(X_train, y_train)\n+    ymean, ystd = reg.predict(X_test, return_std=True)\n+\n+    ax.plot(x_test, func(x_test), color=\"blue\", label=\"sin($2\\\\pi x$)\")\n+    ax.scatter(x_train, y_train, s=50, alpha=0.5, label=\"observation\")\n+    ax.plot(x_test, ymean, color=\"red\", label=\"predict mean\")\n+    ax.fill_between(x_test, ymean-ystd, ymean+ystd,\n+                    color=\"pink\", alpha=0.5, label=\"predict std\")\n+    ax.set_ylim(-1.3, 1.3)\n+    ax.legend()\n+    title = \"$\\\\alpha$_init$={:.2f},\\\\ \\\\lambda$_init$={}$\".format(\n+            init[0], init[1])\n+    if i == 0:\n+        title += \" (Default)\"\n+    ax.set_title(title, fontsize=12)\n+    text = \"$\\\\alpha={:.1f}$\\n$\\\\lambda={:.3f}$\\n$L={:.1f}$\".format(\n+           reg.alpha_, reg.lambda_, reg.scores_[-1])\n+    ax.text(0.05, -1.0, text, fontsize=12)\n+\n+plt.tight_layout()\n+plt.show()\ndiff --git a/sklearn/linear_model/bayes.py b/sklearn/linear_model/bayes.py\n--- a/sklearn/linear_model/bayes.py\n+++ b/sklearn/linear_model/bayes.py\n@@ -55,6 +55,18 @@ class BayesianRidge(LinearModel, RegressorMixin):\n         Gamma distribution prior over the lambda parameter.\n         Default is 1.e-6\n \n+    alpha_init : float\n+        Initial value for alpha (precision of the noise).\n+        If not set, alpha_init is 1/Var(y).\n+\n+            .. versionadded:: 0.22\n+\n+    lambda_init : float\n+        Initial value for lambda (precision of the weights).\n+        If not set, lambda_init is 1.\n+\n+            .. versionadded:: 0.22\n+\n     compute_score : boolean, optional\n         If True, compute the log marginal likelihood at each iteration of the\n         optimization. Default is False.\n@@ -116,9 +128,10 @@ class BayesianRidge(LinearModel, RegressorMixin):\n     >>> clf = linear_model.BayesianRidge()\n     >>> clf.fit([[0,0], [1, 1], [2, 2]], [0, 1, 2])\n     ... # doctest: +NORMALIZE_WHITESPACE\n-    BayesianRidge(alpha_1=1e-06, alpha_2=1e-06, compute_score=False,\n-            copy_X=True, fit_intercept=True, lambda_1=1e-06, lambda_2=1e-06,\n-            n_iter=300, normalize=False, tol=0.001, verbose=False)\n+    BayesianRidge(alpha_1=1e-06, alpha_2=1e-06, alpha_init=None,\n+                  compute_score=False, copy_X=True, fit_intercept=True,\n+                  lambda_1=1e-06, lambda_2=1e-06, lambda_init=None, n_iter=300,\n+                  normalize=False, tol=0.001, verbose=False)\n     >>> clf.predict([[1, 1]])\n     array([1.])\n \n@@ -142,15 +155,17 @@ class BayesianRidge(LinearModel, RegressorMixin):\n     \"\"\"\n \n     def __init__(self, n_iter=300, tol=1.e-3, alpha_1=1.e-6, alpha_2=1.e-6,\n-                 lambda_1=1.e-6, lambda_2=1.e-6, compute_score=False,\n-                 fit_intercept=True, normalize=False, copy_X=True,\n-                 verbose=False):\n+                 lambda_1=1.e-6, lambda_2=1.e-6, alpha_init=None,\n+                 lambda_init=None, compute_score=False, fit_intercept=True,\n+                 normalize=False, copy_X=True, verbose=False):\n         self.n_iter = n_iter\n         self.tol = tol\n         self.alpha_1 = alpha_1\n         self.alpha_2 = alpha_2\n         self.lambda_1 = lambda_1\n         self.lambda_2 = lambda_2\n+        self.alpha_init = alpha_init\n+        self.lambda_init = lambda_init\n         self.compute_score = compute_score\n         self.fit_intercept = fit_intercept\n         self.normalize = normalize\n@@ -199,8 +214,12 @@ def fit(self, X, y, sample_weight=None):\n         eps = np.finfo(np.float64).eps\n         # Add `eps` in the denominator to omit division by zero if `np.var(y)`\n         # is zero\n-        alpha_ = 1. / (np.var(y) + eps)\n-        lambda_ = 1.\n+        alpha_ = self.alpha_init\n+        lambda_ = self.lambda_init\n+        if alpha_ is None:\n+            alpha_ = 1. / (np.var(y) + eps)\n+        if lambda_ is None:\n+            lambda_ = 1.\n \n         verbose = self.verbose\n         lambda_1 = self.lambda_1\n",
  "test_patch": "diff --git a/sklearn/linear_model/tests/test_bayes.py b/sklearn/linear_model/tests/test_bayes.py\n--- a/sklearn/linear_model/tests/test_bayes.py\n+++ b/sklearn/linear_model/tests/test_bayes.py\n@@ -125,6 +125,19 @@ def test_toy_bayesian_ridge_object():\n     assert_array_almost_equal(clf.predict(test), [1, 3, 4], 2)\n \n \n+def test_bayesian_initial_params():\n+    # Test BayesianRidge with initial values (alpha_init, lambda_init)\n+    X = np.vander(np.linspace(0, 4, 5), 4)\n+    y = np.array([0., 1., 0., -1., 0.])    # y = (x^3 - 6x^2 + 8x) / 3\n+\n+    # In this case, starting from the default initial values will increase\n+    # the bias of the fitted curve. So, lambda_init should be small.\n+    reg = BayesianRidge(alpha_init=1., lambda_init=1e-3)\n+    # Check the R2 score nearly equals to one.\n+    r2 = reg.fit(X, y).score(X, y)\n+    assert_almost_equal(r2, 1.)\n+\n+\n def test_prediction_bayesian_ridge_ard_with_constant_input():\n     # Test BayesianRidge and ARDRegression predictions for edge case of\n     # constant target vectors\n",
  "problem_statement": "Allow setting of initial hyperparameters of BayesianRidge\n<!--\r\nIf your issue is a usage question, submit it here instead:\r\n- StackOverflow with the scikit-learn tag: https://stackoverflow.com/questions/tagged/scikit-learn\r\n- Mailing List: https://mail.python.org/mailman/listinfo/scikit-learn\r\nFor more information, see User Questions: http://scikit-learn.org/stable/support.html#user-questions\r\n-->\r\n\r\n<!-- Instructions For Filing a Bug: https://github.com/scikit-learn/scikit-learn/blob/master/CONTRIBUTING.md#filing-bugs -->\r\n\r\n#### Description\r\n<!-- Example: Joblib Error thrown when calling fit on LatentDirichletAllocation with evaluate_every > 0-->\r\nI propose to be able to set initial values ​​of the hyperparameters (alpha, lambda) in BayesianRidge().fit.\r\n\r\nI tried to fit a sinusoidal curve with polynomials by Bayesian ridge regression, but the default initial values did not work well (left figure).\r\n\r\nSo, I corrected the fit method of the BayesianRidge class so that I could set the initial value, and the regression worked well (right figure).\r\n![Figure_1](https://user-images.githubusercontent.com/40843206/55940024-349d4b80-5c7a-11e9-8390-0c3b800b9d19.png)\r\n\r\n#### Steps/Code to Reproduce\r\n<!--\r\nExample:\r\n```python\r\nfrom sklearn.feature_extraction.text import CountVectorizer\r\nfrom sklearn.decomposition import LatentDirichletAllocation\r\n\r\ndocs = [\"Help I have a bug\" for i in range(1000)]\r\n\r\nvectorizer = CountVectorizer(input=docs, analyzer='word')\r\nlda_features = vectorizer.fit_transform(docs)\r\n\r\nlda_model = LatentDirichletAllocation(\r\n    n_topics=10,\r\n    learning_method='online',\r\n    evaluate_every=10,\r\n    n_jobs=4,\r\n)\r\nmodel = lda_model.fit(lda_features)\r\n```\r\nIf the code is too long, feel free to put it in a public gist and link\r\nit in the issue: https://gist.github.com\r\n-->\r\nThe code I wrote is Here.\r\n```\r\n#!/usr/bin/env python\r\n# coding: utf-8\r\n\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\n\r\nfrom math import log\r\nfrom scipy import linalg\r\nfrom sklearn.linear_model import BayesianRidge\r\nfrom sklearn.utils import check_X_y\r\n\r\nclass BayesRidge(BayesianRidge):\r\n    def fit(self, X, y, sample_weight=None, alpha_0=None, lambda_0=None):\r\n        \"\"\"Fit the model\r\n\r\n        Parameters\r\n        ----------\r\n        X : numpy array of shape [n_samples,n_features]\r\n            Training data\r\n        y : numpy array of shape [n_samples]\r\n            Target values. Will be cast to X's dtype if necessary\r\n\r\n        sample_weight : numpy array of shape [n_samples]\r\n            Individual weights for each sample\r\n\r\n            .. versionadded:: 0.20\r\n               parameter *sample_weight* support to BayesianRidge.\r\n\r\n        Returns\r\n        -------\r\n        self : returns an instance of self.\r\n        \"\"\"\r\n        X, y = check_X_y(X, y, dtype=np.float64, y_numeric=True)\r\n        X, y, X_offset_, y_offset_, X_scale_ = self._preprocess_data(\r\n            X, y, self.fit_intercept, self.normalize, self.copy_X,\r\n            sample_weight=sample_weight)\r\n\r\n        if sample_weight is not None:\r\n            # Sample weight can be implemented via a simple rescaling.\r\n            X, y = _rescale_data(X, y, sample_weight)\r\n\r\n        self.X_offset_ = X_offset_\r\n        self.X_scale_ = X_scale_\r\n        n_samples, n_features = X.shape\r\n\r\n        # Initialization of the values of the parameters\r\n        eps = np.finfo(np.float64).eps\r\n        # Add `eps` in the denominator to omit division by zero if `np.var(y)`\r\n        # is zero\r\n        if alpha_0 is None:\r\n            alpha_ = 1. / (np.var(y) + eps)\r\n        else:\r\n            alpha_ = alpha_0\r\n        if lambda_0 is None:\r\n            lambda_ = 1.\r\n        else:\r\n            lambda_ = lambda_0\r\n\r\n        verbose = self.verbose\r\n        lambda_1 = self.lambda_1\r\n        lambda_2 = self.lambda_2\r\n        alpha_1 = self.alpha_1\r\n        alpha_2 = self.alpha_2\r\n\r\n        self.scores_ = list()\r\n        coef_old_ = None\r\n\r\n        XT_y = np.dot(X.T, y)\r\n        U, S, Vh = linalg.svd(X, full_matrices=False)\r\n        eigen_vals_ = S ** 2\r\n\r\n        # Convergence loop of the bayesian ridge regression\r\n        for iter_ in range(self.n_iter):\r\n\r\n            # Compute mu and sigma\r\n            # sigma_ = lambda_ / alpha_ * np.eye(n_features) + np.dot(X.T, X)\r\n            # coef_ = sigma_^-1 * XT * y\r\n            if n_samples > n_features:\r\n                coef_ = np.dot(Vh.T,\r\n                               Vh / (eigen_vals_ +\r\n                                     lambda_ / alpha_)[:, np.newaxis])\r\n                coef_ = np.dot(coef_, XT_y)\r\n                if self.compute_score:\r\n                    logdet_sigma_ = - np.sum(\r\n                        np.log(lambda_ + alpha_ * eigen_vals_))\r\n            else:\r\n                coef_ = np.dot(X.T, np.dot(\r\n                    U / (eigen_vals_ + lambda_ / alpha_)[None, :], U.T))\r\n                coef_ = np.dot(coef_, y)\r\n                if self.compute_score:\r\n                    logdet_sigma_ = np.full(n_features, lambda_,\r\n                                            dtype=np.array(lambda_).dtype)\r\n                    logdet_sigma_[:n_samples] += alpha_ * eigen_vals_\r\n                    logdet_sigma_ = - np.sum(np.log(logdet_sigma_))\r\n\r\n            # Preserve the alpha and lambda values that were used to\r\n            # calculate the final coefficients\r\n            self.alpha_ = alpha_\r\n            self.lambda_ = lambda_\r\n\r\n            # Update alpha and lambda\r\n            rmse_ = np.sum((y - np.dot(X, coef_)) ** 2)\r\n            gamma_ = (np.sum((alpha_ * eigen_vals_) /\r\n                      (lambda_ + alpha_ * eigen_vals_)))\r\n            lambda_ = ((gamma_ + 2 * lambda_1) /\r\n                       (np.sum(coef_ ** 2) + 2 * lambda_2))\r\n            alpha_ = ((n_samples - gamma_ + 2 * alpha_1) /\r\n                      (rmse_ + 2 * alpha_2))\r\n\r\n            # Compute the objective function\r\n            if self.compute_score:\r\n                s = lambda_1 * log(lambda_) - lambda_2 * lambda_\r\n                s += alpha_1 * log(alpha_) - alpha_2 * alpha_\r\n                s += 0.5 * (n_features * log(lambda_) +\r\n                            n_samples * log(alpha_) -\r\n                            alpha_ * rmse_ -\r\n                            (lambda_ * np.sum(coef_ ** 2)) -\r\n                            logdet_sigma_ -\r\n                            n_samples * log(2 * np.pi))\r\n                self.scores_.append(s)\r\n\r\n            # Check for convergence\r\n            if iter_ != 0 and np.sum(np.abs(coef_old_ - coef_)) < self.tol:\r\n                if verbose:\r\n                    print(\"Convergence after \", str(iter_), \" iterations\")\r\n                break\r\n            coef_old_ = np.copy(coef_)\r\n\r\n        self.coef_ = coef_\r\n        sigma_ = np.dot(Vh.T,\r\n                        Vh / (eigen_vals_ + lambda_ / alpha_)[:, np.newaxis])\r\n        self.sigma_ = (1. / alpha_) * sigma_\r\n\r\n        self._set_intercept(X_offset_, y_offset_, X_scale_)\r\n        return self\r\n\r\ndef main():\r\n    def func(x):\r\n        return np.sin(2*np.pi*x)\r\n    size = 25\r\n    np.random.seed(1234)\r\n    xtrain = np.random.uniform(0.,1.,size)\r\n    ytrain = func(xtrain)+np.random.normal(scale=0.1,size=size)\r\n    xtest = np.linspace(0.,1.,100)\r\n\r\n    nOrder = 3\r\n    Xtrain = np.vander(xtrain,nOrder+1,increasing=True)\r\n    Xtest = np.vander(xtest,nOrder+1,increasing=True)\r\n\r\n    fig,ax = plt.subplots(1,2,figsize=(8,4))\r\n    regs = [BayesianRidge(tol=1e-6,fit_intercept=False),\r\n            BayesRidge(tol=1e-6,fit_intercept=False)]\r\n    init = (1.,1.e-3)\r\n\r\n    for i,reg in enumerate(regs):\r\n        if i == 0:\r\n            reg.fit(Xtrain,ytrain)\r\n        elif i == 1:\r\n            reg.fit(Xtrain,ytrain,alpha_0=init[0],lambda_0=init[1])\r\n\r\n        ymean,ystd = reg.predict(Xtest,return_std=True)\r\n        print(reg.alpha_,reg.lambda_)\r\n\r\n        ax[i].scatter(xtrain,ytrain, s=50, alpha=0.5, label=\"observation\")\r\n        ax[i].plot(xtest,func(xtest), color=\"blue\", label=\"sin(2$πx$)\")\r\n        ax[i].plot(xtest,ymean, color=\"red\", label=\"predict_mean\")\r\n        ax[i].fill_between(xtest,ymean-ystd,ymean+ystd, color=\"pink\", alpha=0.5, label=\"predict_std\")\r\n        ax[i].legend()\r\n        if i == 0:\r\n            ax[i].set_title(\"BayesianRidge\")\r\n        elif i == 1:\r\n            ax[i].set_title(\"$α₀={} ,λ₀=${}\".format(init[0],init[1]))\r\n\r\n    plt.tight_layout()\r\n    plt.show()\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n```\r\n#### Expected Results\r\n<!-- Example: No error is thrown. Please paste or describe the expected results.-->\r\nThe right figure\r\n#### Actual Results\r\n<!-- Please paste or specifically describe the actual output or traceback. -->\r\nThe left figure\r\n#### Versions\r\n<!--\r\nPlease run the following snippet and paste the output below.\r\nFor scikit-learn >= 0.20:\r\nimport sklearn; sklearn.show_versions()\r\nFor scikit-learn < 0.20:\r\nimport platform; print(platform.platform())\r\nimport sys; print(\"Python\", sys.version)\r\nimport numpy; print(\"NumPy\", numpy.__version__)\r\nimport scipy; print(\"SciPy\", scipy.__version__)\r\nimport sklearn; print(\"Scikit-Learn\", sklearn.__version__)\r\n-->\r\nSystem:\r\n    python: 3.6.6 (default, Mar  8 2019, 18:24:30)  [GCC 7.3.0]\r\nexecutable: /home/*****/.pyenv/versions/3.6.6/bin/python\r\n   machine: Linux-4.15.0-47-generic-x86_64-with-debian-buster-sid\r\n\r\nBLAS:\r\n    macros: NO_ATLAS_INFO=1, HAVE_CBLAS=None\r\n  lib_dirs: /usr/lib/x86_64-linux-gnu\r\ncblas_libs: cblas\r\n\r\nPython deps:\r\n       pip: 19.0.3\r\nsetuptools: 41.0.0\r\n   sklearn: 0.20.3\r\n     numpy: 1.16.2\r\n     scipy: 1.2.1\r\n    Cython: 0.29.6\r\n    pandas: 0.24.2\r\n\r\n\r\n<!-- Thanks for contributing! -->\r\n\n",
  "hints_text": "Please submit a pull request rather than posting code so that we can see\nthe differences more clearly and comment on them. If you are not\ncomfortable doing that, please let us know.\n\nThank you jnothman\r\nI try it.",
  "created_at": "2019-04-11T11:04:24Z",
  "version": "0.22",
  "FAIL_TO_PASS": "[\"sklearn/linear_model/tests/test_bayes.py::test_bayesian_initial_params\"]",
  "PASS_TO_PASS": "[\"sklearn/linear_model/tests/test_bayes.py::test_n_iter\", \"sklearn/linear_model/tests/test_bayes.py::test_bayesian_ridge_scores\", \"sklearn/linear_model/tests/test_bayes.py::test_bayesian_ridge_score_values\", \"sklearn/linear_model/tests/test_bayes.py::test_bayesian_ridge_parameter\", \"sklearn/linear_model/tests/test_bayes.py::test_bayesian_sample_weights\", \"sklearn/linear_model/tests/test_bayes.py::test_toy_bayesian_ridge_object\", \"sklearn/linear_model/tests/test_bayes.py::test_prediction_bayesian_ridge_ard_with_constant_input\", \"sklearn/linear_model/tests/test_bayes.py::test_std_bayesian_ridge_ard_with_constant_input\", \"sklearn/linear_model/tests/test_bayes.py::test_update_of_sigma_in_ard\", \"sklearn/linear_model/tests/test_bayes.py::test_toy_ard_object\", \"sklearn/linear_model/tests/test_bayes.py::test_return_std\"]",
  "environment_setup_commit": "7e85a6d1f038bbb932b36f18d75df6be937ed00d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.997232",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}