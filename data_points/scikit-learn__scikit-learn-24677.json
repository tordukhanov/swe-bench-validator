{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-24677",
  "base_commit": "530dfc9631b2135412a048b5ec7cf01d155b6067",
  "patch": "diff --git a/sklearn/metrics/cluster/_unsupervised.py b/sklearn/metrics/cluster/_unsupervised.py\n--- a/sklearn/metrics/cluster/_unsupervised.py\n+++ b/sklearn/metrics/cluster/_unsupervised.py\n@@ -9,6 +9,7 @@\n import functools\n \n import numpy as np\n+from scipy.sparse import issparse\n \n from ...utils import check_random_state\n from ...utils import check_X_y\n@@ -122,8 +123,9 @@ def _silhouette_reduce(D_chunk, start, labels, label_freqs):\n \n     Parameters\n     ----------\n-    D_chunk : array-like of shape (n_chunk_samples, n_samples)\n-        Precomputed distances for a chunk.\n+    D_chunk : {array-like, sparse matrix} of shape (n_chunk_samples, n_samples)\n+        Precomputed distances for a chunk. If a sparse matrix is provided,\n+        only CSR format is accepted.\n     start : int\n         First index in the chunk.\n     labels : array-like of shape (n_samples,)\n@@ -131,22 +133,43 @@ def _silhouette_reduce(D_chunk, start, labels, label_freqs):\n     label_freqs : array-like\n         Distribution of cluster labels in ``labels``.\n     \"\"\"\n+    n_chunk_samples = D_chunk.shape[0]\n     # accumulate distances from each sample to each cluster\n-    clust_dists = np.zeros((len(D_chunk), len(label_freqs)), dtype=D_chunk.dtype)\n-    for i in range(len(D_chunk)):\n-        clust_dists[i] += np.bincount(\n-            labels, weights=D_chunk[i], minlength=len(label_freqs)\n-        )\n+    cluster_distances = np.zeros(\n+        (n_chunk_samples, len(label_freqs)), dtype=D_chunk.dtype\n+    )\n \n-    # intra_index selects intra-cluster distances within clust_dists\n-    intra_index = (np.arange(len(D_chunk)), labels[start : start + len(D_chunk)])\n-    # intra_clust_dists are averaged over cluster size outside this function\n-    intra_clust_dists = clust_dists[intra_index]\n+    if issparse(D_chunk):\n+        if D_chunk.format != \"csr\":\n+            raise TypeError(\n+                \"Expected CSR matrix. Please pass sparse matrix in CSR format.\"\n+            )\n+        for i in range(n_chunk_samples):\n+            indptr = D_chunk.indptr\n+            indices = D_chunk.indices[indptr[i] : indptr[i + 1]]\n+            sample_weights = D_chunk.data[indptr[i] : indptr[i + 1]]\n+            sample_labels = np.take(labels, indices)\n+            cluster_distances[i] += np.bincount(\n+                sample_labels, weights=sample_weights, minlength=len(label_freqs)\n+            )\n+    else:\n+        for i in range(n_chunk_samples):\n+            sample_weights = D_chunk[i]\n+            sample_labels = labels\n+            cluster_distances[i] += np.bincount(\n+                sample_labels, weights=sample_weights, minlength=len(label_freqs)\n+            )\n+\n+    # intra_index selects intra-cluster distances within cluster_distances\n+    end = start + n_chunk_samples\n+    intra_index = (np.arange(n_chunk_samples), labels[start:end])\n+    # intra_cluster_distances are averaged over cluster size outside this function\n+    intra_cluster_distances = cluster_distances[intra_index]\n     # of the remaining distances we normalise and extract the minimum\n-    clust_dists[intra_index] = np.inf\n-    clust_dists /= label_freqs\n-    inter_clust_dists = clust_dists.min(axis=1)\n-    return intra_clust_dists, inter_clust_dists\n+    cluster_distances[intra_index] = np.inf\n+    cluster_distances /= label_freqs\n+    inter_cluster_distances = cluster_distances.min(axis=1)\n+    return intra_cluster_distances, inter_cluster_distances\n \n \n def silhouette_samples(X, labels, *, metric=\"euclidean\", **kwds):\n@@ -174,9 +197,11 @@ def silhouette_samples(X, labels, *, metric=\"euclidean\", **kwds):\n \n     Parameters\n     ----------\n-    X : array-like of shape (n_samples_a, n_samples_a) if metric == \\\n+    X : {array-like, sparse matrix} of shape (n_samples_a, n_samples_a) if metric == \\\n             \"precomputed\" or (n_samples_a, n_features) otherwise\n-        An array of pairwise distances between samples, or a feature array.\n+        An array of pairwise distances between samples, or a feature array. If\n+        a sparse matrix is provided, CSR format should be favoured avoiding\n+        an additional copy.\n \n     labels : array-like of shape (n_samples,)\n         Label values for each sample.\n@@ -209,7 +234,7 @@ def silhouette_samples(X, labels, *, metric=\"euclidean\", **kwds):\n     .. [2] `Wikipedia entry on the Silhouette Coefficient\n        <https://en.wikipedia.org/wiki/Silhouette_(clustering)>`_\n     \"\"\"\n-    X, labels = check_X_y(X, labels, accept_sparse=[\"csc\", \"csr\"])\n+    X, labels = check_X_y(X, labels, accept_sparse=[\"csr\"])\n \n     # Check for non-zero diagonal entries in precomputed distance matrix\n     if metric == \"precomputed\":\n@@ -219,10 +244,10 @@ def silhouette_samples(X, labels, *, metric=\"euclidean\", **kwds):\n         )\n         if X.dtype.kind == \"f\":\n             atol = np.finfo(X.dtype).eps * 100\n-            if np.any(np.abs(np.diagonal(X)) > atol):\n-                raise ValueError(error_msg)\n-        elif np.any(np.diagonal(X) != 0):  # integral dtype\n-            raise ValueError(error_msg)\n+            if np.any(np.abs(X.diagonal()) > atol):\n+                raise error_msg\n+        elif np.any(X.diagonal() != 0):  # integral dtype\n+            raise error_msg\n \n     le = LabelEncoder()\n     labels = le.fit_transform(labels)\n",
  "test_patch": "diff --git a/sklearn/metrics/cluster/tests/test_unsupervised.py b/sklearn/metrics/cluster/tests/test_unsupervised.py\n--- a/sklearn/metrics/cluster/tests/test_unsupervised.py\n+++ b/sklearn/metrics/cluster/tests/test_unsupervised.py\n@@ -1,14 +1,17 @@\n import warnings\n \n import numpy as np\n-import scipy.sparse as sp\n import pytest\n-from scipy.sparse import csr_matrix\n+\n+from numpy.testing import assert_allclose\n+from scipy.sparse import csr_matrix, csc_matrix, dok_matrix, lil_matrix\n+from scipy.sparse import issparse\n \n from sklearn import datasets\n from sklearn.utils._testing import assert_array_equal\n from sklearn.metrics.cluster import silhouette_score\n from sklearn.metrics.cluster import silhouette_samples\n+from sklearn.metrics.cluster._unsupervised import _silhouette_reduce\n from sklearn.metrics import pairwise_distances\n from sklearn.metrics.cluster import calinski_harabasz_score\n from sklearn.metrics.cluster import davies_bouldin_score\n@@ -19,11 +22,12 @@ def test_silhouette():\n     dataset = datasets.load_iris()\n     X_dense = dataset.data\n     X_csr = csr_matrix(X_dense)\n-    X_dok = sp.dok_matrix(X_dense)\n-    X_lil = sp.lil_matrix(X_dense)\n+    X_csc = csc_matrix(X_dense)\n+    X_dok = dok_matrix(X_dense)\n+    X_lil = lil_matrix(X_dense)\n     y = dataset.target\n \n-    for X in [X_dense, X_csr, X_dok, X_lil]:\n+    for X in [X_dense, X_csr, X_csc, X_dok, X_lil]:\n         D = pairwise_distances(X, metric=\"euclidean\")\n         # Given that the actual labels are used, we can assume that S would be\n         # positive.\n@@ -282,6 +286,47 @@ def test_silhouette_nonzero_diag(dtype):\n         silhouette_samples(dists, labels, metric=\"precomputed\")\n \n \n+@pytest.mark.parametrize(\"to_sparse\", (csr_matrix, csc_matrix, dok_matrix, lil_matrix))\n+def test_silhouette_samples_precomputed_sparse(to_sparse):\n+    \"\"\"Check that silhouette_samples works for sparse matrices correctly.\"\"\"\n+    X = np.array([[0.2, 0.1, 0.1, 0.2, 0.1, 1.6, 0.2, 0.1]], dtype=np.float32).T\n+    y = [0, 0, 0, 0, 1, 1, 1, 1]\n+    pdist_dense = pairwise_distances(X)\n+    pdist_sparse = to_sparse(pdist_dense)\n+    assert issparse(pdist_sparse)\n+    output_with_sparse_input = silhouette_samples(pdist_sparse, y, metric=\"precomputed\")\n+    output_with_dense_input = silhouette_samples(pdist_dense, y, metric=\"precomputed\")\n+    assert_allclose(output_with_sparse_input, output_with_dense_input)\n+\n+\n+@pytest.mark.parametrize(\"to_sparse\", (csr_matrix, csc_matrix, dok_matrix, lil_matrix))\n+def test_silhouette_samples_euclidean_sparse(to_sparse):\n+    \"\"\"Check that silhouette_samples works for sparse matrices correctly.\"\"\"\n+    X = np.array([[0.2, 0.1, 0.1, 0.2, 0.1, 1.6, 0.2, 0.1]], dtype=np.float32).T\n+    y = [0, 0, 0, 0, 1, 1, 1, 1]\n+    pdist_dense = pairwise_distances(X)\n+    pdist_sparse = to_sparse(pdist_dense)\n+    assert issparse(pdist_sparse)\n+    output_with_sparse_input = silhouette_samples(pdist_sparse, y)\n+    output_with_dense_input = silhouette_samples(pdist_dense, y)\n+    assert_allclose(output_with_sparse_input, output_with_dense_input)\n+\n+\n+@pytest.mark.parametrize(\"to_non_csr_sparse\", (csc_matrix, dok_matrix, lil_matrix))\n+def test_silhouette_reduce(to_non_csr_sparse):\n+    \"\"\"Check for non-CSR input to private method `_silhouette_reduce`.\"\"\"\n+    X = np.array([[0.2, 0.1, 0.1, 0.2, 0.1, 1.6, 0.2, 0.1]], dtype=np.float32).T\n+    pdist_dense = pairwise_distances(X)\n+    pdist_sparse = to_non_csr_sparse(pdist_dense)\n+    y = [0, 0, 0, 0, 1, 1, 1, 1]\n+    label_freqs = np.bincount(y)\n+    with pytest.raises(\n+        TypeError,\n+        match=\"Expected CSR matrix. Please pass sparse matrix in CSR format.\",\n+    ):\n+        _silhouette_reduce(pdist_sparse, start=0, labels=y, label_freqs=label_freqs)\n+\n+\n def assert_raises_on_only_one_label(func):\n     \"\"\"Assert message when there is only one label\"\"\"\n     rng = np.random.RandomState(seed=0)\n",
  "problem_statement": "[MRG] Fixes sklearn.metrics.silhouette_samples for sparse matrices\n<!--\r\nThanks for contributing a pull request! Please ensure you have taken a look at\r\nthe contribution guidelines: https://github.com/scikit-learn/scikit-learn/blob/master/CONTRIBUTING.md#pull-request-checklist\r\n-->\r\n\r\n#### Reference Issues/PRs\r\nFixes #18524 \r\n\r\n\r\n#### What does this implement/fix? Explain your changes.\r\nThe changes update the reduce function used for computing the intra-cluster and inter-cluster distances. The current version is failing at,\r\na) the pre-computed check for sparse matrices while getting the diagonal elements\r\nb) when trying to index a sparse matrix to pass weights to np.bincount function\r\n\r\n#### Any other comments?\r\n\r\n\r\n<!--\r\nPlease be aware that we are a loose team of volunteers so patience is\r\nnecessary; assistance handling other issues is very welcome. We value\r\nall user contributions, no matter how minor they are. If we are slow to\r\nreview, either the pull request needs some benchmarking, tinkering,\r\nconvincing, etc. or more likely the reviewers are simply busy. In either\r\ncase, we ask for your understanding during the review process.\r\nFor more information, see our FAQ on this topic:\r\nhttp://scikit-learn.org/dev/faq.html#why-is-my-pull-request-not-getting-any-attention.\r\n\r\nThanks for contributing!\r\n-->\r\n\n",
  "hints_text": "",
  "created_at": "2022-10-16T10:10:38Z",
  "version": "1.3",
  "FAIL_TO_PASS": "[\"sklearn/metrics/cluster/tests/test_unsupervised.py::test_silhouette_samples_precomputed_sparse[csr_matrix]\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_silhouette_samples_precomputed_sparse[csc_matrix]\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_silhouette_samples_precomputed_sparse[dok_matrix]\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_silhouette_samples_precomputed_sparse[lil_matrix]\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_silhouette_reduce[csc_matrix]\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_silhouette_reduce[dok_matrix]\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_silhouette_reduce[lil_matrix]\"]",
  "PASS_TO_PASS": "[\"sklearn/metrics/cluster/tests/test_unsupervised.py::test_silhouette\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_cluster_size_1\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_silhouette_paper_example\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_correct_labelsize\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_non_encoded_labels\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_non_numpy_labels\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_silhouette_nonzero_diag[float32]\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_silhouette_nonzero_diag[float64]\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_silhouette_samples_euclidean_sparse[csr_matrix]\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_silhouette_samples_euclidean_sparse[csc_matrix]\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_silhouette_samples_euclidean_sparse[dok_matrix]\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_silhouette_samples_euclidean_sparse[lil_matrix]\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_calinski_harabasz_score\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_davies_bouldin_score\", \"sklearn/metrics/cluster/tests/test_unsupervised.py::test_silhouette_score_integer_precomputed\"]",
  "environment_setup_commit": "1e8a5b833d1b58f3ab84099c4582239af854b23a",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.015207",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}