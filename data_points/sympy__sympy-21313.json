{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-21313",
  "base_commit": "546e10799fe55b3e59dea8fa6b3a6d6e71843d33",
  "patch": "diff --git a/sympy/sets/handlers/functions.py b/sympy/sets/handlers/functions.py\n--- a/sympy/sets/handlers/functions.py\n+++ b/sympy/sets/handlers/functions.py\n@@ -1,4 +1,4 @@\n-from sympy import Set, symbols, exp, log, S, Wild, Dummy, oo\n+from sympy import Set, symbols, exp, log, S, Wild, Dummy, oo, Float\n from sympy.core import Expr, Add\n from sympy.core.function import Lambda, _coeff_isneg, FunctionClass\n from sympy.logic.boolalg import true\n@@ -192,7 +192,9 @@ def _set_function(f, self): # noqa:F811\n     a = Wild('a', exclude=[n])\n     b = Wild('b', exclude=[n])\n     match = expr.match(a*n + b)\n-    if match and match[a]:\n+    if match and match[a] and (\n+            not match[a].atoms(Float) and\n+            not match[b].atoms(Float)):\n         # canonical shift\n         a, b = match[a], match[b]\n         if a in [1, -1]:\n",
  "test_patch": "diff --git a/sympy/sets/tests/test_fancysets.py b/sympy/sets/tests/test_fancysets.py\n--- a/sympy/sets/tests/test_fancysets.py\n+++ b/sympy/sets/tests/test_fancysets.py\n@@ -480,6 +480,9 @@ def test_Integers_eval_imageset():\n     y = Symbol('y')\n     L = imageset(x, 2*x + y, S.Integers)\n     assert y + 4 in L\n+    a, b, c = 0.092, 0.433, 0.341\n+    assert a in imageset(x, a + c*x, S.Integers)\n+    assert b in imageset(x, b + c*x, S.Integers)\n \n     _x = symbols('x', negative=True)\n     eq = _x**2 - _x + 1\n",
  "problem_statement": "don't canonicalize imageset based on Float\nWhile writing this [answer](https://stackoverflow.com/a/67053708/1089161) about how to get something resembling a float-version for range to work, I tried to think about how I would do this in SymPy. Although Floats present their own difficulties, there is canonicalization being done with `imageset` expressions that makes this even worse:\r\n```\r\n>>> a,b,c = 0.092, 0.433, 0.341\r\n>>> a in imageset(x,a+c*x,Integers)\r\nTrue\r\n>>> a in imageset(x,b+c*x,Integers)\r\nFalse  <- expected based on nature of floats\r\n>>> b in imageset(x,b+c*x,Integers)  # this should not be expected\r\nFalse <- not expected\r\n```\r\nThat last result should represent an error. The reason it happens is because `b` is replaced with `b%c`:\r\n```\r\n>>> b, round(b%c,3), imageset(x,b+c*x,Integers)\r\n(0.433, 0.092, ImageSet(Lambda(x, 0.341*x + 0.092), Integers))\r\n```\r\nSo while canonicalization is OK for Rationals, it should not be done to Floats.\r\n\r\nWorking around this issue, here is a version of `frange` that might work for SymPy:\r\n```python\r\ndef frange(A, a, step, rational=None, _str=True):\r\n    \"\"\"return all values between `a` and `A` that are separated by `step`\r\n    and that include `A`.\r\n\r\n    EXAMPLES\r\n    ========\r\n\r\n    >>> frange(1, 3, .6)\r\n    FiniteSet(1.0, 1.6, 2.2, 2.8)\r\n    >>> frange(3, 1, .6)\r\n    FiniteSet(1.2, 1.8, 2.4, 3.0)\r\n    >>> frange(1, 3, .6, rational=True)\r\n    FiniteSet(1, 8/5, 11/5, 14/5)\r\n\r\n    >>> a, b, c = 0.092, 0.433, 0.341\r\n    >>> frange(a, b, c) == frange(b, a, c) == FiniteSet(0.092, 0.433)\r\n\r\n    Input values are parsed in WYSIWYG fashion by using Rational\r\n    equivalents of the `str` values of the input. Note the difference\r\n    between the last example above and those below when this is\r\n    disabled:\r\n\r\n    >>> frange(a, b, c, _str=False)\r\n    FiniteSet(0.092)\r\n    >>> frange(b, a, c, _str=False)\r\n    FiniteSet(0.433)\r\n\r\n    The binary representations of `a` and `b` are such that the\r\n    difference is not `c` unless the fraction corresponding to the\r\n    `str` values is used:\r\n\r\n    >>> b - a == c\r\n    False\r\n    >>> Rational(str(b)) - Rational(str(a)) == Rational(str(c))\r\n    True\r\n    \"\"\"\r\n    from sympy.functions.special.gamma_functions import intlike\r\n    if A == a:\r\n        return S.EmptySet\r\n    v = A, a, step\r\n    A, B, C = [Rational(str(i) if _str else i) for i in v]\r\n    inf = min(A, B)\r\n    sup = max(A, B)\r\n    rv = Interval(inf, sup).intersection(\r\n    imageset(x, A + x*C, Integers))\r\n    if not rational and not all(intlike(i) for i in v):\r\n        rv = rv.func(*[float(i) for i in rv])\r\n    return rv\r\n```\n",
  "hints_text": "",
  "created_at": "2021-04-13T17:15:18Z",
  "version": "1.9",
  "FAIL_TO_PASS": "[\"test_Integers_eval_imageset\"]",
  "PASS_TO_PASS": "[\"test_naturals\", \"test_naturals0\", \"test_integers\", \"test_ImageSet\", \"test_image_is_ImageSet\", \"test_halfcircle\", \"test_ImageSet_iterator_not_injective\", \"test_inf_Range_len\", \"test_Range_set\", \"test_Range_symbolic\", \"test_range_range_intersection\", \"test_range_interval_intersection\", \"test_range_is_finite_set\", \"test_Range_eval_imageset\", \"test_fun\", \"test_Reals\", \"test_Complex\", \"test_intersections\", \"test_infinitely_indexed_set_1\", \"test_infinitely_indexed_set_2\", \"test_imageset_intersect_real\", \"test_imageset_intersect_interval\", \"test_imageset_intersect_diophantine\", \"test_infinitely_indexed_set_3\", \"test_ImageSet_simplification\", \"test_ImageSet_contains\", \"test_ComplexRegion_contains\", \"test_ComplexRegion_intersect\", \"test_ComplexRegion_union\", \"test_ComplexRegion_from_real\", \"test_ComplexRegion_measure\", \"test_normalize_theta_set\", \"test_ComplexRegion_FiniteSet\", \"test_union_RealSubSet\", \"test_issue_9980\", \"test_issue_11732\", \"test_issue_11730\", \"test_issue_11938\", \"test_issue_11914\", \"test_issue_9543\", \"test_issue_16871\", \"test_issue_18050\", \"test_Rationals\", \"test_NZQRC_unions\", \"test_imageset_intersection\", \"test_issue_17858\"]",
  "environment_setup_commit": "f9a6f50ec0c74d935c50a6e9c9b2cb0469570d91",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.142699",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}