{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-12585",
  "base_commit": "bfc4a566423e036fbdc9fb02765fd893e4860c85",
  "patch": "diff --git a/sklearn/base.py b/sklearn/base.py\n--- a/sklearn/base.py\n+++ b/sklearn/base.py\n@@ -48,7 +48,7 @@ def clone(estimator, safe=True):\n     # XXX: not handling dictionaries\n     if estimator_type in (list, tuple, set, frozenset):\n         return estimator_type([clone(e, safe=safe) for e in estimator])\n-    elif not hasattr(estimator, 'get_params'):\n+    elif not hasattr(estimator, 'get_params') or isinstance(estimator, type):\n         if not safe:\n             return copy.deepcopy(estimator)\n         else:\n",
  "test_patch": "diff --git a/sklearn/tests/test_base.py b/sklearn/tests/test_base.py\n--- a/sklearn/tests/test_base.py\n+++ b/sklearn/tests/test_base.py\n@@ -167,6 +167,15 @@ def test_clone_sparse_matrices():\n         assert_array_equal(clf.empty.toarray(), clf_cloned.empty.toarray())\n \n \n+def test_clone_estimator_types():\n+    # Check that clone works for parameters that are types rather than\n+    # instances\n+    clf = MyEstimator(empty=MyEstimator)\n+    clf2 = clone(clf)\n+\n+    assert clf.empty is clf2.empty\n+\n+\n def test_repr():\n     # Smoke test the repr of the base estimator.\n     my_estimator = MyEstimator()\n",
  "problem_statement": "clone fails for parameters that are estimator types\n#### Description\r\n\r\n`clone` fails when one or more instance parameters are estimator types (i.e. not instances, but classes). \r\n\r\nI know this is a somewhat unusual use case, but I'm working on a project that provides wrappers for sklearn estimators (https://github.com/phausamann/sklearn-xarray) and I'd like to store the wrapped estimators as their classes - not their instances - as a parameter inside of a wrapper that behaves like an estimator itself. \r\n\r\n#### Steps/Code to Reproduce\r\n\r\n    from sklearn.preprocessing import StandardScaler\r\n    from sklearn.base import clone\r\n    clone(StandardScaler(with_mean=StandardScaler))\r\n\r\n#### Expected Results\r\n\r\nNo error.\r\n\r\n#### Actual Results\r\n```\r\nTraceback (most recent call last):\r\n...\r\n  File \"...\\lib\\site-packages\\sklearn\\base.py\", line 62, in clone\r\n    new_object_params[name] = clone(param, safe=False)\r\n  File \"...\\lib\\site-packages\\sklearn\\base.py\", line 60, in clone\r\n    new_object_params = estimator.get_params(deep=False)\r\nTypeError: get_params() missing 1 required positional argument: 'self'\r\n```\r\n\r\n#### Possible fix\r\n\r\nChange `base.py`, line 51 to: \r\n\r\n    elif not hasattr(estimator, 'get_params') or isinstance(estimator, type):\r\n\r\nI'm not sure whether this might break stuff in other places, however. I'd happily submit a PR if this change is desired.\r\n\r\n#### Versions\r\n\r\n    sklearn: 0.20.0\r\n\r\n\n",
  "hints_text": "I'm not certain that we want to support this case: why do you want it to be\na class? Why do you want it to be a parameter? Why is this better as a\nwrapper than a mixin?\n\nThe idea is the following: Suppose we have some\r\n\r\n    Estimator(param1=None, param2=None)\r\n\r\nthat implements `fit` and `predict` and has a fitted attribute `result_` \r\n\r\nNow the wrapper, providing some compatibility methods, is constructed as\r\n\r\n    EstimatorWrapper(estimator=Estimator, param1=None, param2=None)\r\n\r\nThis wrapper, apart from the `estimator` parameter, behaves exactly like the original `Estimator` class, i.e. it has the attributes `param1` and `param2`, calls `Estimator.fit` and `Estimator.predict` and, when fitted, also has the attribute `result_`. \r\n\r\nThe reason I want to store the `estimator` as its class is to make it clear to the user that any parameter changes are to be done on the wrapper and not on the wrapped estimator. The latter should only be constructed \"on demand\" when one of its methods is called.\r\n\r\nI actually do provide a mixin mechanism, but the problem is that each sklearn estimator would then need a dedicated class that subclasses both the original estimator and the mixin (actually, multiple mixins, one for each estimator method). In the long term, I plan to replicate all sklearn estimators in this manner so they can be used as drop-in replacements when imported from my package, but for now it's a lot easier to use a wrapper (also for user-defined estimators).  \r\n\r\nNow I'm not an expert in python OOP, so I don't claim this is the best way to do it, but it has worked for me quite well so far.\r\n\r\nI do understand that you would not want to support a fringe case like this, regarding the potential for user error when classes and instances are both allowed as parameters. In that case, I think that `clone` should at least be more verbose about why it fails when trying to clone classes.\nI'll have to think about this more another time.\r\n\r\nI don't have any good reason to reject cloning classes, TBH...\nI think it's actually a bug in ``clone``: our test for whether something is an estimator is too loose. If we check that it's an instance in the same \"if\", does that solve the problem?\nWe need to support non-estimators with get_params, such as Kernel, so\n`isinstance(obj, BaseEstimator)` is not appropriate, but `not\nisinstance(obj, type)` might be. Alternatively can check if\n`inspect.ismethod(obj.get_params)`\n",
  "created_at": "2018-11-14T13:20:30Z",
  "version": "0.21",
  "FAIL_TO_PASS": "[\"sklearn/tests/test_base.py::test_clone_estimator_types\"]",
  "PASS_TO_PASS": "[\"sklearn/tests/test_base.py::test_clone\", \"sklearn/tests/test_base.py::test_clone_2\", \"sklearn/tests/test_base.py::test_clone_buggy\", \"sklearn/tests/test_base.py::test_clone_empty_array\", \"sklearn/tests/test_base.py::test_clone_nan\", \"sklearn/tests/test_base.py::test_clone_sparse_matrices\", \"sklearn/tests/test_base.py::test_repr\", \"sklearn/tests/test_base.py::test_str\", \"sklearn/tests/test_base.py::test_get_params\", \"sklearn/tests/test_base.py::test_is_classifier\", \"sklearn/tests/test_base.py::test_set_params\", \"sklearn/tests/test_base.py::test_set_params_passes_all_parameters\", \"sklearn/tests/test_base.py::test_set_params_updates_valid_params\", \"sklearn/tests/test_base.py::test_score_sample_weight\", \"sklearn/tests/test_base.py::test_clone_pandas_dataframe\", \"sklearn/tests/test_base.py::test_pickle_version_warning_is_not_raised_with_matching_version\", \"sklearn/tests/test_base.py::test_pickle_version_warning_is_issued_upon_different_version\", \"sklearn/tests/test_base.py::test_pickle_version_warning_is_issued_when_no_version_info_in_pickle\", \"sklearn/tests/test_base.py::test_pickle_version_no_warning_is_issued_with_non_sklearn_estimator\", \"sklearn/tests/test_base.py::test_pickling_when_getstate_is_overwritten_by_mixin\", \"sklearn/tests/test_base.py::test_pickling_when_getstate_is_overwritten_by_mixin_outside_of_sklearn\", \"sklearn/tests/test_base.py::test_pickling_works_when_getstate_is_overwritten_in_the_child_class\"]",
  "environment_setup_commit": "7813f7efb5b2012412888b69e73d76f2df2b50b6",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.965399",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}