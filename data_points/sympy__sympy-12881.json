{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-12881",
  "base_commit": "d2c3800fd3aaa226c0d37da84086530dd3e5abaf",
  "patch": "diff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -255,7 +255,7 @@ def free_symbols(self):\n         ========\n \n         >>> from sympy import Poly\n-        >>> from sympy.abc import x, y\n+        >>> from sympy.abc import x, y, z\n \n         >>> Poly(x**2 + 1).free_symbols\n         {x}\n@@ -263,12 +263,17 @@ def free_symbols(self):\n         {x, y}\n         >>> Poly(x**2 + y, x).free_symbols\n         {x, y}\n+        >>> Poly(x**2 + y, x, z).free_symbols\n+        {x, y}\n \n         \"\"\"\n-        symbols = set([])\n-\n-        for gen in self.gens:\n-            symbols |= gen.free_symbols\n+        symbols = set()\n+        gens = self.gens\n+        for i in range(len(gens)):\n+            for monom in self.monoms():\n+                if monom[i]:\n+                    symbols |= gens[i].free_symbols\n+                    break\n \n         return symbols | self.free_symbols_in_domain\n \n@@ -609,7 +614,10 @@ def reorder(f, *gens, **args):\n \n     def ltrim(f, gen):\n         \"\"\"\n-        Remove dummy generators from the \"left\" of ``f``.\n+        Remove dummy generators from ``f`` that are to the left of\n+        specified ``gen`` in the generators as ordered. When ``gen``\n+        is an integer, it refers to the generator located at that\n+        position within the tuple of generators of ``f``.\n \n         Examples\n         ========\n@@ -619,20 +627,23 @@ def ltrim(f, gen):\n \n         >>> Poly(y**2 + y*z**2, x, y, z).ltrim(y)\n         Poly(y**2 + y*z**2, y, z, domain='ZZ')\n+        >>> Poly(z, x, y, z).ltrim(-1)\n+        Poly(z, z, domain='ZZ')\n \n         \"\"\"\n         rep = f.as_dict(native=True)\n         j = f._gen_to_level(gen)\n+\n         terms = {}\n \n         for monom, coeff in rep.items():\n-            monom = monom[j:]\n \n-            if monom not in terms:\n-                terms[monom] = coeff\n-            else:\n+            if any(i for i in monom[:j]):\n+                # some generator is used in the portion to be trimmed\n                 raise PolynomialError(\"can't left trim %s\" % f)\n \n+            terms[monom[j:]] = coeff\n+\n         gens = f.gens[j:]\n \n         return f.new(DMP.from_dict(terms, len(gens) - 1, f.rep.dom), *gens)\n@@ -653,7 +664,7 @@ def has_only_gens(f, *gens):\n         False\n \n         \"\"\"\n-        indices = set([])\n+        indices = set()\n \n         for gen in gens:\n             try:\ndiff --git a/sympy/solvers/polysys.py b/sympy/solvers/polysys.py\n--- a/sympy/solvers/polysys.py\n+++ b/sympy/solvers/polysys.py\n@@ -6,7 +6,7 @@\n from sympy.polys import Poly, groebner, roots\n from sympy.polys.polytools import parallel_poly_from_expr\n from sympy.polys.polyerrors import (ComputationFailed,\n-    PolificationFailed, CoercionFailed)\n+    PolificationFailed, CoercionFailed, PolynomialError)\n from sympy.simplify import rcollect\n from sympy.utilities import default_sort_key, postfixes\n \n@@ -37,10 +37,7 @@ def solve_poly_system(seq, *gens, **args):\n     if len(polys) == len(opt.gens) == 2:\n         f, g = polys\n \n-        a, b = f.degree_list()\n-        c, d = g.degree_list()\n-\n-        if a <= 2 and b <= 2 and c <= 2 and d <= 2:\n+        if all(i <= 2 for i in f.degree_list() + g.degree_list()):\n             try:\n                 return solve_biquadratic(f, g, opt)\n             except SolveFailed:\n@@ -79,13 +76,16 @@ def solve_biquadratic(f, g, opt):\n     if len(G) != 2:\n         raise SolveFailed\n \n-    p, q = G\n     x, y = opt.gens\n+    p, q = G\n+    if not p.gcd(q).is_ground:\n+        # not 0-dimensional\n+        raise SolveFailed\n \n     p = Poly(p, x, expand=False)\n-    q = q.ltrim(-1)\n-\n     p_roots = [ rcollect(expr, y) for expr in roots(p).keys() ]\n+\n+    q = q.ltrim(-1)\n     q_roots = list(roots(q).keys())\n \n     solutions = []\n@@ -161,7 +161,7 @@ def solve_generic(polys, opt):\n     def _is_univariate(f):\n         \"\"\"Returns True if 'f' is univariate in its last variable. \"\"\"\n         for monom in f.monoms():\n-            if any(m > 0 for m in monom[:-1]):\n+            if any(m for m in monom[:-1]):\n                 return False\n \n         return True\n",
  "test_patch": "diff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\n--- a/sympy/polys/tests/test_polytools.py\n+++ b/sympy/polys/tests/test_polytools.py\n@@ -468,6 +468,8 @@ def test_Poly_free_symbols():\n     assert Poly(x**2 + sin(y*z)).free_symbols == {x, y, z}\n     assert Poly(x**2 + sin(y*z), x).free_symbols == {x, y, z}\n     assert Poly(x**2 + sin(y*z), x, domain=EX).free_symbols == {x, y, z}\n+    assert Poly(1 + x + x**2, x, y, z).free_symbols == {x}\n+    assert Poly(x + sin(y), z).free_symbols == {x, y}\n \n \n def test_PurePoly_free_symbols():\n@@ -851,9 +853,10 @@ def test_Poly_reorder():\n def test_Poly_ltrim():\n     f = Poly(y**2 + y*z**2, x, y, z).ltrim(y)\n     assert f.as_expr() == y**2 + y*z**2 and f.gens == (y, z)\n+    assert Poly(x*y - x, z, x, y).ltrim(1) == Poly(x*y - x, x, y)\n \n     raises(PolynomialError, lambda: Poly(x*y**2 + y**2, x, y).ltrim(y))\n-\n+    raises(PolynomialError, lambda: Poly(x*y - x, x, y).ltrim(-1))\n \n def test_Poly_has_only_gens():\n     assert Poly(x*y + 1, x, y, z).has_only_gens(x, y) is True\ndiff --git a/sympy/solvers/tests/test_polysys.py b/sympy/solvers/tests/test_polysys.py\n--- a/sympy/solvers/tests/test_polysys.py\n+++ b/sympy/solvers/tests/test_polysys.py\n@@ -1,9 +1,12 @@\n \"\"\"Tests for solvers of systems of polynomial equations. \"\"\"\n \n-from sympy import flatten, I, Integer, Poly, QQ, Rational, S, sqrt, symbols\n+from sympy import (flatten, I, Integer, Poly, QQ, Rational, S, sqrt,\n+    solve, symbols)\n from sympy.abc import x, y, z\n from sympy.polys import PolynomialError\n-from sympy.solvers.polysys import solve_poly_system, solve_triangulated\n+from sympy.solvers.polysys import (solve_poly_system,\n+    solve_triangulated, solve_biquadratic, SolveFailed)\n+from sympy.polys.polytools import parallel_poly_from_expr\n from sympy.utilities.pytest import raises\n \n \n@@ -50,10 +53,10 @@ def test_solve_biquadratic():\n \n     f_1 = (x - 1)**2 + (y - 1)**2 - r**2\n     f_2 = (x - 2)**2 + (y - 2)**2 - r**2\n-\n-    assert solve_poly_system([f_1, f_2], x, y) == \\\n-        [(S(3)/2 - sqrt(-1 + 2*r**2)/2, S(3)/2 + sqrt(-1 + 2*r**2)/2),\n-         (S(3)/2 + sqrt(-1 + 2*r**2)/2, S(3)/2 - sqrt(-1 + 2*r**2)/2)]\n+    s = sqrt(2*r**2 - 1)\n+    a = (3 - s)/2\n+    b = (3 + s)/2\n+    assert solve_poly_system([f_1, f_2], x, y) == [(a, b), (b, a)]\n \n     f_1 = (x - 1)**2 + (y - 2)**2 - r**2\n     f_2 = (x - 1)**2 + (y - 1)**2 - r**2\n@@ -80,8 +83,28 @@ def test_solve_biquadratic():\n     assert len(result) == 2 and all(len(r) == 2 for r in result)\n     assert all(len(r.find(query)) == 1 for r in flatten(result))\n \n-\n-def test_solve_triangualted():\n+    s1 = (x*y - y, x**2 - x)\n+    assert solve(s1) == [{x: 1}, {x: 0, y: 0}]\n+    s2 = (x*y - x, y**2 - y)\n+    assert solve(s2) == [{y: 1}, {x: 0, y: 0}]\n+    gens = (x, y)\n+    for seq in (s1, s2):\n+        (f, g), opt = parallel_poly_from_expr(seq, *gens)\n+        raises(SolveFailed, lambda: solve_biquadratic(f, g, opt))\n+    seq = (x**2 + y**2 - 2, y**2 - 1)\n+    (f, g), opt = parallel_poly_from_expr(seq, *gens)\n+    assert solve_biquadratic(f, g, opt) == [\n+        (-1, -1), (-1, 1), (1, -1), (1, 1)]\n+    ans = [(0, -1), (0, 1)]\n+    seq = (x**2 + y**2 - 1, y**2 - 1)\n+    (f, g), opt = parallel_poly_from_expr(seq, *gens)\n+    assert solve_biquadratic(f, g, opt) == ans\n+    seq = (x**2 + y**2 - 1, x**2 - x + y**2 - 1)\n+    (f, g), opt = parallel_poly_from_expr(seq, *gens)\n+    assert solve_biquadratic(f, g, opt) == ans\n+\n+\n+def test_solve_triangulated():\n     f_1 = x**2 + y + z - 1\n     f_2 = x + y**2 + z - 1\n     f_3 = x + y + z**2 - 1\n",
  "problem_statement": "Poly(x,x,y).free_symbols -> {x, y} instead of just {x}\nNo free symbols of generators that don't appear in the expression of the polynomial should appear in the set of free symbols.\r\n\r\n```\r\ndef free_symbols(poly):\r\n free = set()\r\n for i in range(len(poly.gens)):\r\n    for m in poly.monoms():\r\n        if i in m:\r\n            free |= poly.gens[i].free_symbols\r\n            break\r\n return free | poly.free_symbols_in_domain  # not sure about the domain part....\r\n```\n",
  "hints_text": "```diff\r\ndiff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\r\nindex 9c12741..92e7ca6 100644\r\n--- a/sympy/polys/polytools.py\r\n+++ b/sympy/polys/polytools.py\r\n@@ -255,7 +255,7 @@ def free_symbols(self):\r\n         ========\r\n \r\n         >>> from sympy import Poly\r\n-        >>> from sympy.abc import x, y\r\n+        >>> from sympy.abc import x, y, z\r\n \r\n         >>> Poly(x**2 + 1).free_symbols\r\n         {x}\r\n@@ -263,12 +263,17 @@ def free_symbols(self):\r\n         {x, y}\r\n         >>> Poly(x**2 + y, x).free_symbols\r\n         {x, y}\r\n+        >>> Poly(x**2 + y, x, z).free_symbols\r\n+        {x, y}\r\n \r\n         \"\"\"\r\n-        symbols = set([])\r\n-\r\n-        for gen in self.gens:\r\n-            symbols |= gen.free_symbols\r\n+        symbols = set()\r\n+        gens = self.gens\r\n+        for i in range(len(gens)):\r\n+            for monom in self.monoms():\r\n+                if monom[i]:\r\n+                    symbols |= gens[i].free_symbols\r\n+                    break\r\n \r\n         return symbols | self.free_symbols_in_domain\r\n \r\ndiff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\r\nindex a1e5179..8e30ef1 100644\r\n--- a/sympy/polys/tests/test_polytools.py\r\n+++ b/sympy/polys/tests/test_polytools.py\r\n@@ -468,6 +468,8 @@ def test_Poly_free_symbols():\r\n     assert Poly(x**2 + sin(y*z)).free_symbols == {x, y, z}\r\n     assert Poly(x**2 + sin(y*z), x).free_symbols == {x, y, z}\r\n     assert Poly(x**2 + sin(y*z), x, domain=EX).free_symbols == {x, y, z}\r\n+    assert Poly(1 + x + x**2, x, y, z).free_symbols == {x}\r\n+    assert Poly(x + sin(y), z).free_symbols == {x, y}\r\n \r\n \r\n def test_PurePoly_free_symbols():\r\n\r\n```",
  "created_at": "2017-07-03T15:25:50Z",
  "version": "1.1",
  "FAIL_TO_PASS": "[\"test_Poly_free_symbols\", \"test_Poly_ltrim\"]",
  "PASS_TO_PASS": "[\"test_Poly_from_dict\", \"test_Poly_from_list\", \"test_Poly_from_poly\", \"test_Poly_from_expr\", \"test_Poly__new__\", \"test_Poly__args\", \"test_Poly__gens\", \"test_Poly_zero\", \"test_Poly_one\", \"test_Poly__unify\", \"test_PurePoly_free_symbols\", \"test_Poly__eq__\", \"test_PurePoly__eq__\", \"test_PurePoly_Poly\", \"test_Poly_get_domain\", \"test_Poly_set_domain\", \"test_Poly_get_modulus\", \"test_Poly_set_modulus\", \"test_Poly_add_ground\", \"test_Poly_sub_ground\", \"test_Poly_mul_ground\", \"test_Poly_quo_ground\", \"test_Poly_exquo_ground\", \"test_Poly_abs\", \"test_Poly_neg\", \"test_Poly_add\", \"test_Poly_sub\", \"test_Poly_mul\", \"test_Poly_sqr\", \"test_Poly_pow\", \"test_Poly_divmod\", \"test_Poly_eq_ne\", \"test_Poly_nonzero\", \"test_Poly_properties\", \"test_Poly_is_irreducible\", \"test_Poly_subs\", \"test_Poly_replace\", \"test_Poly_reorder\", \"test_Poly_has_only_gens\", \"test_Poly_to_ring\", \"test_Poly_to_field\", \"test_Poly_to_exact\", \"test_Poly_retract\", \"test_Poly_slice\", \"test_Poly_coeffs\", \"test_Poly_monoms\", \"test_Poly_terms\", \"test_Poly_all_coeffs\", \"test_Poly_all_monoms\", \"test_Poly_all_terms\", \"test_Poly_termwise\", \"test_Poly_length\", \"test_Poly_as_dict\", \"test_Poly_as_expr\", \"test_Poly_lift\", \"test_Poly_deflate\", \"test_Poly_inject\", \"test_Poly_eject\", \"test_Poly_exclude\", \"test_Poly__gen_to_level\", \"test_Poly_degree\", \"test_Poly_degree_list\", \"test_Poly_total_degree\", \"test_Poly_homogenize\", \"test_Poly_homogeneous_order\", \"test_Poly_LC\", \"test_Poly_TC\", \"test_Poly_EC\", \"test_Poly_coeff\", \"test_Poly_nth\", \"test_Poly_LM\", \"test_Poly_LM_custom_order\", \"test_Poly_EM\", \"test_Poly_LT\", \"test_Poly_ET\", \"test_Poly_max_norm\", \"test_Poly_l1_norm\", \"test_Poly_clear_denoms\", \"test_Poly_rat_clear_denoms\", \"test_Poly_integrate\", \"test_Poly_diff\", \"test_issue_9585\", \"test_Poly_eval\", \"test_Poly___call__\", \"test_parallel_poly_from_expr\", \"test_pdiv\", \"test_div\", \"test_gcdex\", \"test_revert\", \"test_subresultants\", \"test_resultant\", \"test_discriminant\", \"test_dispersion\", \"test_gcd_list\", \"test_lcm_list\", \"test_gcd\", \"test_gcd_numbers_vs_polys\", \"test_terms_gcd\", \"test_trunc\", \"test_monic\", \"test_content\", \"test_primitive\", \"test_compose\", \"test_shift\", \"test_transform\", \"test_gff\", \"test_sqf_norm\", \"test_sqf\", \"test_factor_large\", \"test_intervals\", \"test_refine_root\", \"test_count_roots\", \"test_Poly_root\", \"test_real_roots\", \"test_all_roots\", \"test_nroots\", \"test_ground_roots\", \"test_nth_power_roots_poly\", \"test_reduced\", \"test_groebner\", \"test_fglm\", \"test_is_zero_dimensional\", \"test_GroebnerBasis\", \"test_poly\", \"test_keep_coeff\", \"test_noncommutative\", \"test_to_rational_coeffs\", \"test_factor_terms\", \"test_issue_11198\"]",
  "environment_setup_commit": "ec9e3c0436fbff934fa84e22bf07f1b3ef5bfac3",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.078468",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}