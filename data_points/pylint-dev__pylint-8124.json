{
  "repo": "pylint-dev/pylint",
  "instance_id": "pylint-dev__pylint-8124",
  "base_commit": "eb950615d77a6b979af6e0d9954fdb4197f4a722",
  "patch": "diff --git a/pylint/checkers/imports.py b/pylint/checkers/imports.py\n--- a/pylint/checkers/imports.py\n+++ b/pylint/checkers/imports.py\n@@ -439,6 +439,15 @@ class ImportsChecker(DeprecatedMixin, BaseChecker):\n                 \"help\": \"Allow wildcard imports from modules that define __all__.\",\n             },\n         ),\n+        (\n+            \"allow-reexport-from-package\",\n+            {\n+                \"default\": False,\n+                \"type\": \"yn\",\n+                \"metavar\": \"<y or n>\",\n+                \"help\": \"Allow explicit reexports by alias from a package __init__.\",\n+            },\n+        ),\n     )\n \n     def __init__(self, linter: PyLinter) -> None:\n@@ -461,6 +470,7 @@ def open(self) -> None:\n         self.linter.stats = self.linter.stats\n         self.import_graph = defaultdict(set)\n         self._module_pkg = {}  # mapping of modules to the pkg they belong in\n+        self._current_module_package = False\n         self._excluded_edges: defaultdict[str, set[str]] = defaultdict(set)\n         self._ignored_modules: Sequence[str] = self.linter.config.ignored_modules\n         # Build a mapping {'module': 'preferred-module'}\n@@ -470,6 +480,7 @@ def open(self) -> None:\n             if \":\" in module\n         )\n         self._allow_any_import_level = set(self.linter.config.allow_any_import_level)\n+        self._allow_reexport_package = self.linter.config.allow_reexport_from_package\n \n     def _import_graph_without_ignored_edges(self) -> defaultdict[str, set[str]]:\n         filtered_graph = copy.deepcopy(self.import_graph)\n@@ -495,6 +506,10 @@ def deprecated_modules(self) -> set[str]:\n                 all_deprecated_modules = all_deprecated_modules.union(mod_set)\n         return all_deprecated_modules\n \n+    def visit_module(self, node: nodes.Module) -> None:\n+        \"\"\"Store if current module is a package, i.e. an __init__ file.\"\"\"\n+        self._current_module_package = node.package\n+\n     def visit_import(self, node: nodes.Import) -> None:\n         \"\"\"Triggered when an import statement is seen.\"\"\"\n         self._check_reimport(node)\n@@ -917,8 +932,11 @@ def _check_import_as_rename(self, node: ImportNode) -> None:\n             if import_name != aliased_name:\n                 continue\n \n-            if len(splitted_packages) == 1:\n-                self.add_message(\"useless-import-alias\", node=node)\n+            if len(splitted_packages) == 1 and (\n+                self._allow_reexport_package is False\n+                or self._current_module_package is False\n+            ):\n+                self.add_message(\"useless-import-alias\", node=node, confidence=HIGH)\n             elif len(splitted_packages) == 2:\n                 self.add_message(\n                     \"consider-using-from-import\",\n",
  "test_patch": "diff --git a/tests/checkers/unittest_imports.py b/tests/checkers/unittest_imports.py\n--- a/tests/checkers/unittest_imports.py\n+++ b/tests/checkers/unittest_imports.py\n@@ -137,3 +137,46 @@ def test_preferred_module(capsys: CaptureFixture[str]) -> None:\n         assert \"Prefer importing 'sys' instead of 'os'\" in output\n         # assert there were no errors\n         assert len(errors) == 0\n+\n+    @staticmethod\n+    def test_allow_reexport_package(capsys: CaptureFixture[str]) -> None:\n+        \"\"\"Test --allow-reexport-from-package option.\"\"\"\n+\n+        # Option disabled - useless-import-alias should always be emitted\n+        Run(\n+            [\n+                f\"{os.path.join(REGR_DATA, 'allow_reexport')}\",\n+                \"--allow-reexport-from-package=no\",\n+                \"-sn\",\n+            ],\n+            exit=False,\n+        )\n+        output, errors = capsys.readouterr()\n+        assert len(output.split(\"\\n\")) == 5\n+        assert (\n+            \"__init__.py:1:0: C0414: Import alias does not rename original package (useless-import-alias)\"\n+            in output\n+        )\n+        assert (\n+            \"file.py:2:0: C0414: Import alias does not rename original package (useless-import-alias)\"\n+            in output\n+        )\n+        assert len(errors) == 0\n+\n+        # Option enabled - useless-import-alias should only be emitted for 'file.py'\n+        Run(\n+            [\n+                f\"{os.path.join(REGR_DATA, 'allow_reexport')}\",\n+                \"--allow-reexport-from-package=yes\",\n+                \"-sn\",\n+            ],\n+            exit=False,\n+        )\n+        output, errors = capsys.readouterr()\n+        assert len(output.split(\"\\n\")) == 3\n+        assert \"__init__.py\" not in output\n+        assert (\n+            \"file.py:2:0: C0414: Import alias does not rename original package (useless-import-alias)\"\n+            in output\n+        )\n+        assert len(errors) == 0\ndiff --git a/tests/functional/i/import_aliasing.txt b/tests/functional/i/import_aliasing.txt\n--- a/tests/functional/i/import_aliasing.txt\n+++ b/tests/functional/i/import_aliasing.txt\n@@ -1,10 +1,10 @@\n-useless-import-alias:6:0:6:50::Import alias does not rename original package:UNDEFINED\n+useless-import-alias:6:0:6:50::Import alias does not rename original package:HIGH\n consider-using-from-import:8:0:8:22::Use 'from os import path' instead:UNDEFINED\n consider-using-from-import:10:0:10:31::Use 'from foo.bar import foobar' instead:UNDEFINED\n-useless-import-alias:14:0:14:24::Import alias does not rename original package:UNDEFINED\n-useless-import-alias:17:0:17:28::Import alias does not rename original package:UNDEFINED\n-useless-import-alias:18:0:18:38::Import alias does not rename original package:UNDEFINED\n-useless-import-alias:20:0:20:38::Import alias does not rename original package:UNDEFINED\n-useless-import-alias:21:0:21:38::Import alias does not rename original package:UNDEFINED\n-useless-import-alias:23:0:23:36::Import alias does not rename original package:UNDEFINED\n+useless-import-alias:14:0:14:24::Import alias does not rename original package:HIGH\n+useless-import-alias:17:0:17:28::Import alias does not rename original package:HIGH\n+useless-import-alias:18:0:18:38::Import alias does not rename original package:HIGH\n+useless-import-alias:20:0:20:38::Import alias does not rename original package:HIGH\n+useless-import-alias:21:0:21:38::Import alias does not rename original package:HIGH\n+useless-import-alias:23:0:23:36::Import alias does not rename original package:HIGH\n relative-beyond-top-level:26:0:26:27::Attempted relative import beyond top-level package:UNDEFINED\ndiff --git a/tests/regrtest_data/allow_reexport/__init__.py b/tests/regrtest_data/allow_reexport/__init__.py\nnew file mode 100644\n--- /dev/null\n+++ b/tests/regrtest_data/allow_reexport/__init__.py\n@@ -0,0 +1 @@\n+import os as os\ndiff --git a/tests/regrtest_data/allow_reexport/file.py b/tests/regrtest_data/allow_reexport/file.py\nnew file mode 100644\n--- /dev/null\n+++ b/tests/regrtest_data/allow_reexport/file.py\n@@ -0,0 +1,2 @@\n+# pylint: disable=unused-import\n+import os as os\n",
  "problem_statement": "false positive 'useless-import-alias' error for mypy-compatible explicit re-exports\n### Bug description\n\nSuppose a package has the following layout:\r\n```console\r\npackage/\r\n  _submodule1.py  # defines Api1\r\n  _submodule2.py  # defines Api2\r\n  __init__.py     # imports and re-exports Api1 and Api2\r\n```\r\nSince the submodules here implement public APIs, `__init__.py` imports and re-exports them, expecting users to import them from the public, top-level package, e.g. `from package import Api1`.\r\n\r\nSince the implementations of `Api1` and `Api2` are complex, they are split into `_submodule1.py` and `_submodule2.py` for better maintainability and separation of concerns.\r\n\r\nSo `__init__.py` looks like this:\r\n```python\r\nfrom ._submodule1 import Api1 as Api1\r\nfrom ._submodule2 import APi2 as Api2\r\n```\r\n\r\nThe reason for the `as` aliases here is to be explicit that these imports are for the purpose of re-export (without having to resort to defining `__all__`, which is error-prone). Without the `as` aliases, popular linters such as `mypy` will raise an \"implicit re-export\" error ([docs](https://mypy.readthedocs.io/en/stable/command_line.html#cmdoption-mypy-no-implicit-reexport) -- part of `mypy --strict`).\r\n\r\nHowever, pylint does not currently understand this usage, and raises \"useless-import-alias\" errors.\r\n\r\nExample real-world code triggering pylint false positive errors: https://github.com/jab/bidict/blob/caf703e959ed4471bc391a7794411864c1d6ab9d/bidict/__init__.py#L61-L78\n\n### Configuration\n\n_No response_\n\n### Command used\n\n```shell\npylint\n```\n\n\n### Pylint output\n\n```shell\n************* Module bidict\r\nbidict/__init__.py:61:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:61:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:62:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:62:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:62:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:63:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:63:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:64:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:65:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:66:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:66:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:67:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:68:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:69:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:69:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:69:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:70:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:70:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:70:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:70:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:70:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:71:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:71:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:72:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:72:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:72:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:73:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:74:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:74:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:74:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:74:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:74:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:74:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:74:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:74:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:74:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:74:0: C0414: Import alias does not rename original package (useless-import-alias)\r\nbidict/__init__.py:74:0: C0414: Import alias does not rename original package (useless-import-alias)\n```\n\n\n### Expected behavior\n\nNo \"useless-import-alias\" errors should be flagged.\n\n### Pylint version\n\n```shell\npylint 2.13.2\r\nastroid 2.11.2\r\nPython 3.10.2 (main, Feb  2 2022, 07:36:01) [Clang 12.0.0 (clang-1200.0.32.29)]\n```\n\n\n### OS / Environment\n\n_No response_\n\n### Additional dependencies\n\n_No response_\n",
  "hints_text": "> The reason for the as aliases here is to be explicit that these imports are for the purpose of re-export (without having to resort to defining __all__, which is error-prone).\r\n\r\nI think ``__all__``is the way to be explicit about the API of a module.That way you have the API documented in one place at the top of the module without having to check what exactly is imported with  ``import x as x``.  I never heard about  ``import x as x`` and never did the implementer of the check, but I saw the mypy documentation you linked, let's see how widely used this is.\nI don't think there is a way for pylint to detect if the reexport is intended or not. Maybe we could ignore `__init__.py` files 🤔 However, that might be unexpected to the general user.\r\n\r\nProbably the easiest solution in your case would be to add a module level `pylint: disable=useless-import-alias` (before any imports).\nYeah, other linters like mypy specifically support `as` rather than just `__all__` for this, since so many people have been burned by using `__all__`.\r\n\r\n\r\n`__all__` requires maintaining exports as a list of strings, which are all-too-easy to typo (and often tools and IDEs can’t detect when this happens), and also separately (and often far away) from where they’re imported / defined, which is also fragile and error-prone.\n>  tools and IDEs can’t detect when this happens\r\n\r\nYeah I remember when I used liclipse (eclipse + pydev) this was a pain. This is an issue with the IDE though, Pycharm Community Edition handle this correctly.\nSure, some IDEs can help with typos in `__all__`, but that's only one part of the problem with `__all__`. More problematic is that it forces you to maintain exports separately from where they're imported / defined, which makes it too easy for `__all__` to drift out of sync as changes are made to the intended exports.\nAs @cdce8p said, the solution is to disable. I think this is going to stay that way because I don't see how pylint can guess the intent of the implementer. We could make this check optional but I think if you're making library API using this  you're more able to disable the check than a beginner making a genuine mistake is to activate it. We're going to document this in the ``useless-import-alias`` documentation.\nOk, thanks for that. As usage of mypy and mypy-style explicit re-imports continues to grow, it would be interesting to know how many pylint users end up having to disable `useless-import-alias`, and whether that amount ever crosses some threshold for being better as an opt-in rather than an opt-out. Not sure how much usage data you collect though for such decisions (e.g. by looking at usage from open source codebases).\n> crosses some threshold for being better as an opt-in rather than an opt-out\r\n\r\nAn alternative solution would be to not raise this message in ``__init__.py``.\r\n\r\n>  Not sure how much usage data you collect though for such decisions (e.g. by looking at usage from open source codebases).\r\n\r\nTo be frank, it's mostly opened issues and the thumbs-up / comments those issues gather. I'm not looking specifically at open sources projects for each messages it's really time consuming. A well researched comments on this issue with stats and sources, a proposition that is easily implementable with a better result than what we have currently, or this issue gathering 50+ thumbs up and a lot of attention would definitely make us reconsider.\nGot it, good to know.\nJust noticed https://github.com/microsoft/pyright/releases/tag/1.1.278\r\n\r\n> Changed the `reportUnusedImport` check to not report an error for \"from y import x as x\" since x is considered to be re-exported in this case. Previously, this case was exempted only for type stubs.\r\n\r\nOne more tool (pyright) flipping in this direction, fwiw.\nWe'll need an option to exclude ``__init__`` for the check if this become widespread. Reopening in order to not duplicate info.",
  "created_at": "2023-01-27T23:46:57Z",
  "version": "2.16",
  "FAIL_TO_PASS": "[\"tests/checkers/unittest_imports.py::TestImportsChecker::test_allow_reexport_package\"]",
  "PASS_TO_PASS": "[\"tests/checkers/unittest_imports.py::TestImportsChecker::test_relative_beyond_top_level\", \"tests/checkers/unittest_imports.py::TestImportsChecker::test_relative_beyond_top_level_two\", \"tests/checkers/unittest_imports.py::TestImportsChecker::test_relative_beyond_top_level_three\", \"tests/checkers/unittest_imports.py::TestImportsChecker::test_relative_beyond_top_level_four\", \"tests/checkers/unittest_imports.py::TestImportsChecker::test_wildcard_import_init\", \"tests/checkers/unittest_imports.py::TestImportsChecker::test_wildcard_import_non_init\", \"tests/checkers/unittest_imports.py::TestImportsChecker::test_preferred_module\"]",
  "environment_setup_commit": "ff8cdd2b4096c44854731aba556f8a948ff9b3c4",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.916508",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}