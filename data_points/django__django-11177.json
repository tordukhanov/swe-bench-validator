{
  "repo": "django/django",
  "instance_id": "django__django-11177",
  "base_commit": "ed880d92b50c641c3e7f6e8ce5741085ffe1f8fb",
  "patch": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -78,19 +78,22 @@ def raise_last_exception():\n \n \n def ensure_echo_on():\n-    if termios:\n-        fd = sys.stdin\n-        if fd.isatty():\n-            attr_list = termios.tcgetattr(fd)\n-            if not attr_list[3] & termios.ECHO:\n-                attr_list[3] |= termios.ECHO\n-                if hasattr(signal, 'SIGTTOU'):\n-                    old_handler = signal.signal(signal.SIGTTOU, signal.SIG_IGN)\n-                else:\n-                    old_handler = None\n-                termios.tcsetattr(fd, termios.TCSANOW, attr_list)\n-                if old_handler is not None:\n-                    signal.signal(signal.SIGTTOU, old_handler)\n+    \"\"\"\n+    Ensure that echo mode is enabled. Some tools such as PDB disable\n+    it which causes usability issues after reload.\n+    \"\"\"\n+    if not termios or not sys.stdin.isatty():\n+        return\n+    attr_list = termios.tcgetattr(sys.stdin)\n+    if not attr_list[3] & termios.ECHO:\n+        attr_list[3] |= termios.ECHO\n+        if hasattr(signal, 'SIGTTOU'):\n+            old_handler = signal.signal(signal.SIGTTOU, signal.SIG_IGN)\n+        else:\n+            old_handler = None\n+        termios.tcsetattr(sys.stdin, termios.TCSANOW, attr_list)\n+        if old_handler is not None:\n+            signal.signal(signal.SIGTTOU, old_handler)\n \n \n def iter_all_python_module_files():\n@@ -269,7 +272,12 @@ def run(self, django_main_thread):\n         from django.urls import get_resolver\n         # Prevent a race condition where URL modules aren't loaded when the\n         # reloader starts by accessing the urlconf_module property.\n-        get_resolver().urlconf_module\n+        try:\n+            get_resolver().urlconf_module\n+        except Exception:\n+            # Loading the urlconf can result in errors during development.\n+            # If this occurs then swallow the error and continue.\n+            pass\n         logger.debug('Apps ready_event triggered. Sending autoreload_started signal.')\n         autoreload_started.send(sender=self)\n         self.run_loop()\n@@ -316,41 +324,33 @@ class StatReloader(BaseReloader):\n     SLEEP_TIME = 1  # Check for changes once per second.\n \n     def tick(self):\n-        state, previous_timestamp = {}, time.time()\n+        mtimes = {}\n         while True:\n-            state.update(self.loop_files(state, previous_timestamp))\n-            previous_timestamp = time.time()\n+            for filepath, mtime in self.snapshot_files():\n+                old_time = mtimes.get(filepath)\n+                if old_time is None:\n+                    logger.debug('File %s first seen with mtime %s', filepath, mtime)\n+                    mtimes[filepath] = mtime\n+                    continue\n+                elif mtime > old_time:\n+                    logger.debug('File %s previous mtime: %s, current mtime: %s', filepath, old_time, mtime)\n+                    self.notify_file_changed(filepath)\n+\n             time.sleep(self.SLEEP_TIME)\n             yield\n \n-    def loop_files(self, previous_times, previous_timestamp):\n-        updated_times = {}\n-        for path, mtime in self.snapshot_files():\n-            previous_time = previous_times.get(path)\n-            # If there are overlapping globs, a file may be iterated twice.\n-            if path in updated_times:\n-                continue\n-            # A new file has been detected. This could happen due to it being\n-            # imported at runtime and only being polled now, or because the\n-            # file was just created. Compare the file's mtime to the\n-            # previous_timestamp and send a notification if it was created\n-            # since the last poll.\n-            is_newly_created = previous_time is None and mtime > previous_timestamp\n-            is_changed = previous_time is not None and previous_time != mtime\n-            if is_newly_created or is_changed:\n-                logger.debug('File %s. is_changed: %s, is_new: %s', path, is_changed, is_newly_created)\n-                logger.debug('File %s previous mtime: %s, current mtime: %s', path, previous_time, mtime)\n-                self.notify_file_changed(path)\n-                updated_times[path] = mtime\n-        return updated_times\n-\n     def snapshot_files(self):\n+        # watched_files may produce duplicate paths if globs overlap.\n+        seen_files = set()\n         for file in self.watched_files():\n+            if file in seen_files:\n+                continue\n             try:\n                 mtime = file.stat().st_mtime\n             except OSError:\n                 # This is thrown when the file does not exist.\n                 continue\n+            seen_files.add(file)\n             yield file, mtime\n \n     @classmethod\n@@ -556,7 +556,7 @@ def start_django(reloader, main_func, *args, **kwargs):\n     ensure_echo_on()\n \n     main_func = check_errors(main_func)\n-    django_main_thread = threading.Thread(target=main_func, args=args, kwargs=kwargs)\n+    django_main_thread = threading.Thread(target=main_func, args=args, kwargs=kwargs, name='django-main-thread')\n     django_main_thread.setDaemon(True)\n     django_main_thread.start()\n \n",
  "test_patch": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -255,7 +255,7 @@ def test_starts_thread_with_args(self, mocked_check_errors, mocked_thread):\n         self.assertEqual(mocked_thread.call_count, 1)\n         self.assertEqual(\n             mocked_thread.call_args[1],\n-            {'target': fake_main_func, 'args': (123,), 'kwargs': {'abc': 123}}\n+            {'target': fake_main_func, 'args': (123,), 'kwargs': {'abc': 123}, 'name': 'django-main-thread'}\n         )\n         self.assertSequenceEqual(fake_thread.setDaemon.call_args[0], [True])\n         self.assertTrue(fake_thread.start.called)\n@@ -376,26 +376,6 @@ def test_file(self, mocked_modules, notify_mock):\n         self.assertEqual(notify_mock.call_count, 1)\n         self.assertCountEqual(notify_mock.call_args[0], [self.existing_file])\n \n-    @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')\n-    @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())\n-    def test_nonexistent_file(self, mocked_modules, notify_mock):\n-        self.reloader.watch_file(self.nonexistent_file)\n-        with self.tick_twice():\n-            self.ensure_file(self.nonexistent_file)\n-        self.assertEqual(notify_mock.call_count, 1)\n-        self.assertCountEqual(notify_mock.call_args[0], [self.nonexistent_file])\n-\n-    @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')\n-    @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())\n-    def test_nonexistent_file_in_non_existing_directory(self, mocked_modules, notify_mock):\n-        non_existing_directory = self.tempdir / 'non_existing_dir'\n-        nonexistent_file = non_existing_directory / 'test'\n-        self.reloader.watch_file(nonexistent_file)\n-        with self.tick_twice():\n-            self.ensure_file(nonexistent_file)\n-        self.assertEqual(notify_mock.call_count, 1)\n-        self.assertCountEqual(notify_mock.call_args[0], [nonexistent_file])\n-\n     @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')\n     @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())\n     def test_glob(self, mocked_modules, notify_mock):\n@@ -407,18 +387,6 @@ def test_glob(self, mocked_modules, notify_mock):\n         self.assertEqual(notify_mock.call_count, 1)\n         self.assertCountEqual(notify_mock.call_args[0], [self.existing_file])\n \n-    @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')\n-    @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())\n-    def test_glob_non_existing_directory(self, mocked_modules, notify_mock):\n-        non_existing_directory = self.tempdir / 'does_not_exist'\n-        nonexistent_file = non_existing_directory / 'test.py'\n-        self.reloader.watch_dir(non_existing_directory, '*.py')\n-        with self.tick_twice():\n-            self.ensure_file(nonexistent_file)\n-            self.set_mtime(nonexistent_file, time.time())\n-        self.assertEqual(notify_mock.call_count, 1)\n-        self.assertCountEqual(notify_mock.call_args[0], [nonexistent_file])\n-\n     @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')\n     @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())\n     def test_multiple_globs(self, mocked_modules, notify_mock):\n@@ -669,28 +637,8 @@ def test_snapshot_files_updates(self):\n             snapshot2 = dict(self.reloader.snapshot_files())\n             self.assertNotEqual(snapshot1[self.existing_file], snapshot2[self.existing_file])\n \n-    def test_does_not_fire_without_changes(self):\n-        with mock.patch.object(self.reloader, 'watched_files', return_value=[self.existing_file]), \\\n-                mock.patch.object(self.reloader, 'notify_file_changed') as notifier:\n-            mtime = self.existing_file.stat().st_mtime\n-            initial_snapshot = {self.existing_file: mtime}\n-            second_snapshot = self.reloader.loop_files(initial_snapshot, time.time())\n-            self.assertEqual(second_snapshot, {})\n-            notifier.assert_not_called()\n-\n-    def test_fires_when_created(self):\n-        with mock.patch.object(self.reloader, 'watched_files', return_value=[self.nonexistent_file]), \\\n-                mock.patch.object(self.reloader, 'notify_file_changed') as notifier:\n-            self.nonexistent_file.touch()\n-            mtime = self.nonexistent_file.stat().st_mtime\n-            second_snapshot = self.reloader.loop_files({}, mtime - 1)\n-            self.assertCountEqual(second_snapshot.keys(), [self.nonexistent_file])\n-            notifier.assert_called_once_with(self.nonexistent_file)\n-\n-    def test_fires_with_changes(self):\n-        with mock.patch.object(self.reloader, 'watched_files', return_value=[self.existing_file]), \\\n-                mock.patch.object(self.reloader, 'notify_file_changed') as notifier:\n-            initial_snapshot = {self.existing_file: 1}\n-            second_snapshot = self.reloader.loop_files(initial_snapshot, time.time())\n-            notifier.assert_called_once_with(self.existing_file)\n-            self.assertCountEqual(second_snapshot.keys(), [self.existing_file])\n+    def test_snapshot_files_with_duplicates(self):\n+        with mock.patch.object(self.reloader, 'watched_files', return_value=[self.existing_file, self.existing_file]):\n+            snapshot = list(self.reloader.snapshot_files())\n+            self.assertEqual(len(snapshot), 1)\n+            self.assertEqual(snapshot[0][0], self.existing_file)\n",
  "problem_statement": "Django 2.2 autoreloader is failing intermittently (not using watchman)\nDescription\n\t\nSince upgrading to Django 2.2 the autoreloader is working differently and is not always picking up changes to .py files to reload runserver. It seems to work consistently once on a file, but multiple changes to the same file will not necessarily trigger a reload. It's definitely a change in the behavior to previous versions of Django (up to 2.1.7)\nI'm not using watchman.\nI'm running runserver in a python 3.7 slim docker container like ./manage.py runserver 0.0.0.0:8001\nAs a workaround I have tried to add an edit a different .py -- that doesn't seem to help consistently. I've also noticed that the problem seems to sometimes go away by itself -- perhaps there is some change to the timing of the autoreloader which is not clear? For example and ignore interval of a certain duration.\n",
  "hints_text": "I had the exact same problem and finally figured out it was my PyCharm editor. Perhaps this may help others... If you are using PyCharm, check your deployment settings. PyCharm has an option: \"Preserve file timestamps\" on save. Once this box is unchecked, every file update caused watchman to reload as expected.\nAnecdotal datapoint: Saw 3 separate usernames on IRC yesterday (other than Sammie, who I think was also around?) suggesting they'd noted differences/problems with the auto-reloader not picking up changes in the new version (presumably the stat reloader, as none of them had watchman installed AFAIK). One of them was on Windows, don't know about the others.\nHmmm... Not sure what to make of this yet. So is this just a docs issue? Is there a change in behaviour without Watchman, i.e. what should be the old behaviour? (Adding Tom, since he knows most about it.)\nOk, this isn't good! Thanks for CCing me Carlton. I added a fair bit of logging to the autoreloader, if anyone in this thread could enable the django.utils.autoreload logger and set it's verbosity to DEBUG and paste any logs here then that would be very, very helpful. It smells like this might be a timestamp resolution issue of some kind however it's really hard to tell. Regarding your comment Sammie, are you sure you are using Watchman? Without Watchman the file modification timestamps are polled, with Watchman then something more efficient should be used and in theory the timestamps are not required.\nI've just been going through the 2.1 autoreloader code and I noticed an omission: if _win: mtime -= stat.st_ctime It references this ticket: https://code.djangoproject.com/ticket/937. I'm really not clear on if this is the root cause of any issues on Windows (the MSDN documentation is pretty unclear), but I will include a PR to include it anyway: ​https://github.com/django/django/pull/11176 I have a few more thoughts on potential causes, but the output from the autoreloader logger is critical if we have any hope of finding out the root cause.\nTom, For me this issue was specifically tied with PyCharm not changing timestamps when saving to a remote location. I've not faced a single issue since fixing the setting in the IDE. Furthermore, when I upgraded to Django 2.2, the documentation for what had changed did not mention anything about having to install watchman and so therefore I have not, confirmed on system too not to be installed.\nGiven the multiple reports I'm going to Accept this as a bug ref the changes related to #27685. (We can recategorise, if needed, when we've pinned it down further.)\nI turned on the verbose loader as per Tom Forbes' request and here is how it starts: Watching for file changes with StatReloader Watching for file changes with StatReloader Waiting for apps ready_event. Performing system checks... 2019-04-05T16:24:21.447185000Z Apps ready_event triggered. Sending autoreload_started signal. Watching dir /code/locale with glob **/*.mo. Watching dir /usr/local/lib/python3.7/site-packages/django/contrib/admin/locale with glob **/*.mo. Watching dir /usr/local/lib/python3.7/site-packages/django/contrib/auth/locale with glob **/*.mo. Watching dir /usr/local/lib/python3.7/site-packages/django/contrib/contenttypes/locale with glob **/*.mo. Watching dir /usr/local/lib/python3.7/site-packages/django/contrib/sessions/locale with glob **/*.mo. Watching dir /usr/local/lib/python3.7/site-packages/django/contrib/messages/locale with glob **/*.mo. Watching dir /usr/local/lib/python3.7/site-packages/django/contrib/staticfiles/locale with glob **/*.mo. Watching dir /usr/local/lib/python3.7/site-packages/django/contrib/sites/locale with glob **/*.mo. Watching dir /usr/local/lib/python3.7/site-packages/corsheaders/locale with glob **/*.mo. Watching dir /usr/local/lib/python3.7/site-packages/django_celery_beat/locale with glob **/*.mo. Watching dir /usr/local/lib/python3.7/site-packages/django_extensions/locale with glob **/*.mo. Watching dir /usr/local/lib/python3.7/site-packages/django_inlinecss/locale with glob **/*.mo. Watching dir /usr/local/lib/python3.7/site-packages/django_otp/locale with glob **/*.mo. Watching dir /usr/local/lib/python3.7/site-packages/django_otp/plugins/otp_totp/locale with glob **/*.mo. Watching dir /usr/local/lib/python3.7/site-packages/encrypted_model_fields/locale with glob **/*.mo. Watching dir /usr/local/lib/python3.7/site-packages/graphene_django/locale with glob **/*.mo. Watching dir /usr/local/lib/python3.7/site-packages/localflavor/locale with glob **/*.mo. Watching dir /usr/local/lib/python3.7/site-packages/polymorphic/locale with glob **/*.mo. Watching dir /code/accounts/locale with glob **/*.mo. Watching dir /code/audits/locale with glob **/*.mo. Watching dir /code/borrowers/locale with glob **/*.mo. Watching dir /code/calendars/locale with glob **/*.mo. Watching dir /code/datarooms/locale with glob **/*.mo. Watching dir /code/deals/locale with glob **/*.mo. Watching dir /code/institutions/locale with glob **/*.mo. Watching dir /code/notifications/locale with glob **/*.mo. Watching dir /code/payments/locale with glob **/*.mo. Watching dir /code/widgets/locale with glob **/*.mo. System check identified no issues (0 silenced). April 05, 2019 - 16:24:27 Django version 2.2, using settings 'backend.settings' Starting development server at http://0.0.0.0:8001/ Quit the server with CONTROL-C. Here's an example of picking up a change successfully: django_1 | File /code/core/domain_utils.py. is_changed: False, is_new: True django_1 | File /code/core/domain_utils.py previous mtime: None, current mtime: 1554481667.0 django_1 | /code/core/domain_utils.py notified as changed. Signal results: [(<function translation_file_changed at 0x7ffae676e8c8>, None)]. django_1 | /code/core/domain_utils.py changed, reloading. django_1 | /code/core/domain_utils.py changed, reloading. django_1 | Watching for file changes with StatReloader django_1 | Watching for file changes with StatReloader django_1 | Performing system checks... When the auto-reloader fails to detect a change, nothing is logged.\nI will try and fix this tomorrow, but for prosperity's sake the issue as I can see it is this: In the StatReloader.loop_files, on Windows, seems to have a condition where all files are treated as new and for some reason files with changed modification times are not treated as actually changed: I have a clear debug log from a very helpful chap on IRC that clearly shows the mtime of a file changing but not triggering as the file being changed, which can only happen in a particularly weird set of circumstances. I've attached the full log to the ticket. I feel the solution is to more faithfully copy the previous stat reloader as that seemed to work correctly, which means removing some (seemingly premature) optimizations I tried to add.\nI've spoken with one of the people experiencing issues and he confirmed that the patch above seems to have stopped the reloading issues.\nUpdate from the user testing the branch: He's been using the patch I provided for a week and has experienced no issues reloading at all. While I'm unable to replicate it locally, and it seems to depend on the platform, I'd consider this enough of a validation that the fix is correct.",
  "created_at": "2019-04-05T12:40:59Z",
  "version": "3.0",
  "FAIL_TO_PASS": "[\"test_snapshot_files_with_duplicates (utils_tests.test_autoreload.StatReloaderTests)\", \"test_starts_thread_with_args (utils_tests.test_autoreload.StartDjangoTests)\"]",
  "PASS_TO_PASS": "[\"test_common_roots (utils_tests.test_autoreload.TestCommonRoots)\", \"test_no_exception (utils_tests.test_autoreload.TestRaiseLastException)\", \"test_raises_exception (utils_tests.test_autoreload.TestRaiseLastException)\", \"test_watchman_available (utils_tests.test_autoreload.GetReloaderTests)\", \"test_watchman_unavailable (utils_tests.test_autoreload.GetReloaderTests)\", \"test_manage_py (utils_tests.test_autoreload.RestartWithReloaderTests)\", \"test_python_m_django (utils_tests.test_autoreload.RestartWithReloaderTests)\", \"test_calls_start_django (utils_tests.test_autoreload.RunWithReloaderTests)\", \"test_calls_sys_exit (utils_tests.test_autoreload.RunWithReloaderTests)\", \"test_swallows_keyboard_interrupt (utils_tests.test_autoreload.RunWithReloaderTests)\", \"test_mutates_error_files (utils_tests.test_autoreload.TestCheckErrors)\", \"test_sys_paths_absolute (utils_tests.test_autoreload.TestSysPathDirectories)\", \"test_sys_paths_directories (utils_tests.test_autoreload.TestSysPathDirectories)\", \"test_sys_paths_non_existing (utils_tests.test_autoreload.TestSysPathDirectories)\", \"test_sys_paths_with_directories (utils_tests.test_autoreload.TestSysPathDirectories)\", \"test_run_loop_catches_stopiteration (utils_tests.test_autoreload.BaseReloaderTests)\", \"test_run_loop_stop_and_return (utils_tests.test_autoreload.BaseReloaderTests)\", \"test_wait_for_apps_ready_checks_for_exception (utils_tests.test_autoreload.BaseReloaderTests)\", \"test_wait_for_apps_ready_without_exception (utils_tests.test_autoreload.BaseReloaderTests)\", \"test_watch_files_with_recursive_glob (utils_tests.test_autoreload.BaseReloaderTests)\", \"test_watch_with_glob (utils_tests.test_autoreload.BaseReloaderTests)\", \"test_watch_with_single_file (utils_tests.test_autoreload.BaseReloaderTests)\", \"test_watch_without_absolute (utils_tests.test_autoreload.BaseReloaderTests)\", \"test_file (utils_tests.test_autoreload.StatReloaderTests)\", \"test_glob (utils_tests.test_autoreload.StatReloaderTests)\", \"test_glob_recursive (utils_tests.test_autoreload.StatReloaderTests)\", \"test_multiple_globs (utils_tests.test_autoreload.StatReloaderTests)\", \"test_multiple_recursive_globs (utils_tests.test_autoreload.StatReloaderTests)\", \"test_nested_glob_recursive (utils_tests.test_autoreload.StatReloaderTests)\", \"test_overlapping_glob_recursive (utils_tests.test_autoreload.StatReloaderTests)\", \"test_overlapping_globs (utils_tests.test_autoreload.StatReloaderTests)\", \"test_snapshot_files_ignores_missing_files (utils_tests.test_autoreload.StatReloaderTests)\", \"test_snapshot_files_updates (utils_tests.test_autoreload.StatReloaderTests)\", \"test_check_errors_called (utils_tests.test_autoreload.StartDjangoTests)\", \"test_echo_on_called (utils_tests.test_autoreload.StartDjangoTests)\", \"test_watchman_becomes_unavailable (utils_tests.test_autoreload.StartDjangoTests)\", \".pyc and .pyo files are included in the files list.\", \"test_check_errors (utils_tests.test_autoreload.TestIterModulesAndFiles)\", \"test_check_errors_catches_all_exceptions (utils_tests.test_autoreload.TestIterModulesAndFiles)\", \"test_file_added (utils_tests.test_autoreload.TestIterModulesAndFiles)\", \"test_module_without_spec (utils_tests.test_autoreload.TestIterModulesAndFiles)\", \"test_paths_are_pathlib_instances (utils_tests.test_autoreload.TestIterModulesAndFiles)\", \"iter_all_python_module_file() ignores weakref modules.\", \"test_zip_reload (utils_tests.test_autoreload.TestIterModulesAndFiles)\"]",
  "environment_setup_commit": "419a78300f7cd27611196e1e464d50fd0385ff27",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.563377",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}