{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-17845",
  "base_commit": "dd53633d0f28ed8656480e25a49615258121cb5d",
  "patch": "diff --git a/sympy/calculus/singularities.py b/sympy/calculus/singularities.py\n--- a/sympy/calculus/singularities.py\n+++ b/sympy/calculus/singularities.py\n@@ -73,11 +73,11 @@ def singularities(expression, symbol):\n     >>> singularities(x**2 + x + 1, x)\n     EmptySet\n     >>> singularities(1/(x + 1), x)\n-    {-1}\n+    FiniteSet(-1)\n     >>> singularities(1/(y**2 + 1), y)\n-    {-I, I}\n+    FiniteSet(I, -I)\n     >>> singularities(1/(y**3 + 1), y)\n-    {-1, 1/2 - sqrt(3)*I/2, 1/2 + sqrt(3)*I/2}\n+    FiniteSet(-1, 1/2 - sqrt(3)*I/2, 1/2 + sqrt(3)*I/2)\n \n     \"\"\"\n     if not expression.is_rational_function(symbol):\ndiff --git a/sympy/calculus/util.py b/sympy/calculus/util.py\n--- a/sympy/calculus/util.py\n+++ b/sympy/calculus/util.py\n@@ -744,7 +744,7 @@ def stationary_points(f, symbol, domain=S.Reals):\n               2                                2\n \n     >>> stationary_points(sin(x),x, Interval(0, 4*pi))\n-    {pi/2, 3*pi/2, 5*pi/2, 7*pi/2}\n+    FiniteSet(pi/2, 3*pi/2, 5*pi/2, 7*pi/2)\n \n     \"\"\"\n     from sympy import solveset, diff\n@@ -1550,7 +1550,7 @@ def intersection(self, other):\n         EmptySet\n \n         >>> AccumBounds(1, 4).intersection(FiniteSet(1, 2, 5))\n-        {1, 2}\n+        FiniteSet(1, 2)\n \n         \"\"\"\n         if not isinstance(other, (AccumBounds, FiniteSet)):\ndiff --git a/sympy/categories/baseclasses.py b/sympy/categories/baseclasses.py\n--- a/sympy/categories/baseclasses.py\n+++ b/sympy/categories/baseclasses.py\n@@ -482,7 +482,7 @@ def objects(self):\n         >>> B = Object(\"B\")\n         >>> K = Category(\"K\", FiniteSet(A, B))\n         >>> K.objects\n-        Class({Object(\"A\"), Object(\"B\")})\n+        Class(FiniteSet(Object(\"A\"), Object(\"B\")))\n \n         \"\"\"\n         return self.args[1]\n@@ -677,7 +677,7 @@ def __new__(cls, *args):\n         True\n         >>> d = Diagram([f, g], {g * f: \"unique\"})\n         >>> d.conclusions[g * f]\n-        {unique}\n+        FiniteSet(unique)\n \n         \"\"\"\n         premises = {}\n@@ -809,7 +809,7 @@ def objects(self):\n         >>> g = NamedMorphism(B, C, \"g\")\n         >>> d = Diagram([f, g])\n         >>> d.objects\n-        {Object(\"A\"), Object(\"B\"), Object(\"C\")}\n+        FiniteSet(Object(\"A\"), Object(\"B\"), Object(\"C\"))\n \n         \"\"\"\n         return self.args[2]\ndiff --git a/sympy/combinatorics/partitions.py b/sympy/combinatorics/partitions.py\n--- a/sympy/combinatorics/partitions.py\n+++ b/sympy/combinatorics/partitions.py\n@@ -42,7 +42,7 @@ def __new__(cls, *partition):\n         >>> from sympy.combinatorics.partitions import Partition\n         >>> a = Partition([1, 2], [3])\n         >>> a\n-        {{3}, {1, 2}}\n+        Partition(FiniteSet(1, 2), FiniteSet(3))\n         >>> a.partition\n         [[1, 2], [3]]\n         >>> len(a)\n@@ -53,7 +53,7 @@ def __new__(cls, *partition):\n         Creating Partition from Python sets:\n \n         >>> Partition({1, 2, 3}, {4, 5})\n-        {{4, 5}, {1, 2, 3}}\n+        Partition(FiniteSet(1, 2, 3), FiniteSet(4, 5))\n \n         Creating Partition from SymPy finite sets:\n \n@@ -61,7 +61,7 @@ def __new__(cls, *partition):\n         >>> a = FiniteSet(1, 2, 3)\n         >>> b = FiniteSet(4, 5)\n         >>> Partition(a, b)\n-        {{4, 5}, {1, 2, 3}}\n+        Partition(FiniteSet(1, 2, 3), FiniteSet(4, 5))\n         \"\"\"\n         args = []\n         dups = False\n@@ -107,7 +107,7 @@ def sort_key(self, order=None):\n         >>> d = Partition(list(range(4)))\n         >>> l = [d, b, a + 1, a, c]\n         >>> l.sort(key=default_sort_key); l\n-        [{{1, 2}}, {{1}, {2}}, {{1, x}}, {{3, 4}}, {{0, 1, 2, 3}}]\n+        [Partition(FiniteSet(1, 2)), Partition(FiniteSet(1), FiniteSet(2)), Partition(FiniteSet(1, x)), Partition(FiniteSet(3, 4)), Partition(FiniteSet(0, 1, 2, 3))]\n         \"\"\"\n         if order is None:\n             members = self.members\n@@ -250,7 +250,7 @@ def RGS(self):\n         >>> a.RGS\n         (0, 0, 1, 2, 2)\n         >>> a + 1\n-        {{3}, {4}, {5}, {1, 2}}\n+        Partition(FiniteSet(1, 2), FiniteSet(3), FiniteSet(4), FiniteSet(5))\n         >>> _.RGS\n         (0, 0, 1, 2, 3)\n         \"\"\"\n@@ -278,12 +278,12 @@ def from_rgs(self, rgs, elements):\n \n         >>> from sympy.combinatorics.partitions import Partition\n         >>> Partition.from_rgs([0, 1, 2, 0, 1], list('abcde'))\n-        {{c}, {a, d}, {b, e}}\n+        Partition(FiniteSet(c), FiniteSet(a, d), FiniteSet(b, e))\n         >>> Partition.from_rgs([0, 1, 2, 0, 1], list('cbead'))\n-        {{e}, {a, c}, {b, d}}\n+        Partition(FiniteSet(e), FiniteSet(a, c), FiniteSet(b, d))\n         >>> a = Partition([1, 4], [2], [3, 5])\n         >>> Partition.from_rgs(a.RGS, a.members)\n-        {{2}, {1, 4}, {3, 5}}\n+        Partition(FiniteSet(1, 4), FiniteSet(2), FiniteSet(3, 5))\n         \"\"\"\n         if len(rgs) != len(elements):\n             raise ValueError('mismatch in rgs and element lengths')\ndiff --git a/sympy/combinatorics/polyhedron.py b/sympy/combinatorics/polyhedron.py\n--- a/sympy/combinatorics/polyhedron.py\n+++ b/sympy/combinatorics/polyhedron.py\n@@ -47,9 +47,9 @@ def __new__(cls, corners, faces=[], pgroup=[]):\n \n             >>> from sympy.combinatorics.polyhedron import Polyhedron\n             >>> Polyhedron(list('abc'), [(1, 2, 0)]).faces\n-            {(0, 1, 2)}\n+            FiniteSet((0, 1, 2))\n             >>> Polyhedron(list('abc'), [(1, 0, 2)]).faces\n-            {(0, 1, 2)}\n+            FiniteSet((0, 1, 2))\n \n         The allowed transformations are entered as allowable permutations\n         of the vertices for the polyhedron. Instance of Permutations\n@@ -92,7 +92,7 @@ def __new__(cls, corners, faces=[], pgroup=[]):\n         >>> tetra.size\n         4\n         >>> tetra.edges\n-        {(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)}\n+        FiniteSet((0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3))\n         >>> tetra.corners\n         (w, x, y, z)\n \n@@ -365,7 +365,7 @@ def __new__(cls, corners, faces=[], pgroup=[]):\n \n         >>> from sympy.combinatorics.polyhedron import cube\n         >>> cube.edges\n-        {(0, 1), (0, 3), (0, 4), '...', (4, 7), (5, 6), (6, 7)}\n+        FiniteSet((0, 1), (0, 3), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (3, 7), (4, 5), (4, 7), (5, 6), (6, 7))\n \n         If you want to use letters or other names for the corners you\n         can still use the pre-calculated faces:\n@@ -493,7 +493,7 @@ def edges(self):\n         >>> corners = (a, b, c)\n         >>> faces = [(0, 1, 2)]\n         >>> Polyhedron(corners, faces).edges\n-        {(0, 1), (0, 2), (1, 2)}\n+        FiniteSet((0, 1), (0, 2), (1, 2))\n \n         \"\"\"\n         if self._edges is None:\ndiff --git a/sympy/core/function.py b/sympy/core/function.py\n--- a/sympy/core/function.py\n+++ b/sympy/core/function.py\n@@ -237,9 +237,9 @@ def nargs(self):\n         corresponding set will be returned:\n \n         >>> Function('f', nargs=1).nargs\n-        {1}\n+        FiniteSet(1)\n         >>> Function('f', nargs=(2, 1)).nargs\n-        {1, 2}\n+        FiniteSet(1, 2)\n \n         The undefined function, after application, also has the nargs\n         attribute; the actual number of arguments is always available by\n@@ -972,7 +972,7 @@ class WildFunction(Function, AtomicExpr):\n \n     >>> F = WildFunction('F', nargs=2)\n     >>> F.nargs\n-    {2}\n+    FiniteSet(2)\n     >>> f(x).match(F)\n     >>> f(x, y).match(F)\n     {F_: f(x, y)}\n@@ -983,7 +983,7 @@ class WildFunction(Function, AtomicExpr):\n \n     >>> F = WildFunction('F', nargs=(1, 2))\n     >>> F.nargs\n-    {1, 2}\n+    FiniteSet(1, 2)\n     >>> f(x).match(F)\n     {F_: f(x)}\n     >>> f(x, y).match(F)\ndiff --git a/sympy/logic/boolalg.py b/sympy/logic/boolalg.py\n--- a/sympy/logic/boolalg.py\n+++ b/sympy/logic/boolalg.py\n@@ -131,7 +131,7 @@ def as_set(self):\n         >>> from sympy import Symbol, Eq, Or, And\n         >>> x = Symbol('x', real=True)\n         >>> Eq(x, 0).as_set()\n-        {0}\n+        FiniteSet(0)\n         >>> (x > 0).as_set()\n         Interval.open(0, oo)\n         >>> And(-2 < x, x < 2).as_set()\ndiff --git a/sympy/printing/str.py b/sympy/printing/str.py\n--- a/sympy/printing/str.py\n+++ b/sympy/printing/str.py\n@@ -149,14 +149,6 @@ def _print_Exp1(self, expr):\n     def _print_ExprCondPair(self, expr):\n         return '(%s, %s)' % (self._print(expr.expr), self._print(expr.cond))\n \n-    def _print_FiniteSet(self, s):\n-        s = sorted(s, key=default_sort_key)\n-        if len(s) > 10:\n-            printset = s[:3] + ['...'] + s[-3:]\n-        else:\n-            printset = s\n-        return '{' + ', '.join(self._print(el) for el in printset) + '}'\n-\n     def _print_Function(self, expr):\n         return expr.func.__name__ + \"(%s)\" % self.stringify(expr.args, \", \")\n \ndiff --git a/sympy/sets/conditionset.py b/sympy/sets/conditionset.py\n--- a/sympy/sets/conditionset.py\n+++ b/sympy/sets/conditionset.py\n@@ -65,20 +65,20 @@ class ConditionSet(Set):\n \n     >>> c = ConditionSet(x, x < 1, {x, z})\n     >>> c.subs(x, y)\n-    ConditionSet(x, x < 1, {y, z})\n+    ConditionSet(x, x < 1, FiniteSet(y, z))\n \n     A second substitution is needed to change the dummy symbol, too:\n \n     >>> _.subs(x, y)\n-    ConditionSet(y, y < 1, {y, z})\n+    ConditionSet(y, y < 1, FiniteSet(y, z))\n \n     And trying to replace the dummy symbol with anything but a symbol\n     is ignored: the only change possible will be in the base set:\n \n     >>> ConditionSet(y, y < 1, {y, z}).subs(y, 1)\n-    ConditionSet(y, y < 1, {z})\n+    ConditionSet(y, y < 1, FiniteSet(z))\n     >>> _.subs(y, 1)\n-    ConditionSet(y, y < 1, {z})\n+    ConditionSet(y, y < 1, FiniteSet(z))\n \n     Notes\n     =====\ndiff --git a/sympy/sets/fancysets.py b/sympy/sets/fancysets.py\n--- a/sympy/sets/fancysets.py\n+++ b/sympy/sets/fancysets.py\n@@ -278,7 +278,7 @@ class ImageSet(Set):\n     False\n \n     >>> FiniteSet(0, 1, 2, 3, 4, 5, 6, 7, 9, 10).intersect(squares)\n-    {1, 4, 9}\n+    FiniteSet(1, 4, 9)\n \n     >>> square_iterable = iter(squares)\n     >>> for i in range(4):\n@@ -300,7 +300,7 @@ class ImageSet(Set):\n     >>> solutions = ImageSet(Lambda(n, n*pi), S.Integers) # solutions of sin(x) = 0\n     >>> dom = Interval(-1, 1)\n     >>> dom.intersect(solutions)\n-    {0}\n+    FiniteSet(0)\n \n     See Also\n     ========\n@@ -921,7 +921,7 @@ def normalize_theta_set(theta):\n     >>> normalize_theta_set(Interval(-3*pi/2, -pi/2))\n     Interval(pi/2, 3*pi/2)\n     >>> normalize_theta_set(FiniteSet(0, pi, 3*pi))\n-    {0, pi}\n+    FiniteSet(0, pi)\n \n     \"\"\"\n     from sympy.functions.elementary.trigonometric import _pi_coeff as coeff\n@@ -1200,7 +1200,7 @@ def from_real(cls, sets):\n         >>> from sympy import Interval, ComplexRegion\n         >>> unit = Interval(0,1)\n         >>> ComplexRegion.from_real(unit)\n-        CartesianComplexRegion(ProductSet(Interval(0, 1), {0}))\n+        CartesianComplexRegion(ProductSet(Interval(0, 1), FiniteSet(0)))\n \n         \"\"\"\n         if not sets.is_subset(S.Reals):\ndiff --git a/sympy/sets/powerset.py b/sympy/sets/powerset.py\n--- a/sympy/sets/powerset.py\n+++ b/sympy/sets/powerset.py\n@@ -43,7 +43,7 @@ class PowerSet(Set):\n     A power set of a finite set:\n \n     >>> PowerSet(FiniteSet(1, 2, 3))\n-    PowerSet({1, 2, 3})\n+    PowerSet(FiniteSet(1, 2, 3))\n \n     A power set of an empty set:\n \n@@ -60,7 +60,9 @@ class PowerSet(Set):\n     Evaluating the power set of a finite set to its explicit form:\n \n     >>> PowerSet(FiniteSet(1, 2, 3)).rewrite(FiniteSet)\n-    {EmptySet, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}\n+    FiniteSet(FiniteSet(1), FiniteSet(1, 2), FiniteSet(1, 3),\n+            FiniteSet(1, 2, 3), FiniteSet(2), FiniteSet(2, 3),\n+            FiniteSet(3), EmptySet)\n \n     References\n     ==========\ndiff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -109,7 +109,7 @@ def union(self, other):\n         >>> Interval(0, 1) + Interval(2, 3)\n         Union(Interval(0, 1), Interval(2, 3))\n         >>> Interval(1, 2, True, True) + FiniteSet(2, 3)\n-        Union({3}, Interval.Lopen(1, 2))\n+        Union(FiniteSet(3), Interval.Lopen(1, 2))\n \n         Similarly it is possible to use the '-' operator for set differences:\n \n@@ -469,7 +469,7 @@ def powerset(self):\n         >>> from sympy import FiniteSet, EmptySet\n         >>> A = EmptySet\n         >>> A.powerset()\n-        {EmptySet}\n+        FiniteSet(EmptySet)\n \n         A power set of a finite set:\n \n@@ -532,9 +532,9 @@ def boundary(self):\n \n         >>> from sympy import Interval\n         >>> Interval(0, 1).boundary\n-        {0, 1}\n+        FiniteSet(0, 1)\n         >>> Interval(0, 1, True, False).boundary\n-        {0, 1}\n+        FiniteSet(0, 1)\n         \"\"\"\n         return self._boundary\n \n@@ -659,7 +659,7 @@ class ProductSet(Set):\n     >>> from sympy import Interval, FiniteSet, ProductSet\n     >>> I = Interval(0, 5); S = FiniteSet(1, 2, 3)\n     >>> ProductSet(I, S)\n-    ProductSet(Interval(0, 5), {1, 2, 3})\n+    ProductSet(Interval(0, 5), FiniteSet(1, 2, 3))\n \n     >>> (2, 2) in ProductSet(I, S)\n     True\n@@ -1492,7 +1492,7 @@ class Complement(Set, EvalfMixin):\n \n     >>> from sympy import Complement, FiniteSet\n     >>> Complement(FiniteSet(0, 1, 2), FiniteSet(1))\n-    {0, 2}\n+    FiniteSet(0, 2)\n \n     See Also\n     =========\n@@ -1683,18 +1683,18 @@ class FiniteSet(Set, EvalfMixin):\n \n     >>> from sympy import FiniteSet\n     >>> FiniteSet(1, 2, 3, 4)\n-    {1, 2, 3, 4}\n+    FiniteSet(1, 2, 3, 4)\n     >>> 3 in FiniteSet(1, 2, 3, 4)\n     True\n \n     >>> members = [1, 2, 3, 4]\n     >>> f = FiniteSet(*members)\n     >>> f\n-    {1, 2, 3, 4}\n+    FiniteSet(1, 2, 3, 4)\n     >>> f - FiniteSet(2)\n-    {1, 3, 4}\n+    FiniteSet(1, 3, 4)\n     >>> f + FiniteSet(2, 5)\n-    {1, 2, 3, 4, 5}\n+    FiniteSet(1, 2, 3, 4, 5)\n \n     References\n     ==========\n@@ -1893,7 +1893,7 @@ class SymmetricDifference(Set):\n \n     >>> from sympy import SymmetricDifference, FiniteSet\n     >>> SymmetricDifference(FiniteSet(1, 2, 3), FiniteSet(3, 4, 5))\n-    {1, 2, 4, 5}\n+    FiniteSet(1, 2, 4, 5)\n \n     See Also\n     ========\ndiff --git a/sympy/solvers/inequalities.py b/sympy/solvers/inequalities.py\n--- a/sympy/solvers/inequalities.py\n+++ b/sympy/solvers/inequalities.py\n@@ -29,13 +29,13 @@ def solve_poly_inequality(poly, rel):\n     >>> from sympy.solvers.inequalities import solve_poly_inequality\n \n     >>> solve_poly_inequality(Poly(x, x, domain='ZZ'), '==')\n-    [{0}]\n+    [FiniteSet(0)]\n \n     >>> solve_poly_inequality(Poly(x**2 - 1, x, domain='ZZ'), '!=')\n     [Interval.open(-oo, -1), Interval.open(-1, 1), Interval.open(1, oo)]\n \n     >>> solve_poly_inequality(Poly(x**2 - 1, x, domain='ZZ'), '==')\n-    [{-1}, {1}]\n+    [FiniteSet(-1), FiniteSet(1)]\n \n     See Also\n     ========\n@@ -141,7 +141,7 @@ def solve_rational_inequalities(eqs):\n     >>> solve_rational_inequalities([[\n     ... ((Poly(-x + 1), Poly(1, x)), '>='),\n     ... ((Poly(-x + 1), Poly(1, x)), '<=')]])\n-    {1}\n+    FiniteSet(1)\n \n     >>> solve_rational_inequalities([[\n     ... ((Poly(x), Poly(1, x)), '!='),\ndiff --git a/sympy/solvers/solveset.py b/sympy/solvers/solveset.py\n--- a/sympy/solvers/solveset.py\n+++ b/sympy/solvers/solveset.py\n@@ -136,14 +136,14 @@ def _invert(f_x, y, x, domain=S.Complexes):\n     >>> invert_complex(exp(x), y, x)\n     (x, ImageSet(Lambda(_n, I*(2*_n*pi + arg(y)) + log(Abs(y))), Integers))\n     >>> invert_real(exp(x), y, x)\n-    (x, Intersection({log(y)}, Reals))\n+    (x, Intersection(FiniteSet(log(y)), Reals))\n \n     When does exp(x) == 1?\n \n     >>> invert_complex(exp(x), 1, x)\n     (x, ImageSet(Lambda(_n, 2*_n*I*pi), Integers))\n     >>> invert_real(exp(x), 1, x)\n-    (x, {0})\n+    (x, FiniteSet(0))\n \n     See Also\n     ========\n@@ -805,7 +805,7 @@ def solve_decomposition(f, symbol, domain):\n     >>> x = Symbol('x')\n     >>> f1 = exp(2*x) - 3*exp(x) + 2\n     >>> sd(f1, x, S.Reals)\n-    {0, log(2)}\n+    FiniteSet(0, log(2))\n     >>> f2 = sin(x)**2 + 2*sin(x) + 1\n     >>> pprint(sd(f2, x, S.Reals), use_unicode=False)\n               3*pi\n@@ -1365,11 +1365,11 @@ def _solve_exponential(lhs, rhs, symbol, domain):\n     >>> solve_expo(2**x + 3**x - 5**x, 0, x, S.Reals)  # not solvable\n     ConditionSet(x, Eq(2**x + 3**x - 5**x, 0), Reals)\n     >>> solve_expo(a**x - b**x, 0, x, S.Reals)  # solvable but incorrect assumptions\n-    ConditionSet(x, (a > 0) & (b > 0), {0})\n+    ConditionSet(x, (a > 0) & (b > 0), FiniteSet(0))\n     >>> solve_expo(3**(2*x) - 2**(x + 3), 0, x, S.Reals)\n-    {-3*log(2)/(-2*log(3) + log(2))}\n+    FiniteSet(-3*log(2)/(-2*log(3) + log(2)))\n     >>> solve_expo(2**x - 4**x, 0, x, S.Reals)\n-    {0}\n+    FiniteSet(0)\n \n     * Proof of correctness of the method\n \n@@ -1525,7 +1525,7 @@ def _solve_logarithm(lhs, rhs, symbol, domain):\n     >>> x = symbols('x')\n     >>> f = log(x - 3) + log(x + 3)\n     >>> solve_log(f, 0, x, S.Reals)\n-    {-sqrt(10), sqrt(10)}\n+    FiniteSet(sqrt(10), -sqrt(10))\n \n     * Proof of correctness\n \n@@ -1679,7 +1679,7 @@ def _transolve(f, symbol, domain):\n     >>> from sympy import symbols, S, pprint\n     >>> x = symbols('x', real=True) # assumption added\n     >>> transolve(5**(x - 3) - 3**(2*x + 1), x, S.Reals)\n-    {-(log(3) + 3*log(5))/(-log(5) + 2*log(3))}\n+    FiniteSet(-(log(3) + 3*log(5))/(-log(5) + 2*log(3)))\n \n     How ``_transolve`` works\n     ========================\n@@ -1921,9 +1921,9 @@ def solveset(f, symbol=None, domain=S.Complexes):\n     >>> R = S.Reals\n     >>> x = Symbol('x')\n     >>> solveset(exp(x) - 1, x, R)\n-    {0}\n+    FiniteSet(0)\n     >>> solveset_real(exp(x) - 1, x)\n-    {0}\n+    FiniteSet(0)\n \n     The solution is mostly unaffected by assumptions on the symbol,\n     but there may be some slight difference:\n@@ -2423,7 +2423,7 @@ def linsolve(system, *symbols):\n     [6],\n     [9]])\n     >>> linsolve((A, b), [x, y, z])\n-    {(-1, 2, 0)}\n+    FiniteSet((-1, 2, 0))\n \n     * Parametric Solution: In case the system is underdetermined, the\n       function will return a parametric solution in terms of the given\n@@ -2434,20 +2434,20 @@ def linsolve(system, *symbols):\n     >>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n     >>> b = Matrix([3, 6, 9])\n     >>> linsolve((A, b), x, y, z)\n-    {(z - 1, 2 - 2*z, z)}\n+    FiniteSet((z - 1, 2 - 2*z, z))\n \n     If no symbols are given, internally generated symbols will be used.\n     The `tau0` in the 3rd position indicates (as before) that the 3rd\n     variable -- whatever it's named -- can take on any value:\n \n     >>> linsolve((A, b))\n-    {(tau0 - 1, 2 - 2*tau0, tau0)}\n+    FiniteSet((tau0 - 1, 2 - 2*tau0, tau0))\n \n     * List of Equations as input\n \n     >>> Eqns = [3*x + 2*y - z - 1, 2*x - 2*y + 4*z + 2, - x + y/2 - z]\n     >>> linsolve(Eqns, x, y, z)\n-    {(1, -2, -2)}\n+    FiniteSet((1, -2, -2))\n \n     * Augmented Matrix as input\n \n@@ -2458,21 +2458,21 @@ def linsolve(system, *symbols):\n     [2, 6,  8, 3],\n     [6, 8, 18, 5]])\n     >>> linsolve(aug, x, y, z)\n-    {(3/10, 2/5, 0)}\n+    FiniteSet((3/10, 2/5, 0))\n \n     * Solve for symbolic coefficients\n \n     >>> a, b, c, d, e, f = symbols('a, b, c, d, e, f')\n     >>> eqns = [a*x + b*y - c, d*x + e*y - f]\n     >>> linsolve(eqns, x, y)\n-    {((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d))}\n+    FiniteSet(((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d)))\n \n     * A degenerate system returns solution as set of given\n       symbols.\n \n     >>> system = Matrix(([0, 0, 0], [0, 0, 0], [0, 0, 0]))\n     >>> linsolve(system, x, y)\n-    {(x, y)}\n+    FiniteSet((x, y))\n \n     * For an empty system linsolve returns empty set\n \n@@ -2483,7 +2483,7 @@ def linsolve(system, *symbols):\n       is detected:\n \n     >>> linsolve([x*(1/x - 1), (y - 1)**2 - y**2 + 1], x, y)\n-    {(1, 1)}\n+    FiniteSet((1, 1))\n     >>> linsolve([x**2 - 1], x)\n     Traceback (most recent call last):\n     ...\n@@ -2647,33 +2647,33 @@ def substitution(system, symbols, result=[{}], known_symbols=[],\n     >>> x, y = symbols('x, y', real=True)\n     >>> from sympy.solvers.solveset import substitution\n     >>> substitution([x + y], [x], [{y: 1}], [y], set([]), [x, y])\n-    {(-1, 1)}\n+    FiniteSet((-1, 1))\n \n     * when you want soln should not satisfy eq `x + 1 = 0`\n \n     >>> substitution([x + y], [x], [{y: 1}], [y], set([x + 1]), [y, x])\n     EmptySet\n     >>> substitution([x + y], [x], [{y: 1}], [y], set([x - 1]), [y, x])\n-    {(1, -1)}\n+    FiniteSet((1, -1))\n     >>> substitution([x + y - 1, y - x**2 + 5], [x, y])\n-    {(-3, 4), (2, -1)}\n+    FiniteSet((-3, 4), (2, -1))\n \n     * Returns both real and complex solution\n \n     >>> x, y, z = symbols('x, y, z')\n     >>> from sympy import exp, sin\n     >>> substitution([exp(x) - sin(y), y**2 - 4], [x, y])\n-    {(ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2),\n-    (ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2)}\n+    FiniteSet((ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2),\n+            (ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2))\n \n     >>> eqs = [z**2 + exp(2*x) - sin(y), -3 + exp(-y)]\n     >>> substitution(eqs, [y, z])\n-    {(-log(3), -sqrt(-exp(2*x) - sin(log(3)))),\n-    (-log(3), sqrt(-exp(2*x) - sin(log(3)))),\n+    FiniteSet((-log(3), sqrt(-exp(2*x) - sin(log(3)))),\n+    (-log(3), -sqrt(-exp(2*x) - sin(log(3)))),\n     (ImageSet(Lambda(_n, 2*_n*I*pi - log(3)), Integers),\n-    ImageSet(Lambda(_n, -sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers)),\n+       ImageSet(Lambda(_n, sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers)),\n     (ImageSet(Lambda(_n, 2*_n*I*pi - log(3)), Integers),\n-    ImageSet(Lambda(_n, sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers))}\n+       ImageSet(Lambda(_n, -sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers)))\n \n     \"\"\"\n \n@@ -3254,7 +3254,7 @@ def nonlinsolve(system, *symbols):\n     >>> from sympy.solvers.solveset import nonlinsolve\n     >>> x, y, z = symbols('x, y, z', real=True)\n     >>> nonlinsolve([x*y - 1, 4*x**2 + y**2 - 5], [x, y])\n-    {(-1, -1), (-1/2, -2), (1/2, 2), (1, 1)}\n+    FiniteSet((-1, -1), (-1/2, -2), (1/2, 2), (1, 1))\n \n     1. Positive dimensional system and complements:\n \n@@ -3273,7 +3273,7 @@ def nonlinsolve(system, *symbols):\n     {(---, -d, -, {d} \\ {0}), (-, -d, ---, {d} \\ {0})}\n        d       d               d       d\n     >>> nonlinsolve([(x+y)**2 - 4, x + y - 2], [x, y])\n-    {(2 - y, y)}\n+    FiniteSet((2 - y, y))\n \n     2. If some of the equations are non-polynomial then `nonlinsolve`\n     will call the `substitution` function and return real and complex solutions,\n@@ -3281,8 +3281,9 @@ def nonlinsolve(system, *symbols):\n \n     >>> from sympy import exp, sin\n     >>> nonlinsolve([exp(x) - sin(y), y**2 - 4], [x, y])\n-    {(ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2),\n-    (ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2)}\n+    FiniteSet((ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2),\n+            (ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2))\n+\n \n     3. If system is non-linear polynomial and zero-dimensional then it\n     returns both solution (real and complex solutions, if present) using\n@@ -3290,7 +3291,7 @@ def nonlinsolve(system, *symbols):\n \n     >>> from sympy import sqrt\n     >>> nonlinsolve([x**2 - 2*y**2 -2, x*y - 2], [x, y])\n-    {(-2, -1), (2, 1), (-sqrt(2)*I, sqrt(2)*I), (sqrt(2)*I, -sqrt(2)*I)}\n+    FiniteSet((-2, -1), (2, 1), (-sqrt(2)*I, sqrt(2)*I), (sqrt(2)*I, -sqrt(2)*I))\n \n     4. `nonlinsolve` can solve some linear (zero or positive dimensional)\n     system (because it uses the `groebner` function to get the\n@@ -3299,7 +3300,7 @@ def nonlinsolve(system, *symbols):\n     `nonlinsolve`, because `linsolve` is better for general linear systems.\n \n     >>> nonlinsolve([x + 2*y -z - 3, x - y - 4*z + 9 , y + z - 4], [x, y, z])\n-    {(3*z - 5, 4 - z, z)}\n+    FiniteSet((3*z - 5, 4 - z, z))\n \n     5. System having polynomial equations and only real solution is\n     solved using `solve_poly_system`:\n@@ -3307,11 +3308,11 @@ def nonlinsolve(system, *symbols):\n     >>> e1 = sqrt(x**2 + y**2) - 10\n     >>> e2 = sqrt(y**2 + (-x + 10)**2) - 3\n     >>> nonlinsolve((e1, e2), (x, y))\n-    {(191/20, -3*sqrt(391)/20), (191/20, 3*sqrt(391)/20)}\n+    FiniteSet((191/20, -3*sqrt(391)/20), (191/20, 3*sqrt(391)/20))\n     >>> nonlinsolve([x**2 + 2/y - 2, x + y - 3], [x, y])\n-    {(1, 2), (1 - sqrt(5), 2 + sqrt(5)), (1 + sqrt(5), 2 - sqrt(5))}\n+    FiniteSet((1, 2), (1 - sqrt(5), 2 + sqrt(5)), (1 + sqrt(5), 2 - sqrt(5)))\n     >>> nonlinsolve([x**2 + 2/y - 2, x + y - 3], [y, x])\n-    {(2, 1), (2 - sqrt(5), 1 + sqrt(5)), (2 + sqrt(5), 1 - sqrt(5))}\n+    FiniteSet((2, 1), (2 - sqrt(5), 1 + sqrt(5)), (2 + sqrt(5), 1 - sqrt(5)))\n \n     6. It is better to use symbols instead of Trigonometric Function or\n     Function (e.g. replace `sin(x)` with symbol, replace `f(x)` with symbol\ndiff --git a/sympy/stats/stochastic_process_types.py b/sympy/stats/stochastic_process_types.py\n--- a/sympy/stats/stochastic_process_types.py\n+++ b/sympy/stats/stochastic_process_types.py\n@@ -553,7 +553,7 @@ class DiscreteMarkovChain(DiscreteTimeStochasticProcess, MarkovProcess):\n     >>> Y = DiscreteMarkovChain(\"Y\", [0, 1, 2], T)\n     >>> YS = DiscreteMarkovChain(\"Y\")\n     >>> Y.state_space\n-    {0, 1, 2}\n+    FiniteSet(0, 1, 2)\n     >>> Y.transition_probabilities\n     Matrix([\n     [0.5, 0.2, 0.3],\n",
  "test_patch": "diff --git a/sympy/printing/tests/test_str.py b/sympy/printing/tests/test_str.py\n--- a/sympy/printing/tests/test_str.py\n+++ b/sympy/printing/tests/test_str.py\n@@ -707,8 +707,12 @@ def test_RandomDomain():\n \n \n def test_FiniteSet():\n-    assert str(FiniteSet(*range(1, 51))) == '{1, 2, 3, ..., 48, 49, 50}'\n-    assert str(FiniteSet(*range(1, 6))) == '{1, 2, 3, 4, 5}'\n+    assert str(FiniteSet(*range(1, 51))) == (\n+        'FiniteSet(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,'\n+        ' 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,'\n+        ' 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50)'\n+    )\n+    assert str(FiniteSet(*range(1, 6))) == 'FiniteSet(1, 2, 3, 4, 5)'\n \n \n def test_UniversalSet():\n",
  "problem_statement": "Interval and FiniteSet printing\nCurrently \r\nstr(Interval(0,1)) produces \"[0, 1]\" \r\nand \r\nstr(FiniteSet(1,2,3)) produces \"{1, 2, 3}\"\r\n\r\nThis violates the str(object) is valid code to create object principle. \r\n\r\nIf we change this then code for Interval looks quite ugly. We will end up printing things like \"Interval(0, 1, True, False)\" to the screen.\r\n\r\nOriginal issue for #6265: http://code.google.com/p/sympy/issues/detail?id=3166\r\nOriginal author: https://code.google.com/u/109882876523836932473/\r\n\n",
  "hints_text": "But may be I mistaken about of this printing policy. It is possible that this policy (as I described above) is outdated.\r\n\r\nBut I note, that only the `repr` must return valid code.\r\nFor `str` ( which prints for the user reading) it is not obligatory.\r\n\r\nAt least it is written in the docstrings of modules, as I understand.\r\n\r\n**Labels:** Printing  \r\n\r\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=3166#c1\r\nOriginal author: https://code.google.com/u/109448925098397033296/\r\n\nAnother idea, for the classes which can take Intervals as arguments, it is possible to use the short construction string.\r\n```\r\nIn [3]: x = Symbol('x', real=True)\r\n\r\nIn [4]: Intersection(Interval(1, 3), Interval(x, 6))\r\nOut[4]: [1, 3] ∩ [x, 6]\r\n\r\nIn [5]: str(Intersection(Interval(1, 3), Interval(x, 6)))\r\nOut[5]: Intersection([1, 3], [x, 6])\r\n\r\nThe Out[5] can be valid not only as:\r\nOut[5]: Intersection(Interval(1, 3), Interval(x, 6))\r\n```\r\nbut and as\r\n```\r\nOut[5]: Intersection((1, 3), (x, 6))\r\n```\r\nif Intersection constructor can accept tuple and understand that it is Interval and parse correctly.\r\n\r\nThis case is only of the ends are not open. (Or for open? As it will be confused and strange that (1, 3) --> [1, 3] for `pprint`)\r\n\r\nUnfortunately it is not possiblely to use `Intersection([1, 3], [x, 6])`, because \r\narguments must be immutable.\r\n\r\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=3166#c2\r\nOriginal author: https://code.google.com/u/109448925098397033296/\r\n\nI think it is better not to connect Intersection and Interval too strongly.\r\n\r\nIntersection will be used for many different kinds of classes, not just Interval. (1,2) could equally well refer to Interval(1,2) or FiniteSet(1,2). \r\n\r\nI think that creating the special syntax will create problems in the future. \r\n\r\nIf, as you say in your first comment, it is not important for str(object) to be valid code to produce object then I think that this issue is not important.\r\n\r\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=3166#c3\r\nOriginal author: https://code.google.com/u/109882876523836932473/\r\n\n```\n**Status:** Valid  \n\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=3166#c4\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n```\nWe have moved issues to GitHub https://github.com/sympy/sympy/issues .\n\n**Labels:** Restrict-AddIssueComment-Commit  \n\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=3166#c5\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n```\nWe have moved issues to GitHub https://github.com/sympy/sympy/issues .\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=3166#c6\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\nIs this issue still worth fixing? The printing of both FiniteSet and Interval has been unchanged for some time now. It would seem gratuitous to fix at at this point...\n```python\r\n>>> S(str(Interval(0,1)) )\r\nInterval(0, 1)\r\n>>> type(S(str(FiniteSet(0,1)) ))\r\n<class 'set'>\r\n```\r\n\r\nPerhaps `set`, like `dict`, is just not handled yet by `sympify`.\nSympify will convert a `set` to a `FiniteSet` but doesn't recognise a set literal and passes that on to eval.\nFor the original issue this has already been changed for Interval but not FiniteSet:\r\n```julia\r\nIn [1]: str(Interval(0, 1))                                                                                                                                   \r\nOut[1]: 'Interval(0, 1)'\r\n\r\nIn [2]: str(FiniteSet(1))                                                                                                                                     \r\nOut[2]: '{1}'\r\n```\r\nChanging this for FiniteSet does not seem problematic. PR underway...",
  "created_at": "2019-11-02T22:51:16Z",
  "version": "1.5",
  "FAIL_TO_PASS": "[\"test_FiniteSet\"]",
  "PASS_TO_PASS": "[\"test_printmethod\", \"test_Abs\", \"test_Add\", \"test_Catalan\", \"test_ComplexInfinity\", \"test_Derivative\", \"test_dict\", \"test_Dict\", \"test_Dummy\", \"test_EulerGamma\", \"test_Exp\", \"test_factorial\", \"test_Function\", \"test_Geometry\", \"test_GoldenRatio\", \"test_TribonacciConstant\", \"test_ImaginaryUnit\", \"test_Infinity\", \"test_Integer\", \"test_Integral\", \"test_Interval\", \"test_AccumBounds\", \"test_Lambda\", \"test_Limit\", \"test_list\", \"test_Matrix_str\", \"test_Mul\", \"test_NaN\", \"test_NegativeInfinity\", \"test_Order\", \"test_Permutation_Cycle\", \"test_Pi\", \"test_Poly\", \"test_PolyRing\", \"test_FracField\", \"test_PolyElement\", \"test_FracElement\", \"test_Pow\", \"test_sqrt\", \"test_Rational\", \"test_Float\", \"test_Relational\", \"test_CRootOf\", \"test_RootSum\", \"test_GroebnerBasis\", \"test_set\", \"test_SparseMatrix\", \"test_Sum\", \"test_Symbol\", \"test_tuple\", \"test_Quaternion_str_printer\", \"test_Quantity_str\", \"test_wild_str\", \"test_zeta\", \"test_issue_3101\", \"test_issue_3103\", \"test_issue_4021\", \"test_sstrrepr\", \"test_infinity\", \"test_full_prec\", \"test_noncommutative\", \"test_empty_printer\", \"test_settings\", \"test_RandomDomain\", \"test_UniversalSet\", \"test_PrettyPoly\", \"test_categories\", \"test_Tr\", \"test_issue_6387\", \"test_MatMul_MatAdd\", \"test_MatrixSlice\", \"test_true_false\", \"test_Equivalent\", \"test_Xor\", \"test_Complement\", \"test_SymmetricDifference\", \"test_UnevaluatedExpr\", \"test_MatrixElement_printing\", \"test_MatrixSymbol_printing\", \"test_Subs_printing\", \"test_issue_15716\", \"test_str_special_matrices\"]",
  "environment_setup_commit": "70381f282f2d9d039da860e391fe51649df2779d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.118776",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}