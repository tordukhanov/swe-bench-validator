{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-12812",
  "base_commit": "7efbee85cf49d767a11de8344b2b99b2b2460769",
  "patch": "diff --git a/sympy/diffgeom/diffgeom.py b/sympy/diffgeom/diffgeom.py\n--- a/sympy/diffgeom/diffgeom.py\n+++ b/sympy/diffgeom/diffgeom.py\n@@ -12,6 +12,7 @@\n from sympy.core.compatibility import reduce\n from sympy.combinatorics import Permutation\n \n+\n # TODO you are a bit excessive in the use of Dummies\n # TODO dummy point, literal field\n # TODO too often one needs to call doit or simplify on the output, check the\n@@ -574,6 +575,9 @@ def __call__(self, scalar_field):\n         if covariant_order(scalar_field) or contravariant_order(scalar_field):\n             raise ValueError('Only scalar fields can be supplied as arguments to vector fields.')\n \n+        if scalar_field is None:\n+            return self\n+\n         base_scalars = list(scalar_field.atoms(BaseScalarField))\n \n         # First step: e_x(x+r**2) -> e_x(x) + 2*r*e_x(r)\n@@ -789,10 +793,10 @@ class TensorProduct(Expr):\n     \"\"\"Tensor product of forms.\n \n     The tensor product permits the creation of multilinear functionals (i.e.\n-    higher order tensors) out of lower order forms (e.g. 1-forms). However, the\n-    higher tensors thus created lack the interesting features provided by the\n-    other type of product, the wedge product, namely they are not antisymmetric\n-    and hence are not form fields.\n+    higher order tensors) out of lower order fields (e.g. 1-forms and vector\n+    fields). However, the higher tensors thus created lack the interesting\n+    features provided by the other type of product, the wedge product, namely\n+    they are not antisymmetric and hence are not form fields.\n \n     Examples\n     ========\n@@ -810,6 +814,11 @@ class TensorProduct(Expr):\n     0\n     >>> TensorProduct(R2.dx, R2.x*R2.dy)(R2.x*R2.e_x, R2.e_y)\n     x**2\n+    >>> TensorProduct(R2.e_x, R2.e_y)(R2.x**2, R2.y**2)\n+    4*x*y\n+    >>> TensorProduct(R2.e_y, R2.dx)(R2.y)\n+    dx\n+\n \n     You can nest tensor products.\n \n@@ -833,14 +842,12 @@ class TensorProduct(Expr):\n \n     \"\"\"\n     def __new__(cls, *args):\n-        if any(contravariant_order(a) for a in args):\n-            raise ValueError('A vector field was supplied as an argument to TensorProduct.')\n-        scalar = Mul(*[m for m in args if covariant_order(m) == 0])\n-        forms = [m for m in args if covariant_order(m)]\n-        if forms:\n-            if len(forms) == 1:\n-                return scalar*forms[0]\n-            return scalar*super(TensorProduct, cls).__new__(cls, *forms)\n+        scalar = Mul(*[m for m in args if covariant_order(m) + contravariant_order(m) == 0])\n+        multifields = [m for m in args if covariant_order(m) + contravariant_order(m)]\n+        if multifields:\n+            if len(multifields) == 1:\n+                return scalar*multifields[0]\n+            return scalar*super(TensorProduct, cls).__new__(cls, *multifields)\n         else:\n             return scalar\n \n@@ -848,25 +855,25 @@ def __init__(self, *args):\n         super(TensorProduct, self).__init__()\n         self._args = args\n \n-    def __call__(self, *v_fields):\n-        \"\"\"Apply on a list of vector_fields.\n+    def __call__(self, *fields):\n+        \"\"\"Apply on a list of fields.\n \n-        If the number of vector fields supplied is not equal to the order of\n-        the form field the list of arguments is padded with ``None``'s.\n+        If the number of input fields supplied is not equal to the order of\n+        the tensor product field, the list of arguments is padded with ``None``'s.\n \n         The list of arguments is divided in sublists depending on the order of\n         the forms inside the tensor product. The sublists are provided as\n         arguments to these forms and the resulting expressions are given to the\n         constructor of ``TensorProduct``.\n         \"\"\"\n-        tot_order = covariant_order(self)\n-        tot_args = len(v_fields)\n+        tot_order = covariant_order(self) + contravariant_order(self)\n+        tot_args = len(fields)\n         if tot_args != tot_order:\n-            v_fields = list(v_fields) + [None]*(tot_order - tot_args)\n-        orders = [covariant_order(f) for f in self._args]\n+            fields = list(fields) + [None]*(tot_order - tot_args)\n+        orders = [covariant_order(f) + contravariant_order(f) for f in self._args]\n         indices = [sum(orders[:i + 1]) for i in range(len(orders) - 1)]\n-        v_fields = [v_fields[i:j] for i, j in zip([0] + indices, indices + [None])]\n-        multipliers = [t[0].rcall(*t[1]) for t in zip(self._args, v_fields)]\n+        fields = [fields[i:j] for i, j in zip([0] + indices, indices + [None])]\n+        multipliers = [t[0].rcall(*t[1]) for t in zip(self._args, fields)]\n         return TensorProduct(*multipliers)\n \n     def _latex(self, printer, *args):\n@@ -896,6 +903,8 @@ class WedgeProduct(TensorProduct):\n     -1\n     >>> WedgeProduct(R2.dx, R2.x*R2.dy)(R2.x*R2.e_x, R2.e_y)\n     x**2\n+    >>> WedgeProduct(R2.e_x,R2.e_y)(R2.y,None)\n+    -e_x\n \n     You can nest wedge products.\n \n@@ -906,15 +915,15 @@ class WedgeProduct(TensorProduct):\n     \"\"\"\n     # TODO the calculation of signatures is slow\n     # TODO you do not need all these permutations (neither the prefactor)\n-    def __call__(self, *vector_fields):\n+    def __call__(self, *fields):\n         \"\"\"Apply on a list of vector_fields.\n \n         The expression is rewritten internally in terms of tensor products and evaluated.\"\"\"\n-        orders = (covariant_order(e) for e in self.args)\n+        orders = (covariant_order(e) + contravariant_order(e) for e in self.args)\n         mul = 1/Mul(*(factorial(o) for o in orders))\n-        perms = permutations(vector_fields)\n+        perms = permutations(fields)\n         perms_par = (Permutation(\n-            p).signature() for p in permutations(list(range(len(vector_fields)))))\n+            p).signature() for p in permutations(list(range(len(fields)))))\n         tensor_prod = TensorProduct(*self.args)\n         return mul*Add(*[tensor_prod(*p[0])*p[1] for p in zip(perms, perms_par)])\n \n@@ -1340,6 +1349,8 @@ def contravariant_order(expr, _strict=False):\n         return 0\n     elif isinstance(expr, BaseVectorField):\n         return 1\n+    elif isinstance(expr, TensorProduct):\n+        return sum(contravariant_order(a) for a in expr.args)\n     elif not _strict or expr.atoms(BaseScalarField):\n         return 0\n     else:  # If it does not contain anything related to the diffgeom module and it is _strict\n",
  "test_patch": "diff --git a/sympy/diffgeom/tests/test_diffgeom.py b/sympy/diffgeom/tests/test_diffgeom.py\n--- a/sympy/diffgeom/tests/test_diffgeom.py\n+++ b/sympy/diffgeom/tests/test_diffgeom.py\n@@ -73,11 +73,31 @@ def test_differential():\n def test_products():\n     assert TensorProduct(\n         R2.dx, R2.dy)(R2.e_x, R2.e_y) == R2.dx(R2.e_x)*R2.dy(R2.e_y) == 1\n-    assert WedgeProduct(R2.dx, R2.dy)(R2.e_x, R2.e_y) == 1\n     assert TensorProduct(R2.dx, R2.dy)(None, R2.e_y) == R2.dx\n     assert TensorProduct(R2.dx, R2.dy)(R2.e_x, None) == R2.dy\n     assert TensorProduct(R2.dx, R2.dy)(R2.e_x) == R2.dy\n     assert TensorProduct(R2.x, R2.dx) == R2.x*R2.dx\n+    assert TensorProduct(\n+        R2.e_x, R2.e_y)(R2.x, R2.y) == R2.e_x(R2.x) * R2.e_y(R2.y) == 1\n+    assert TensorProduct(R2.e_x, R2.e_y)(None, R2.y) == R2.e_x\n+    assert TensorProduct(R2.e_x, R2.e_y)(R2.x, None) == R2.e_y\n+    assert TensorProduct(R2.e_x, R2.e_y)(R2.x) == R2.e_y\n+    assert TensorProduct(R2.x, R2.e_x) == R2.x * R2.e_x\n+    assert TensorProduct(\n+        R2.dx, R2.e_y)(R2.e_x, R2.y) == R2.dx(R2.e_x) * R2.e_y(R2.y) == 1\n+    assert TensorProduct(R2.dx, R2.e_y)(None, R2.y) == R2.dx\n+    assert TensorProduct(R2.dx, R2.e_y)(R2.e_x, None) == R2.e_y\n+    assert TensorProduct(R2.dx, R2.e_y)(R2.e_x) == R2.e_y\n+    assert TensorProduct(R2.x, R2.e_x) == R2.x * R2.e_x\n+    assert TensorProduct(\n+        R2.e_x, R2.dy)(R2.x, R2.e_y) == R2.e_x(R2.x) * R2.dy(R2.e_y) == 1\n+    assert TensorProduct(R2.e_x, R2.dy)(None, R2.e_y) == R2.e_x\n+    assert TensorProduct(R2.e_x, R2.dy)(R2.x, None) == R2.dy\n+    assert TensorProduct(R2.e_x, R2.dy)(R2.x) == R2.dy\n+    assert TensorProduct(R2.e_y,R2.e_x)(R2.x**2 + R2.y**2,R2.x**2 + R2.y**2) == 4*R2.x*R2.y\n+\n+    assert WedgeProduct(R2.dx, R2.dy)(R2.e_x, R2.e_y) == 1\n+    assert WedgeProduct(R2.e_x, R2.e_y)(R2.x, R2.y) == 1\n \n \n def test_lie_derivative():\n@@ -126,6 +146,11 @@ def test_helpers_and_coordinate_dependent():\n     twoform_not_sym = TensorProduct(R2.dx, R2.dx) + TensorProduct(R2.dx, R2.dy)\n     twoform_not_TP = WedgeProduct(R2.dx, R2.dy)\n \n+    one_vector = R2.e_x + R2.e_y\n+    two_vector = TensorProduct(R2.e_x, R2.e_y)\n+    three_vector = TensorProduct(R2.e_x, R2.e_y, R2.e_x)\n+    two_wp = WedgeProduct(R2.e_x,R2.e_y)\n+\n     assert covariant_order(one_form) == 1\n     assert covariant_order(two_form) == 2\n     assert covariant_order(three_form) == 3\n@@ -134,6 +159,11 @@ def test_helpers_and_coordinate_dependent():\n     assert covariant_order(two_form + twoform_not_sym) == 2\n     assert covariant_order(two_form + twoform_not_TP) == 2\n \n+    assert contravariant_order(one_vector) == 1\n+    assert contravariant_order(two_vector) == 2\n+    assert contravariant_order(three_vector) == 3\n+    assert contravariant_order(two_vector + two_wp) == 2\n+\n     raises(ValueError, lambda: covariant_order(misform_a))\n     raises(ValueError, lambda: covariant_order(misform_b))\n     raises(ValueError, lambda: covariant_order(misform_c))\n@@ -163,8 +193,6 @@ def test_correct_arguments():\n \n     raises(ValueError, lambda: R2.dx(R2.x))\n \n-    raises(ValueError, lambda: TensorProduct(R2.e_x, R2.dx))\n-\n     raises(ValueError, lambda: LieDerivative(R2.dx, R2.dx))\n     raises(ValueError, lambda: LieDerivative(R2.x, R2.dx))\n \n",
  "problem_statement": "diffgeom does not support multivector fields >(0,m) well enough\nA limitation of the diffgeom package is that it does not provide support for fields higher than (0,m). TensorProduct, WedgeProduct, and others all assume inputs of differential form-fields, while mixed multivector fields make sense in some contexts (such as Poisson geometry).\r\n\r\nI'll work on implementing (n,m)-fields in the current code, where it makes sense.\n",
  "hints_text": "",
  "created_at": "2017-06-26T22:21:56Z",
  "version": "1.0",
  "FAIL_TO_PASS": "[\"test_products\", \"test_helpers_and_coordinate_dependent\"]",
  "PASS_TO_PASS": "[\"test_point\", \"test_commutator\", \"test_differential\", \"test_lie_derivative\", \"test_correct_arguments\"]",
  "environment_setup_commit": "50b81f9f6be151014501ffac44e5dc6b2416938f",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.078331",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}