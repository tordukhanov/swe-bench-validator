{
  "repo": "django/django",
  "instance_id": "django__django-14894",
  "base_commit": "9466fd78420a851460c92673dad50a5737c75b12",
  "patch": "diff --git a/django/contrib/postgres/aggregates/statistics.py b/django/contrib/postgres/aggregates/statistics.py\n--- a/django/contrib/postgres/aggregates/statistics.py\n+++ b/django/contrib/postgres/aggregates/statistics.py\n@@ -36,7 +36,7 @@ class RegrAvgY(StatAggregate):\n class RegrCount(StatAggregate):\n     function = 'REGR_COUNT'\n     output_field = IntegerField()\n-    empty_aggregate_value = 0\n+    empty_result_set_value = 0\n \n \n class RegrIntercept(StatAggregate):\ndiff --git a/django/db/models/aggregates.py b/django/db/models/aggregates.py\n--- a/django/db/models/aggregates.py\n+++ b/django/db/models/aggregates.py\n@@ -21,12 +21,12 @@ class Aggregate(Func):\n     filter_template = '%s FILTER (WHERE %%(filter)s)'\n     window_compatible = True\n     allow_distinct = False\n-    empty_aggregate_value = None\n+    empty_result_set_value = None\n \n     def __init__(self, *expressions, distinct=False, filter=None, default=None, **extra):\n         if distinct and not self.allow_distinct:\n             raise TypeError(\"%s does not allow distinct.\" % self.__class__.__name__)\n-        if default is not None and self.empty_aggregate_value is not None:\n+        if default is not None and self.empty_result_set_value is not None:\n             raise TypeError(f'{self.__class__.__name__} does not allow default.')\n         self.distinct = distinct\n         self.filter = filter\n@@ -117,7 +117,7 @@ class Count(Aggregate):\n     name = 'Count'\n     output_field = IntegerField()\n     allow_distinct = True\n-    empty_aggregate_value = 0\n+    empty_result_set_value = 0\n \n     def __init__(self, expression, filter=None, **extra):\n         if expression == '*':\ndiff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -150,10 +150,10 @@ def __ror__(self, other):\n class BaseExpression:\n     \"\"\"Base class for all query expressions.\"\"\"\n \n+    empty_result_set_value = NotImplemented\n     # aggregate specific fields\n     is_summary = False\n     _output_field_resolved_to_none = False\n-    empty_aggregate_value = NotImplemented\n     # Can the expression be used in a WHERE clause?\n     filterable = True\n     # Can the expression can be used as a source expression in Window?\n@@ -702,7 +702,13 @@ def as_sql(self, compiler, connection, function=None, template=None, arg_joiner=\n         sql_parts = []\n         params = []\n         for arg in self.source_expressions:\n-            arg_sql, arg_params = compiler.compile(arg)\n+            try:\n+                arg_sql, arg_params = compiler.compile(arg)\n+            except EmptyResultSet:\n+                empty_result_set_value = getattr(arg, 'empty_result_set_value', NotImplemented)\n+                if empty_result_set_value is NotImplemented:\n+                    raise\n+                arg_sql, arg_params = compiler.compile(Value(empty_result_set_value))\n             sql_parts.append(arg_sql)\n             params.extend(arg_params)\n         data = {**self.extra, **extra_context}\n@@ -797,7 +803,7 @@ def _resolve_output_field(self):\n             return fields.UUIDField()\n \n     @property\n-    def empty_aggregate_value(self):\n+    def empty_result_set_value(self):\n         return self.value\n \n \n@@ -1114,6 +1120,7 @@ class Subquery(BaseExpression, Combinable):\n     \"\"\"\n     template = '(%(subquery)s)'\n     contains_aggregate = False\n+    empty_result_set_value = None\n \n     def __init__(self, queryset, output_field=None, **extra):\n         # Allow the usage of both QuerySet and sql.Query objects.\ndiff --git a/django/db/models/functions/comparison.py b/django/db/models/functions/comparison.py\n--- a/django/db/models/functions/comparison.py\n+++ b/django/db/models/functions/comparison.py\n@@ -66,9 +66,9 @@ def __init__(self, *expressions, **extra):\n         super().__init__(*expressions, **extra)\n \n     @property\n-    def empty_aggregate_value(self):\n+    def empty_result_set_value(self):\n         for expression in self.get_source_expressions():\n-            result = expression.empty_aggregate_value\n+            result = expression.empty_result_set_value\n             if result is NotImplemented or result is not None:\n                 return result\n         return None\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -266,8 +266,12 @@ def get_select_from_parent(klass_info):\n             try:\n                 sql, params = self.compile(col)\n             except EmptyResultSet:\n-                # Select a predicate that's always False.\n-                sql, params = '0', ()\n+                empty_result_set_value = getattr(col, 'empty_result_set_value', NotImplemented)\n+                if empty_result_set_value is NotImplemented:\n+                    # Select a predicate that's always False.\n+                    sql, params = '0', ()\n+                else:\n+                    sql, params = self.compile(Value(empty_result_set_value))\n             else:\n                 sql, params = col.select_format(self, sql, params)\n             ret.append((col, (sql, params), alias))\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -143,6 +143,7 @@ class Query(BaseExpression):\n     \"\"\"A single SQL query.\"\"\"\n \n     alias_prefix = 'T'\n+    empty_result_set_value = None\n     subq_aliases = frozenset([alias_prefix])\n \n     compiler = 'SQLCompiler'\n@@ -487,11 +488,11 @@ def get_aggregation(self, using, added_aggregate_names):\n             self.default_cols = False\n             self.extra = {}\n \n-        empty_aggregate_result = [\n-            expression.empty_aggregate_value\n+        empty_set_result = [\n+            expression.empty_result_set_value\n             for expression in outer_query.annotation_select.values()\n         ]\n-        elide_empty = not any(result is NotImplemented for result in empty_aggregate_result)\n+        elide_empty = not any(result is NotImplemented for result in empty_set_result)\n         outer_query.clear_ordering(force=True)\n         outer_query.clear_limits()\n         outer_query.select_for_update = False\n@@ -499,7 +500,7 @@ def get_aggregation(self, using, added_aggregate_names):\n         compiler = outer_query.get_compiler(using, elide_empty=elide_empty)\n         result = compiler.execute_sql(SINGLE)\n         if result is None:\n-            result = empty_aggregate_result\n+            result = empty_set_result\n \n         converters = compiler.get_converters(outer_query.annotation_select.values())\n         result = next(compiler.apply_converters((result,), converters))\n",
  "test_patch": "diff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py\n--- a/tests/aggregation/tests.py\n+++ b/tests/aggregation/tests.py\n@@ -1367,7 +1367,7 @@ def test_empty_result_optimization(self):\n                     'books_count': 0,\n                 }\n             )\n-        # Expression without empty_aggregate_value forces queries to be\n+        # Expression without empty_result_set_value forces queries to be\n         # executed even if they would return an empty result set.\n         raw_books_count = Func('book', function='COUNT')\n         raw_books_count.contains_aggregate = True\ndiff --git a/tests/annotations/tests.py b/tests/annotations/tests.py\n--- a/tests/annotations/tests.py\n+++ b/tests/annotations/tests.py\n@@ -210,6 +210,12 @@ def test_empty_expression_annotation(self):\n         self.assertEqual(len(books), Book.objects.count())\n         self.assertTrue(all(not book.selected for book in books))\n \n+    def test_empty_queryset_annotation(self):\n+        qs = Author.objects.annotate(\n+            empty=Subquery(Author.objects.values('id').none())\n+        )\n+        self.assertIsNone(qs.first().empty)\n+\n     def test_annotate_with_aggregation(self):\n         books = Book.objects.annotate(is_book=Value(1), rating_count=Count('rating'))\n         for book in books:\ndiff --git a/tests/db_functions/comparison/test_coalesce.py b/tests/db_functions/comparison/test_coalesce.py\n--- a/tests/db_functions/comparison/test_coalesce.py\n+++ b/tests/db_functions/comparison/test_coalesce.py\n@@ -1,4 +1,4 @@\n-from django.db.models import TextField\n+from django.db.models import Subquery, TextField\n from django.db.models.functions import Coalesce, Lower\n from django.test import TestCase\n from django.utils import timezone\n@@ -70,3 +70,14 @@ def test_ordering(self):\n             authors, ['John Smith', 'Rhonda'],\n             lambda a: a.name\n         )\n+\n+    def test_empty_queryset(self):\n+        Author.objects.create(name='John Smith')\n+        tests = [\n+            Author.objects.none(),\n+            Subquery(Author.objects.none()),\n+        ]\n+        for empty_query in tests:\n+            with self.subTest(empty_query.__class__.__name__):\n+                qs = Author.objects.annotate(annotation=Coalesce(empty_query, 42))\n+                self.assertEqual(qs.first().annotation, 42)\n",
  "problem_statement": "Incorrect annotation value when doing a subquery with empty queryset\nDescription\n\t\nORM seems to generate annotation/subqueries incorrectly if empty queryset is used. \nModels:\nclass Article(models.Model):\n\tauthor_name = models.CharField(max_length=100)\n\tcontent = models.TextField()\n\tis_public = models.BooleanField()\nclass Comment(models.Model):\n\tarticle = models.ForeignKey(Article, related_name=\"comments\", on_delete=models.CASCADE)\n\tauthor_name = models.CharField(max_length=100)\n\tcontent = models.TextField()\ntest data:\narticle = Article.objects.create(author_name=\"Jack\", content=\"Example content\", is_public=True)\ncomment = Comment.objects.create(article=article, author_name=\"John\", content=\"Example comment\")\nqueries:\nqs = Article.objects.all()\n# keep one list_x uncommented to see the difference:\nlist_x = [\"random_thing_that_is_not_equal_to_any_authors_name\"] # list not empty, bug doesnt occur\n#list_x = [] # if this list is empty, then the bug occurs\ncomment_qs = Comment.objects.filter(author_name__in=list_x)\nqs = qs.annotate(\n\tA=Coalesce(Subquery(\n\t\tcomment_qs.annotate(x=Count('content')).values('x')[:1], output_field=IntegerField(),\n\t), 101) # if list_x == [], Coalesce wont work and A will be 0 instead of 101\n)\n# please note that above annotation doesnt make much logical sense, its just for testing purposes\nqs = qs.annotate(\n\tB=Value(99, output_field=IntegerField())\n)\nqs = qs.annotate(\n\tC=F(\"A\") + F(\"B\") # if list_x == [], C will result in 0 sic! instead of 101 + 99 = 200\n)\ndata = {\n\t\"A\": qs.last().A,\n\t\"B\": qs.last().B,\n\t\"C\": qs.last().C,\n}\nprint(data)\nprint(format_sql(qs.query))\nconsole output for list_x=[\"random_thing_that_is_not_equal_to_any_authors_name\"] (expected, correct):\n{'A': 101, 'B': 99, 'C': 200}\nSELECT \"articles_article\".\"id\",\n\t \"articles_article\".\"author_name\",\n\t \"articles_article\".\"content\",\n\t \"articles_article\".\"is_public\",\n\t COALESCE(\n\t\t\t\t (SELECT COUNT(U0.\"content\") AS \"x\"\n\t\t\t\t FROM \"articles_comment\" U0\n\t\t\t\t WHERE U0.\"author_name\" IN (random_thing_that_is_not_equal_to_any_authors_name)\n\t\t\t\t GROUP BY U0.\"id\", U0.\"article_id\", U0.\"author_name\", U0.\"content\"\n\t\t\t\t LIMIT 1), 101) AS \"A\",\n\t 99 AS \"B\",\n\t (COALESCE(\n\t\t\t\t (SELECT COUNT(U0.\"content\") AS \"x\"\n\t\t\t\t\tFROM \"articles_comment\" U0\n\t\t\t\t\tWHERE U0.\"author_name\" IN (random_thing_that_is_not_equal_to_any_authors_name)\n\t\t\t\t\tGROUP BY U0.\"id\", U0.\"article_id\", U0.\"author_name\", U0.\"content\"\n\t\t\t\t\tLIMIT 1), 101) + 99) AS \"C\"\nFROM \"articles_article\"\nconsole output for list_x=[] (incorrect):\n{'A': 0, 'B': 99, 'C': 0}\nSELECT \"articles_article\".\"id\",\n\t \"articles_article\".\"author_name\",\n\t \"articles_article\".\"content\",\n\t \"articles_article\".\"is_public\",\n\t 0 AS \"A\",\n\t 99 AS \"B\",\n\t 0 AS \"C\"\nFROM \"articles_article\"\nBackground story: Above queries are made up (simplified), but based on some parts of logic that I had in my code. list_x was generated dynamically, and it was very hard to detect what is causing unexpected results. This behavior is very strange, I believe its a bug and needs to be fixed, because it is totally unintuitive that:\nSomeModel.objects.filter(x__in=[\"something_that_causes_this_qs_lenth_to_be_0\"])\nand \nSomeModel.objects.filter(x__in=[]) \nmay yield different results when used in queries later, even though results of this querysets are logically equivalent\nI will attach a minimal repro project (with code from above)\n",
  "hints_text": "The 0 assignment on empty result set comes from ​this line. I assume we could adjust the logic to rely on getattr(col, 'empty_aggregate_value', NotImplemented) and fallback to '0' if it's missing. Makes me wonder if we'd want to rename empty_aggregate_value to empty_result_set_value instead since it would not entirely be bound to aggregation anymore. e.g. the following should exhibit the same behavior Author.objects.annotate(annotation=Coalesce(Author.objects.empty(), 42)) It also seems weird that we default to 0 as opposed to NULL which would be a more correct value for a non-coalesced annotation. Alternatively we could adjust Coalesce.as_sql to catch EmptyResultSet when it's compiling its source expressions but that's more involved as most of the logic for that currently lives in Func.as_sql. We could also use both of these approaches.\nHi! Thanks for the hints Simon, I tried a first patch where we catch empty values here ​https://github.com/django/django/pull/14770 Should we expand the solution a bit further and rename empty_aggregate_value as you suggested, and use it in the SQLCompiler too?\nHi, thanks for your PR, do we have any updates on this?\nHi, the patch is waiting on some review I believe. So once a maintainer has a bit of time available, we'll be able to move forward :)",
  "created_at": "2021-09-24T20:08:24Z",
  "version": "4.1",
  "FAIL_TO_PASS": "[\"test_empty_queryset (db_functions.comparison.test_coalesce.CoalesceTests)\", \"test_gt_two_expressions (db_functions.comparison.test_coalesce.CoalesceTests)\", \"test_empty_queryset_annotation (annotations.tests.NonAggregateAnnotationTestCase)\"]",
  "PASS_TO_PASS": "[\"test_basic (db_functions.comparison.test_coalesce.CoalesceTests)\", \"test_mixed_values (db_functions.comparison.test_coalesce.CoalesceTests)\", \"test_ordering (db_functions.comparison.test_coalesce.CoalesceTests)\", \"test_aggregate_alias (annotations.tests.AliasTests)\", \"test_alias_after_annotation (annotations.tests.AliasTests)\", \"test_alias_annotate_with_aggregation (annotations.tests.AliasTests)\", \"test_alias_annotation_expression (annotations.tests.AliasTests)\", \"test_alias_default_alias_expression (annotations.tests.AliasTests)\", \"test_basic_alias (annotations.tests.AliasTests)\", \"test_basic_alias_annotation (annotations.tests.AliasTests)\", \"test_basic_alias_f_annotation (annotations.tests.AliasTests)\", \"test_basic_alias_f_transform_annotation (annotations.tests.AliasTests)\", \"test_dates_alias (annotations.tests.AliasTests)\", \"test_datetimes_alias (annotations.tests.AliasTests)\", \"test_defer_only_alias (annotations.tests.AliasTests)\", \"test_filter_alias_agg_with_double_f (annotations.tests.AliasTests)\", \"test_filter_alias_with_double_f (annotations.tests.AliasTests)\", \"test_filter_alias_with_f (annotations.tests.AliasTests)\", \"test_joined_alias_annotation (annotations.tests.AliasTests)\", \"test_order_by_alias (annotations.tests.AliasTests)\", \"test_order_by_alias_aggregate (annotations.tests.AliasTests)\", \"test_overwrite_alias_with_annotation (annotations.tests.AliasTests)\", \"test_overwrite_annotation_with_alias (annotations.tests.AliasTests)\", \"test_update_with_alias (annotations.tests.AliasTests)\", \"test_values_alias (annotations.tests.AliasTests)\", \"test_aggregate_over_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_annotate_exists (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_annotate_with_aggregation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_annotation_aggregate_with_m2o (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_annotation_exists_aggregate_values_chaining (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_annotation_filter_with_subquery (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_annotation_in_f_grouped_by_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_annotation_reverse_m2m (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_annotation_subquery_and_aggregate_values_chaining (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_annotation_subquery_outerref_transform (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_annotation_with_m2m (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_arguments_must_be_expressions (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_basic_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_basic_f_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_boolean_value_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_chaining_annotation_filter_with_m2m (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_chaining_transforms (annotations.tests.NonAggregateAnnotationTestCase)\", \"Columns are aligned in the correct order for resolve_columns. This test\", \"test_column_field_ordering_with_deferred (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_combined_annotation_commutative (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_combined_expression_annotation_with_aggregation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_combined_f_expression_annotation_with_aggregation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_custom_functions (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_custom_functions_can_ref_other_functions (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_custom_transform_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_decimal_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"Deferred attributes can be referenced by an annotation,\", \"test_empty_expression_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_filter_agg_with_double_f (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_filter_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_filter_annotation_with_double_f (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_filter_annotation_with_f (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_filter_decimal_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_filter_wrong_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_grouping_by_q_expression_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_joined_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_joined_transformed_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_mixed_type_annotation_date_interval (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_mixed_type_annotation_numbers (annotations.tests.NonAggregateAnnotationTestCase)\", \"Fields on an inherited model can be referenced by an\", \"Annotating None onto a model round-trips\", \"test_order_by_aggregate (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_order_by_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_q_expression_annotation_with_aggregation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_raw_sql_with_inherited_field (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_update_with_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"Annotations can reference fields in a values clause,\", \"test_values_with_pk_annotation (annotations.tests.NonAggregateAnnotationTestCase)\", \"test_add_implementation (aggregation.tests.AggregateTestCase)\", \"test_aggregate_alias (aggregation.tests.AggregateTestCase)\", \"test_aggregate_annotation (aggregation.tests.AggregateTestCase)\", \"test_aggregate_in_order_by (aggregation.tests.AggregateTestCase)\", \"test_aggregate_join_transform (aggregation.tests.AggregateTestCase)\", \"test_aggregate_multi_join (aggregation.tests.AggregateTestCase)\", \"test_aggregate_over_aggregate (aggregation.tests.AggregateTestCase)\", \"test_aggregate_over_complex_annotation (aggregation.tests.AggregateTestCase)\", \"test_aggregate_transform (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_compound_expression (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_expression (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_group_by (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_integer (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_passed_another_aggregate (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_unset (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_unsupported_by_count (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_using_date_from_database (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_using_date_from_python (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_using_datetime_from_database (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_using_datetime_from_python (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_using_decimal_from_database (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_using_decimal_from_python (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_using_duration_from_database (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_using_duration_from_python (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_using_time_from_database (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_using_time_from_python (aggregation.tests.AggregateTestCase)\", \"test_aggregation_default_zero (aggregation.tests.AggregateTestCase)\", \"test_aggregation_exists_annotation (aggregation.tests.AggregateTestCase)\", \"test_aggregation_expressions (aggregation.tests.AggregateTestCase)\", \"test_aggregation_nested_subquery_outerref (aggregation.tests.AggregateTestCase)\", \"test_aggregation_order_by_not_selected_annotation_values (aggregation.tests.AggregateTestCase)\", \"Random() is not included in the GROUP BY when used for ordering.\", \"Subquery annotations are excluded from the GROUP BY if they are\", \"test_aggregation_subquery_annotation_exists (aggregation.tests.AggregateTestCase)\", \"Subquery annotations must be included in the GROUP BY if they use\", \"test_aggregation_subquery_annotation_related_field (aggregation.tests.AggregateTestCase)\", \"Subquery annotations and external aliases are excluded from the GROUP\", \"test_aggregation_subquery_annotation_values_collision (aggregation.tests.AggregateTestCase)\", \"test_annotate_basic (aggregation.tests.AggregateTestCase)\", \"test_annotate_defer (aggregation.tests.AggregateTestCase)\", \"test_annotate_defer_select_related (aggregation.tests.AggregateTestCase)\", \"test_annotate_m2m (aggregation.tests.AggregateTestCase)\", \"test_annotate_ordering (aggregation.tests.AggregateTestCase)\", \"test_annotate_over_annotate (aggregation.tests.AggregateTestCase)\", \"test_annotate_values (aggregation.tests.AggregateTestCase)\", \"test_annotate_values_aggregate (aggregation.tests.AggregateTestCase)\", \"test_annotate_values_list (aggregation.tests.AggregateTestCase)\", \"test_annotated_aggregate_over_annotated_aggregate (aggregation.tests.AggregateTestCase)\", \"test_annotation (aggregation.tests.AggregateTestCase)\", \"test_annotation_expressions (aggregation.tests.AggregateTestCase)\", \"test_arguments_must_be_expressions (aggregation.tests.AggregateTestCase)\", \"test_avg_decimal_field (aggregation.tests.AggregateTestCase)\", \"test_avg_duration_field (aggregation.tests.AggregateTestCase)\", \"test_backwards_m2m_annotate (aggregation.tests.AggregateTestCase)\", \"test_coalesced_empty_result_set (aggregation.tests.AggregateTestCase)\", \"test_combine_different_types (aggregation.tests.AggregateTestCase)\", \"test_complex_aggregations_require_kwarg (aggregation.tests.AggregateTestCase)\", \"test_complex_values_aggregation (aggregation.tests.AggregateTestCase)\", \"test_count (aggregation.tests.AggregateTestCase)\", \"test_count_distinct_expression (aggregation.tests.AggregateTestCase)\", \"test_count_star (aggregation.tests.AggregateTestCase)\", \".dates() returns a distinct set of dates when applied to a\", \"test_decimal_max_digits_has_no_effect (aggregation.tests.AggregateTestCase)\", \"test_distinct_on_aggregate (aggregation.tests.AggregateTestCase)\", \"test_empty_aggregate (aggregation.tests.AggregateTestCase)\", \"test_empty_result_optimization (aggregation.tests.AggregateTestCase)\", \"test_even_more_aggregate (aggregation.tests.AggregateTestCase)\", \"test_exists_extra_where_with_aggregate (aggregation.tests.AggregateTestCase)\", \"test_exists_none_with_aggregate (aggregation.tests.AggregateTestCase)\", \"test_expression_on_aggregation (aggregation.tests.AggregateTestCase)\", \"test_filter_aggregate (aggregation.tests.AggregateTestCase)\", \"test_filtering (aggregation.tests.AggregateTestCase)\", \"test_fkey_aggregate (aggregation.tests.AggregateTestCase)\", \"Exists annotations are included in the GROUP BY if they are\", \"Subquery annotations are included in the GROUP BY if they are\", \"An annotation included in values() before an aggregate should be\", \"test_more_aggregation (aggregation.tests.AggregateTestCase)\", \"test_multi_arg_aggregate (aggregation.tests.AggregateTestCase)\", \"test_multiple_aggregates (aggregation.tests.AggregateTestCase)\", \"An annotation not included in values() before an aggregate should be\", \"test_nonaggregate_aggregation_throws (aggregation.tests.AggregateTestCase)\", \"test_nonfield_annotation (aggregation.tests.AggregateTestCase)\", \"test_order_of_precedence (aggregation.tests.AggregateTestCase)\", \"test_related_aggregate (aggregation.tests.AggregateTestCase)\", \"test_reverse_fkey_annotate (aggregation.tests.AggregateTestCase)\", \"test_single_aggregate (aggregation.tests.AggregateTestCase)\", \"Sum on a distinct() QuerySet should aggregate only the distinct items.\", \"test_sum_duration_field (aggregation.tests.AggregateTestCase)\", \"Subqueries do not needlessly contain ORDER BY, SELECT FOR UPDATE or\", \"Aggregation over sliced queryset works correctly.\", \"Doing exclude() on a foreign model after annotate() doesn't crash.\", \"test_values_aggregation (aggregation.tests.AggregateTestCase)\", \"test_values_annotation_with_expression (aggregation.tests.AggregateTestCase)\"]",
  "environment_setup_commit": "647480166bfe7532e8c471fef0146e3a17e6c0c9",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.706959",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}