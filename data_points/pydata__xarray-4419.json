{
  "repo": "pydata/xarray",
  "instance_id": "pydata__xarray-4419",
  "base_commit": "2ed6d57fa5e14e87e83c8194e619538f6edcd90a",
  "patch": "diff --git a/xarray/core/concat.py b/xarray/core/concat.py\n--- a/xarray/core/concat.py\n+++ b/xarray/core/concat.py\n@@ -463,6 +463,9 @@ def ensure_common_dims(vars):\n             combined = concat_vars(vars, dim, positions)\n             assert isinstance(combined, Variable)\n             result_vars[k] = combined\n+        elif k in result_vars:\n+            # preserves original variable order\n+            result_vars[k] = result_vars.pop(k)\n \n     result = Dataset(result_vars, attrs=result_attrs)\n     absent_coord_names = coord_names - set(result.variables)\n",
  "test_patch": "diff --git a/xarray/tests/test_concat.py b/xarray/tests/test_concat.py\n--- a/xarray/tests/test_concat.py\n+++ b/xarray/tests/test_concat.py\n@@ -558,3 +558,36 @@ def test_concat_merge_single_non_dim_coord():\n     for coords in [\"different\", \"all\"]:\n         with raises_regex(ValueError, \"'y' not present in all datasets\"):\n             concat([da1, da2, da3], dim=\"x\")\n+\n+\n+def test_concat_preserve_coordinate_order():\n+    x = np.arange(0, 5)\n+    y = np.arange(0, 10)\n+    time = np.arange(0, 4)\n+    data = np.zeros((4, 10, 5), dtype=bool)\n+\n+    ds1 = Dataset(\n+        {\"data\": ([\"time\", \"y\", \"x\"], data[0:2])},\n+        coords={\"time\": time[0:2], \"y\": y, \"x\": x},\n+    )\n+    ds2 = Dataset(\n+        {\"data\": ([\"time\", \"y\", \"x\"], data[2:4])},\n+        coords={\"time\": time[2:4], \"y\": y, \"x\": x},\n+    )\n+\n+    expected = Dataset(\n+        {\"data\": ([\"time\", \"y\", \"x\"], data)},\n+        coords={\"time\": time, \"y\": y, \"x\": x},\n+    )\n+\n+    actual = concat([ds1, ds2], dim=\"time\")\n+\n+    # check dimension order\n+    for act, exp in zip(actual.dims, expected.dims):\n+        assert act == exp\n+        assert actual.dims[act] == expected.dims[exp]\n+\n+    # check coordinate order\n+    for act, exp in zip(actual.coords, expected.coords):\n+        assert act == exp\n+        assert_identical(actual.coords[act], expected.coords[exp])\n",
  "problem_statement": "concat changes variable order\n#### Code Sample, a copy-pastable example if possible\r\n\r\nA \"Minimal, Complete and Verifiable Example\" will make it much easier for maintainers to help you:\r\nhttp://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports\r\n \r\n- Case 1: Creation of Dataset without Coordinates\r\n```python\r\ndata = np.zeros((2,3))\r\nds = xr.Dataset({'test': (['c', 'b'],  data)})\r\nprint(ds.dims)\r\nds2 = xr.concat([ds, ds], dim='c')\r\nprint(ds2.dims)\r\n```\r\nyields (assumed correct) output of:\r\n```\r\nFrozen(SortedKeysDict({'c': 2, 'b': 3}))\r\nFrozen(SortedKeysDict({'c': 4, 'b': 3}))\r\n```\r\n- Case 2: Creation of Dataset with Coordinates\r\n```python\r\ndata = np.zeros((2,3))\r\nds = xr.Dataset({'test': (['c', 'b'],  data)}, \r\n                coords={'c': (['c'], np.arange(data.shape[0])),\r\n                        'b': (['b'], np.arange(data.shape[1])),})\r\nprint(ds.dims)\r\nds2 = xr.concat([ds, ds], dim='c')\r\nprint(ds2.dims)\r\n```\r\nyields (assumed false) output of:\r\n```\r\nFrozen(SortedKeysDict({'c': 2, 'b': 3}))\r\nFrozen(SortedKeysDict({'b': 3, 'c': 4}))\r\n```\r\n\r\n#### Problem description\r\n\r\n`xr.concat` changes the dimension order for `.dims` as well as `.sizes` to  an alphanumerically sorted representation.\r\n\r\n#### Expected Output\r\n\r\n`xr.concat` should not change the dimension order in any case.\r\n\r\n```\r\nFrozen(SortedKeysDict({'c': 2, 'b': 3}))\r\nFrozen(SortedKeysDict({'c': 4, 'b': 3}))\r\n```\r\n\r\n#### Output of ``xr.show_versions()``\r\n\r\n<details>\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit: None\r\npython: 3.7.1 | packaged by conda-forge | (default, Nov 13 2018, 18:33:04) \r\n[GCC 7.3.0]\r\npython-bits: 64\r\nOS: Linux\r\nOS-release: 4.12.14-lp150.12.48-default\r\nmachine: x86_64\r\nprocessor: x86_64\r\nbyteorder: little\r\nLC_ALL: None\r\nLANG: de_DE.UTF-8\r\nLOCALE: de_DE.UTF-8\r\nlibhdf5: 1.10.4\r\nlibnetcdf: 4.6.2\r\n\r\nxarray: 0.11.3\r\npandas: 0.24.1\r\nnumpy: 1.16.1\r\nscipy: 1.2.0\r\nnetCDF4: 1.4.2\r\npydap: None\r\nh5netcdf: 0.6.2\r\nh5py: 2.9.0\r\nNio: None\r\nzarr: None\r\ncftime: 1.0.3.4\r\nPseudonetCDF: None\r\nrasterio: None\r\ncfgrib: None\r\niris: None\r\nbottleneck: 1.2.1\r\ncyordereddict: None\r\ndask: None\r\ndistributed: None\r\nmatplotlib: 3.0.2\r\ncartopy: 0.17.0\r\nseaborn: None\r\nsetuptools: 40.8.0\r\npip: 19.0.2\r\nconda: None\r\npytest: 4.2.0\r\nIPython: 7.2.0\r\nsphinx: None\r\n\r\n</details>\r\n\n[BUG] xr.concat inverts coordinates order\n<!-- A short summary of the issue, if appropriate -->\r\n\r\nFollowing the issue #3969 \r\nMerging two datasets using xr.concat inverts the coordinates order.\r\n\r\n#### MCVE Code Sample\r\n\r\n```\r\nimport numpy as np\r\nimport xarray as xr\r\n\r\nx = np.arange(0,10)\r\ny = np.arange(0,10)\r\ntime = [0,1]\r\ndata = np.zeros((10,10), dtype=bool)\r\ndataArray1 = xr.DataArray([data], coords={'time': [time[0]], 'y': y, 'x': x},\r\n                             dims=['time', 'y', 'x'])\r\ndataArray2 = xr.DataArray([data], coords={'time': [time[1]], 'y': y, 'x': x},\r\n                             dims=['time', 'y', 'x'])\r\ndataArray1 = dataArray1.to_dataset(name='data')\r\ndataArray2 = dataArray2.to_dataset(name='data')\r\n\r\nprint(dataArray1)\r\nprint(xr.concat([dataArray1,dataArray2], dim='time'))\r\n```\r\n#### Current Output\r\n\r\n```\r\n<xarray.Dataset>\r\nDimensions:  (time: 1, x: 10, y: 10)\r\nCoordinates:\r\n  * time     (time) int64 0\r\n  * y        (y) int64 0 1 2 3 4 5 6 7 8 9\r\n  * x        (x) int64 0 1 2 3 4 5 6 7 8 9\r\nData variables:\r\n    data     (time, y, x) bool False False False False ... False False False\r\n<xarray.Dataset>\r\nDimensions:  (time: 2, x: 10, y: 10)\r\nCoordinates:\r\n  * x        (x) int64 0 1 2 3 4 5 6 7 8 9  ##Inverted x and y\r\n  * y        (y) int64 0 1 2 3 4 5 6 7 8 9\r\n  * time     (time) int64 0 1\r\nData variables:\r\n    data     (time, y, x) bool False False False False ... False False False\r\n\r\n```\r\n\r\n#### Expected Output\r\n```\r\n<xarray.Dataset>\r\nDimensions:  (time: 1, x: 10, y: 10)\r\nCoordinates:\r\n  * time     (time) int64 0\r\n  * y        (y) int64 0 1 2 3 4 5 6 7 8 9\r\n  * x        (x) int64 0 1 2 3 4 5 6 7 8 9\r\nData variables:\r\n    data     (time, y, x) bool False False False False ... False False False\r\n<xarray.Dataset>\r\nDimensions:  (time: 2, x: 10, y: 10)\r\nCoordinates:\r\n  * y        (y) int64 0 1 2 3 4 5 6 7 8 9\r\n  * x        (x) int64 0 1 2 3 4 5 6 7 8 9\r\n  * time     (time) int64 0 1\r\nData variables:\r\n    data     (time, y, x) bool False False False False ... False False False\r\n\r\n```\r\n\r\n\r\n#### Problem Description\r\n\r\nThe concat function should not invert the coordinates but maintain the original order.\r\n\r\n#### Versions\r\n\r\n<details><summary>INSTALLED VERSIONS\r\n</summary>\r\n------------------\r\ncommit: None\r\npython: 3.6.8 (default, May  7 2019, 14:58:50)\r\n[GCC 8.3.0]\r\npython-bits: 64\r\nOS: Linux\r\nOS-release: 4.15.0-88-generic\r\nmachine: x86_64\r\nprocessor: x86_64\r\nbyteorder: little\r\nLC_ALL: None\r\nLANG: C.UTF-8\r\nLOCALE: en_US.UTF-8\r\nlibhdf5: None\r\nlibnetcdf: None\r\n\r\nxarray: 0.15.1\r\npandas: 1.0.3\r\nnumpy: 1.18.2\r\nscipy: None\r\nnetCDF4: None\r\npydap: None\r\nh5netcdf: None\r\nh5py: None\r\nNio: None\r\nzarr: None\r\ncftime: None\r\nnc_time_axis: None\r\nPseudoNetCDF: None\r\nrasterio: None\r\ncfgrib: None\r\niris: None\r\nbottleneck: None\r\ndask: None\r\ndistributed: None\r\nmatplotlib: 3.2.0\r\ncartopy: None\r\nseaborn: None\r\nnumbagg: None\r\nsetuptools: 46.1.3\r\npip: 9.0.1\r\nconda: None\r\npytest: None\r\nIPython: 7.13.0\r\nsphinx: 2.4.3</details>\r\n\n",
  "hints_text": "Xref: [Gitter Chat](https://gitter.im/pydata/xarray?at=5c88ef25d3b35423cbb02afc)\nThis has also implications for the output using `.to_netcdf()`. If we read a netcdf dataset (same structure as above) with `xr.open_dataset` and then do the above `xr.concat` and save the resulting dataset with `.to_netcdf` then the dimensions of the dataset will be reversed in the resulting file.\r\n\r\nNow, as the `xr.concat` operation need to change the length of the dimension ('c', which is not allowed by netCDF library), this is done by creating a new dataset. In this creation process xarray obviously uses the alphanumerically sorted representation of the source dataset dimension's and not the creation order as in the source dataset. \r\n\r\nI did not find any hints in the docs on that topic.  I need to preserve the original dimension ordering as declared in the source dataset. How can I achieve this using xarray?\nYour system might print dataset dimensions like `Frozen(SortedKeysDict({'c': 2, 'b': 3}))`, but the iteration order will always be sorted (including if you write the dataset to disk as netcdf file).\r\n\r\nWhen we drop support for Python 3.5, xarray might switch to dimensions matching order of insertion, since we'll get that for free with Python dictionary. But I still doubt we would make any guarantees about preserving dimension order in xarray operations, just like we don't guarantee variable order as part of xarray's API. It should be deterministic (with fixed versions of xarray and dependencies), but you shouldn't write your code in a way that breaks if changes.\r\n\r\nWhat's your actual use-case here? What are you trying to do that needs preserving of dimension order?\nThanks for looking into this @shoyer.\r\n\r\n> Your system might print dataset dimensions like `Frozen(SortedKeysDict({'c': 2, 'b': 3}))`, but the iteration order will always be sorted (including if you write the dataset to disk as netcdf file).\r\n\r\nThis isn't true for my system. If we consider this example:\r\n\r\n```python\r\ndata = np.zeros((2,3))\r\nds = xr.Dataset({'test': (['c', 'b'],  data)}, \r\n                coords={'c': (['c'], np.arange(data.shape[0])),\r\n                        'b': (['b'], np.arange(data.shape[1])),})\r\nds.to_netcdf('test_dims.nc')\r\nds2 = xr.concat([ds, ds], dim='c')\r\nds2.to_netcdf('test_dims2.nc')\r\n```\r\nDumping the created files gives the following:\r\n\r\n```\r\nnetcdf test_dims {\r\ndimensions:\r\n        c = 2 ;\r\n        b = 3 ;\r\nvariables:\r\n        double test(c, b) ;\r\n                test:_FillValue = NaN ;\r\n        int64 c(c) ;\r\n        int64 b(b) ;\r\ndata:\r\n\r\n test =\r\n  0, 0, 0,\r\n  0, 0, 0 ;\r\n\r\n c = 0, 1 ;\r\n\r\n b = 0, 1, 2 ;\r\n}\r\n```\r\n```\r\nnetcdf test_dims2 {\r\ndimensions:\r\n        b = 3 ;\r\n        c = 4 ;\r\nvariables:\r\n        int64 b(b) ;\r\n        double test(c, b) ;\r\n                test:_FillValue = NaN ;\r\n        int64 c(c) ;\r\ndata:\r\n\r\n b = 0, 1, 2 ;\r\n\r\n test =\r\n  0, 0, 0,\r\n  0, 0, 0,\r\n  0, 0, 0,\r\n  0, 0, 0 ;\r\n\r\n c = 0, 1, 0, 1 ;\r\n}\r\n```\r\nMy use case is, well, I have to use some legacy code.\r\n\r\nConcerning my code, yes I'm trying to write it as robust as possible. Finally I wan't to replace the legacy code with the implementation relying completely on xarray, but that's a long way to go.\r\n\r\n\r\n\nDimensions are written to netCDF files in the order in which they appear on variables in the Dataset:\r\nhttps://github.com/pydata/xarray/blob/f382fd840dafa5fdd95e66a7ddd15a3d498c1bce/xarray/backends/common.py#L325-L329\r\n\r\nIt sounds like your use-case is writing netCDF files to disk with a desired dimension order? We could conceivably add an \"encoding\" option to datasets for specifying dimension order, like how we support controlling unlimited dimensions.\n> Dimensions are written to netCDF files in the order in which they appear on variables in the Dataset:\r\n\r\nI was assuming something along that lines. But in my variable `test` the 'c' dim is first. And it is written correctly, if there are no coordinates in that dataset (test_dim0). If there are coordinates (test_dims2) the dimensions are written in wrong order. So there is something working in one config and not in the other.\r\n\r\nMy use case is, that the dimensions should appear in the same order as in the source files.\n> I was assuming something along that lines. But in my variable `test` the 'c' dim is first. And it is written correctly, if there are no coordinates in that dataset (test_dim0). If there are coordinates (test_dims2) the dimensions are written in wrong order. So there is something working in one config and not in the other.\r\n\r\nThe order of dimensions in the netCDF file matches the order of their appearance on variables in the netCDF files. In your first file, it's `(c, b)` on variable `test`. In the second file, it's `b` on variable `b` and `c` from variable `test`.\r\n\r\n> My use case is, that the dimensions should appear in the same order as in the source files.\r\n\r\nSorry, xarray is not going to satisfy this use. If you want this guarantee in all cases, you should pick a different tool.\n@shoyer I'm sorry if I did not explain well enough and if my intentions were vague. So let me first clarify, I really appreciate all your hard work to make xarray better. I've adapted many of my workflows to use xarray and I'm happy that such a library exist.\r\n\r\nLet's consider just one more example where I hopefully get better to the point of my problems in understanding.\r\n\r\nTwo files are created, same dimensions, same data, but one without coordinates the other with coordinates.\r\n\r\n```python\r\ndata = np.zeros((2,3))\r\nsrc_dim0 = xr.Dataset({'test': (['c', 'b'],  data)})\r\nsrc_dim0.to_netcdf('src_dim0.nc')\r\n\r\nsrc_dim1 = xr.Dataset({'test': (['c', 'b'],  data)}, \r\n                      coords={'c': (['c'], np.arange(data.shape[0])),\r\n                              'b': (['b'], np.arange(data.shape[1])),})\r\nsrc_dim1.to_netcdf('src_dim1.nc')\r\n```\r\nThe dump of both:\r\n```\r\nnetcdf src_dim0 {\r\ndimensions:\r\n\tc = 2 ;\r\n\tb = 3 ;\r\nvariables:\r\n\tdouble test(c, b) ;\r\n\t\ttest:_FillValue = NaN ;\r\ndata:\r\n\r\n test =\r\n  0, 0, 0,\r\n  0, 0, 0 ;\r\n}\r\n\r\nnetcdf src_dim1 {\r\ndimensions:\r\n\tc = 2 ;\r\n\tb = 3 ;\r\nvariables:\r\n\tdouble test(c, b) ;\r\n\t\ttest:_FillValue = NaN ;\r\n\tint64 c(c) ;\r\n\tint64 b(b) ;\r\ndata:\r\n\r\n test =\r\n  0, 0, 0,\r\n  0, 0, 0 ;\r\n\r\n c = 0, 1 ;\r\n\r\n b = 0, 1, 2 ;\r\n}\r\n```\r\n\r\nNow, from the dump, the 'c' dimension is first in both. Lets read those files again and concat them along the `c`-dimension:\r\n\r\n```python\r\ndst_dim0 = xr.open_dataset('src_dim0.nc')\r\ndst_dim0 = xr.concat([dst_dim0, dst_dim0], dim='c')\r\ndst_dim0.to_netcdf('dst_dim0.nc')\r\n\r\ndst_dim1 = xr.open_dataset('src_dim1.nc')\r\ndst_dim1 = xr.concat([dst_dim1, dst_dim1], dim='c')\r\ndst_dim1.to_netcdf('dst_dim1.nc')\r\n```\r\n\r\nNow, and this is what confuses me, the file without coordinates has 'c' dimension first and the file with coordinates has 'b' dimension first.:\r\n```\r\nnetcdf dst_dim0 {\r\ndimensions:\r\n\tc = 4 ;\r\n\tb = 3 ;\r\nvariables:\r\n\tdouble test(c, b) ;\r\n\t\ttest:_FillValue = NaN ;\r\ndata:\r\n\r\n test =\r\n  0, 0, 0,\r\n  0, 0, 0,\r\n  0, 0, 0,\r\n  0, 0, 0 ;\r\n}\r\n\r\nnetcdf dst_dim1 {\r\ndimensions:\r\n\tb = 3 ;\r\n\tc = 4 ;\r\nvariables:\r\n\tint64 b(b) ;\r\n\tdouble test(c, b) ;\r\n\t\ttest:_FillValue = NaN ;\r\n\tint64 c(c) ;\r\ndata:\r\n\r\n b = 0, 1, 2 ;\r\n\r\n test =\r\n  0, 0, 0,\r\n  0, 0, 0,\r\n  0, 0, 0,\r\n  0, 0, 0 ;\r\n\r\n c = 0, 1, 0, 1 ;\r\n}\r\n```\r\n\r\nI really like to understand why there is this difference. Thanks for your patience!\nThis is due to the internal implementation of `xarray.concat`, which sometimes reorders variables. I doubt the reordering was intentional. It's probably just a side effect of how `concat` takes multiple passes over different types of variables to figure out how to combine them.\r\n\r\nYou are welcome to take a look at improving this, though I doubt this would be particularly easy to fix. Certainly the code in `concat` could use some clean-up, and if we can preserve the order of variables on outputs that would be an improvement in usability. But it's still not something I would consider a \"bug\" *per se*.\n@shoyer Yes, that was what I was assuming. But was a bit confused too, as the concat docs say, that dimension order is not affected. But maybe I get this wrong and the order of dimensions is not affected only for DataArrays.\r\n\r\nIIUC xarray creates a new dataset during concat, because the dimensions cannot be expanded (due to netCDF4 limitations). So I would need to look at that specific part, where this creation process takes place. \r\n\r\nI would also not speak of \"bug\" here, but if such reordering happens only in certain conditions users (I mean at least me) can get confused.\r\n\r\nI'll try to find out under what conditions this happens and try to come up with some workaround. Will also try ti find my way through the concat-mechanism. Again, I really appreciate your help in this issue. \r\nI can rename the issue to a somewhat better name, do you have a suggestion? **Ambiguous dimension reorder in Dataset concat** maybe?\r\n\r\n\nSorry, fat fingers...\n@shoyer I'm working on a notebook with all testing inside. Just found that if I have 3 dimensions ('c', 'd', 'b') the ordering is preserved in ~any case~ (~with and~ without coords) for concat along any dimension. Will link the notebook next day.\r\n\r\nUpdate: Need to be more thorough...with coordinates it reorders also with 3 dims.\nJust as note for me, to not have to reiterate:\r\n\r\n- It seems, that variables are handled in creation order. Means that `concat ` reads them, handles them (even if the variable remains unchanged) and writes them to the new dataset in that order.\r\n- This does not happen for coordinate for some reason. There only the changed dimension is handled and written after the variables. The unaffected coordinates are written at the beginning before the variables.\r\n\r\nExample (dst concat over 'x'):\r\nThe ordering of the src_dim1 is because the dimensions in the variables/coordinates are x,y,z in that order. The ordering of the dst_dim1 is because the dimensions in the variables/coordinates are z, y, x.\r\n```\r\nnetcdf src_dim1 {\r\ndimensions:\r\n\tx = 2 ;\r\n\ty = 3 ;\r\n\tz = 4 ;\r\nvariables:\r\n\tdouble test2(x, y) ;\r\n\t\ttest2:_FillValue = NaN ;\r\n\tdouble test3(x, z) ;\r\n\t\ttest3:_FillValue = NaN ;\r\n\tdouble test1(y, z) ;\r\n\t\ttest1:_FillValue = NaN ;\r\n\tint64 z(z) ;\r\n\tint64 y(y) ;\r\n\tint64 x(x) ;\r\n```\r\n```\r\nnetcdf dst_dim1 {\r\ndimensions:\r\n\tz = 4 ;\r\n\ty = 3 ;\r\n\tx = 4 ;\r\nvariables:\r\n\tint64 z(z) ;\r\n\tint64 y(y) ;\r\n\tdouble test2(x, y) ;\r\n\t\ttest2:_FillValue = NaN ;\r\n\tdouble test3(x, z) ;\r\n\t\ttest3:_FillValue = NaN ;\r\n\tdouble test1(x, y, z) ;\r\n\t\ttest1:_FillValue = NaN ;\r\n\tint64 x(x) ;\r\n```\r\n\r\nIt seems, that the two coordinates (z and y) are written first, then the variables, and then the changed coordinate. Now trying to find, where this happens. If the two coordinates would be written in the same way as the variables (and after them), then the ordering would be x,y,z as in the source. \r\n\r\n\n@shoyer I think I found the relevant lines of code in `combine.py`. It might be possible to preserve the (*correct*) order of dimensions at least with regard to their occurrence in variables (and not in coordinates). But that would mean to treat variables and coordinates consecutively in some way..\r\n\r\nIn the docs there is a Warning: \r\n*We are changing the behavior of iterating over a Dataset the next major release of xarray, to only include data variables instead of both data variables and coordinates. In the meantime, prefer iterating over ds.data_vars or ds.coords.* [below here](http://xarray.pydata.org/en/stable/data-structures.html#dataset-contents).\r\n\r\nDoes that mean that this also affects internal machinery (like in concat)? If so, could you point me to some code where this is taken care of or give some explanation or links where this is discussed?\r\n\r\nUpdate: I' working with latest 0.12.0 release.\r\n\nThat warning should be removed — we already finished that deprecation cycle!\nsee https://github.com/pydata/xarray/pull/2818 for removing that warning\n@shoyer Attached the description of the issue source and kind of workaround.\r\n\r\nDuring `concat` a `result_vars = OrderedDict()` is created.\r\nAfter that it is iterated over the first dataset `datasets[0].variables.items()` and those variables which are not affected by the `concat` are added to the `result_vars` :\r\nhttps://github.com/pydata/xarray/blob/a5ca64ac5988f0c9c9c6b741a5de16e81b90cad5/xarray/core/combine.py#L244-L246\r\n\r\nAfter several checks the affected variables are treated and added to `result_vars`:\r\nhttps://github.com/pydata/xarray/blob/a5ca64ac5988f0c9c9c6b741a5de16e81b90cad5/xarray/core/combine.py#L301-L306\r\n\r\nThe comment indicates what you already mentioned, that the reorder might be unintentional. But due to the handling in two separate iterations over `datasets[0].variables`, the source variable order is not preserved (and with that in some cases the order of the dimensions).\r\n\r\nThis can be worked around by changing the second iteration to:\r\n```python\r\n# re-initialize result_vars to write in correct order\r\nresult_vars = OrderedDict()\r\n\r\n# stack up each variable to fill-out the dataset (in order)\r\nfor k in datasets[0].variables:\r\n    if k in concat_over:\r\n        vars = ensure_common_dims([ds.variables[k] for ds in datasets])\r\n        combined = concat_vars(vars, dim, positions)\r\n        insert_result_variable(k, combined)\r\n    else:\r\n        insert_result_variable(k, datasets[0].variables[k])  \r\n```\r\nWith this workaround applied, the `concat` works as expected and the variable/coordinate order (and with that the dimension order) is preserved. I'm thinking about a better solution but wanted to get some feedback from you first, if I#m on the right track. Thanks!\nAfter checking a bit more in older issues, this seems related: https://github.com/pydata/xarray/pull/1049, ping @fmaussion.\r\n\r\nAnd also @shoyer's [comment](https://github.com/pydata/xarray/pull/1049/files#r83541671) suggest that those two iterations/loops I mentioned above need to be addressed correctly.\r\n\r\n\ndon't use the `Coordinates` section to check the order. `Dataset` objects may have multiple data variables (each with a possibly different order of dimensions) so for displaying it needs to define some kind of order.\r\n\r\nWhat you want to compare is the order of dimensions referenced by a variable:\r\n```\r\n<xarray.Dataset>\r\nDimensions:  (time: 1, x: 10, y: 10)\r\nCoordinates:\r\n  * time     (time) int64 0\r\n  * y        (y) int64 0 1 2 3 4 5 6 7 8 9\r\n  * x        (x) int64 0 1 2 3 4 5 6 7 8 9\r\nData variables:\r\n    data     (time, y, x) bool False False False False ... False False False\r\n             ^^^^^^^^^^^^\r\n```\r\nand you will notice that the order does not change.\r\n\r\nTo make this less confusing, maybe we should always sort the coordinates when displaying them? I'm guessing that right now they are displayed in the order they were added to the coordinates.\nThis rings a bell! It has be discussed in https://github.com/pydata/xarray/issues/2811. I've done extensive checks back then, but didn't come up with an PR.\r\n\r\nMy workaround or solution is outlined [in this comment](https://github.com/pydata/xarray/issues/2811#issuecomment-473810333). Code might have been changed!\n@keewis yes you are right, but still a consistent ordering would be less confusing, including maybe also the Dimensions field.\r\nNow Dimensions shows first x and then y, even though the data itself has y,x ordering.",
  "created_at": "2020-09-14T07:13:33Z",
  "version": "0.12",
  "FAIL_TO_PASS": "[\"xarray/tests/test_concat.py::test_concat_preserve_coordinate_order\"]",
  "PASS_TO_PASS": "[\"xarray/tests/test_concat.py::test_concat_compat\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_simple[dim1-different]\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_simple[dim1-minimal]\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_simple[dim2-different]\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_simple[dim2-minimal]\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_merge_variables_present_in_some_datasets\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_2\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_coords_kwarg[dim1-different]\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_coords_kwarg[dim1-minimal]\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_coords_kwarg[dim1-all]\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_coords_kwarg[dim2-different]\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_coords_kwarg[dim2-minimal]\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_coords_kwarg[dim2-all]\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_dim_precedence\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_data_vars\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_coords\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_constant_index\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_size0\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_autoalign\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_errors\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_join_kwarg\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_combine_attrs_kwarg\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_promote_shape\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_do_not_promote\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_dim_is_variable\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_multiindex\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_fill_value[fill_value0]\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_fill_value[2]\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_fill_value[2.0]\", \"xarray/tests/test_concat.py::TestConcatDataset::test_concat_fill_value[fill_value3]\", \"xarray/tests/test_concat.py::TestConcatDataArray::test_concat\", \"xarray/tests/test_concat.py::TestConcatDataArray::test_concat_encoding\", \"xarray/tests/test_concat.py::TestConcatDataArray::test_concat_lazy\", \"xarray/tests/test_concat.py::TestConcatDataArray::test_concat_fill_value[fill_value0]\", \"xarray/tests/test_concat.py::TestConcatDataArray::test_concat_fill_value[2]\", \"xarray/tests/test_concat.py::TestConcatDataArray::test_concat_fill_value[2.0]\", \"xarray/tests/test_concat.py::TestConcatDataArray::test_concat_join_kwarg\", \"xarray/tests/test_concat.py::TestConcatDataArray::test_concat_combine_attrs_kwarg\", \"xarray/tests/test_concat.py::test_concat_attrs_first_variable[attr20-attr10]\", \"xarray/tests/test_concat.py::test_concat_attrs_first_variable[attr20-attr11]\", \"xarray/tests/test_concat.py::test_concat_attrs_first_variable[attr20-attr12]\", \"xarray/tests/test_concat.py::test_concat_attrs_first_variable[attr21-attr10]\", \"xarray/tests/test_concat.py::test_concat_attrs_first_variable[attr21-attr11]\", \"xarray/tests/test_concat.py::test_concat_attrs_first_variable[attr21-attr12]\", \"xarray/tests/test_concat.py::test_concat_merge_single_non_dim_coord\"]",
  "environment_setup_commit": "1c198a191127c601d091213c4b3292a8bb3054e1",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.878563",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}