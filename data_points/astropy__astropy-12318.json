{
  "repo": "astropy/astropy",
  "instance_id": "astropy__astropy-12318",
  "base_commit": "43ce7895bb5b61d4fab2f9cc7d07016cf105f18e",
  "patch": "diff --git a/astropy/modeling/physical_models.py b/astropy/modeling/physical_models.py\n--- a/astropy/modeling/physical_models.py\n+++ b/astropy/modeling/physical_models.py\n@@ -27,7 +27,12 @@ class BlackBody(Fittable1DModel):\n         Blackbody temperature.\n \n     scale : float or `~astropy.units.Quantity` ['dimensionless']\n-        Scale factor\n+        Scale factor.  If dimensionless, input units will assumed\n+        to be in Hz and output units in (erg / (cm ** 2 * s * Hz * sr).\n+        If not dimensionless, must be equivalent to either\n+        (erg / (cm ** 2 * s * Hz * sr) or erg / (cm ** 2 * s * AA * sr),\n+        in which case the result will be returned in the requested units and\n+        the scale will be stripped of units (with the float value applied).\n \n     Notes\n     -----\n@@ -70,12 +75,40 @@ class BlackBody(Fittable1DModel):\n     scale = Parameter(default=1.0, min=0, description=\"Scale factor\")\n \n     # We allow values without units to be passed when evaluating the model, and\n-    # in this case the input x values are assumed to be frequencies in Hz.\n+    # in this case the input x values are assumed to be frequencies in Hz or wavelengths\n+    # in AA (depending on the choice of output units controlled by units on scale\n+    # and stored in self._output_units during init).\n     _input_units_allow_dimensionless = True\n \n     # We enable the spectral equivalency by default for the spectral axis\n     input_units_equivalencies = {'x': u.spectral()}\n \n+    # Store the native units returned by B_nu equation\n+    _native_units = u.erg / (u.cm ** 2 * u.s * u.Hz * u.sr)\n+\n+    # Store the base native output units.  If scale is not dimensionless, it\n+    # must be equivalent to one of these.  If equivalent to SLAM, then\n+    # input_units will expect AA for 'x', otherwise Hz.\n+    _native_output_units = {'SNU': u.erg / (u.cm ** 2 * u.s * u.Hz * u.sr),\n+                            'SLAM': u.erg / (u.cm ** 2 * u.s * u.AA * u.sr)}\n+\n+    def __init__(self, *args, **kwargs):\n+        scale = kwargs.get('scale', None)\n+\n+        # Support scale with non-dimensionless unit by stripping the unit and\n+        # storing as self._output_units.\n+        if hasattr(scale, 'unit') and not scale.unit.is_equivalent(u.dimensionless_unscaled):\n+            output_units = scale.unit\n+            if not output_units.is_equivalent(self._native_units, u.spectral_density(1*u.AA)):\n+                raise ValueError(f\"scale units not dimensionless or in surface brightness: {output_units}\")\n+\n+            kwargs['scale'] = scale.value\n+            self._output_units = output_units\n+        else:\n+            self._output_units = self._native_units\n+\n+        return super().__init__(*args, **kwargs)\n+\n     def evaluate(self, x, temperature, scale):\n         \"\"\"Evaluate the model.\n \n@@ -83,7 +116,8 @@ def evaluate(self, x, temperature, scale):\n         ----------\n         x : float, `~numpy.ndarray`, or `~astropy.units.Quantity` ['frequency']\n             Frequency at which to compute the blackbody. If no units are given,\n-            this defaults to Hz.\n+            this defaults to Hz (or AA if `scale` was initialized with units\n+            equivalent to erg / (cm ** 2 * s * AA * sr)).\n \n         temperature : float, `~numpy.ndarray`, or `~astropy.units.Quantity`\n             Temperature of the blackbody. If no units are given, this defaults\n@@ -119,30 +153,18 @@ def evaluate(self, x, temperature, scale):\n         else:\n             in_temp = temperature\n \n+        if not isinstance(x, u.Quantity):\n+            # then we assume it has input_units which depends on the\n+            # requested output units (either Hz or AA)\n+            in_x = u.Quantity(x, self.input_units['x'])\n+        else:\n+            in_x = x\n+\n         # Convert to units for calculations, also force double precision\n         with u.add_enabled_equivalencies(u.spectral() + u.temperature()):\n-            freq = u.Quantity(x, u.Hz, dtype=np.float64)\n+            freq = u.Quantity(in_x, u.Hz, dtype=np.float64)\n             temp = u.Quantity(in_temp, u.K)\n \n-        # check the units of scale and setup the output units\n-        bb_unit = u.erg / (u.cm ** 2 * u.s * u.Hz * u.sr)  # default unit\n-        # use the scale that was used at initialization for determining the units to return\n-        # to support returning the right units when fitting where units are stripped\n-        if hasattr(self.scale, \"unit\") and self.scale.unit is not None:\n-            # check that the units on scale are covertable to surface brightness units\n-            if not self.scale.unit.is_equivalent(bb_unit, u.spectral_density(x)):\n-                raise ValueError(\n-                    f\"scale units not surface brightness: {self.scale.unit}\"\n-                )\n-            # use the scale passed to get the value for scaling\n-            if hasattr(scale, \"unit\"):\n-                mult_scale = scale.value\n-            else:\n-                mult_scale = scale\n-            bb_unit = self.scale.unit\n-        else:\n-            mult_scale = scale\n-\n         # Check if input values are physically possible\n         if np.any(temp < 0):\n             raise ValueError(f\"Temperature should be positive: {temp}\")\n@@ -158,7 +180,17 @@ def evaluate(self, x, temperature, scale):\n         # Calculate blackbody flux\n         bb_nu = 2.0 * const.h * freq ** 3 / (const.c ** 2 * boltzm1) / u.sr\n \n-        y = mult_scale * bb_nu.to(bb_unit, u.spectral_density(freq))\n+        if self.scale.unit is not None:\n+            # Will be dimensionless at this point, but may not be dimensionless_unscaled\n+            if not hasattr(scale, 'unit'):\n+                # during fitting, scale will be passed without units\n+                # but we still need to convert from the input dimensionless\n+                # to dimensionless unscaled\n+                scale = scale * self.scale.unit\n+            scale = scale.to(u.dimensionless_unscaled).value\n+\n+        # NOTE: scale is already stripped of any input units\n+        y = scale * bb_nu.to(self._output_units, u.spectral_density(freq))\n \n         # If the temperature parameter has no unit, we should return a unitless\n         # value. This occurs for instance during fitting, since we drop the\n@@ -169,10 +201,13 @@ def evaluate(self, x, temperature, scale):\n \n     @property\n     def input_units(self):\n-        # The input units are those of the 'x' value, which should always be\n-        # Hz. Because we do this, and because input_units_allow_dimensionless\n-        # is set to True, dimensionless values are assumed to be in Hz.\n-        return {self.inputs[0]: u.Hz}\n+        # The input units are those of the 'x' value, which will depend on the\n+        # units compatible with the expected output units.\n+        if self._output_units.is_equivalent(self._native_output_units['SNU']):\n+            return {self.inputs[0]: u.Hz}\n+        else:\n+            # only other option is equivalent with SLAM\n+            return {self.inputs[0]: u.AA}\n \n     def _parameter_units_for_data_units(self, inputs_unit, outputs_unit):\n         return {\"temperature\": u.K}\n@@ -180,9 +215,15 @@ def _parameter_units_for_data_units(self, inputs_unit, outputs_unit):\n     @property\n     def bolometric_flux(self):\n         \"\"\"Bolometric flux.\"\"\"\n+        if self.scale.unit is not None:\n+            # Will be dimensionless at this point, but may not be dimensionless_unscaled\n+            scale = self.scale.quantity.to(u.dimensionless_unscaled)\n+        else:\n+            scale = self.scale.value\n+\n         # bolometric flux in the native units of the planck function\n         native_bolflux = (\n-            self.scale.value * const.sigma_sb * self.temperature ** 4 / np.pi\n+            scale * const.sigma_sb * self.temperature ** 4 / np.pi\n         )\n         # return in more \"astro\" units\n         return native_bolflux.to(u.erg / (u.cm ** 2 * u.s))\n",
  "test_patch": "diff --git a/astropy/modeling/tests/test_physical_models.py b/astropy/modeling/tests/test_physical_models.py\n--- a/astropy/modeling/tests/test_physical_models.py\n+++ b/astropy/modeling/tests/test_physical_models.py\n@@ -40,6 +40,17 @@ def test_blackbody_sefanboltzman_law():\n     assert_quantity_allclose(b.bolometric_flux, 133.02471751812573 * u.W / (u.m * u.m))\n \n \n+def test_blackbody_input_units():\n+    SLAM = u.erg / (u.cm ** 2 * u.s * u.AA * u.sr)\n+    SNU = u.erg / (u.cm ** 2 * u.s * u.Hz * u.sr)\n+\n+    b_lam = BlackBody(3000*u.K, scale=1*SLAM)\n+    assert(b_lam.input_units['x'] == u.AA)\n+\n+    b_nu = BlackBody(3000*u.K, scale=1*SNU)\n+    assert(b_nu.input_units['x'] == u.Hz)\n+\n+\n def test_blackbody_return_units():\n     # return of evaluate has no units when temperature has no units\n     b = BlackBody(1000.0 * u.K, scale=1.0)\n@@ -72,7 +83,7 @@ def test_blackbody_fit():\n     b_fit = fitter(b, wav, fnu, maxiter=1000)\n \n     assert_quantity_allclose(b_fit.temperature, 2840.7438355865065 * u.K)\n-    assert_quantity_allclose(b_fit.scale, 5.803783292762381e-17 * u.Jy / u.sr)\n+    assert_quantity_allclose(b_fit.scale, 5.803783292762381e-17)\n \n \n def test_blackbody_overflow():\n@@ -104,10 +115,11 @@ def test_blackbody_exceptions_and_warnings():\n     \"\"\"Test exceptions.\"\"\"\n \n     # Negative temperature\n-    with pytest.raises(ValueError) as exc:\n+    with pytest.raises(\n+            ValueError,\n+            match=\"Temperature should be positive: \\\\[-100.\\\\] K\"):\n         bb = BlackBody(-100 * u.K)\n         bb(1.0 * u.micron)\n-    assert exc.value.args[0] == \"Temperature should be positive: [-100.] K\"\n \n     bb = BlackBody(5000 * u.K)\n \n@@ -121,11 +133,11 @@ def test_blackbody_exceptions_and_warnings():\n         bb(-1.0 * u.AA)\n     assert len(w) == 1\n \n-    # Test that a non surface brightness converatable scale unit\n-    with pytest.raises(ValueError) as exc:\n+    # Test that a non surface brightness convertible scale unit raises an error\n+    with pytest.raises(\n+            ValueError,\n+            match=\"scale units not dimensionless or in surface brightness: Jy\"):\n         bb = BlackBody(5000 * u.K, scale=1.0 * u.Jy)\n-        bb(1.0 * u.micron)\n-    assert exc.value.args[0] == \"scale units not surface brightness: Jy\"\n \n \n def test_blackbody_array_temperature():\n@@ -146,6 +158,45 @@ def test_blackbody_array_temperature():\n     assert flux.shape == (3, 4)\n \n \n+def test_blackbody_dimensionless():\n+    \"\"\"Test support for dimensionless (but not unscaled) units for scale\"\"\"\n+    T = 3000 * u.K\n+    r = 1e14 * u.cm\n+    DL = 100 * u.Mpc\n+    scale = np.pi * (r / DL)**2\n+\n+    bb1 = BlackBody(temperature=T, scale=scale)\n+    # even though we passed scale with units, we should be able to evaluate with unitless\n+    bb1.evaluate(0.5, T.value, scale.to_value(u.dimensionless_unscaled))\n+\n+    bb2 = BlackBody(temperature=T, scale=scale.to_value(u.dimensionless_unscaled))\n+    bb2.evaluate(0.5, T.value, scale.to_value(u.dimensionless_unscaled))\n+\n+    # bolometric flux for both cases should be equivalent\n+    assert(bb1.bolometric_flux == bb2.bolometric_flux)\n+\n+\n+@pytest.mark.skipif(\"not HAS_SCIPY\")\n+def test_blackbody_dimensionless_fit():\n+    T = 3000 * u.K\n+    r = 1e14 * u.cm\n+    DL = 100 * u.Mpc\n+    scale = np.pi * (r / DL)**2\n+\n+    bb1 = BlackBody(temperature=T, scale=scale)\n+    bb2 = BlackBody(temperature=T, scale=scale.to_value(u.dimensionless_unscaled))\n+\n+    fitter = LevMarLSQFitter()\n+\n+    wav = np.array([0.5, 5, 10]) * u.micron\n+    fnu = np.array([1, 10, 5]) * u.Jy / u.sr\n+\n+    bb1_fit = fitter(bb1, wav, fnu, maxiter=1000)\n+    bb2_fit = fitter(bb2, wav, fnu, maxiter=1000)\n+\n+    assert(bb1_fit.temperature == bb2_fit.temperature)\n+\n+\n @pytest.mark.parametrize(\"mass\", (2.0000000000000E15 * u.M_sun, 3.976819741e+45 * u.kg))\n def test_NFW_evaluate(mass):\n     \"\"\"Evaluation, density, and radii validation of NFW model.\"\"\"\n",
  "problem_statement": "BlackBody bolometric flux is wrong if scale has units of dimensionless_unscaled\nThe `astropy.modeling.models.BlackBody` class has the wrong bolometric flux if `scale` argument is passed as a Quantity with `dimensionless_unscaled` units, but the correct bolometric flux if `scale` is simply a float.\r\n\r\n### Description\r\n<!-- Provide a general description of the bug. -->\r\n\r\n### Expected behavior\r\nExpected output from sample code:\r\n\r\n```\r\n4.823870774433646e-16 erg / (cm2 s)\r\n4.823870774433646e-16 erg / (cm2 s)\r\n```\r\n\r\n### Actual behavior\r\nActual output from sample code:\r\n\r\n```\r\n4.5930032795393893e+33 erg / (cm2 s)\r\n4.823870774433646e-16 erg / (cm2 s)\r\n```\r\n\r\n### Steps to Reproduce\r\nSample code:\r\n\r\n```python\r\nfrom astropy.modeling.models import BlackBody\r\nfrom astropy import units as u\r\nimport numpy as np\r\n\r\nT = 3000 * u.K\r\nr = 1e14 * u.cm\r\nDL = 100 * u.Mpc\r\nscale = np.pi * (r / DL)**2\r\n\r\nprint(BlackBody(temperature=T, scale=scale).bolometric_flux)\r\nprint(BlackBody(temperature=T, scale=scale.to_value(u.dimensionless_unscaled)).bolometric_flux)\r\n```\r\n\r\n### System Details\r\n```pycon\r\n>>> import numpy; print(\"Numpy\", numpy.__version__)\r\nNumpy 1.20.2\r\n>>> import astropy; print(\"astropy\", astropy.__version__)\r\nastropy 4.3.dev758+g1ed1d945a\r\n>>> import scipy; print(\"Scipy\", scipy.__version__)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nModuleNotFoundError: No module named 'scipy'\r\n>>> import matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nModuleNotFoundError: No module named 'matplotlib'\r\n```\n",
  "hints_text": "I forgot who added that part of `BlackBody`. It was either @karllark or @astrofrog .\nThere are several problems here:\r\n\r\n1. In `BlackBody.evaluate()`, there is an `if` statement that handles two special cases: either scale is dimensionless, and multiplies the original blackbody surface brightness, or `scale` has units that are compatible with surface brightness, and replaces the original surface brightness. This check is broken, because it does not correctly handle the case that `scale` has a unit, but that unit is compatible with `dimensionless_unscaled`. This is easy to fix.\r\n2. The `BlackBody.bolometric_flux` method does not handle this special case. Again, this is easy to fix.\r\n3. In the case that  `scale` has units that are compatible with surface brightness, it is impossible to unambiguously determine the correct multiplier in `BlackBody.bolometric_flux`, because the conversion may depend on the frequency or wavelength at which the scale was given. This might be a design flaw.\r\n\r\nUnless I'm missing something, there is no way for this class to give an unambiguous and correct value of the bolometric flux, unless `scale` is dimensionless. Is that correct?\nHere's another weird output from BlackBody. I _think_ it's a manifestation of the same bug, or at least it's related. I create three black bodies:\r\n\r\n* `bb1` with a scale=1 erg / (cm2 Hz s sr)\r\n* `bb2` with a scale=1 J / (cm2 Hz s sr)\r\n* `bb3` with a scale=1e7 erg / (cm2 Hz s sr)\r\n\r\nThe spectra from `bb1` and `bb2` look the same, even though `bb2` should be (1 J / 1 erg) = 1e7 times as bright! And the spectrum from `bb3` looks different from `bb2`, even though 1e7 erg = 1 J.\r\n\r\n```python\r\nfrom astropy.modeling.models import BlackBody\r\nfrom astropy import units as u\r\nfrom matplotlib import pyplot as plt\r\nimport numpy as np\r\n\r\nnu = np.geomspace(0.1, 10) * u.micron\r\nbb1 = BlackBody(temperature=3000*u.K, scale=1*u.erg/(u.cm ** 2 * u.s * u.Hz * u.sr))\r\nbb2 = BlackBody(temperature=3000*u.K, scale=1*u.J/(u.cm ** 2 * u.s * u.Hz * u.sr))\r\nbb3 = BlackBody(temperature=3000*u.K, scale=1e7*u.erg/(u.cm ** 2 * u.s * u.Hz * u.sr))\r\n\r\nfig, ax = plt.subplots()\r\nax.set_xscale('log')\r\nax.set_yscale('log')\r\nax.plot(nu.value, bb1(nu).to_value(u.erg/(u.cm ** 2 * u.s * u.Hz * u.sr)), lw=4, label='bb1')\r\nax.plot(nu.value, bb2(nu).to_value(u.erg/(u.cm ** 2 * u.s * u.Hz * u.sr)), label='bb2')\r\nax.plot(nu.value, bb3(nu).to_value(u.erg/(u.cm ** 2 * u.s * u.Hz * u.sr)), label='bb3')\r\nax.legend()\r\nfig.savefig('test.png')\r\n```\r\n\r\n![test](https://user-images.githubusercontent.com/728407/115497738-3e2ef600-a23a-11eb-93b0-c9e358afd986.png)\r\n\nThis is great testing of the code.  Thanks!\r\n\r\nI think I was the one that added this capability.  I don't have time at this point to investigate this issue in detail.  I can look at in the near(ish) future.  If someone else is motivated and has time to investigate and solve, I'm happy to cheer from the sidelines.\nIn pseudocode, here's what the code does with `scale`:\r\n\r\n* If `scale` has no units, it simply multiplies a standard blackbody.\r\n* If `scale` has units that are compatible with flux density, it splits off the value and unit. The value multiplies the standard blackbody, and the output is converted to the given unit.\r\n\r\nSo in both cases, the actual _units_ of the `scale` parameter are ignored. Only the _value_ of the `scale` parameter matters.\r\n\r\nAs nice as the spectral equivalencies are, I think it was a mistake to support a dimensionful `scale` parameter. Clearly that case is completely broken. Can we simply remove that functionality?\nBeginning to think that the scale keyword should go away (in time, deprecated first of course) and docs updated to clearly show how to convert between units (flam to fnu for example) and remove sterradians.  Astropy does have great units support and the scale functionality can all be accomplished with such.  Not 100% sure yet, looking forward to seeing what others think.\r\n\r\nThe blackbody function would return in default units and scale (fnu seems like the best choice, but kinda arbitrary in the end).\r\n\r\nIf my memory is correct, the scale keyword was partially introduced to be able to reproduce the previous behavior of two backbody functions that were deprecated and have now been removed from astropy.\nNo, I think @astrofrog introduced scale for fitting. The functional, uh, functions that we have removed did not have scaling.\nFWIW, I still have the old stuff over at https://github.com/spacetelescope/synphot_refactor/blob/master/synphot/blackbody.py . I never got around to using the new models over there. 😬 \nIn trying to handle support for flux units outside of the `BlackBody` model, I ran into a few issues that I'll try to summarize with an example below.\r\n\r\n```\r\nfrom astropy.modeling import models\r\nimport astropy.units as u\r\n\r\nimport numpy as np\r\n\r\nFLAM = u.erg / (u.cm ** 2 * u.s * u.AA)\r\nSLAM = u.erg / (u.cm ** 2 * u.s * u.AA * u.sr)\r\n\r\nwavelengths = np.linspace(2000, 50000, 10001)*u.AA\r\n```\r\n\r\nUsing `Scale` to handle the unit conversion fails in the forward model because the `Scale` model will not accept wavelength units as input (it seems `factor` **must** be provided in the same units as the input x-array, but we need output of `sr` for the units to cooperate).\r\n\r\n```\r\nm = models.BlackBody(temperature=5678*u.K, scale=1.0*SLAM) * models.Scale(factor=1.0*u.sr)\r\n    \r\nfluxes = m(wavelengths)\r\n```\r\n\r\nwhich gives the error: `Scale: Units of input 'x', Angstrom (length), could not be converted to required input units of sr (solid angle)`.\r\n\r\nUsing `Linear1D` with a slope of 0 and an intercept as the scaling factor (with appropriate units to convert from wavelength to `sr`) does work for the forward model, and yields correct units from the `Compound` model, but fails within fitting when calling `without_units_for_data`:\r\n\r\n```\r\nm = models.BlackBody(temperature=5678*u.K, scale=1.0*SLAM) * models.Linear1D(slope=0.0*u.sr/u.AA, intercept=1.0*u.sr)\r\n\r\nfluxes = m(wavelengths)\r\nm.without_units_for_data(x=wavelengths, y=fluxes)\r\n```\r\n\r\nwith the error: `'sr' (solid angle) and 'erg / (Angstrom cm2 s)' (power density/spectral flux density wav) are not convertible`.  It seems to me that this error _might_ be a bug (?), and if it could be fixed, then this approach would technically work for handling the scale and unit conversions externally, but its not exactly obvious or clean from the user-perspective.\r\n\r\nIs there another approach for handling the conversion externally to the model that works with fitting and `Compound` models?  If not, then either the `without_units_for_data` needs to work for a case like this, or I think `scale` in `BlackBody` might need to be kept and extended to support `FLAM` and `FNU` units as input to allow fluxes as output.\nWhile I broadly like the cleanness of @karllark's approach of just saying \"rescale to your hearts desire\", I'm concerned that the ship has essentially sailed.  In particular, I think the following are true:\r\n1. Plenty of other models have scale parameters, so users probably took that up conceptually already\r\n2. In situations like `specutils` where the blackbody model is used as a tool on already-existing data, it's often useful to carry around the model *with its units*.\r\n\r\nSo to me that argues pretty clearly for \"allow `scale` to have whatever units the user wants. But I see a way to \"have our cake and eat it too\":\r\n\r\n1. Take the existing blackbody model, remove the `scale`, and call it `UnscaledBlackbodyModel` or something\r\n2. Make a new `BlackbodyModel` which is a compound model using `Scale` (with `scale` as the keyword), assuming @kecnry's report that it failed can be fixed (since it sure seems like as a bug).\r\n\r\nThat way we can let people move in the direction @karllark suggested if it seems like people actually like it by telling them to use `UnscaledBlackbodyModel`, but fixing the problem with `Scale` at the same time.  \r\n\r\n(Plan B, at least if we want something fixed for Astropy 5.0, is to just fix `scale` and have the above be a longer-term plan for maybe 5.1)\nIf someone else wants to do Plan B for ver5.0 as described by @eteq, that's fine with me.  I won't have time before Friday to do such.\nI think that all of these proposed solutions fail to address the problem that scale units of FLAM or FNU cannot be handled unambiguously, because the reference frequency or wavelength is unspecified.\nI feel the way forward on this topic is to generate a list of use cases for the use of the scale keyword and then we can figure out how to modify the current code.  These use cases can be coded up into tests.  I have to admit I'm getting a little lost in knowing what all the uses of scale.\nAnd if all the use cases are compatible with each other.\n@lpsinger - agreed.  The `bolometric_flux` method and adding support for flux units to `evaluate` are definitely related, but have slightly different considerations that make this quite difficult.  Sorry if the latter goal somewhat hijacked this issue - but I do think the solution needs to account for both (as well as the unitless \"bug\" in your original post).\r\n\r\n@karllark - also agreed.  After looking into this in more detail, I think `scale` really has 2 (and perhaps eventually 3) different purposes: a _unitless_ scale to the blackbody equation, determining the output units of `evaluate` and whether it should be wrt wavelength or frequency, and possibly would also be responsible for providing `sterradians` to convert to flux units.  Separating this functionality into three separate arguments might be the simplest to implement and perhaps the clearest and might resolve the `bolometric_flux` concern, but also is clunky for the user and might be a little difficult for backwards compatibility.  Keeping it as one argument is definitely convenient, but confusing and raises issues with ambiguity in `bolometric_flux` mentioned above.\n@kecnry, I'm concerned that overloading the scale to handle either a unitless value or a value with units of steradians is a footgun, because depending on the units you pass, it may or may not add a factor of pi. This is a footgun because people often think of steradians as being dimensionless.\n@lpsinger (and others) - how would you feel about splitting the parameters then?  \r\n* `scale`: **must** be unitless (or convertible to true unitless), perhaps with backwards compatibility support for SLAM and SNU units that get stripped and interpreted as `output_units`.  I think this can then be used in both `evaluate` and `bolometric_flux`.\r\n* `solid_angle` (or similar name): which is only required when wanting the `evaluate` method to output in flux units.  If provided, you must also set a compatible unit for `output_units`.\r\n* `output_units` (or similar name): choose whether `evaluate` will output SNU (default as it is now), SLAM, FNU, or FLAM units (with compatibility checks for the other arguments: you can't set this to SLAM or SNU and pass `solid_angle`, for example).\r\n\r\nThe downside here is that in the flux case, fitting both `scale` and `solid_angle` will be entirely degenerate, so one of the two will likely need to be held fixed.  In some use-cases where you don't care about how much of the scale belongs to which units, it might be convenient to just leave one fixed at unity and let the other absorb the full scale factor.  But the upside is that I _think_ this approach might get around the ambiguity cases you brought up?\nA delta on @kecnry's suggestion to make it a bit less confusing to the user (maybe?) would be to have *3* classes, one that's just `BaseBlackbodyModel` with only the temperature (and no units), a `BlackbodyModel` that's what @kecnry suggeted just above, and a  `FluxButNotDensityReallyIMeanItBlackbodyModel` (ok, maybe a different name is needed there) which has the originally posed `scale` but not `solid_angle`.\r\n\r\nMy motivation here is that I rarely actually want to think about solid angle at all if I can avoid it, but sometimes I have to.\n@eteq - I would be for that, but then `FluxButNotDensityReallyIMeanItBlackbodyModel` would likely have to raise an error if calling `bolometric_flux` or possibly could estimate through integration (over wavelength or frequency) instead.\nYeah, I'm cool with that, as long as the exception message says something like \"not sure why you're seeing this?  Try using BlackbodyModel instead\"\nIf you end up with a few new classes, the user documentation needs some serious explaining, as I feel like this is going against \"There should be one-- and preferably only one --obvious way to do it\" ([PEP 20](https://www.python.org/dev/peps/pep-0020/)) a little...\n@eteq @pllim - it might be possible to achieve this same use-case (not having to worry about thinking about solid angle if you don't intend to make calls to `bolometric_flux`) in a single class by allowing `solid_angle = None` for the flux case and absorbing the steradians into the scale factor.  That case would then need to raise an informative error for calls to `bolometric_flux` to avoid the ambiguity issue.  The tradeoff I see is more complex argument validation logic and extended documentation in a single class rather than multiple classes for different use-cases.\r\n\r\nIf no one thinks of any major drawbacks/concerns, I will take a stab at that implementation and come up with examples for each of the use-cases discussed so far and we can then reconsider if splitting into separate classes is warranted.\r\n\r\nThanks for all the good ideas!\nHere are some proposed pseudo-code calls that I think could cover all the cases above with a single class including new optional `solid_angle` and `output_units` arguments.  Please let me know if I've missed any cases or if any of these wouldn't act as you'd expect.  \r\n\r\nAs you can see, there are quite a few different scenarios, so this is likely to be a documentation and testing challenge - but I'm guessing any approach will have that same problem.  Ultimately though it boils down to attempting to pull the units out of `scale` to avoid the ambiguous issues brought up here, while still allowing support for output and fitting in flux units (by supporting both separating the dimensionless scale from the solid angle to allow calling `bolometric_flux` and also by absorbing them together for the case of fitting a single scale factor and sacrificing the ability to call `bolometric_flux`).\r\n\r\n\r\n**SNU/SLAM units**\r\n\r\n`BlackBody(temperature, [scale (float or unitless)], output_units=(None, SNU, or SLAM))`\r\n* if `output_units` is not provided or `None`, defaults to `SNU` to match current behavior\r\n* unitless `scale` converted to unitless_unscaled (should address this *original* bug report)\r\n* returns in SNU/SLAM units \r\n* `bolometric_flux` uses unitless `scale` directly (matches current behavior)\r\n\r\n\r\n`BlackBody(temperature, scale (SNU or SLAM units))`\r\n* for **backwards compatibility** only\r\n* `output_units = scale.unit`, `scale = scale.value`\r\n* returns in SNU/SLAM units\r\n* `bolometric_flux`: we have two options here: (1) interpret this as a unitless `scale` with units being interpreted only for the sake of output units which matches current behavior (2) raise an error that `bolometric_flux` requires unitless `scale` to be passed (see [point 3 in the comment above](https://github.com/astropy/astropy/issues/11547#issuecomment-822667522)).\r\n\r\n\r\n`BlackBody(temperature, scale (with other units), output_units=(None, SNU, or SLAM))`\r\n* **ERROR**: `scale` cannot have units if `output_units` are SNU or SLAM (or non-SNU/SLAM units if `output_units` not provided or None)\r\n\r\n**FNU/FLAM units**\r\n\r\n`BlackBody(temperature, scale (float or unitless), solid_angle (u.sr), output_units=(FNU or FLAM))`\r\n* unitless `scale` converted to unitless_unscaled\r\n* returns in FNU/FLAM\r\n* `bolometric_flux` uses unitless `scale` directly (since separated from `solid_angle`)\r\n* fitting: either raise an error if both `scale` and `solid_angle` are left unfixed or just let it be degenerate?\r\n\r\n`BlackBody(temperature, scale (sr units), output_units=(FNU or FLAM))`\r\n* `scale = scale.value`, `solid_angle = 1.0*u.sr` and **automatically set to be kept fixed** during fitting\r\n* returns in FNU/FLAM\r\n* `bolometric_flux` => ERROR: must provide separate `scale` and `solid_angle` to call `bolometric_flux` (i.e. the previous case)\r\n\r\n`BlackBody(temperature, scale (FNU or FLAM units))`\r\n* to match **backwards compatibility** case for SNU/SLAM\r\n* `output_units = scale.unit`, `scale = scale.value`, `solid_angle = 1.0*u.sr` and **automatically set to be kept fixed** during fitting\r\n* returns in FNU/FLAM units\r\n* `bolometric_flux` => ERROR: same as above, must provide separate `scale` and `solid_angle`.\r\n\r\n`BlackBody(temperature, scale (float, unitless, or non sr units), output_units=(FNU or FLAM))`\r\n* **ERROR**: FNU/FLAM requires scale to have FNU/FLAM/sr units OR unitless with solid_angle provided (any of the cases above)\nUpon further reflection, I think that we are twisting ourselves into a knot by treating the black body as a special case when it comes to this pesky factor of pi. It's not. The factor of pi comes up any time that you need to convert from specific intensity (S_nu a.k.a. B_nu [erg cm^-2 s^-1 Hz^-1 sr^-1]) to flux density (F_nu [erg cm^-2 s^-1 Hz^-1]) assuming that your emitting surface element radiates isotropically. It's just the integral of cos(theta) from theta=0 to pi/2.\r\n\r\nBlackBody only looks like a special case among the astropy models because there are no other physical radiation models. If we declared a constant specific intensity source model class, then we would be having the same argument about whether we need to have a dual flux density class with an added factor of pi.\r\n\r\nWhat we commonly call Planck's law is B_nu. In order to avoid confusing users who are expecting the class to use the textbook definition, the Astropy model should _not_ insert the factor of pi.\r\n\r\nInstead, I propose that we go back to for `astropy.modeling.models.BlackBody`:\r\n\r\n1. `scale` may have units of dimensionless_unscaled or solid angle, and in either case simply multiplies the output, or\r\n2. has no scale parameter.\r\n\r\nIn both cases, support for scale in FNU/FLAM/SNU/SLAM is deprecated because it cannot be implemented correctly and unambiguously.\r\n\r\nAnd in both cases, synphot keeps its own BlackBody1D class (perhaps renamed to BlackBodyFlux1D to mirror ConstFlux1D) and it _does_ have the factor of pi added.\nBTW, I found this to be a nice refresher: https://www.cv.nrao.edu/~sransom/web/Ch2.html\n> synphot keeps its own BlackBody1D class (perhaps renamed to BlackBodyFlux1D to mirror ConstFlux1D)\r\n\r\n`synphot` never used the new blackbody stuff here, so I think it can be safely left out of the changes here. If you feel strongly about its model names, feel free to open issue at https://github.com/spacetelescope/synphot_refactor/issues but I don't think it will affect anything at `astropy` or vice versa. 😅 \n@lpsinger - good points. I agree that this situation isn't fundamentally unique to BlackBody, and on further thought along those lines, can't think of any practical reason not to abstract away the `solid_angle` entirely from my use-cases above (as it should probably always either be N/A or pi - allowing it to possibly be fitted or set incorrectly just asks for problems).  I have gone back and forth with myself about your point for *not* adding support for including the pi automatically, but as long as the default behavior remains the \"pure\" B_nu form, I think there are significant practical advantages for supporting more flexibility.  The more this conversation continues, the more convinced I am that `scale` is indeed useful, but that we should move towards forcing it to be unitless to avoid a lot of these confusing scenarios.  I'm worried that allowing `scale` to have steradians as units will cause more confusion (although I appreciate the simplicity of just multiplying the result).\r\n\r\nSo... my (current) vote would be to still implement a separate `output_units` argument to make sure any change in units (and/or inclusion of pi) is explicitly clear and to take over the role of differentiating between specific intensity and flux density (by eventually requiring `scale` to be unitless and always handling the pi internally if requesting in flux units).\r\n\r\nAssuming we can't remove support for units in `scale` this release without warning, that leaves us with the following:\r\n\r\n* `BlackBody(temperature, [scale (float or unitless)], output_units=(None, SNU, or SLAM))`\r\n* temporary support for `BlackBody(temperature, scale (SNU or SLAM units))`: this is the current supported syntax that we want to deprecate. In the meantime, we would split the `scale` quantity into `scale` (unitless) and `output_units`.  I think this still might be a bit confusing for the `bolometric_flux` case, so we may want to raise an error/warning there?\r\n* `BlackBody(temperature, [scale (float or unitless)], output_units=(FNU or FLAM))`: since scale is unitless, it is assumed *not* to include the pi, the returned value is multiplied by `scale*pi` internally and with requested units.\r\n* temporary support for `BlackBody(temperature, scale (FNU, FLAM))`: here `scale` includes units of solid angle, so internally we would set `scale = scale.value/pi` and then use the above treatment to multiply by `scale*pi`.  Note that this does mean the these last two cases behave a little differently for passing the same \"number\" to `scale`, as without units it assumes to not include the pi, but will assume to include the pi if passed as a quantity. Definitely not ideal - I suppose we don't need to add support for this case since it wasn't supported in the past.  But if we do, we may again want to raise an error/warning when calling `bolometric_flux`?\r\n\r\nIf we don't like the `output_units` argument, this could be done instead with `BlackBody` vs `BlackBodyFlux` model (similar to @eteq's suggestion earlier), still deprecate passing units to scale as described above for both classes, and leave any unit conversion between *NU and *LAM to the user.  Separate classes may be slightly cleaner looking and help separate the documentation, while a single class with the `output_units` argument provides a little more convenience functionality.\nI think we should not include the factor of pi at all in the astropy model because it assumes not only that one is integrating over a solid angle, but that the temperature is uniform over the body. In general, that does not have to be the case, does it?\r\n\r\nWould we ruffle too many feathers if we deprecated `scale` altogether?\n> Would we ruffle too many feathers\r\n\r\nCan't be worse than the episode when we deprecated `clobber` in `io.fits`... 😅 \nNo, not in general.  But so long as we only support a single temperature, I think it's reasonable that that would assume uniform temperature. \r\n\r\nI think getting rid of `scale` entirely was @karllark's original suggestion, but then all of this logic is left to be done externally (likely by the user).  My attempts to do so with the existing `Scale` or `Linear1D` models, [showed complications](https://github.com/astropy/astropy/issues/11547#issuecomment-949734738).  Perhaps I was missing something there and there's a better way... or maybe we need to work on fixing underlying bugs or lack of flexibility in `Compound` models instead.  I also agree with @eteq's [arguments that users would expect a scale](https://github.com/astropy/astropy/issues/11547#issuecomment-951154117) and that it might indeed ruffle some feathers.\n> No, not in general. But so long as we only support a single temperature, I think it's reasonable that that would assume uniform temperature.\r\n\r\nIt may be fair to assume a uniform temperature, but the factor of pi is also kind of assuming that the emitting surface is a sphere, isn't it?\r\n\r\n> I think getting rid of `scale` entirely was @karllark's original suggestion, but then all of this logic is left to be done externally (likely by the user). My attempts to do so with the existing `Scale` or `Linear1D` models, [showed complications](https://github.com/astropy/astropy/issues/11547#issuecomment-949734738). Perhaps I was missing something there and there's a better way... or maybe we need to work on fixing underlying bugs or lack of flexibility in `Compound` models instead. I also agree with @eteq's [arguments that users would expect a scale](https://github.com/astropy/astropy/issues/11547#issuecomment-951154117) and that it might indeed ruffle some feathers.\r\n\r\nI see. In that case, it seems that we are converging toward retaining the `scale` attribute but deprecating any but dimensionless units for it. Is that an accurate statement? If so, then I can whip up a PR.\nYes, most likely a sphere, or at least anything where the solid angle is pi.  But I agree that adding the generality for any solid angle will probably never be used and just adds unnecessary complication.\r\n\r\nI think that's the best approach for now (deprecating unit support in `scale` but supporting flux units) and then if in the future we want to completely remove `scale`, that is an option as long as external scaling can pick up the slack.  I already started on testing some implementations, so am happy to put together the PR (and will tag you so you can look at it and comment before any decision is made).\n> I think that's the best approach for now (deprecating unit support in `scale` but supporting flux units) and then if in the future we want to completely remove `scale`, that is an option as long as external scaling can pick up the slack. I already started on testing some implementations, so am happy to put together the PR (and will tag you so you can look at it and comment before any decision is made).\r\n\r\nGo for it.",
  "created_at": "2021-10-28T15:32:17Z",
  "version": "4.3",
  "FAIL_TO_PASS": "[\"astropy/modeling/tests/test_physical_models.py::test_blackbody_input_units\", \"astropy/modeling/tests/test_physical_models.py::test_blackbody_exceptions_and_warnings\", \"astropy/modeling/tests/test_physical_models.py::test_blackbody_dimensionless\"]",
  "PASS_TO_PASS": "[\"astropy/modeling/tests/test_physical_models.py::test_blackbody_evaluate[temperature0]\", \"astropy/modeling/tests/test_physical_models.py::test_blackbody_evaluate[temperature1]\", \"astropy/modeling/tests/test_physical_models.py::test_blackbody_weins_law\", \"astropy/modeling/tests/test_physical_models.py::test_blackbody_sefanboltzman_law\", \"astropy/modeling/tests/test_physical_models.py::test_blackbody_return_units\", \"astropy/modeling/tests/test_physical_models.py::test_blackbody_overflow\", \"astropy/modeling/tests/test_physical_models.py::test_blackbody_array_temperature\", \"astropy/modeling/tests/test_physical_models.py::test_NFW_evaluate[mass0]\", \"astropy/modeling/tests/test_physical_models.py::test_NFW_evaluate[mass1]\", \"astropy/modeling/tests/test_physical_models.py::test_NFW_circular_velocity\", \"astropy/modeling/tests/test_physical_models.py::test_NFW_exceptions_and_warnings_and_misc\"]",
  "environment_setup_commit": "298ccb478e6bf092953bca67a3d29dc6c35f6752",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.521638",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}