{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-16632",
  "base_commit": "09427d754153e90a8c51c21d84bc0536b336087f",
  "patch": "diff --git a/sympy/parsing/sympy_parser.py b/sympy/parsing/sympy_parser.py\n--- a/sympy/parsing/sympy_parser.py\n+++ b/sympy/parsing/sympy_parser.py\n@@ -10,9 +10,13 @@\n import ast\n import unicodedata\n \n-from sympy.core.compatibility import exec_, StringIO\n+from sympy.core.compatibility import exec_, StringIO, iterable\n from sympy.core.basic import Basic\n from sympy.core import Symbol\n+from sympy.core.function import arity\n+from sympy.utilities.misc import filldedent, func_name\n+\n+\n \n def _token_splittable(token):\n     \"\"\"\n@@ -381,41 +385,58 @@ def _split_symbols(tokens, local_dict, global_dict):\n         result = []\n         split = False\n         split_previous=False\n+\n         for tok in tokens:\n             if split_previous:\n                 # throw out closing parenthesis of Symbol that was split\n                 split_previous=False\n                 continue\n             split_previous=False\n+\n             if tok[0] == NAME and tok[1] in ['Symbol', 'Function']:\n                 split = True\n+\n             elif split and tok[0] == NAME:\n                 symbol = tok[1][1:-1]\n+\n                 if predicate(symbol):\n                     tok_type = result[-2][1]  # Symbol or Function\n                     del result[-2:]  # Get rid of the call to Symbol\n-                    for char in symbol[:-1]:\n+\n+                    i = 0\n+                    while i < len(symbol):\n+                        char = symbol[i]\n                         if char in local_dict or char in global_dict:\n                             result.extend([(NAME, \"%s\" % char)])\n+                        elif char.isdigit():\n+                            char = [char]\n+                            for i in range(i + 1, len(symbol)):\n+                                if not symbol[i].isdigit():\n+                                  i -= 1\n+                                  break\n+                                char.append(symbol[i])\n+                            char = ''.join(char)\n+                            result.extend([(NAME, 'Number'), (OP, '('),\n+                                           (NAME, \"'%s'\" % char), (OP, ')')])\n                         else:\n-                            result.extend([(NAME, 'Symbol'), (OP, '('),\n+                            use = tok_type if i == len(symbol) else 'Symbol'\n+                            result.extend([(NAME, use), (OP, '('),\n                                            (NAME, \"'%s'\" % char), (OP, ')')])\n-                    char = symbol[-1]\n-                    if char in local_dict or char in global_dict:\n-                        result.extend([(NAME, \"%s\" % char)])\n-                    else:\n-                        result.extend([(NAME, tok_type), (OP, '('),\n-                                       (NAME, \"'%s'\" % char), (OP, ')')])\n+                        i += 1\n \n                     # Set split_previous=True so will skip\n                     # the closing parenthesis of the original Symbol\n                     split = False\n                     split_previous = True\n                     continue\n+\n                 else:\n                     split = False\n+\n             result.append(tok)\n+\n         return result\n+\n     return _split_symbols\n \n \n@@ -636,6 +657,7 @@ def convert_xor(tokens, local_dict, global_dict):\n \n     return result\n \n+\n def repeated_decimals(tokens, local_dict, global_dict):\n     \"\"\"\n     Allows 0.2[1] notation to represent the repeated decimal 0.2111... (19/90)\n@@ -726,6 +748,7 @@ def is_digit(s):\n \n     return result\n \n+\n def auto_number(tokens, local_dict, global_dict):\n     \"\"\"\n     Converts numeric literals to use SymPy equivalents.\n@@ -759,6 +782,7 @@ def auto_number(tokens, local_dict, global_dict):\n \n     return result\n \n+\n def rationalize(tokens, local_dict, global_dict):\n     \"\"\"Converts floats into ``Rational``. Run AFTER ``auto_number``.\"\"\"\n     result = []\n@@ -953,11 +977,29 @@ def parse_expr(s, local_dict=None, transformations=standard_transformations,\n \n     if local_dict is None:\n         local_dict = {}\n+    elif not isinstance(local_dict, dict):\n+        raise TypeError('expecting local_dict to be a dict')\n \n     if global_dict is None:\n         global_dict = {}\n         exec_('from sympy import *', global_dict)\n-\n+    elif not isinstance(global_dict, dict):\n+        raise TypeError('expecting global_dict to be a dict')\n+\n+    transformations = transformations or ()\n+    if transformations:\n+        if not iterable(transformations):\n+            raise TypeError(\n+                '`transformations` should be a list of functions.')\n+        for _ in transformations:\n+            if not callable(_):\n+                raise TypeError(filldedent('''\n+                    expected a function in `transformations`,\n+                    not %s''' % func_name(_)))\n+            if arity(_) != 3:\n+                raise TypeError(filldedent('''\n+                    a transformation should be function that\n+                    takes 3 arguments'''))\n     code = stringify_expr(s, local_dict, global_dict, transformations)\n \n     if not evaluate:\n",
  "test_patch": "diff --git a/sympy/parsing/tests/test_sympy_parser.py b/sympy/parsing/tests/test_sympy_parser.py\n--- a/sympy/parsing/tests/test_sympy_parser.py\n+++ b/sympy/parsing/tests/test_sympy_parser.py\n@@ -1,7 +1,9 @@\n # -*- coding: utf-8 -*-\n \n+\n import sys\n \n+\n from sympy.core import Symbol, Function, Float, Rational, Integer, I, Mul, Pow, Eq\n from sympy.core.compatibility import PY3\n from sympy.functions import exp, factorial, factorial2, sin\n@@ -11,9 +13,10 @@\n \n from sympy.parsing.sympy_parser import (\n     parse_expr, standard_transformations, rationalize, TokenError,\n-    split_symbols, implicit_multiplication, convert_equals_signs, convert_xor,\n-    function_exponentiation,\n-)\n+    split_symbols, implicit_multiplication, convert_equals_signs,\n+    convert_xor, function_exponentiation,\n+    implicit_multiplication_application,\n+    )\n \n \n def test_sympy_parser():\n@@ -48,10 +51,22 @@ def test_sympy_parser():\n             evaluate=False),\n         'Limit(sin(x), x, 0, dir=\"-\")': Limit(sin(x), x, 0, dir='-'),\n \n+\n     }\n     for text, result in inputs.items():\n         assert parse_expr(text) == result\n \n+    raises(TypeError, lambda:\n+        parse_expr('x', standard_transformations))\n+    raises(TypeError, lambda:\n+        parse_expr('x', transformations=lambda x,y: 1))\n+    raises(TypeError, lambda:\n+        parse_expr('x', transformations=(lambda x,y: 1,)))\n+    raises(TypeError, lambda: parse_expr('x', transformations=((),)))\n+    raises(TypeError, lambda: parse_expr('x', {}, [], []))\n+    raises(TypeError, lambda: parse_expr('x', [], [], {}))\n+    raises(TypeError, lambda: parse_expr('x', [], [], {}))\n+\n \n def test_rationalize():\n     inputs = {\n@@ -65,6 +80,7 @@ def test_rationalize():\n def test_factorial_fail():\n     inputs = ['x!!!', 'x!!!!', '(!)']\n \n+\n     for text in inputs:\n         try:\n             parse_expr(text)\n@@ -77,18 +93,22 @@ def test_repeated_fail():\n     inputs = ['1[1]', '.1e1[1]', '0x1[1]', '1.1j[1]', '1.1[1 + 1]',\n         '0.1[[1]]', '0x1.1[1]']\n \n+\n     # All are valid Python, so only raise TypeError for invalid indexing\n     for text in inputs:\n         raises(TypeError, lambda: parse_expr(text))\n \n+\n     inputs = ['0.1[', '0.1[1', '0.1[]']\n     for text in inputs:\n         raises((TokenError, SyntaxError), lambda: parse_expr(text))\n \n+\n def test_repeated_dot_only():\n     assert parse_expr('.[1]') == Rational(1, 9)\n     assert parse_expr('1 + .[1]') == Rational(10, 9)\n \n+\n def test_local_dict():\n     local_dict = {\n         'my_function': lambda x: x + 2\n@@ -137,6 +157,7 @@ def test_issue_7663():\n     e = '2*(x+1)'\n     assert parse_expr(e, evaluate=0) == parse_expr(e, evaluate=False)\n \n+\n def test_issue_10560():\n     inputs = {\n         '4*-3' : '(-3)*4',\n@@ -145,6 +166,7 @@ def test_issue_10560():\n     for text, result in inputs.items():\n         assert parse_expr(text, evaluate=False) == parse_expr(result, evaluate=False)\n \n+\n def test_issue_10773():\n     inputs = {\n     '-10/5': '(-10)/5',\n@@ -161,6 +183,7 @@ def test_split_symbols():\n     y = Symbol('y')\n     xy = Symbol('xy')\n \n+\n     assert parse_expr(\"xy\") == xy\n     assert parse_expr(\"xy\", transformations=transformations) == x*y\n \n@@ -173,6 +196,7 @@ def test_split_symbols_function():\n     a = Symbol('a')\n     f = Function('f')\n \n+\n     assert parse_expr(\"ay(x+1)\", transformations=transformations) == a*y*(x+1)\n     assert parse_expr(\"af(x+1)\", transformations=transformations,\n                       local_dict={'f':f}) == a*f(x+1)\n@@ -196,6 +220,7 @@ def test_match_parentheses_implicit_multiplication():\n                       (implicit_multiplication,)\n     raises(TokenError, lambda: parse_expr('(1,2),(3,4]',transformations=transformations))\n \n+\n def test_convert_equals_signs():\n     transformations = standard_transformations + \\\n                         (convert_equals_signs, )\n@@ -213,17 +238,34 @@ def test_parse_function_issue_3539():\n     assert parse_expr('f(x)') == f(x)\n \n \n+def test_split_symbols_numeric():\n+    transformations = (\n+        standard_transformations +\n+        (implicit_multiplication_application,))\n+\n+    n = Symbol('n')\n+    expr1 = parse_expr('2**n * 3**n')\n+    expr2 = parse_expr('2**n3**n', transformations=transformations)\n+    assert expr1 == expr2 == 2**n*3**n\n+\n+    expr1 = parse_expr('n12n34', transformations=transformations)\n+    assert expr1 == n*12*n*34\n+\n+\n def test_unicode_names():\n     if not PY3:\n         skip(\"test_unicode_names can only pass in Python 3\")\n \n+\n     assert parse_expr(u'α') == Symbol(u'α')\n \n+\n def test_python3_features():\n     # Make sure the tokenizer can handle Python 3-only features\n     if sys.version_info < (3, 6):\n         skip(\"test_python3_features requires Python 3.6 or newer\")\n \n+\n     assert parse_expr(\"123_456\") == 123456\n     assert parse_expr(\"1.2[3_4]\") == parse_expr(\"1.2[34]\") == Rational(611, 495)\n     assert parse_expr(\"1.2[012_012]\") == parse_expr(\"1.2[012012]\") == Rational(400, 333)\n",
  "problem_statement": "parsing expressions with powers\n`from sympy.parsing.sympy_parser import (\r\n    parse_expr,\r\n    standard_transformations,\r\n    implicit_multiplication_application,\r\n)`\r\n\r\n`transformations = (standard_transformations + (implicit_multiplication_application,))`\r\n\r\n`expr1 = parse_expr('2**n * 3**n')`\r\n`expr2 = parse_expr('2**n3**n', transformations=transformations)`\r\n\r\n`print(type(expr1), expr1.args, expr1) --> <class 'sympy.core.power.Pow'> (6, n) 6**n`\r\n`print(type(expr2), expr2.args, expr2) --> <class 'sympy.core.mul.Mul'> (3**n, 2**n) 3**n*2**n`\r\n\r\nand if i will do something with expr1 and expr2 i will get wrong results:\r\n\r\n`\r\nprint(expr1 - expr2) --> 6**n - 3**n*2**n        # Not Zero!!!\r\n`\r\n\r\ni have tried simplify, powsimp (force=True too), powdenest, also i have tried create var('n', positive=True, integer=True) and set parameter local_dict into parse_expr and use another transformations in parsing, but i could not get 0.\r\nMaybe somebody tell me how i can get zero after expr1 - expr2?\r\n\r\nThank you \n",
  "hints_text": "The '3' got parsed as a Symbol in expr2:\r\n```python\r\n>>> srepr(expr2)\r\n\"Mul(Pow(Integer(2), Symbol('n')), Pow(Symbol('3'), Symbol('n')))\"\r\n                                       ^^^^^^^^^^^\r\n```\nThis is bug? Or what? :(\n> how i can get zero after expr1 - expr2?\r\n\r\nThe hack is to do `expr2 = expr2.subs(Symbol('3'), 3)` and work with that until the bug is fixed.\nThank you, but i have this bug not only for '3', i can't fix this bug automatically for all cases :)\r\nI hope, that this bug will be fix.\nI'm not sure how easy this will be to fix: you have an ambiguous expression. `n3` is a valid variable name so either you have a syntax error -- one of the powers is missing an argument as in `2**n3*?**n` or `2**?*n3**n` or it should be split (as in this case you want). But if there is more than 1 number, then what?\r\n`2**n32**n` could have a base of 32 or 2 and or `2**n2.3**n` could have a base of 2.3 or 0.3. Perhaps the simplest thing to do is raise a parsing error if any Symbol (not in a locals dictionary) is created whose name is a number.",
  "created_at": "2019-04-12T09:19:30Z",
  "version": "1.5",
  "FAIL_TO_PASS": "[\"test_split_symbols_numeric\"]",
  "PASS_TO_PASS": "[\"test_sympy_parser\", \"test_rationalize\", \"test_factorial_fail\", \"test_repeated_fail\", \"test_repeated_dot_only\", \"test_local_dict\", \"test_local_dict_split_implmult\", \"test_local_dict_symbol_to_fcn\", \"test_global_dict\", \"test_issue_2515\", \"test_split_symbols\", \"test_split_symbols_function\", \"test_functional_exponent\", \"test_match_parentheses_implicit_multiplication\", \"test_convert_equals_signs\", \"test_parse_function_issue_3539\", \"test_unicode_names\"]",
  "environment_setup_commit": "70381f282f2d9d039da860e391fe51649df2779d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.109234",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}