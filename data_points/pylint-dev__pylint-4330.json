{
  "repo": "pylint-dev/pylint",
  "instance_id": "pylint-dev__pylint-4330",
  "base_commit": "5e1928b325bc798f5be1ab94031bf6816d058d9f",
  "patch": "diff --git a/pylint/checkers/spelling.py b/pylint/checkers/spelling.py\n--- a/pylint/checkers/spelling.py\n+++ b/pylint/checkers/spelling.py\n@@ -17,6 +17,7 @@\n # Copyright (c) 2020 Ganden Schaffner <gschaffner@pm.me>\n # Copyright (c) 2020 hippo91 <guillaume.peillex@gmail.com>\n # Copyright (c) 2020 Damien Baty <damien.baty@polyconseil.fr>\n+# Copyright (c) 2021 Eli Fine <ejfine@gmail.com>\n \n # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n # For details: https://github.com/PyCQA/pylint/blob/master/COPYING\n@@ -26,6 +27,7 @@\n import os\n import re\n import tokenize\n+from typing import Pattern\n \n from pylint.checkers import BaseTokenChecker\n from pylint.checkers.utils import check_messages\n@@ -79,7 +81,7 @@ def get_tokenizer(\n     instr = \" To make it work, install the 'python-enchant' package.\"\n \n \n-class WordsWithDigigtsFilter(Filter):\n+class WordsWithDigitsFilter(Filter):\n     \"\"\"Skips words with digits.\"\"\"\n \n     def _skip(self, word):\n@@ -99,7 +101,21 @@ def _skip(self, word):\n         return \"_\" in word\n \n \n-class CamelCasedWord(Filter):\n+class RegExFilter(Filter):\n+    \"\"\"Parent class for filters using regular expressions.\n+\n+    This filter skips any words the match the expression\n+    assigned to the class attribute ``_pattern``.\n+\n+    \"\"\"\n+\n+    _pattern: Pattern[str]\n+\n+    def _skip(self, word) -> bool:\n+        return bool(self._pattern.match(word))\n+\n+\n+class CamelCasedWord(RegExFilter):\n     r\"\"\"Filter skipping over camelCasedWords.\n     This filter skips any words matching the following regular expression:\n \n@@ -109,11 +125,8 @@ class CamelCasedWord(Filter):\n     \"\"\"\n     _pattern = re.compile(r\"^([a-z]+([\\d]|[A-Z])(?:\\w+)?)\")\n \n-    def _skip(self, word):\n-        return bool(self._pattern.match(word))\n \n-\n-class SphinxDirectives(Filter):\n+class SphinxDirectives(RegExFilter):\n     r\"\"\"Filter skipping over Sphinx Directives.\n     This filter skips any words matching the following regular expression:\n \n@@ -124,11 +137,8 @@ class SphinxDirectives(Filter):\n     # The final ` in the pattern is optional because enchant strips it out\n     _pattern = re.compile(r\"^(:([a-z]+)){1,2}:`([^`]+)(`)?\")\n \n-    def _skip(self, word):\n-        return bool(self._pattern.match(word))\n-\n \n-class ForwardSlashChunkder(Chunker):\n+class ForwardSlashChunker(Chunker):\n     \"\"\"\n     This chunker allows splitting words like 'before/after' into 'before' and 'after'\n     \"\"\"\n@@ -169,6 +179,23 @@ def _next(self):\n         raise StopIteration()\n \n \n+CODE_FLANKED_IN_BACKTICK_REGEX = re.compile(r\"(\\s|^)(`{1,2})([^`]+)(\\2)([^`]|$)\")\n+\n+\n+def _strip_code_flanked_in_backticks(line: str) -> str:\n+    \"\"\"Alter line so code flanked in backticks is ignored.\n+\n+    Pyenchant automatically strips backticks when parsing tokens,\n+    so this cannot be done at the individual filter level.\"\"\"\n+\n+    def replace_code_but_leave_surrounding_characters(match_obj) -> str:\n+        return match_obj.group(1) + match_obj.group(5)\n+\n+    return CODE_FLANKED_IN_BACKTICK_REGEX.sub(\n+        replace_code_but_leave_surrounding_characters, line\n+    )\n+\n+\n class SpellingChecker(BaseTokenChecker):\n     \"\"\"Check spelling in comments and docstrings\"\"\"\n \n@@ -245,6 +272,15 @@ class SpellingChecker(BaseTokenChecker):\n                 \"help\": \"Limits count of emitted suggestions for spelling mistakes.\",\n             },\n         ),\n+        (\n+            \"spelling-ignore-comment-directives\",\n+            {\n+                \"default\": \"fmt: on,fmt: off,noqa:,noqa,nosec,isort:skip,mypy:\",\n+                \"type\": \"string\",\n+                \"metavar\": \"<comma separated words>\",\n+                \"help\": \"List of comma separated words that should be considered directives if they appear and the beginning of a comment and should not be checked.\",\n+            },\n+        ),\n     )\n \n     def open(self):\n@@ -264,6 +300,10 @@ def open(self):\n         # \"pylint\" appears in comments in pylint pragmas.\n         self.ignore_list.extend([\"param\", \"pylint\"])\n \n+        self.ignore_comment_directive_list = [\n+            w.strip() for w in self.config.spelling_ignore_comment_directives.split(\",\")\n+        ]\n+\n         # Expand tilde to allow e.g. spelling-private-dict-file = ~/.pylintdict\n         if self.config.spelling_private_dict_file:\n             self.config.spelling_private_dict_file = os.path.expanduser(\n@@ -283,12 +323,12 @@ def open(self):\n \n         self.tokenizer = get_tokenizer(\n             dict_name,\n-            chunkers=[ForwardSlashChunkder],\n+            chunkers=[ForwardSlashChunker],\n             filters=[\n                 EmailFilter,\n                 URLFilter,\n                 WikiWordFilter,\n-                WordsWithDigigtsFilter,\n+                WordsWithDigitsFilter,\n                 WordsWithUnderscores,\n                 CamelCasedWord,\n                 SphinxDirectives,\n@@ -308,9 +348,19 @@ def _check_spelling(self, msgid, line, line_num):\n             initial_space = 0\n         if line.strip().startswith(\"#\") and \"docstring\" not in msgid:\n             line = line.strip()[1:]\n+            # A ``Filter`` cannot determine if the directive is at the beginning of a line,\n+            #   nor determine if a colon is present or not (``pyenchant`` strips trailing colons).\n+            #   So implementing this here.\n+            for iter_directive in self.ignore_comment_directive_list:\n+                if line.startswith(\" \" + iter_directive):\n+                    line = line[(len(iter_directive) + 1) :]\n+                    break\n             starts_with_comment = True\n         else:\n             starts_with_comment = False\n+\n+        line = _strip_code_flanked_in_backticks(line)\n+\n         for word, word_start_at in self.tokenizer(line.strip()):\n             word_start_at += initial_space\n             lower_cased_word = word.casefold()\ndiff --git a/pylint/testutils/decorator.py b/pylint/testutils/decorator.py\n--- a/pylint/testutils/decorator.py\n+++ b/pylint/testutils/decorator.py\n@@ -7,17 +7,21 @@\n \n \n def set_config(**kwargs):\n-    \"\"\"Decorator for setting config values on a checker.\"\"\"\n+    \"\"\"Decorator for setting config values on a checker.\n+\n+    Passing the args and kwargs back to the test function itself\n+    allows this decorator to be used on parametrized test cases.\n+    \"\"\"\n \n     def _wrapper(fun):\n         @functools.wraps(fun)\n-        def _forward(self):\n+        def _forward(self, *args, **test_function_kwargs):\n             for key, value in kwargs.items():\n                 setattr(self.checker.config, key, value)\n             if isinstance(self, CheckerTestCase):\n                 # reopen checker in case, it may be interested in configuration change\n                 self.checker.open()\n-            fun(self)\n+            fun(self, *args, **test_function_kwargs)\n \n         return _forward\n \n",
  "test_patch": "diff --git a/tests/checkers/unittest_spelling.py b/tests/checkers/unittest_spelling.py\n--- a/tests/checkers/unittest_spelling.py\n+++ b/tests/checkers/unittest_spelling.py\n@@ -37,7 +37,9 @@\n         pass\n \n \n-class TestSpellingChecker(CheckerTestCase):\n+class TestSpellingChecker(CheckerTestCase):  # pylint:disable=too-many-public-methods\n+    # This is a test case class, not sure why it would be relevant to have\n+    #   this pylint rule enforced for test case classes.\n     CHECKER_CLASS = spelling.SpellingChecker\n \n     skip_on_missing_package_or_dict = pytest.mark.skipif(\n@@ -303,6 +305,107 @@ def test_skip_sphinx_directives_2(self):\n         ):\n             self.checker.visit_classdef(stmt)\n \n+    @skip_on_missing_package_or_dict\n+    @set_config(spelling_dict=spell_dict)\n+    @pytest.mark.parametrize(\n+        \",\".join(\n+            (\n+                \"misspelled_portion_of_directive\",\n+                \"second_portion_of_directive\",\n+                \"description\",\n+            )\n+        ),\n+        (\n+            (\"fmt\", \": on\", \"black directive to turn on formatting\"),\n+            (\"fmt\", \": off\", \"black directive to turn off formatting\"),\n+            (\"noqa\", \"\", \"pycharm directive\"),\n+            (\"noqa\", \":\", \"flake8 / zimports directive\"),\n+            (\"nosec\", \"\", \"bandit directive\"),\n+            (\"isort\", \":skip\", \"isort directive\"),\n+            (\"mypy\", \":\", \"mypy directive\"),\n+        ),\n+    )\n+    def test_skip_tool_directives_at_beginning_of_comments_but_still_raise_error_if_directive_appears_later_in_comment(  # pylint:disable=unused-argument\n+        # Having the extra description parameter allows the description\n+        #   to show up in the pytest output as part of the test name\n+        #   when running parametrized tests.\n+        self,\n+        misspelled_portion_of_directive,\n+        second_portion_of_directive,\n+        description,\n+    ):\n+        full_comment = f\"# {misspelled_portion_of_directive}{second_portion_of_directive} {misspelled_portion_of_directive}\"\n+        with self.assertAddsMessages(\n+            Message(\n+                \"wrong-spelling-in-comment\",\n+                line=1,\n+                args=(\n+                    misspelled_portion_of_directive,\n+                    full_comment,\n+                    f\"  {'^'*len(misspelled_portion_of_directive)}\",\n+                    self._get_msg_suggestions(misspelled_portion_of_directive),\n+                ),\n+            )\n+        ):\n+            self.checker.process_tokens(_tokenize_str(full_comment))\n+\n+    @skip_on_missing_package_or_dict\n+    @set_config(spelling_dict=spell_dict)\n+    def test_skip_code_flanked_in_double_backticks(self):\n+        full_comment = \"# The function ``.qsize()`` .qsize()\"\n+        with self.assertAddsMessages(\n+            Message(\n+                \"wrong-spelling-in-comment\",\n+                line=1,\n+                args=(\n+                    \"qsize\",\n+                    full_comment,\n+                    \"                 ^^^^^\",\n+                    self._get_msg_suggestions(\"qsize\"),\n+                ),\n+            )\n+        ):\n+            self.checker.process_tokens(_tokenize_str(full_comment))\n+\n+    @skip_on_missing_package_or_dict\n+    @set_config(spelling_dict=spell_dict)\n+    def test_skip_code_flanked_in_single_backticks(self):\n+        full_comment = \"# The function `.qsize()` .qsize()\"\n+        with self.assertAddsMessages(\n+            Message(\n+                \"wrong-spelling-in-comment\",\n+                line=1,\n+                args=(\n+                    \"qsize\",\n+                    full_comment,\n+                    \"                 ^^^^^\",\n+                    self._get_msg_suggestions(\"qsize\"),\n+                ),\n+            )\n+        ):\n+            self.checker.process_tokens(_tokenize_str(full_comment))\n+\n+    @skip_on_missing_package_or_dict\n+    @set_config(\n+        spelling_dict=spell_dict,\n+        spelling_ignore_comment_directives=\"newdirective:,noqa\",\n+    )\n+    def test_skip_directives_specified_in_pylintrc(self):\n+        full_comment = \"# newdirective: do this newdirective\"\n+        with self.assertAddsMessages(\n+            Message(\n+                \"wrong-spelling-in-comment\",\n+                line=1,\n+                args=(\n+                    \"newdirective\",\n+                    full_comment,\n+                    \"          ^^^^^^^^^^^^\",\n+                    self._get_msg_suggestions(\"newdirective\"),\n+                ),\n+            )\n+        ):\n+            self.checker.process_tokens(_tokenize_str(full_comment))\n+\n     @skip_on_missing_package_or_dict\n     @set_config(spelling_dict=spell_dict)\n     def test_handle_words_joined_by_forward_slash(self):\n",
  "problem_statement": "Have spellchecker ignore code in docstring or comments (i.e. things flanked with double backticks)\n### Is your feature request related to a problem? Please describe\r\n\r\nWhen I run the spellchecker, I have comments like \r\n> The ``.qsize()`` method requires that blah blah blah\r\n\r\nThe spellchecker raises an error saying qsize is not a word. I would prefer not to have to add all these things into the 'words to ignore' dictionary, as I really only want qsize to be allowed if I explicitly flank it with backticks to indicate that it is code...if I accidentally typed qsize instead of size in a comment I would still want that flagged.  I also don't want to have to disable pylint spellchecking for that whole line of comment or the whole docstring.\r\n\r\n### Describe the solution you'd like\r\n\r\nAnything flanked in backticks should be ignored by the spellchecker (a likely easy implementation would be to add another filter like is already in place for Sphinx directives).\r\n\r\nWould you be open to a PR to address this?\n",
  "hints_text": "Thank you for opening the issue :) ! I think this would make a lot of sense.\nShould it require double backticks on each side?  or should it be more open, and anything flanked in either single or double backticks be considered code?\nMarkdown require a single backtick and rst double backticks, so I think it's ok to permit both.",
  "created_at": "2021-04-09T14:43:27Z",
  "version": "2.8",
  "FAIL_TO_PASS": "[\"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_tool_directives_at_beginning_of_comments_but_still_raise_error_if_directive_appears_later_in_comment[fmt-:\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_tool_directives_at_beginning_of_comments_but_still_raise_error_if_directive_appears_later_in_comment[noqa--pycharm\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_tool_directives_at_beginning_of_comments_but_still_raise_error_if_directive_appears_later_in_comment[noqa-:-flake8\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_tool_directives_at_beginning_of_comments_but_still_raise_error_if_directive_appears_later_in_comment[nosec--bandit\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_tool_directives_at_beginning_of_comments_but_still_raise_error_if_directive_appears_later_in_comment[isort-:skip-isort\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_tool_directives_at_beginning_of_comments_but_still_raise_error_if_directive_appears_later_in_comment[mypy-:-mypy\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_code_flanked_in_double_backticks\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_code_flanked_in_single_backticks\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_directives_specified_in_pylintrc\"]",
  "PASS_TO_PASS": "[\"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_check_bad_coment\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_check_bad_coment_custom_suggestion_count\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_check_bad_docstring\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_shebangs\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_python_coding_comments\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_top_level_pylint_enable_disable_comments\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_words_with_numbers\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_wiki_words\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_camel_cased_words\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_words_with_underscores\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_email_address\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_urls\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_sphinx_directives\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_skip_sphinx_directives_2\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_handle_words_joined_by_forward_slash\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_more_than_one_error_in_same_line_for_same_word_on_docstring\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_more_than_one_error_in_same_line_for_same_word_on_comment\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_docstring_lines_that_look_like_comments_1\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_docstring_lines_that_look_like_comments_2\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_docstring_lines_that_look_like_comments_3\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_docstring_lines_that_look_like_comments_4\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_docstring_lines_that_look_like_comments_5\", \"tests/checkers/unittest_spelling.py::TestSpellingChecker::test_docstring_lines_that_look_like_comments_6\"]",
  "environment_setup_commit": "49a6206c7756307844c1c32c256afdf9836d7bce",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.906948",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}