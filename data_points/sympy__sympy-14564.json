{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-14564",
  "base_commit": "57379b832b25bf22ef5e5ab6c8ee3fa0e863f48d",
  "patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -1798,7 +1798,12 @@ def _print_ImageSet(self, s):\n \n     def _print_ConditionSet(self, s):\n         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])\n-        return r\"\\left\\{%s\\; |\\; %s \\in %s \\wedge %s \\right\\}\" % (\n+        if s.base_set is S.UniversalSet:\n+            return r\"\\left\\{%s \\mid %s \\right\\}\" % (\n+            vars_print,\n+            self._print(s.condition.as_expr()))\n+\n+        return r\"\\left\\{%s \\mid %s \\in %s \\wedge %s \\right\\}\" % (\n             vars_print,\n             vars_print,\n             self._print(s.base_set),\ndiff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -1778,8 +1778,11 @@ def _print_ConditionSet(self, ts):\n                 cond = self._print_seq(cond, \"(\", \")\")\n \n         bar = self._print(\"|\")\n-        base = self._print(ts.base_set)\n \n+        if ts.base_set is S.UniversalSet:\n+            return self._print_seq((variables, bar, cond), \"{\", \"}\", ' ')\n+\n+        base = self._print(ts.base_set)\n         return self._print_seq((variables, bar, variables, inn,\n                                 base, _and, cond), \"{\", \"}\", ' ')\n \ndiff --git a/sympy/printing/str.py b/sympy/printing/str.py\n--- a/sympy/printing/str.py\n+++ b/sympy/printing/str.py\n@@ -103,6 +103,13 @@ def _print_Catalan(self, expr):\n     def _print_ComplexInfinity(self, expr):\n         return 'zoo'\n \n+    def _print_ConditionSet(self, s):\n+        args = tuple([self._print(i) for i in (s.sym, s.condition)])\n+        if s.base_set is S.UniversalSet:\n+            return 'ConditionSet(%s, %s)' % args\n+        args += (self._print(s.base_set),)\n+        return 'ConditionSet(%s, %s, %s)' % args\n+\n     def _print_Derivative(self, expr):\n         dexpr = expr.expr\n         dvars = [i[0] if i[1] == 1 else i for i in expr.variable_count]\ndiff --git a/sympy/sets/conditionset.py b/sympy/sets/conditionset.py\n--- a/sympy/sets/conditionset.py\n+++ b/sympy/sets/conditionset.py\n@@ -1,8 +1,10 @@\n from __future__ import print_function, division\n \n from sympy import S\n+from sympy.sets.contains import Contains\n from sympy.core.basic import Basic\n from sympy.core.containers import Tuple\n+from sympy.core.expr import Expr\n from sympy.core.function import Lambda\n from sympy.core.logic import fuzzy_bool\n from sympy.core.symbol import Symbol, Dummy\n@@ -10,6 +12,7 @@\n from sympy.sets.sets import (Set, Interval, Intersection, EmptySet, Union,\n                              FiniteSet)\n from sympy.utilities.iterables import sift\n+from sympy.utilities.misc import filldedent\n from sympy.multipledispatch import dispatch\n \n \n@@ -23,7 +26,8 @@ class ConditionSet(Set):\n     ========\n \n     >>> from sympy import Symbol, S, ConditionSet, pi, Eq, sin, Interval\n-    >>> x = Symbol('x')\n+    >>> from sympy.abc import x, y, z\n+\n     >>> sin_sols = ConditionSet(x, Eq(sin(x), 0), Interval(0, 2*pi))\n     >>> 2*pi in sin_sols\n     True\n@@ -33,65 +37,136 @@ class ConditionSet(Set):\n     False\n     >>> 5 in ConditionSet(x, x**2 > 4, S.Reals)\n     True\n+\n+    If the value is not in the base set, the result is false:\n+\n+    >>> 5 in ConditionSet(x, x**2 > 4, Interval(2, 4))\n+    False\n+\n+    Notes\n+    =====\n+\n+    Symbols with assumptions should be avoided or else the\n+    condition may evaluate without consideration of the set:\n+\n+    >>> n = Symbol('n', negative=True)\n+    >>> cond = (n > 0); cond\n+    False\n+    >>> ConditionSet(n, cond, S.Integers)\n+    EmptySet()\n+\n+    In addition, substitution of a dummy symbol can only be\n+    done with a generic symbol with matching commutativity\n+    or else a symbol that has identical assumptions. If the\n+    base set contains the dummy symbol it is logically distinct\n+    and will be the target of substitution.\n+\n+    >>> c = ConditionSet(x, x < 1, {x, z})\n+    >>> c.subs(x, y)\n+    ConditionSet(x, x < 1, {y, z})\n+\n+    A second substitution is needed to change the dummy symbol, too:\n+\n+    >>> _.subs(x, y)\n+    ConditionSet(y, y < 1, {y, z})\n+\n+    And trying to replace the dummy symbol with anything but a symbol\n+    is ignored: the only change possible will be in the base set:\n+\n+    >>> ConditionSet(y, y < 1, {y, z}).subs(y, 1)\n+    ConditionSet(y, y < 1, {z})\n+    >>> _.subs(y, 1)\n+    ConditionSet(y, y < 1, {z})\n+\n+    Notes\n+    =====\n+\n+    If no base set is specified, the universal set is implied:\n+\n+    >>> ConditionSet(x, x < 1).base_set\n+    UniversalSet()\n+\n+    Although expressions other than symbols may be used, this\n+    is discouraged and will raise an error if the expression\n+    is not found in the condition:\n+\n+    >>> ConditionSet(x + 1, x + 1 < 1, S.Integers)\n+    ConditionSet(x + 1, x + 1 < 1, S.Integers)\n+\n+    >>> ConditionSet(x + 1, x < 1, S.Integers)\n+    Traceback (most recent call last):\n+    ...\n+    ValueError: non-symbol dummy not recognized in condition\n+\n+    Although the name is usually respected, it must be replaced if\n+    the base set is another ConditionSet and the dummy symbol\n+    and appears as a free symbol in the base set and the dummy symbol\n+    of the base set appears as a free symbol in the condition:\n+\n+    >>> ConditionSet(x, x < y, ConditionSet(y, x + y < 2, S.Integers))\n+    ConditionSet(lambda, (lambda < y) & (lambda + x < 2), S.Integers)\n+\n+    The best way to do anything with the dummy symbol is to access\n+    it with the sym property.\n+\n+    >>> _.subs(_.sym, Symbol('_x'))\n+    ConditionSet(_x, (_x < y) & (_x + x < 2), S.Integers)\n     \"\"\"\n-    def __new__(cls, sym, condition, base_set):\n+    def __new__(cls, sym, condition, base_set=S.UniversalSet):\n         # nonlinsolve uses ConditionSet to return an unsolved system\n         # of equations (see _return_conditionset in solveset) so until\n         # that is changed we do minimal checking of the args\n-        unsolved = isinstance(sym, (Tuple, tuple))\n-        if unsolved:\n+        if isinstance(sym, (Tuple, tuple)):  # unsolved eqns syntax\n             sym = Tuple(*sym)\n             condition = FiniteSet(*condition)\n-        else:\n-            condition = as_Boolean(condition)\n+            return Basic.__new__(cls, sym, condition, base_set)\n+        condition = as_Boolean(condition)\n         if isinstance(base_set, set):\n             base_set = FiniteSet(*base_set)\n         elif not isinstance(base_set, Set):\n             raise TypeError('expecting set for base_set')\n-        if condition == S.false:\n+        if condition is S.false:\n             return S.EmptySet\n-        if condition == S.true:\n+        if condition is S.true:\n             return base_set\n         if isinstance(base_set, EmptySet):\n             return base_set\n-        if not unsolved:\n-            if isinstance(base_set, FiniteSet):\n-                sifted = sift(\n-                    base_set, lambda _: fuzzy_bool(\n-                        condition.subs(sym, _)))\n-                if sifted[None]:\n-                    return Union(FiniteSet(*sifted[True]),\n-                        Basic.__new__(cls, sym, condition,\n-                        FiniteSet(*sifted[None])))\n-                else:\n-                    return FiniteSet(*sifted[True])\n-            if isinstance(base_set, cls):\n-                s, c, base_set = base_set.args\n-                if sym == s:\n-                    condition = And(condition, c)\n-                elif sym not in c.free_symbols:\n-                    condition = And(condition, c.xreplace({s: sym}))\n-                elif s not in condition.free_symbols:\n-                    condition = And(condition.xreplace({sym: s}), c)\n-                    sym = s\n-                else:\n-                    # user will have to use cls.sym to get symbol\n-                    dum = Symbol('lambda')\n-                    if dum in condition.free_symbols or \\\n-                            dum in c.free_symbols:\n-                        dum = Dummy(str(dum))\n-                    condition = And(\n-                        condition.xreplace({sym: dum}),\n-                        c.xreplace({s: dum}))\n-                    sym = dum\n-            if sym in base_set.free_symbols or \\\n-                    not isinstance(sym, Symbol):\n-                s = Symbol('lambda')\n-                if s in base_set.free_symbols:\n-                    s = Dummy('lambda')\n-                condition = condition.xreplace({sym: s})\n+        know = None\n+        if isinstance(base_set, FiniteSet):\n+            sifted = sift(\n+                base_set, lambda _: fuzzy_bool(\n+                    condition.subs(sym, _)))\n+            if sifted[None]:\n+                know = FiniteSet(*sifted[True])\n+                base_set = FiniteSet(*sifted[None])\n+            else:\n+                return FiniteSet(*sifted[True])\n+        if isinstance(base_set, cls):\n+            s, c, base_set = base_set.args\n+            if sym == s:\n+                condition = And(condition, c)\n+            elif sym not in c.free_symbols:\n+                condition = And(condition, c.xreplace({s: sym}))\n+            elif s not in condition.free_symbols:\n+                condition = And(condition.xreplace({sym: s}), c)\n                 sym = s\n-        return Basic.__new__(cls, sym, condition, base_set)\n+            else:\n+                # user will have to use cls.sym to get symbol\n+                dum = Symbol('lambda')\n+                if dum in condition.free_symbols or \\\n+                        dum in c.free_symbols:\n+                    dum = Dummy(str(dum))\n+                condition = And(\n+                    condition.xreplace({sym: dum}),\n+                    c.xreplace({s: dum}))\n+                sym = dum\n+        if not isinstance(sym, Symbol):\n+            s = Dummy('lambda')\n+            if s not in condition.xreplace({sym: s}).free_symbols:\n+                raise ValueError(\n+                    'non-symbol dummy not recognized in condition')\n+        rv = Basic.__new__(cls, sym, condition, base_set)\n+        return rv if know is None else Union(know, rv)\n \n     sym = property(lambda self: self.args[0])\n     condition = property(lambda self: self.args[1])\n@@ -107,16 +182,45 @@ def contains(self, other):\n             other), self.base_set.contains(other))\n \n     def _eval_subs(self, old, new):\n-        if not isinstance(self.sym, Symbol):\n+        if not isinstance(self.sym, Expr):\n             # Don't do anything with the equation set syntax;\n             # that should go away, eventually.\n             return self\n-        if old == self.sym:\n-            if new not in self.free_symbols:\n-                if isinstance(new, Symbol):\n-                    return self.func(*[i.subs(old, new) for i in self.args])\n-            return self.func(self.sym, self.condition, self.base_set.subs(old, new))\n-        return self.func(*([self.sym] + [i.subs(old, new) for i in self.args[1:]]))\n+        sym, cond, base = self.args\n+        if old == sym:\n+            # we try to be as lenient as possible to allow\n+            # the dummy symbol to be changed\n+            base = base.subs(old, new)\n+            if isinstance(new, Symbol):\n+                # if the assumptions don't match, the cond\n+                # might evaluate or change\n+                if (new.assumptions0 == old.assumptions0 or\n+                        len(new.assumptions0) == 1 and\n+                        old.is_commutative == new.is_commutative):\n+                    if base != self.base_set:\n+                        # it will be aggravating to have the dummy\n+                        # symbol change if you are trying to target\n+                        # the base set so if the base set is changed\n+                        # leave the dummy symbol alone -- a second\n+                        # subs will be needed to change the dummy\n+                        return self.func(sym, cond, base)\n+                    else:\n+                        return self.func(new, cond.subs(old, new), base)\n+                raise ValueError(filldedent('''\n+                    A dummy symbol can only be\n+                    replaced with a symbol having the same\n+                    assumptions or one having a single assumption\n+                    having the same commutativity.\n+                '''))\n+            # don't target cond: it is there to tell how\n+            # the base set should be filtered and if new is not in\n+            # the base set then this substitution is ignored\n+            return self.func(sym, cond, base)\n+        cond = self.condition.subs(old, new)\n+        base = self.base_set.subs(old, new)\n+        if cond is S.true:\n+            return ConditionSet(new, Contains(new, base), base)\n+        return self.func(self.sym, cond, base)\n \n     def dummy_eq(self, other, symbol=None):\n         if not isinstance(other, self.func):\n",
  "test_patch": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -781,7 +781,9 @@ def test_latex_ImageSet():\n def test_latex_ConditionSet():\n     x = Symbol('x')\n     assert latex(ConditionSet(x, Eq(x**2, 1), S.Reals)) == \\\n-        r\"\\left\\{x\\; |\\; x \\in \\mathbb{R} \\wedge x^{2} = 1 \\right\\}\"\n+        r\"\\left\\{x \\mid x \\in \\mathbb{R} \\wedge x^{2} = 1 \\right\\}\"\n+    assert latex(ConditionSet(x, Eq(x**2, 1), S.UniversalSet)) == \\\n+        r\"\\left\\{x \\mid x^{2} = 1 \\right\\}\"\n \n \n def test_latex_ComplexRegion():\ndiff --git a/sympy/sets/tests/test_conditionset.py b/sympy/sets/tests/test_conditionset.py\n--- a/sympy/sets/tests/test_conditionset.py\n+++ b/sympy/sets/tests/test_conditionset.py\n@@ -1,7 +1,7 @@\n from sympy.sets import (ConditionSet, Intersection, FiniteSet,\n     EmptySet, Union)\n from sympy import (Symbol, Eq, Lt, S, Abs, sin, pi, Lambda, Interval,\n-    And, Mod)\n+    And, Mod, oo, Function)\n from sympy.utilities.pytest import raises\n \n \n@@ -10,6 +10,7 @@\n y = Symbol('y')\n z = Symbol('z')\n L = Symbol('lambda')\n+f = Function('f')\n \n \n def test_CondSet():\n@@ -20,6 +21,16 @@ def test_CondSet():\n     assert 3*pi not in sin_sols_principal\n     assert 5 in ConditionSet(x, x**2 > 4, S.Reals)\n     assert 1 not in ConditionSet(x, x**2 > 4, S.Reals)\n+    # in this case, 0 is not part of the base set so\n+    # it can't be in any subset selected by the condition\n+    assert 0 not in ConditionSet(x, y > 5, Interval(1, 7))\n+    # since 'in' requires a true/false, the following raises\n+    # an error because the given value provides no information\n+    # for the condition to evaluate (since the condition does\n+    # not depend on the dummy symbol): the result is `y > 5`.\n+    # In this case, ConditionSet is just acting like\n+    # Piecewise((Interval(1, 7), y > 5), (S.EmptySet, True)).\n+    raises(TypeError, lambda: 6 in ConditionSet(x, y > 5, Interval(1, 7)))\n \n     assert isinstance(ConditionSet(x, x < 1, {x, y}).base_set, FiniteSet)\n     raises(TypeError, lambda: ConditionSet(x, x + 1, {x, y}))\n@@ -41,9 +52,7 @@ def test_CondSet():\n     assert c == C(c.sym, (L < y) & (x < 1), I)\n     assert c.sym not in (x, y, L)\n     c = C(y, x < 1, C(x, y < x, FiniteSet(L)))\n-    assert c == C(\n-        c.sym, c.condition.xreplace({L: c.sym}), FiniteSet(L))\n-    assert c.sym not in (x, y, L)\n+    assert c == C(L, And(x < 1, y < L), FiniteSet(L))\n \n \n def test_CondSet_intersect():\n@@ -84,11 +93,44 @@ def test_subs_CondSet():\n     # you can only replace sym with a symbol that is not in\n     # the free symbols\n     assert c.subs(x, 1) == c\n-    assert c.subs(x, y) == c\n+    assert c.subs(x, y) == ConditionSet(y, y < 2, s)\n+\n+    # double subs needed to change dummy if the base set\n+    # also contains the dummy\n+    orig = ConditionSet(y, y < 2, s)\n+    base = orig.subs(y, w)\n+    and_dummy = base.subs(y, w)\n+    assert base == ConditionSet(y, y < 2, {w, z})\n+    assert and_dummy == ConditionSet(w, w < 2, {w, z})\n+\n     assert c.subs(x, w) == ConditionSet(w, w < 2, s)\n     assert ConditionSet(x, x < y, s\n         ).subs(y, w) == ConditionSet(x, x < w, s.subs(y, w))\n-\n+    # if the user uses assumptions that cause the condition\n+    # to evaluate, that can't be helped from SymPy's end\n+    n = Symbol('n', negative=True)\n+    assert ConditionSet(n, 0 < n, S.Integers) is S.EmptySet\n+    p = Symbol('p', positive=True)\n+    assert ConditionSet(n, n < y, S.Integers\n+        ).subs(n, x) == ConditionSet(x, x < y, S.Integers)\n+    nc = Symbol('nc', commutative=False)\n+    raises(ValueError, lambda: ConditionSet(\n+        x, x < p, S.Integers).subs(x, nc))\n+    raises(ValueError, lambda: ConditionSet(\n+        x, x < p, S.Integers).subs(x, n))\n+    raises(ValueError, lambda: ConditionSet(\n+        x + 1, x < 1, S.Integers))\n+    raises(ValueError, lambda: ConditionSet(\n+        x + 1, x < 1, s))\n+    assert ConditionSet(\n+        n, n < x, Interval(0, oo)).subs(x, p) == Interval(0, oo)\n+    assert ConditionSet(\n+        n, n < x, Interval(-oo, 0)).subs(x, p) == S.EmptySet\n+    assert ConditionSet(f(x), f(x) < 1, {w, z}\n+        ).subs(f(x), y) == ConditionSet(y, y < 1, {w, z})\n+\n+\n+def test_subs_CondSet_tebr():\n     # to eventually be removed\n     c = ConditionSet((x, y), {x + 1, x + y}, S.Reals)\n     assert c.subs(x, z) == c\n@@ -111,3 +153,18 @@ def test_dummy_eq():\n     assert c1.dummy_eq(c3) is False\n     assert c.dummy_eq(c1) is False\n     assert c1.dummy_eq(c) is False\n+\n+\n+def test_contains():\n+    assert 6 in ConditionSet(x, x > 5, Interval(1, 7))\n+    assert (8 in ConditionSet(x, y > 5, Interval(1, 7))) is False\n+    # `in` should give True or False; in this case there is not\n+    # enough information for that result\n+    raises(TypeError,\n+        lambda: 6 in ConditionSet(x, y > 5, Interval(1, 7)))\n+    assert ConditionSet(x, y > 5, Interval(1, 7)\n+        ).contains(6) == (y > 5)\n+    assert ConditionSet(x, y > 5, Interval(1, 7)\n+        ).contains(8) is S.false\n+    assert ConditionSet(x, y > 5, Interval(1, 7)\n+        ).contains(w) == And(w >= 1, w <= 7, y > 5)\n",
  "problem_statement": "ambiguous behavior of ConditionSet\n```\r\nHelp on class ConditionSet in module sympy.sets.conditionset:\r\n\r\nclass ConditionSet(sympy.sets.sets.Set)\r\n |  Set of elements which satisfies a given condition.\r\n |\r\n |  {x | condition(x) is True for x in S}\r\n\r\n...\r\n```\r\nDoes that mean the \"set of all x in S for which condition(x) is True\" or \"the set S if the condition(x) is True\"?\r\n```\r\n>>> c = ConditionSet(x,x>5,Interval(1,7))\r\n>>> c.subs(x,8)  # 8 is not in S\r\nInterval(1, 7)\r\n>>> 8 in c\r\nFalse\r\n\r\n>>> c = ConditionSet(x,x>5,S.Integers)\r\n>>> c.subs(x,2*pi)  # 2pi is not an integer\r\nS.Integers\r\n>>> 2*pi in c\r\nFalse\r\n\r\n>>> c=ConditionSet(y,x>5,S.Integers)\r\n>>> c.subs(x,4)\r\nEmptySet()\r\n>>> c.subs(x,6)\r\nS.Integers\r\n>>> 6 in c\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"...sympy\\sets\\sets.py\", line 556, in __contains__\r\n    raise TypeError('contains did not evaluate to a bool: %r' % symb)\r\nTypeError: contains did not evaluate to a bool: x > 5\r\n>>> 3 in c\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"...sympy\\sets\\sets.py\", line 556, in __contains__\r\n    raise TypeError('contains did not evaluate to a bool: %r' % symb)\r\nTypeError: contains did not evaluate to a bool: x > 5\r\n\r\nPerhaps an error at instantiation should be raise if the condition is not a function of the given variable?\r\n```\r\nAlso, should there be a doit method or autoevaluation for something like this?\r\n```\r\n>>> ConditionSet(x,x>5,Interval(1,3))\r\nConditionSet(x, x > 5, Interval(1, 3))  <--- should this evaluate to False?\r\n```\r\n\r\nOther fixes:\r\n`ConditionSet(x,x>5,Interval(1,7)).subs(x, 8)` should be S.EmptySet\r\n\r\n`ConditionSet(x,x>5,Interval(1,7)).subs(x, Symbol('n', negative=True)` should be unchanged: the dummy is not there to help with the condition, only to test idientify where the element from the base_set should be tested in the condition.\n",
  "hints_text": "It should mean  \"set of all x in S for which condition(x) is True\". The role of `x` is comparable to the role of an integration variable in a definite integral: It can be replaced by another symbol but it does not make sense to replace it by a number.\r\n\r\nI think `ConditionSet(x,x>5,Interval(1,3))` should evaluate to `EmptySet`.\nSo it's like a filter? If so, then ConditionSet(x, x> 5, S.Reals) -> Interval.open(5, oo). If I understand correctly, it is similar to ImageSet. We could write `ImageSet(Lambda(x, 2*x), S.Integers)` or `ConditionSet(x, Eq(Mod(x, 2), 0), S.Integers)` to mean \"the set of even integers\". A difference, however, is that the former is iterable:\r\n\r\n```\r\n>>> it = iter(ImageSet(Lambda(x, 2*x), S.Integers))\r\n>>> [next(it) for i in range(5)]\r\n[0, 2, −2, 4, −4]\r\n```\n`ConditionSet(x,x>5,Interval(1,7)).subs(x, 8)` should be S.EmptySet\r\n`ConditionSet(x,x>5,Interval(1,7)).subs(x, Symbol('n', negative=True)` should be unchanged: the dummy is not there to help with the condition, only to test idientify where the element from the `base_set` should be tested in the condition.\r\n",
  "created_at": "2018-03-26T20:09:34Z",
  "version": "1.1",
  "FAIL_TO_PASS": "[\"test_latex_ConditionSet\", \"test_CondSet\", \"test_subs_CondSet\"]",
  "PASS_TO_PASS": "[\"test_printmethod\", \"test_latex_basic\", \"test_latex_builtins\", \"test_latex_SingularityFunction\", \"test_latex_cycle\", \"test_latex_permutation\", \"test_latex_Float\", \"test_latex_vector_expressions\", \"test_latex_symbols\", \"test_latex_functions\", \"test_function_subclass_different_name\", \"test_hyper_printing\", \"test_latex_bessel\", \"test_latex_fresnel\", \"test_latex_brackets\", \"test_latex_indexed\", \"test_latex_derivatives\", \"test_latex_subs\", \"test_latex_integrals\", \"test_latex_sets\", \"test_latex_SetExpr\", \"test_latex_Range\", \"test_latex_sequences\", \"test_latex_FourierSeries\", \"test_latex_FormalPowerSeries\", \"test_latex_intervals\", \"test_latex_AccumuBounds\", \"test_latex_emptyset\", \"test_latex_commutator\", \"test_latex_union\", \"test_latex_symmetric_difference\", \"test_latex_Complement\", \"test_latex_Complexes\", \"test_latex_productset\", \"test_latex_Naturals\", \"test_latex_Naturals0\", \"test_latex_Integers\", \"test_latex_ImageSet\", \"test_latex_ComplexRegion\", \"test_latex_Contains\", \"test_latex_sum\", \"test_latex_product\", \"test_latex_limits\", \"test_latex_log\", \"test_issue_3568\", \"test_latex\", \"test_latex_dict\", \"test_latex_list\", \"test_latex_rational\", \"test_latex_inverse\", \"test_latex_DiracDelta\", \"test_latex_Heaviside\", \"test_latex_KroneckerDelta\", \"test_latex_LeviCivita\", \"test_mode\", \"test_latex_Piecewise\", \"test_latex_Matrix\", \"test_latex_matrix_with_functions\", \"test_latex_NDimArray\", \"test_latex_mul_symbol\", \"test_latex_issue_4381\", \"test_latex_issue_4576\", \"test_latex_pow_fraction\", \"test_noncommutative\", \"test_latex_order\", \"test_latex_Lambda\", \"test_latex_PolyElement\", \"test_latex_FracElement\", \"test_latex_Poly\", \"test_latex_Poly_order\", \"test_latex_ComplexRootOf\", \"test_latex_RootSum\", \"test_settings\", \"test_latex_numbers\", \"test_latex_euler\", \"test_lamda\", \"test_custom_symbol_names\", \"test_matAdd\", \"test_matMul\", \"test_latex_MatrixSlice\", \"test_latex_RandomDomain\", \"test_PrettyPoly\", \"test_integral_transforms\", \"test_PolynomialRingBase\", \"test_categories\", \"test_Modules\", \"test_QuotientRing\", \"test_Tr\", \"test_Adjoint\", \"test_Hadamard\", \"test_ZeroMatrix\", \"test_boolean_args_order\", \"test_imaginary\", \"test_builtins_without_args\", \"test_latex_greek_functions\", \"test_translate\", \"test_other_symbols\", \"test_modifiers\", \"test_greek_symbols\", \"test_builtin_no_args\", \"test_issue_6853\", \"test_Mul\", \"test_Pow\", \"test_issue_7180\", \"test_issue_8409\", \"test_issue_7117\", \"test_issue_2934\", \"test_issue_10489\", \"test_issue_12886\", \"test_issue_13651\", \"test_latex_UnevaluatedExpr\", \"test_MatrixElement_printing\", \"test_MatrixSymbol_printing\", \"test_Quaternion_latex_printing\", \"test_TensorProduct_printing\", \"test_CondSet_intersect\", \"test_issue_9849\", \"test_simplified_FiniteSet_in_CondSet\", \"test_free_symbols\", \"test_subs_CondSet_tebr\", \"test_dummy_eq\"]",
  "environment_setup_commit": "ec9e3c0436fbff934fa84e22bf07f1b3ef5bfac3",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.094288",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}