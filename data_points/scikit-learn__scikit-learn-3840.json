{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-3840",
  "base_commit": "6b5440a9964480ccb0fe1b59ab516d9228186571",
  "patch": "diff --git a/sklearn/metrics/ranking.py b/sklearn/metrics/ranking.py\n--- a/sklearn/metrics/ranking.py\n+++ b/sklearn/metrics/ranking.py\n@@ -217,7 +217,8 @@ def _binary_uninterpolated_average_precision(\n                                  sample_weight=sample_weight)\n \n \n-def roc_auc_score(y_true, y_score, average=\"macro\", sample_weight=None):\n+def roc_auc_score(y_true, y_score, average=\"macro\", sample_weight=None,\n+                  max_fpr=None):\n     \"\"\"Compute Area Under the Receiver Operating Characteristic Curve (ROC AUC)\n     from prediction scores.\n \n@@ -257,6 +258,10 @@ def roc_auc_score(y_true, y_score, average=\"macro\", sample_weight=None):\n     sample_weight : array-like of shape = [n_samples], optional\n         Sample weights.\n \n+    max_fpr : float > 0 and <= 1, optional\n+        If not ``None``, the standardized partial AUC [3]_ over the range\n+        [0, max_fpr] is returned.\n+\n     Returns\n     -------\n     auc : float\n@@ -269,6 +274,9 @@ def roc_auc_score(y_true, y_score, average=\"macro\", sample_weight=None):\n     .. [2] Fawcett T. An introduction to ROC analysis[J]. Pattern Recognition\n            Letters, 2006, 27(8):861-874.\n \n+    .. [3] `Analyzing a portion of the ROC curve. McClish, 1989\n+            <http://www.ncbi.nlm.nih.gov/pubmed/2668680>`_\n+\n     See also\n     --------\n     average_precision_score : Area under the precision-recall curve\n@@ -292,7 +300,25 @@ def _binary_roc_auc_score(y_true, y_score, sample_weight=None):\n \n         fpr, tpr, tresholds = roc_curve(y_true, y_score,\n                                         sample_weight=sample_weight)\n-        return auc(fpr, tpr)\n+        if max_fpr is None or max_fpr == 1:\n+            return auc(fpr, tpr)\n+        if max_fpr <= 0 or max_fpr > 1:\n+            raise ValueError(\"Expected max_frp in range ]0, 1], got: %r\"\n+                             % max_fpr)\n+\n+        # Add a single point at max_fpr by linear interpolation\n+        stop = np.searchsorted(fpr, max_fpr, 'right')\n+        x_interp = [fpr[stop - 1], fpr[stop]]\n+        y_interp = [tpr[stop - 1], tpr[stop]]\n+        tpr = np.append(tpr[:stop], np.interp(max_fpr, x_interp, y_interp))\n+        fpr = np.append(fpr[:stop], max_fpr)\n+        partial_auc = auc(fpr, tpr)\n+\n+        # McClish correction: standardize result to be 0.5 if non-discriminant\n+        # and 1 if maximal\n+        min_area = 0.5 * max_fpr**2\n+        max_area = max_fpr\n+        return 0.5 * (1 + (partial_auc - min_area) / (max_area - min_area))\n \n     y_type = type_of_target(y_true)\n     if y_type == \"binary\":\n",
  "test_patch": "diff --git a/sklearn/metrics/tests/test_common.py b/sklearn/metrics/tests/test_common.py\n--- a/sklearn/metrics/tests/test_common.py\n+++ b/sklearn/metrics/tests/test_common.py\n@@ -163,6 +163,7 @@\n     \"samples_roc_auc\": partial(roc_auc_score, average=\"samples\"),\n     \"micro_roc_auc\": partial(roc_auc_score, average=\"micro\"),\n     \"macro_roc_auc\": partial(roc_auc_score, average=\"macro\"),\n+    \"partial_roc_auc\": partial(roc_auc_score, max_fpr=0.5),\n \n     \"average_precision_score\": average_precision_score,\n     \"weighted_average_precision_score\":\n@@ -220,6 +221,7 @@\n     \"weighted_roc_auc\",\n     \"macro_roc_auc\",\n     \"samples_roc_auc\",\n+    \"partial_roc_auc\",\n \n     # with default average='binary', multiclass is prohibited\n     \"precision_score\",\n@@ -240,7 +242,7 @@\n \n # Threshold-based metrics with an \"average\" argument\n THRESHOLDED_METRICS_WITH_AVERAGING = [\n-    \"roc_auc_score\", \"average_precision_score\",\n+    \"roc_auc_score\", \"average_precision_score\", \"partial_roc_auc\",\n ]\n \n # Metrics with a \"pos_label\" argument\n@@ -297,7 +299,7 @@\n     \"unnormalized_log_loss\",\n \n     \"roc_auc_score\", \"weighted_roc_auc\", \"samples_roc_auc\",\n-    \"micro_roc_auc\", \"macro_roc_auc\",\n+    \"micro_roc_auc\", \"macro_roc_auc\", \"partial_roc_auc\",\n \n     \"average_precision_score\", \"weighted_average_precision_score\",\n     \"samples_average_precision_score\", \"micro_average_precision_score\",\ndiff --git a/sklearn/metrics/tests/test_ranking.py b/sklearn/metrics/tests/test_ranking.py\n--- a/sklearn/metrics/tests/test_ranking.py\n+++ b/sklearn/metrics/tests/test_ranking.py\n@@ -1,5 +1,6 @@\n from __future__ import division, print_function\n \n+import pytest\n import numpy as np\n from itertools import product\n import warnings\n@@ -148,6 +149,34 @@ def _average_precision_slow(y_true, y_score):\n     return average_precision\n \n \n+def _partial_roc_auc_score(y_true, y_predict, max_fpr):\n+    \"\"\"Alternative implementation to check for correctness of `roc_auc_score`\n+    with `max_fpr` set.\n+    \"\"\"\n+\n+    def _partial_roc(y_true, y_predict, max_fpr):\n+        fpr, tpr, _ = roc_curve(y_true, y_predict)\n+        new_fpr = fpr[fpr <= max_fpr]\n+        new_fpr = np.append(new_fpr, max_fpr)\n+        new_tpr = tpr[fpr <= max_fpr]\n+        idx_out = np.argmax(fpr > max_fpr)\n+        idx_in = idx_out - 1\n+        x_interp = [fpr[idx_in], fpr[idx_out]]\n+        y_interp = [tpr[idx_in], tpr[idx_out]]\n+        new_tpr = np.append(new_tpr, np.interp(max_fpr, x_interp, y_interp))\n+        return (new_fpr, new_tpr)\n+\n+    new_fpr, new_tpr = _partial_roc(y_true, y_predict, max_fpr)\n+    partial_auc = auc(new_fpr, new_tpr)\n+\n+    # Formula (5) from McClish 1989\n+    fpr1 = 0\n+    fpr2 = max_fpr\n+    min_area = 0.5 * (fpr2 - fpr1) * (fpr2 + fpr1)\n+    max_area = fpr2 - fpr1\n+    return 0.5 * (1 + (partial_auc - min_area) / (max_area - min_area))\n+\n+\n def test_roc_curve():\n     # Test Area under Receiver Operating Characteristic (ROC) curve\n     y_true, _, probas_pred = make_prediction(binary=True)\n@@ -1052,3 +1081,28 @@ def test_ranking_loss_ties_handling():\n     assert_almost_equal(label_ranking_loss([[1, 0, 0]], [[0.25, 0.5, 0.5]]), 1)\n     assert_almost_equal(label_ranking_loss([[1, 0, 1]], [[0.25, 0.5, 0.5]]), 1)\n     assert_almost_equal(label_ranking_loss([[1, 1, 0]], [[0.25, 0.5, 0.5]]), 1)\n+\n+\n+def test_partial_roc_auc_score():\n+    # Check `roc_auc_score` for max_fpr != `None`\n+    y_true = np.array([0, 0, 1, 1])\n+    assert roc_auc_score(y_true, y_true, max_fpr=1) == 1\n+    assert roc_auc_score(y_true, y_true, max_fpr=0.001) == 1\n+    with pytest.raises(ValueError):\n+        assert roc_auc_score(y_true, y_true, max_fpr=-0.1)\n+    with pytest.raises(ValueError):\n+        assert roc_auc_score(y_true, y_true, max_fpr=1.1)\n+    with pytest.raises(ValueError):\n+        assert roc_auc_score(y_true, y_true, max_fpr=0)\n+\n+    y_scores = np.array([0.1,  0,  0.1, 0.01])\n+    roc_auc_with_max_fpr_one = roc_auc_score(y_true, y_scores, max_fpr=1)\n+    unconstrained_roc_auc = roc_auc_score(y_true, y_scores)\n+    assert roc_auc_with_max_fpr_one == unconstrained_roc_auc\n+    assert roc_auc_score(y_true, y_scores, max_fpr=0.3) == 0.5\n+\n+    y_true, y_pred, _ = make_prediction(binary=True)\n+    for max_fpr in np.linspace(1e-4, 1, 5):\n+        assert_almost_equal(\n+            roc_auc_score(y_true, y_pred, max_fpr=max_fpr),\n+            _partial_roc_auc_score(y_true, y_pred, max_fpr))\n",
  "problem_statement": "partial AUC\nI suggest adding partial AUC to the metrics. this would compute the area under the curve up to a specified FPR (in the case of the ROC curve). this measure is important for comparing classifiers in cases where FPR is much more important than TPR. The partial AUC should also allow applying the McClish correction. see here: http://cran.r-project.org/web/packages/pROC/pROC.pdf\n\n",
  "hints_text": "+1\n\n+1\n\n@arjoly @mblondel is anyone working on this right now?\n\nHi,\n\nI'd like to help.\n\n@arjoly @mblondel @MechCoder , may I take this one?\n\nOnly if it is ok for you @MechCoder .\n\nYou can take this one. :-)\n\nsure :)\n\nOk! I'll try my best. :)\n\n@eyaler \nIn this pROC package, it is possible to choose between \"specificity\" (fpr) and \"sensitivity\" (tpr).\nAnd both are determined by an interval, e.g. [0.8, 1.0]\n\nShould I do the same?\n\n@karane\nthank you for taking this.\nI am only familiar with the use case of looking at the pAUC over an interval of low fpr (high specificity)\n\n@eyaler \nyou're welcome\n\nThat's Ok. I think I got it. :)\n\n@eyaler The partial AUC is indeed usually defined in the low FPR interval. This is also the way McClish described it in her seminal paper (in [McClish, 1989](http://www.ncbi.nlm.nih.gov/pubmed/2668680?dopt=Abstract&holding=f1000,f1000m,isrctn)). However it makes no sense to me why one wouldn't want it on the high TPR region too: at times TPR can be much more important than the FPR. See [Jiang, 1996](http://www.ncbi.nlm.nih.gov/pubmed/8939225?dopt=Abstract&holding=f1000,f1000m,isrctn) who first proposed to do this (afaik).\n\n@karane I would advise against defining it on an interval where both bounds can be changed: it makes the implementation much more tricky, and I haven't seen any case where it is actually useful. Just define it on the TPR interval [0.0, X](and on the FPR interval [X, 1.0]) where only X can be changed. In that case the trapezoid computation is pretty straightforward, most code in the auc function in pROC is there to deal with the multiple edge cases raised by releasing the second bound too.\n\n+1\n",
  "created_at": "2014-11-07T23:15:42Z",
  "version": "0.20",
  "FAIL_TO_PASS": "[\"sklearn/metrics/tests/test_common.py::test_sample_order_invariance_multilabel_and_multioutput\", \"sklearn/metrics/tests/test_common.py::test_invariance_string_vs_numbers_labels\", \"sklearn/metrics/tests/test_common.py::test_inf_nan_input\", \"sklearn/metrics/tests/test_ranking.py::test_partial_roc_auc_score\"]",
  "PASS_TO_PASS": "[\"sklearn/metrics/tests/test_common.py::test_symmetry\", \"sklearn/metrics/tests/test_common.py::test_sample_order_invariance\", \"sklearn/metrics/tests/test_common.py::test_format_invariance_with_1d_vectors\", \"sklearn/metrics/tests/test_common.py::test_multioutput_number_of_output_differ\", \"sklearn/metrics/tests/test_common.py::test_multioutput_regression_invariance_to_dimension_shuffling\", \"sklearn/metrics/tests/test_common.py::test_multilabel_representation_invariance\", \"sklearn/metrics/tests/test_common.py::test_raise_value_error_multilabel_sequences\", \"sklearn/metrics/tests/test_common.py::test_normalize_option_binary_classification\", \"sklearn/metrics/tests/test_common.py::test_normalize_option_multiclass_classification\", \"sklearn/metrics/tests/test_common.py::test_normalize_option_multilabel_classification\", \"sklearn/metrics/tests/test_common.py::test_no_averaging_labels\", \"sklearn/metrics/tests/test_ranking.py::test_roc_curve\", \"sklearn/metrics/tests/test_ranking.py::test_roc_curve_end_points\", \"sklearn/metrics/tests/test_ranking.py::test_roc_returns_consistency\", \"sklearn/metrics/tests/test_ranking.py::test_roc_curve_multi\", \"sklearn/metrics/tests/test_ranking.py::test_roc_curve_confidence\", \"sklearn/metrics/tests/test_ranking.py::test_roc_curve_hard\", \"sklearn/metrics/tests/test_ranking.py::test_roc_curve_one_label\", \"sklearn/metrics/tests/test_ranking.py::test_roc_curve_toydata\", \"sklearn/metrics/tests/test_ranking.py::test_roc_curve_drop_intermediate\", \"sklearn/metrics/tests/test_ranking.py::test_roc_curve_fpr_tpr_increasing\", \"sklearn/metrics/tests/test_ranking.py::test_auc\", \"sklearn/metrics/tests/test_ranking.py::test_auc_duplicate_values\", \"sklearn/metrics/tests/test_ranking.py::test_auc_errors\", \"sklearn/metrics/tests/test_ranking.py::test_deprecated_auc_reorder\", \"sklearn/metrics/tests/test_ranking.py::test_auc_score_non_binary_class\", \"sklearn/metrics/tests/test_ranking.py::test_binary_clf_curve\", \"sklearn/metrics/tests/test_ranking.py::test_precision_recall_curve\", \"sklearn/metrics/tests/test_ranking.py::test_precision_recall_curve_pos_label\", \"sklearn/metrics/tests/test_ranking.py::test_precision_recall_curve_errors\", \"sklearn/metrics/tests/test_ranking.py::test_precision_recall_curve_toydata\", \"sklearn/metrics/tests/test_ranking.py::test_average_precision_constant_values\", \"sklearn/metrics/tests/test_ranking.py::test_score_scale_invariance\", \"sklearn/metrics/tests/test_ranking.py::test_coverage_error\", \"sklearn/metrics/tests/test_ranking.py::test_coverage_tie_handling\", \"sklearn/metrics/tests/test_ranking.py::test_label_ranking_loss\", \"sklearn/metrics/tests/test_ranking.py::test_ranking_appropriate_input_shape\", \"sklearn/metrics/tests/test_ranking.py::test_ranking_loss_ties_handling\"]",
  "environment_setup_commit": "55bf5d93e5674f13a1134d93a11fd0cd11aabcd1",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.026731",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}