{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-14067",
  "base_commit": "7b8cbc875b862ebb81a9b3415bdee235cca99ca6",
  "patch": "diff --git a/sklearn/externals/_scipy_linalg.py b/sklearn/externals/_scipy_linalg.py\nnew file mode 100644\n--- /dev/null\n+++ b/sklearn/externals/_scipy_linalg.py\n@@ -0,0 +1,118 @@\n+# This should remained pinned to version 1.2 and not updated like other\n+# externals.\n+\"\"\"Copyright (c) 2001-2002 Enthought, Inc.  2003-2019, SciPy Developers.\n+All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions\n+are met:\n+\n+1. Redistributions of source code must retain the above copyright\n+   notice, this list of conditions and the following disclaimer.\n+\n+2. Redistributions in binary form must reproduce the above\n+   copyright notice, this list of conditions and the following\n+   disclaimer in the documentation and/or other materials provided\n+   with the distribution.\n+\n+3. Neither the name of the copyright holder nor the names of its\n+   contributors may be used to endorse or promote products derived\n+   from this software without specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\"\"\"\n+\n+import numpy as np\n+import scipy.linalg.decomp as decomp\n+\n+\n+def pinvh(a, cond=None, rcond=None, lower=True, return_rank=False,\n+          check_finite=True):\n+    \"\"\"\n+    Compute the (Moore-Penrose) pseudo-inverse of a Hermitian matrix.\n+\n+    Copied in from scipy==1.2.2, in order to preserve the default choice of the\n+    `cond` and `above_cutoff` values which determine which values of the matrix\n+    inversion lie below threshold and are so set to zero. Changes in scipy 1.3\n+    resulted in a smaller default threshold and thus slower convergence of\n+    dependent algorithms in some cases (see Sklearn github issue #14055).\n+\n+    Calculate a generalized inverse of a Hermitian or real symmetric matrix\n+    using its eigenvalue decomposition and including all eigenvalues with\n+    'large' absolute value.\n+\n+    Parameters\n+    ----------\n+    a : (N, N) array_like\n+        Real symmetric or complex hermetian matrix to be pseudo-inverted\n+    cond, rcond : float or None\n+        Cutoff for 'small' eigenvalues.\n+        Singular values smaller than rcond * largest_eigenvalue are considered\n+        zero.\n+\n+        If None or -1, suitable machine precision is used.\n+    lower : bool, optional\n+        Whether the pertinent array data is taken from the lower or upper\n+        triangle of a. (Default: lower)\n+    return_rank : bool, optional\n+        if True, return the effective rank of the matrix\n+    check_finite : bool, optional\n+        Whether to check that the input matrix contains only finite numbers.\n+        Disabling may give a performance gain, but may result in problems\n+        (crashes, non-termination) if the inputs do contain infinities or NaNs.\n+\n+    Returns\n+    -------\n+    B : (N, N) ndarray\n+        The pseudo-inverse of matrix `a`.\n+    rank : int\n+        The effective rank of the matrix.  Returned if return_rank == True\n+\n+    Raises\n+    ------\n+    LinAlgError\n+        If eigenvalue does not converge\n+\n+    Examples\n+    --------\n+    >>> from scipy.linalg import pinvh\n+    >>> a = np.random.randn(9, 6)\n+    >>> a = np.dot(a, a.T)\n+    >>> B = pinvh(a)\n+    >>> np.allclose(a, np.dot(a, np.dot(B, a)))\n+    True\n+    >>> np.allclose(B, np.dot(B, np.dot(a, B)))\n+    True\n+\n+    \"\"\"\n+    a = decomp._asarray_validated(a, check_finite=check_finite)\n+    s, u = decomp.eigh(a, lower=lower, check_finite=False)\n+\n+    if rcond is not None:\n+        cond = rcond\n+    if cond in [None, -1]:\n+        t = u.dtype.char.lower()\n+        factor = {'f': 1E3, 'd': 1E6}\n+        cond = factor[t] * np.finfo(t).eps\n+\n+    # For Hermitian matrices, singular values equal abs(eigenvalues)\n+    above_cutoff = (abs(s) > cond * np.max(abs(s)))\n+    psigma_diag = 1.0 / s[above_cutoff]\n+    u = u[:, above_cutoff]\n+\n+    B = np.dot(u * psigma_diag, np.conjugate(u).T)\n+\n+    if return_rank:\n+        return B, len(psigma_diag)\n+    else:\n+        return B\ndiff --git a/sklearn/linear_model/bayes.py b/sklearn/linear_model/bayes.py\n--- a/sklearn/linear_model/bayes.py\n+++ b/sklearn/linear_model/bayes.py\n@@ -8,12 +8,12 @@\n from math import log\n import numpy as np\n from scipy import linalg\n-from scipy.linalg import pinvh\n \n from .base import LinearModel, _rescale_data\n from ..base import RegressorMixin\n from ..utils.extmath import fast_logdet\n from ..utils import check_X_y\n+from ..utils.fixes import pinvh\n \n \n ###############################################################################\ndiff --git a/sklearn/utils/fixes.py b/sklearn/utils/fixes.py\n--- a/sklearn/utils/fixes.py\n+++ b/sklearn/utils/fixes.py\n@@ -45,6 +45,13 @@ def _parse_version(version_string):\n     # once support for sp_version < (1, 3) is dropped\n     from ..externals._lobpcg import lobpcg  # noqa\n \n+if sp_version >= (1, 3):\n+    # Preserves earlier default choice of pinvh cutoff `cond` value.\n+    # Can be removed once issue #14055 is fully addressed.\n+    from ..externals._scipy_linalg import pinvh\n+else:\n+    from scipy.linalg import pinvh # noqa\n+\n if sp_version >= (0, 19):\n     def _argmax(arr_or_spmatrix, axis=None):\n         return arr_or_spmatrix.argmax(axis=axis)\n",
  "test_patch": "diff --git a/sklearn/linear_model/tests/test_bayes.py b/sklearn/linear_model/tests/test_bayes.py\n--- a/sklearn/linear_model/tests/test_bayes.py\n+++ b/sklearn/linear_model/tests/test_bayes.py\n@@ -200,6 +200,24 @@ def test_toy_ard_object():\n     assert_array_almost_equal(clf.predict(test), [1, 3, 4], 2)\n \n \n+def test_ard_accuracy_on_easy_problem():\n+    # Check that ARD converges with reasonable accuracy on an easy problem\n+    # (Github issue #14055)\n+    # This particular seed seems to converge poorly in the failure-case\n+    # (scipy==1.3.0, sklearn==0.21.2)\n+    seed = 45\n+    X = np.random.RandomState(seed=seed).normal(size=(250, 3))\n+    y = X[:, 1]\n+\n+    regressor = ARDRegression()\n+    regressor.fit(X, y)\n+\n+    abs_coef_error = np.abs(1 - regressor.coef_[1])\n+    # Expect an accuracy of better than 1E-4 in most cases -\n+    # Failure-case produces 0.16!\n+    assert abs_coef_error < 0.01\n+\n+\n def test_return_std():\n     # Test return_std option for both Bayesian regressors\n     def f(X):\n",
  "problem_statement": "ARD Regressor accuracy degrades when upgrading Scipy 1.2.1 -> 1.3.0\nHi, \r\nbit of a tricky one, I'm hoping someone will have some time and/or suggestions for further investigation!\r\n\r\nThere seems to be an often-occurring worsening of performance (i.e. accuracy, although run-time increases too!) from the ARD regressor when upgrading from Scipy 1.2.1 -> 1.3.0. \r\n\r\n## Description\r\nOn a very simple dataset (see code snippets below) where a near-perfect fit should be achievable, typical error seems to degrade from order 1E-5 to 1E-2. Notably, convergence iterations seem to increase also from ~a few (~5) to around 50-200 iterations.\r\n\r\nHere's the headline plot, plotting absolute co-efficient error when fit across 1000 datasets generated with different random seeds:\r\n![coeff_abs_error_histograms](https://user-images.githubusercontent.com/1352905/59188556-cc7ebf00-8b6f-11e9-9be1-0de44f4beaee.png)\r\n\r\nNote how with Scipy==1.2.1, errors are largely constrained to <0.01, while with Scipy==1.3.0 they range up to 0.05 (and in a few rare cases the algorithm produces garbage results, see later).\r\n\r\nI guess this could be (probably is?) a Scipy rather than Sklearn issue, but probably the only way to confirm / isolate that would be to start here.\r\n\r\nIt's also possible that this worsening of behaviour is a weirdness of my particular toy example, but the difference in behaviour seems large and unexpected enough to warrant further investigation, I'd hope!\r\n\r\n## Steps/Code to Reproduce\r\n### Single Seed:\r\nOK, so here's a short snippet on just a single seed if you're curious to try this yourself. I'm generating three vectors of normally distributed values, 250 samples. Then the target is just a perfect copy of one of those vectors (index=1). We measure the accuracy of the fit by simply checking how close that coefficient is to 1.0 (the other coefficients always shrink to 0., as you'd hope):\r\n\r\n```\r\nimport scipy\r\nimport sklearn\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\nfrom sklearn.linear_model import ARDRegression\r\n\r\nsklearn.show_versions()\r\n\r\ndef test_ard_regressor(dataset: np.ndarray) -> float:\r\n    X = dataset\r\n    y = X[:,1]\r\n    regressor = ARDRegression(verbose=True)\r\n    regressor.fit(X, y)\r\n    abs_coef_error = np.abs(1 - regressor.coef_[1])\r\n    print(abs_coef_error)\r\n    return abs_coef_error\r\n\r\nsize=250\r\nX = np.random.RandomState(seed=45).normal(size=(size,3))\r\n\r\ntest_ard_regressor(X)\r\n```\r\n\r\n#### Results\r\nScipy 1.2.1:\r\n```\r\npython single_seed.py \r\n\r\nSystem:\r\n    python: 3.6.7 (default, Oct 22 2018, 11:32:17)  [GCC 8.2.0]\r\nexecutable: /home/staley/.virtualenvs/sklearn-bug-scipy-1.2.1/bin/python\r\n   machine: Linux-4.15.0-47-generic-x86_64-with-Ubuntu-18.04-bionic\r\n\r\nBLAS:\r\n    macros: HAVE_CBLAS=None\r\n  lib_dirs: /usr/lib/x86_64-linux-gnu\r\ncblas_libs: openblas, openblas\r\n\r\nPython deps:\r\n       pip: 19.1.1\r\nsetuptools: 41.0.1\r\n   sklearn: 0.21.2\r\n     numpy: 1.16.4\r\n     scipy: 1.2.1\r\n    Cython: None\r\n    pandas: None\r\nConverged after 4 iterations\r\n9.647701516568574e-07\r\n```\r\n\r\nScipy 1.3.0\r\n```\r\npython single_seed.py \r\n\r\nSystem:\r\n    python: 3.6.7 (default, Oct 22 2018, 11:32:17)  [GCC 8.2.0]\r\nexecutable: /home/staley/.virtualenvs/sklearn-bug-scipy-1.3/bin/python\r\n   machine: Linux-4.15.0-47-generic-x86_64-with-Ubuntu-18.04-bionic\r\n\r\nBLAS:\r\n    macros: HAVE_CBLAS=None\r\n  lib_dirs: /usr/lib/x86_64-linux-gnu\r\ncblas_libs: openblas, openblas\r\n\r\nPython deps:\r\n       pip: 19.1.1\r\nsetuptools: 41.0.1\r\n   sklearn: 0.21.2\r\n     numpy: 1.16.4\r\n     scipy: 1.3.0\r\n    Cython: None\r\n    pandas: None\r\nConverged after 18 iterations\r\n0.16538104739325354\r\n\r\n```\r\n\r\n### Datasets from 1000 different seeds\r\nIt could be that there's some oddity of the random data from a single seed, so I set up some short scripts to first generate a static collection of 1000 of the datasets as seen above, then collate the results from both versions of scipy. The snippets are as follows:\r\n\r\nMake data:\r\n```\r\nimport numpy as np\r\nsize=250\r\nrandom_datasets = {seed: np.random.RandomState(seed).normal(size=(size,3)) \r\n                   for seed in range(1000)}\r\nnp.savez('random_datasets.npz', data=list(random_datasets.values()), seeds=list(random_datasets.keys()))\r\n```\r\n\r\nTest sklearn:\r\n```\r\nimport scipy\r\nimport sklearn\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\nfrom sklearn.linear_model import ARDRegression\r\n\r\nrandom_datasets = np.load('random_datasets.npz')\r\nrandom_datasets=dict(zip(random_datasets['seeds'], random_datasets['data']))\r\n\r\ndef test_ard_regressor(dataset: np.ndarray) -> float:\r\n    X = dataset\r\n    y = X[:,1]\r\n    regressor = ARDRegression(verbose=True)\r\n    regressor.fit(X, y)\r\n    abs_coef_error = np.abs(1 - regressor.coef_[1])\r\n    print(abs_coef_error)\r\n    return abs_coef_error\r\n\r\nresults = []\r\nfor seed, data in random_datasets.items():\r\n    print(\"Seed:\",seed)\r\n    results.append(test_ard_regressor(data))\r\n\r\nnp.save(f'scipy_{scipy.__version__}_results', np.array(results))\r\n```\r\n\r\nPlot results:\r\n```\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\nresults_1_2_1 = np.load(\"./scipy_1.2.1_results.npy\")\r\nresults_1_3_0 = np.load(\"./scipy_1.3.0_results.npy\")\r\n\r\ncounts, bin_edges = np.histogram(results_1_2_1)\r\n\r\nax = plt.gca()\r\nax.hist(results_1_2_1, label=\"scipy==1.2.1\", alpha=0.5, bins=bin_edges)\r\nax.hist(results_1_3_0, label=\"scipy==1.3.0\", alpha=0.5, bins=bin_edges)\r\n# ax.set_xlim(0, 1.0)\r\nax.legend()\r\nplt.show()\r\n```\r\n\r\nA little investigating summary statistics of those datasets in notebook gives the following points of comparison:\r\n```\r\n> np.median(results_1_2_1)\r\n1.1909624002770514e-05\r\n> np.median(results_1_3_0)\r\n0.008368892887510193\r\n\r\n>np.percentile(results_1_2_1, 99)\r\n0.03166983391537859\r\n>np.percentile(results_1_3_0, 99)\r\n0.16551247976283737\r\n\r\n\r\n> results_1_2_1.max()\r\n0.08478086928684647\r\n>results_1_3_0.max()\r\n46606.5545533851 \r\n\r\n```\r\n\n",
  "hints_text": "Thanks for the report. After a quick check `ARDRegression` uses `pinvh` from scipy. The cutoff factor for small singular values  was recently changed in https://github.com/scipy/scipy/pull/10067 it might be worth setting the previous value in scikit-learn code and see if that allows you to reproduce previous results.\nThanks for the suggestion, I'll see if I can pin that down.\nthat's not the first time this change is causing issues in our code https://github.com/scikit-learn/scikit-learn/pull/13903\nYep, a quick-and-dirty [patch](https://github.com/timstaley/scikit-learn/commit/742392269794167ba329b889d77947dd391692fc) confirms this is due to the aforementioned pinvh cond changes \r\n(https://github.com/scipy/scipy/pull/10067)\r\n\r\nI'll try and clean that up into something more readable and maintainable, making it clear what's a 'choose_pinvh_cutoff' subroutine and that the current option is to just match default scipy behaviour pre 1.3.0.\r\nThat should revert the accuracy regression, while leaving room if anyone wants to have a think about a more rigorous approach to computing a sensible pinvh cutoff value (not something I'm up to speed on personally).",
  "created_at": "2019-06-11T14:13:50Z",
  "version": "0.22",
  "FAIL_TO_PASS": "[\"sklearn/linear_model/tests/test_bayes.py::test_ard_accuracy_on_easy_problem\"]",
  "PASS_TO_PASS": "[\"sklearn/linear_model/tests/test_bayes.py::test_n_iter\", \"sklearn/linear_model/tests/test_bayes.py::test_bayesian_ridge_scores\", \"sklearn/linear_model/tests/test_bayes.py::test_bayesian_ridge_score_values\", \"sklearn/linear_model/tests/test_bayes.py::test_bayesian_ridge_parameter\", \"sklearn/linear_model/tests/test_bayes.py::test_bayesian_sample_weights\", \"sklearn/linear_model/tests/test_bayes.py::test_toy_bayesian_ridge_object\", \"sklearn/linear_model/tests/test_bayes.py::test_bayesian_initial_params\", \"sklearn/linear_model/tests/test_bayes.py::test_prediction_bayesian_ridge_ard_with_constant_input\", \"sklearn/linear_model/tests/test_bayes.py::test_std_bayesian_ridge_ard_with_constant_input\", \"sklearn/linear_model/tests/test_bayes.py::test_update_of_sigma_in_ard\", \"sklearn/linear_model/tests/test_bayes.py::test_toy_ard_object\", \"sklearn/linear_model/tests/test_bayes.py::test_return_std\"]",
  "environment_setup_commit": "7e85a6d1f038bbb932b36f18d75df6be937ed00d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.002048",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}