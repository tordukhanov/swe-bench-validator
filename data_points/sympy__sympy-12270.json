{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-12270",
  "base_commit": "a79801c044c2b0ed74176e4abc18f4ca2b38ac58",
  "patch": "diff --git a/sympy/core/expr.py b/sympy/core/expr.py\n--- a/sympy/core/expr.py\n+++ b/sympy/core/expr.py\n@@ -11,7 +11,6 @@\n \n from collections import defaultdict\n \n-\n class Expr(Basic, EvalfMixin):\n     \"\"\"\n     Base class for algebraic expressions.\n@@ -1940,6 +1939,8 @@ def extract_multiplicatively(self, c):\n            x/6\n \n         \"\"\"\n+        from .function import _coeff_isneg\n+\n         c = sympify(c)\n         if self is S.NaN:\n             return None\n@@ -1947,15 +1948,18 @@ def extract_multiplicatively(self, c):\n             return self\n         elif c == self:\n             return S.One\n+\n         if c.is_Add:\n             cc, pc = c.primitive()\n             if cc is not S.One:\n                 c = Mul(cc, pc, evaluate=False)\n+\n         if c.is_Mul:\n             a, b = c.as_two_terms()\n             x = self.extract_multiplicatively(a)\n             if x is not None:\n                 return x.extract_multiplicatively(b)\n+\n         quotient = self / c\n         if self.is_Number:\n             if self is S.Infinity:\n@@ -1998,16 +2002,31 @@ def extract_multiplicatively(self, c):\n                 return quotient\n         elif self.is_Add:\n             cs, ps = self.primitive()\n-            if cs is not S.One:\n-                return Mul(cs, ps, evaluate=False).extract_multiplicatively(c)\n+            # assert cs >= 1\n+            if c.is_Number and c is not S.NegativeOne:\n+                # assert c != 1 (handled at top)\n+                if cs is not S.One:\n+                    if c.is_negative:\n+                        xc = -(cs.extract_multiplicatively(-c))\n+                    else:\n+                        xc = cs.extract_multiplicatively(c)\n+                    if xc is not None:\n+                        return xc*ps  # rely on 2-arg Mul to restore Add\n+                return  # |c| != 1 can only be extracted from cs\n+            if c == ps:\n+                return cs\n+            # check args of ps\n             newargs = []\n-            for arg in self.args:\n+            for arg in ps.args:\n                 newarg = arg.extract_multiplicatively(c)\n-                if newarg is not None:\n-                    newargs.append(newarg)\n-                else:\n-                    return None\n-            return Add(*newargs)\n+                if newarg is None:\n+                    return  # all or nothing\n+                newargs.append(newarg)\n+            # args should be in same order so use unevaluated return\n+            if cs is not S.One:\n+                return Add._from_args([cs*t for t in newargs])\n+            else:\n+                return Add._from_args(newargs)\n         elif self.is_Mul:\n             args = list(self.args)\n             for i, arg in enumerate(args):\n",
  "test_patch": "diff --git a/sympy/core/tests/test_expr.py b/sympy/core/tests/test_expr.py\n--- a/sympy/core/tests/test_expr.py\n+++ b/sympy/core/tests/test_expr.py\n@@ -1012,6 +1012,12 @@ def test_extractions():\n     assert (sqrt(x)).extract_multiplicatively(x) is None\n     assert (sqrt(x)).extract_multiplicatively(1/x) is None\n     assert x.extract_multiplicatively(-x) is None\n+    assert (-2 - 4*I).extract_multiplicatively(-2) == 1 + 2*I\n+    assert (-2 - 4*I).extract_multiplicatively(3) is None\n+    assert (-2*x - 4*y - 8).extract_multiplicatively(-2) == x + 2*y + 4\n+    assert (-2*x*y - 4*x**2*y).extract_multiplicatively(-2*y) == 2*x**2 + x\n+    assert (2*x*y + 4*x**2*y).extract_multiplicatively(2*y) == 2*x**2 + x\n+    assert (-4*y**2*x).extract_multiplicatively(-3*y) is None\n \n     assert ((x*y)**3).extract_additively(1) is None\n     assert (x + 1).extract_additively(x) == 1\n",
  "problem_statement": "cannot extract_multiplicatively(-2) from (-2*x - 2*y)\nI think this might be a bug.\r\n````\r\n>>> (2+4*I).extract_multiplicatively(2)    # yes\r\n1 + 2*I\r\n>>> (-2-4*I).extract_multiplicatively(-1)   # yes\r\n2 + 4*I\r\n>>> (-2-4*I).extract_multiplicatively(-2)   # bug?\r\n````\r\nsimilarly:\r\n````\r\n>>> (2*x + 4*y + 8).extract_multiplicatively(2)   # yes\r\nx + 2*y + 4\r\n>>> (-2*x - 4*y - 8).extract_multiplicatively(2)    # yes\r\n-x - 2*y - 4\r\n>>> (-2*x - 4*y - 8).extract_multiplicatively(-1)    # yes\r\n2*x + 4*y + 8\r\n>>> (-2*x - 4*y - 8).extract_multiplicatively(-2)    # bug?\r\n````\r\n\r\nAssuming it is indeed a bug, here is why it happens:\r\n\r\nLook in `core/expr.py` where:\r\n````\r\n>>> (-2*x - 4*y - 8).primitive()\r\n(2, -x - 2*y - 4)\r\n````\r\nwhich is then made into a *non-evaluated* `Mul`, from which `-2` cannot be multiplicatively extracted; for example:\r\n````\r\n>>> Mul(2, -x).extract_multiplicatively(-2)\r\nx\r\n>>> Mul(2, -x, evaluate=False).extract_multiplicatively(-2)\r\n````\r\n@smichr do you think this is bug? (see your commit 8968b85310506c0a2b34f3d7aeb8e0d88f87885b: not clear whether we still need this special case anyway)\n",
  "hints_text": "I would like to work on this issue. Please help me to start with it!\nI do not understand why do we need \r\n`elif self.is_positive and quotient.is_negative:\r\n                    return None`\r\nin line 1975-76 of `sympy/core/expr.py` ?? \r\nAs mentioned in the doc of the function `extract_multiplicatively`, If it is to preserve the properties of args of self(i.e., if self being a positive number, result should be positive), then what about the args of `-2-4*I` here??\r\n```>>> (-2-4*I).extract_multiplicatively(-1)   # yes```\r\n``` 2 + 4*I```\r\n\nI'm not an expert so this is not much of an answer...  See `could_extract_minus_sign()` for an example of something that uses this.  You could also try dropping that `elif` and running the tests: I think you'll see endless recursion b/c this is used internally in various algorithms.\r\n\r\n> then what about the args of `-2-4*I` here??\r\n\r\nThat thing is an `Add`.  It should try to extract `-1` from each of the things in the `Add`.  In this case that is `-2` and `Mul(-4, I)`, each of which can have `-1` extracted from it.  (I think same should be true for `-2`, hence I filed this bug).\n> I think same should be true for -2 \r\n\r\n This is what I thought it should work for, if it works fine for -1. But then what about the properties of arguments of self (the signs will then then be reversed )?? \r\nIf we intend to preserve the properties, I think it shouldn't work for -1 as well!\nMaybe those docs are vague, ignore. Could_extract_minus_sign definitely replies on the -1 to keep working.\nSorry \"relies\" not replies\nwell i have worked on it and noticed that extract_multiplicatively works fine if you give second argument as positive..and if you give negative value there are many cases where it fails...\r\nFor example \r\n`>>> f=x**3*y**2\r\n >>> f.extract_multiplicatively(x*y)\r\n >>> x**2*y\r\n >>> f.extract_multiplicatively(-x*y)\r\n >>>\r\n`\r\n\nThat looks like the correct behaviour: there is no minus sign in `x**3*y**2` so cannot extract.\r\n\r\nMy understanding of `.extract_multiplicatively(-1)` is something like \"would a human factor a minus sign out of this expression?\"\nPut another way (and as I think I've said above at least once), if you could extract a \"-1\" from `x*y` then `.could_extract_minus_sign` would fail the `{e, -e}` thing explained in its docs.\n> do you think this is bug\r\n\r\nYes. Consider:\r\n\r\n```\r\n>>> (-2-4*x).extract_multiplicatively(1+2*x)\r\n>>> (-2-4*x).extract_multiplicatively(-1-2*x)\r\n2\r\n```\r\n\r\nIt allows a negative expression to be extracted. It seems that it should allow a bare negative to be extracted. I think I would change the routine by just recasting the input. Something like\r\n\r\n```\r\ngiven expr, test\r\nif test.is_Number and test < 0:\r\n  return (-expr).extract_multiplicatively(-test)\r\n```\n@smichr, I think the recasting you suggested would fail in the following test case.\r\n```\r\n>>> (2*x).extract_multiplicatively(-1)\r\n-2*x\r\n```\r\nBut this should have been ```None```.\r\n\n> I think the recasting you suggested would fail\r\n\r\nYes. What about doing something like\r\n\r\n```\r\nfrom sympy.core.function import _coeff_isneg as f\r\nif test < 0 and all(f(t) for t in Add.make_args(expr)):\r\n    return (-expr).extract_multiplicatively(-test)\r\n```",
  "created_at": "2017-03-09T06:53:11Z",
  "version": "1.0",
  "FAIL_TO_PASS": "[\"test_extractions\"]",
  "PASS_TO_PASS": "[\"test_basic\", \"test_ibasic\", \"test_relational_assumptions\", \"test_relational_noncommutative\", \"test_basic_nostr\", \"test_atoms\", \"test_is_polynomial\", \"test_is_rational_function\", \"test_is_algebraic_expr\", \"test_SAGE1\", \"test_SAGE2\", \"test_SAGE3\", \"test_len\", \"test_doit\", \"test_attribute_error\", \"test_args\", \"test_noncommutative_expand_issue_3757\", \"test_as_numer_denom\", \"test_as_independent\", \"test_replace\", \"test_find\", \"test_count\", \"test_has_basics\", \"test_has_multiple\", \"test_has_piecewise\", \"test_has_iterative\", \"test_has_integrals\", \"test_has_tuple\", \"test_has_units\", \"test_has_polys\", \"test_has_physics\", \"test_as_poly_as_expr\", \"test_nonzero\", \"test_is_number\", \"test_as_coeff_add\", \"test_as_coeff_mul\", \"test_nan_extractions\", \"test_coeff\", \"test_coeff2\", \"test_coeff2_0\", \"test_coeff_expand\", \"test_integrate\", \"test_as_base_exp\", \"test_issue_4963\", \"test_as_powers_dict\", \"test_as_coefficients_dict\", \"test_args_cnc\", \"test_new_rawargs\", \"test_issue_5226\", \"test_free_symbols\", \"test_issue_5300\", \"test_floordiv\", \"test_as_coeff_Mul\", \"test_as_coeff_Add\", \"test_expr_sorting\", \"test_as_ordered_factors\", \"test_sort_key_atomic_expr\", \"test_primitive\", \"test_issue_5843\", \"test_random\", \"test_round\", \"test_held_expression_UnevaluatedExpr\", \"test_round_exception_nostr\", \"test_extract_branch_factor\", \"test_identity_removal\", \"test_float_0\", \"test_issue_6325\", \"test_issue_7426\", \"test_issue_1112\", \"test_issue_10161\", \"test_issue_10755\"]",
  "environment_setup_commit": "50b81f9f6be151014501ffac44e5dc6b2416938f",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.076490",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}