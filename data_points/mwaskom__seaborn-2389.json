{
  "repo": "mwaskom/seaborn",
  "instance_id": "mwaskom__seaborn-2389",
  "base_commit": "bcdac5411a1b71ff8d4a2fd12a937c129513e79e",
  "patch": "diff --git a/seaborn/matrix.py b/seaborn/matrix.py\n--- a/seaborn/matrix.py\n+++ b/seaborn/matrix.py\n@@ -38,22 +38,15 @@ def _index_to_ticklabels(index):\n \n def _convert_colors(colors):\n     \"\"\"Convert either a list of colors or nested lists of colors to RGB.\"\"\"\n-    to_rgb = mpl.colors.colorConverter.to_rgb\n-\n-    if isinstance(colors, pd.DataFrame):\n-        # Convert dataframe\n-        return pd.DataFrame({col: colors[col].map(to_rgb)\n-                            for col in colors})\n-    elif isinstance(colors, pd.Series):\n-        return colors.map(to_rgb)\n-    else:\n-        try:\n-            to_rgb(colors[0])\n-            # If this works, there is only one level of colors\n-            return list(map(to_rgb, colors))\n-        except ValueError:\n-            # If we get here, we have nested lists\n-            return [list(map(to_rgb, l)) for l in colors]\n+    to_rgb = mpl.colors.to_rgb\n+\n+    try:\n+        to_rgb(colors[0])\n+        # If this works, there is only one level of colors\n+        return list(map(to_rgb, colors))\n+    except ValueError:\n+        # If we get here, we have nested lists\n+        return [list(map(to_rgb, l)) for l in colors]\n \n \n def _matrix_mask(data, mask):\n@@ -93,7 +86,7 @@ def _matrix_mask(data, mask):\n     return mask\n \n \n-class _HeatMapper(object):\n+class _HeatMapper:\n     \"\"\"Draw a heatmap plot of a matrix with nice labels and colormaps.\"\"\"\n \n     def __init__(self, data, vmin, vmax, cmap, center, robust, annot, fmt,\n@@ -132,9 +125,6 @@ def __init__(self, data, vmin, vmax, cmap, center, robust, annot, fmt,\n         elif yticklabels is False:\n             yticklabels = []\n \n-        # Get the positions and used label for the ticks\n-        nx, ny = data.T.shape\n-\n         if not len(xticklabels):\n             self.xticks = []\n             self.xticklabels = []\n@@ -889,9 +879,9 @@ def _preprocess_colors(self, data, colors, axis):\n                 else:\n                     colors = colors.reindex(data.columns)\n \n-                # Replace na's with background color\n+                # Replace na's with white color\n                 # TODO We should set these to transparent instead\n-                colors = colors.fillna('white')\n+                colors = colors.astype(object).fillna('white')\n \n                 # Extract color values and labels from frame/series\n                 if isinstance(colors, pd.DataFrame):\n",
  "test_patch": "diff --git a/seaborn/tests/test_matrix.py b/seaborn/tests/test_matrix.py\n--- a/seaborn/tests/test_matrix.py\n+++ b/seaborn/tests/test_matrix.py\n@@ -780,6 +780,26 @@ def test_colors_input(self):\n \n         assert len(cg.fig.axes) == 6\n \n+    def test_categorical_colors_input(self):\n+        kws = self.default_kws.copy()\n+\n+        row_colors = pd.Series(self.row_colors, dtype=\"category\")\n+        col_colors = pd.Series(\n+            self.col_colors, dtype=\"category\", index=self.df_norm.columns\n+        )\n+\n+        kws['row_colors'] = row_colors\n+        kws['col_colors'] = col_colors\n+\n+        exp_row_colors = list(map(mpl.colors.to_rgb, row_colors))\n+        exp_col_colors = list(map(mpl.colors.to_rgb, col_colors))\n+\n+        cg = mat.ClusterGrid(self.df_norm, **kws)\n+        npt.assert_array_equal(cg.row_colors, exp_row_colors)\n+        npt.assert_array_equal(cg.col_colors, exp_col_colors)\n+\n+        assert len(cg.fig.axes) == 6\n+\n     def test_nested_colors_input(self):\n         kws = self.default_kws.copy()\n \n",
  "problem_statement": "ValueError: fill value must be in categories\nIn the  _preprocess_colors function, there is the code to replace na's with background color as the comment said, using `colors = colors.fillna('white')`, however, if the original colors do not contain the 'white' category, this line would raise the Pandas ValueError:fill value must be in categories in `Pandas 0.25.3`.\n",
  "hints_text": "Can you please share a reproducible example that demonstrates the issue? I can't really figure out what you're talking about from this description.\nHere's a self-contained example, using ``clustermap()``. This has to do with colors input for row/col colors that are pandas ``category`` dtype:\r\n```python\r\nimport seaborn as sns; sns.set(color_codes=True)\r\niris = sns.load_dataset(\"iris\")\r\nspecies = iris.pop(\"species\")\r\nrow_colors=species.map(dict(zip(species.unique(), \"rbg\")))\r\nrow_colors=row_colors.astype('category')\r\ng = sns.clustermap(iris, row_colors=row_colors)\r\n```\r\n\r\nThis raises the following error:\r\n```\r\nValueError: fill value must be in categories\r\n```\nThanks @MaozGelbart. It would still be helpful to understand the real-world case where the color annotations need to be categorical.\nSame issue here",
  "created_at": "2020-12-18T19:35:43Z",
  "version": "0.12",
  "FAIL_TO_PASS": "[\"seaborn/tests/test_matrix.py::TestClustermap::test_categorical_colors_input\"]",
  "PASS_TO_PASS": "[\"seaborn/tests/test_matrix.py::TestHeatmap::test_ndarray_input\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_df_input\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_df_multindex_input\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_mask_input[float]\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_mask_input[int64]\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_mask_input[object]\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_mask_limits\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_default_vlims\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_robust_vlims\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_custom_sequential_vlims\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_custom_diverging_vlims\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_array_with_nans\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_mask\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_custom_cmap\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_centered_vlims\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_default_colors\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_custom_vlim_colors\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_custom_center_colors\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_cmap_with_properties\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_tickabels_off\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_custom_ticklabels\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_custom_ticklabel_interval\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_heatmap_annotation\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_heatmap_annotation_overwrite_kws\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_heatmap_annotation_with_mask\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_heatmap_annotation_mesh_colors\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_heatmap_annotation_other_data\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_heatmap_annotation_with_limited_ticklabels\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_heatmap_cbar\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_heatmap_axes\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_heatmap_ticklabel_rotation\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_heatmap_inner_lines\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_square_aspect\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_mask_validation\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_missing_data_mask\", \"seaborn/tests/test_matrix.py::TestHeatmap::test_cbar_ticks\", \"seaborn/tests/test_matrix.py::TestDendrogram::test_ndarray_input\", \"seaborn/tests/test_matrix.py::TestDendrogram::test_df_input\", \"seaborn/tests/test_matrix.py::TestDendrogram::test_df_multindex_input\", \"seaborn/tests/test_matrix.py::TestDendrogram::test_axis0_input\", \"seaborn/tests/test_matrix.py::TestDendrogram::test_rotate_input\", \"seaborn/tests/test_matrix.py::TestDendrogram::test_rotate_axis0_input\", \"seaborn/tests/test_matrix.py::TestDendrogram::test_custom_linkage\", \"seaborn/tests/test_matrix.py::TestDendrogram::test_label_false\", \"seaborn/tests/test_matrix.py::TestDendrogram::test_linkage_scipy\", \"seaborn/tests/test_matrix.py::TestDendrogram::test_dendrogram_plot\", \"seaborn/tests/test_matrix.py::TestDendrogram::test_dendrogram_rotate\", \"seaborn/tests/test_matrix.py::TestDendrogram::test_dendrogram_ticklabel_rotation\", \"seaborn/tests/test_matrix.py::TestClustermap::test_ndarray_input\", \"seaborn/tests/test_matrix.py::TestClustermap::test_df_input\", \"seaborn/tests/test_matrix.py::TestClustermap::test_corr_df_input\", \"seaborn/tests/test_matrix.py::TestClustermap::test_pivot_input\", \"seaborn/tests/test_matrix.py::TestClustermap::test_colors_input\", \"seaborn/tests/test_matrix.py::TestClustermap::test_nested_colors_input\", \"seaborn/tests/test_matrix.py::TestClustermap::test_colors_input_custom_cmap\", \"seaborn/tests/test_matrix.py::TestClustermap::test_z_score\", \"seaborn/tests/test_matrix.py::TestClustermap::test_z_score_axis0\", \"seaborn/tests/test_matrix.py::TestClustermap::test_standard_scale\", \"seaborn/tests/test_matrix.py::TestClustermap::test_standard_scale_axis0\", \"seaborn/tests/test_matrix.py::TestClustermap::test_z_score_standard_scale\", \"seaborn/tests/test_matrix.py::TestClustermap::test_color_list_to_matrix_and_cmap\", \"seaborn/tests/test_matrix.py::TestClustermap::test_nested_color_list_to_matrix_and_cmap\", \"seaborn/tests/test_matrix.py::TestClustermap::test_color_list_to_matrix_and_cmap_axis1\", \"seaborn/tests/test_matrix.py::TestClustermap::test_savefig\", \"seaborn/tests/test_matrix.py::TestClustermap::test_plot_dendrograms\", \"seaborn/tests/test_matrix.py::TestClustermap::test_cluster_false\", \"seaborn/tests/test_matrix.py::TestClustermap::test_row_col_colors\", \"seaborn/tests/test_matrix.py::TestClustermap::test_cluster_false_row_col_colors\", \"seaborn/tests/test_matrix.py::TestClustermap::test_row_col_colors_df\", \"seaborn/tests/test_matrix.py::TestClustermap::test_row_col_colors_df_shuffled\", \"seaborn/tests/test_matrix.py::TestClustermap::test_row_col_colors_df_missing\", \"seaborn/tests/test_matrix.py::TestClustermap::test_row_col_colors_df_one_axis\", \"seaborn/tests/test_matrix.py::TestClustermap::test_row_col_colors_series\", \"seaborn/tests/test_matrix.py::TestClustermap::test_row_col_colors_series_shuffled\", \"seaborn/tests/test_matrix.py::TestClustermap::test_row_col_colors_series_missing\", \"seaborn/tests/test_matrix.py::TestClustermap::test_row_col_colors_ignore_heatmap_kwargs\", \"seaborn/tests/test_matrix.py::TestClustermap::test_row_col_colors_raise_on_mixed_index_types\", \"seaborn/tests/test_matrix.py::TestClustermap::test_mask_reorganization\", \"seaborn/tests/test_matrix.py::TestClustermap::test_ticklabel_reorganization\", \"seaborn/tests/test_matrix.py::TestClustermap::test_noticklabels\", \"seaborn/tests/test_matrix.py::TestClustermap::test_size_ratios\", \"seaborn/tests/test_matrix.py::TestClustermap::test_cbar_pos\", \"seaborn/tests/test_matrix.py::TestClustermap::test_square_warning\", \"seaborn/tests/test_matrix.py::TestClustermap::test_clustermap_annotation\"]",
  "environment_setup_commit": "d25872b0fc99dbf7e666a91f59bd4ed125186aa1",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.834474",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}