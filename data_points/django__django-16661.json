{
  "repo": "django/django",
  "instance_id": "django__django-16661",
  "base_commit": "d687febce5868545f99974d2499a91f81a32fef5",
  "patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -461,12 +461,14 @@ def lookup_allowed(self, lookup, value):\n                 # Lookups on nonexistent fields are ok, since they're ignored\n                 # later.\n                 break\n-            # It is allowed to filter on values that would be found from local\n-            # model anyways. For example, if you filter on employee__department__id,\n-            # then the id value would be found already from employee__department_id.\n             if not prev_field or (\n                 prev_field.is_relation\n-                and field not in prev_field.path_infos[-1].target_fields\n+                and field not in model._meta.parents.values()\n+                and field is not model._meta.auto_field\n+                and (\n+                    model._meta.auto_field is None\n+                    or part not in getattr(prev_field, \"to_fields\", [])\n+                )\n             ):\n                 relation_parts.append(part)\n             if not getattr(field, \"path_infos\", None):\n",
  "test_patch": "diff --git a/tests/modeladmin/tests.py b/tests/modeladmin/tests.py\n--- a/tests/modeladmin/tests.py\n+++ b/tests/modeladmin/tests.py\n@@ -154,6 +154,35 @@ class EmployeeProfileAdmin(ModelAdmin):\n             ma.lookup_allowed(\"employee__department__code\", \"test_value\"), True\n         )\n \n+    @isolate_apps(\"modeladmin\")\n+    def test_lookup_allowed_foreign_primary(self):\n+        class Country(models.Model):\n+            name = models.CharField(max_length=256)\n+\n+        class Place(models.Model):\n+            country = models.ForeignKey(Country, models.CASCADE)\n+\n+        class Restaurant(models.Model):\n+            place = models.OneToOneField(Place, models.CASCADE, primary_key=True)\n+\n+        class Waiter(models.Model):\n+            restaurant = models.ForeignKey(Restaurant, models.CASCADE)\n+\n+        class WaiterAdmin(ModelAdmin):\n+            list_filter = [\n+                \"restaurant__place__country\",\n+                \"restaurant__place__country__name\",\n+            ]\n+\n+        ma = WaiterAdmin(Waiter, self.site)\n+        self.assertIs(ma.lookup_allowed(\"restaurant__place__country\", \"1\"), True)\n+        self.assertIs(\n+            ma.lookup_allowed(\"restaurant__place__country__id__exact\", \"1\"), True\n+        )\n+        self.assertIs(\n+            ma.lookup_allowed(\"restaurant__place__country__name\", \"test_value\"), True\n+        )\n+\n     def test_field_arguments(self):\n         # If fields is specified, fieldsets_add and fieldsets_change should\n         # just stick the fields into a formsets structure and return it.\n",
  "problem_statement": "ModelAdmin.lookup_allowed() incorrectly raises DisallowedModelAdminLookup lookup with foreign key as primary key\nDescription\n\t \n\t\t(last modified by Tim Graham)\n\t \nWrote a failing test for tests/modeladmin/tests.py to demonstrate - same test/code passes on 1.8\n@isolate_apps('modeladmin')\ndef test_lookup_allowed_foreign_primary(self):\n\tclass Country(models.Model):\n\t\tname = models.CharField(max_length=256)\n\tclass Place(models.Model):\n\t\tcountry = models.ForeignKey(Country, models.CASCADE)\n\tclass Restaurant(models.Model):\n\t\tplace = models.OneToOneField(Place, models.CASCADE, primary_key=True)\n\tclass Waiter(models.Model):\n\t\trestaurant = models.ForeignKey(Restaurant, models.CASCADE)\n\tclass WaiterAdmin(ModelAdmin):\n\t\tlist_filter = [\n\t\t\t'restaurant__place__country',\n\t\t]\n\tma = WaiterAdmin(Waiter, self.site)\n\tself.assertIs(ma.lookup_allowed('restaurant__place__country', 'test_value'), True)\nI think this is caused by the admin thinking that having a foreign key field as a primary key is the same as concrete inheritance. So when you try and check lookups for restaurant__place__country it thinks 'place' is the concrete parent of 'restaurant' and shortcuts it to restaurant__country which isn't in 'list_filter'. And you can't add restaurant__country to list_filter because country isn't actually on restaurant.\n",
  "hints_text": "Bisected to 8f30556329b64005d63b66859a74752a0b261315.",
  "created_at": "2023-03-18T09:26:58Z",
  "version": "5.0",
  "FAIL_TO_PASS": "[\"test_lookup_allowed_foreign_primary (modeladmin.tests.ModelAdminTests.test_lookup_allowed_foreign_primary)\"]",
  "PASS_TO_PASS": "[\"has_add_permission returns True for users who can add objects and\", \"has_change_permission returns True for users who can edit objects and\", \"has_delete_permission returns True for users who can delete objects and\", \"as_module_permission returns True for users who have any permission\", \"has_view_permission() returns True for users who can view objects and\", \"test_inline_has_add_permission_uses_obj (modeladmin.tests.ModelAdminPermissionTests.test_inline_has_add_permission_uses_obj)\", \"The custom ModelForm's `Meta.exclude` is overridden if\", \"The custom ModelForm's `Meta.exclude` is respected when used in\", \"test_custom_form_validation (modeladmin.tests.ModelAdminTests.test_custom_form_validation)\", \"test_custom_formfield_override_readonly (modeladmin.tests.ModelAdminTests.test_custom_formfield_override_readonly)\", \"test_default_attributes (modeladmin.tests.ModelAdminTests.test_default_attributes)\", \"test_default_fields (modeladmin.tests.ModelAdminTests.test_default_fields)\", \"test_default_fieldsets (modeladmin.tests.ModelAdminTests.test_default_fieldsets)\", \"test_default_foreign_key_widget (modeladmin.tests.ModelAdminTests.test_default_foreign_key_widget)\", \"test_field_arguments (modeladmin.tests.ModelAdminTests.test_field_arguments)\", \"test_field_arguments_restricted_on_form (modeladmin.tests.ModelAdminTests.test_field_arguments_restricted_on_form)\", \"test_foreign_key_as_radio_field (modeladmin.tests.ModelAdminTests.test_foreign_key_as_radio_field)\", \"The `exclude` kwarg passed to `ModelAdmin.get_form()` overrides all\", \"The `exclude` kwarg passed to `InlineModelAdmin.get_formset()`\", \"test_formset_overriding_get_exclude_with_form_exclude (modeladmin.tests.ModelAdminTests.test_formset_overriding_get_exclude_with_form_exclude)\", \"test_formset_overriding_get_exclude_with_form_fields (modeladmin.tests.ModelAdminTests.test_formset_overriding_get_exclude_with_form_fields)\", \"test_get_autocomplete_fields (modeladmin.tests.ModelAdminTests.test_get_autocomplete_fields)\", \"test_get_deleted_objects (modeladmin.tests.ModelAdminTests.test_get_deleted_objects)\", \"ModelAdmin.get_deleted_objects() uses ModelAdmin.has_delete_permission()\", \"test_get_exclude_overrides_exclude (modeladmin.tests.ModelAdminTests.test_get_exclude_overrides_exclude)\", \"test_get_exclude_takes_obj (modeladmin.tests.ModelAdminTests.test_get_exclude_takes_obj)\", \"test_get_fieldsets (modeladmin.tests.ModelAdminTests.test_get_fieldsets)\", \"test_log_actions (modeladmin.tests.ModelAdminTests.test_log_actions)\", \"A lookup_allowed allows a parameter whose field lookup doesn't exist.\", \"test_lookup_allowed_onetoone (modeladmin.tests.ModelAdminTests.test_lookup_allowed_onetoone)\", \"test_modeladmin_repr (modeladmin.tests.ModelAdminTests.test_modeladmin_repr)\", \"test_modeladmin_str (modeladmin.tests.ModelAdminTests.test_modeladmin_str)\", \"test_overriding_get_exclude (modeladmin.tests.ModelAdminTests.test_overriding_get_exclude)\", \"test_queryset_override (modeladmin.tests.ModelAdminTests.test_queryset_override)\", \"The autocomplete_fields, raw_id_fields, and radio_fields widgets may\", \"`obj` is passed from `InlineModelAdmin.get_fieldsets()` to\"]",
  "environment_setup_commit": "4a72da71001f154ea60906a2f74898d32b7322a7",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.766771",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}