{
  "repo": "django/django",
  "instance_id": "django__django-16511",
  "base_commit": "ecafcaf634fcef93f9da8cb12795273dd1c3a576",
  "patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -926,25 +926,32 @@ async def aget_or_create(self, defaults=None, **kwargs):\n             **kwargs,\n         )\n \n-    def update_or_create(self, defaults=None, **kwargs):\n+    def update_or_create(self, defaults=None, create_defaults=None, **kwargs):\n         \"\"\"\n         Look up an object with the given kwargs, updating one with defaults\n-        if it exists, otherwise create a new one.\n+        if it exists, otherwise create a new one. Optionally, an object can\n+        be created with different values than defaults by using\n+        create_defaults.\n         Return a tuple (object, created), where created is a boolean\n         specifying whether an object was created.\n         \"\"\"\n-        defaults = defaults or {}\n+        if create_defaults is None:\n+            update_defaults = create_defaults = defaults or {}\n+        else:\n+            update_defaults = defaults or {}\n         self._for_write = True\n         with transaction.atomic(using=self.db):\n             # Lock the row so that a concurrent update is blocked until\n             # update_or_create() has performed its save.\n-            obj, created = self.select_for_update().get_or_create(defaults, **kwargs)\n+            obj, created = self.select_for_update().get_or_create(\n+                create_defaults, **kwargs\n+            )\n             if created:\n                 return obj, created\n-            for k, v in resolve_callables(defaults):\n+            for k, v in resolve_callables(update_defaults):\n                 setattr(obj, k, v)\n \n-            update_fields = set(defaults)\n+            update_fields = set(update_defaults)\n             concrete_field_names = self.model._meta._non_pk_concrete_field_names\n             # update_fields does not support non-concrete fields.\n             if concrete_field_names.issuperset(update_fields):\n@@ -964,9 +971,10 @@ def update_or_create(self, defaults=None, **kwargs):\n                 obj.save(using=self.db)\n         return obj, False\n \n-    async def aupdate_or_create(self, defaults=None, **kwargs):\n+    async def aupdate_or_create(self, defaults=None, create_defaults=None, **kwargs):\n         return await sync_to_async(self.update_or_create)(\n             defaults=defaults,\n+            create_defaults=create_defaults,\n             **kwargs,\n         )\n \n",
  "test_patch": "diff --git a/tests/async/test_async_queryset.py b/tests/async/test_async_queryset.py\n--- a/tests/async/test_async_queryset.py\n+++ b/tests/async/test_async_queryset.py\n@@ -99,10 +99,17 @@ async def test_aupdate_or_create(self):\n             id=self.s1.id, defaults={\"field\": 2}\n         )\n         self.assertEqual(instance, self.s1)\n+        self.assertEqual(instance.field, 2)\n         self.assertIs(created, False)\n         instance, created = await SimpleModel.objects.aupdate_or_create(field=4)\n         self.assertEqual(await SimpleModel.objects.acount(), 4)\n         self.assertIs(created, True)\n+        instance, created = await SimpleModel.objects.aupdate_or_create(\n+            field=5, defaults={\"field\": 7}, create_defaults={\"field\": 6}\n+        )\n+        self.assertEqual(await SimpleModel.objects.acount(), 5)\n+        self.assertIs(created, True)\n+        self.assertEqual(instance.field, 6)\n \n     @skipUnlessDBFeature(\"has_bulk_insert\")\n     @async_to_sync\ndiff --git a/tests/async/test_async_related_managers.py b/tests/async/test_async_related_managers.py\n--- a/tests/async/test_async_related_managers.py\n+++ b/tests/async/test_async_related_managers.py\n@@ -44,12 +44,18 @@ async def test_aupdate_or_create(self):\n         self.assertIs(created, True)\n         self.assertEqual(await self.mtm1.simples.acount(), 1)\n         self.assertEqual(new_simple.field, 2)\n-        new_simple, created = await self.mtm1.simples.aupdate_or_create(\n+        new_simple1, created = await self.mtm1.simples.aupdate_or_create(\n             id=new_simple.id, defaults={\"field\": 3}\n         )\n         self.assertIs(created, False)\n-        self.assertEqual(await self.mtm1.simples.acount(), 1)\n-        self.assertEqual(new_simple.field, 3)\n+        self.assertEqual(new_simple1.field, 3)\n+\n+        new_simple2, created = await self.mtm1.simples.aupdate_or_create(\n+            field=4, defaults={\"field\": 6}, create_defaults={\"field\": 5}\n+        )\n+        self.assertIs(created, True)\n+        self.assertEqual(new_simple2.field, 5)\n+        self.assertEqual(await self.mtm1.simples.acount(), 2)\n \n     async def test_aupdate_or_create_reverse(self):\n         new_relatedmodel, created = await self.s1.relatedmodel_set.aupdate_or_create()\ndiff --git a/tests/generic_relations/tests.py b/tests/generic_relations/tests.py\n--- a/tests/generic_relations/tests.py\n+++ b/tests/generic_relations/tests.py\n@@ -59,6 +59,19 @@ def test_generic_update_or_create_when_created(self):\n         self.assertTrue(created)\n         self.assertEqual(count + 1, self.bacon.tags.count())\n \n+    def test_generic_update_or_create_when_created_with_create_defaults(self):\n+        count = self.bacon.tags.count()\n+        tag, created = self.bacon.tags.update_or_create(\n+            # Since, the \"stinky\" tag doesn't exist create\n+            # a \"juicy\" tag.\n+            create_defaults={\"tag\": \"juicy\"},\n+            defaults={\"tag\": \"uncured\"},\n+            tag=\"stinky\",\n+        )\n+        self.assertEqual(tag.tag, \"juicy\")\n+        self.assertIs(created, True)\n+        self.assertEqual(count + 1, self.bacon.tags.count())\n+\n     def test_generic_update_or_create_when_updated(self):\n         \"\"\"\n         Should be able to use update_or_create from the generic related manager\n@@ -74,6 +87,17 @@ def test_generic_update_or_create_when_updated(self):\n         self.assertEqual(count + 1, self.bacon.tags.count())\n         self.assertEqual(tag.tag, \"juicy\")\n \n+    def test_generic_update_or_create_when_updated_with_defaults(self):\n+        count = self.bacon.tags.count()\n+        tag = self.bacon.tags.create(tag=\"stinky\")\n+        self.assertEqual(count + 1, self.bacon.tags.count())\n+        tag, created = self.bacon.tags.update_or_create(\n+            create_defaults={\"tag\": \"uncured\"}, defaults={\"tag\": \"juicy\"}, id=tag.id\n+        )\n+        self.assertIs(created, False)\n+        self.assertEqual(count + 1, self.bacon.tags.count())\n+        self.assertEqual(tag.tag, \"juicy\")\n+\n     async def test_generic_async_aupdate_or_create(self):\n         tag, created = await self.bacon.tags.aupdate_or_create(\n             id=self.fatty.id, defaults={\"tag\": \"orange\"}\n@@ -86,6 +110,22 @@ async def test_generic_async_aupdate_or_create(self):\n         self.assertEqual(await self.bacon.tags.acount(), 3)\n         self.assertEqual(tag.tag, \"pink\")\n \n+    async def test_generic_async_aupdate_or_create_with_create_defaults(self):\n+        tag, created = await self.bacon.tags.aupdate_or_create(\n+            id=self.fatty.id,\n+            create_defaults={\"tag\": \"pink\"},\n+            defaults={\"tag\": \"orange\"},\n+        )\n+        self.assertIs(created, False)\n+        self.assertEqual(tag.tag, \"orange\")\n+        self.assertEqual(await self.bacon.tags.acount(), 2)\n+        tag, created = await self.bacon.tags.aupdate_or_create(\n+            tag=\"pink\", create_defaults={\"tag\": \"brown\"}\n+        )\n+        self.assertIs(created, True)\n+        self.assertEqual(await self.bacon.tags.acount(), 3)\n+        self.assertEqual(tag.tag, \"brown\")\n+\n     def test_generic_get_or_create_when_created(self):\n         \"\"\"\n         Should be able to use get_or_create from the generic related manager\n@@ -550,6 +590,26 @@ def test_update_or_create_defaults(self):\n         self.assertFalse(created)\n         self.assertEqual(tag.content_object.id, diamond.id)\n \n+    def test_update_or_create_defaults_with_create_defaults(self):\n+        # update_or_create() should work with virtual fields (content_object).\n+        quartz = Mineral.objects.create(name=\"Quartz\", hardness=7)\n+        diamond = Mineral.objects.create(name=\"Diamond\", hardness=7)\n+        tag, created = TaggedItem.objects.update_or_create(\n+            tag=\"shiny\",\n+            create_defaults={\"content_object\": quartz},\n+            defaults={\"content_object\": diamond},\n+        )\n+        self.assertIs(created, True)\n+        self.assertEqual(tag.content_object.id, quartz.id)\n+\n+        tag, created = TaggedItem.objects.update_or_create(\n+            tag=\"shiny\",\n+            create_defaults={\"content_object\": quartz},\n+            defaults={\"content_object\": diamond},\n+        )\n+        self.assertIs(created, False)\n+        self.assertEqual(tag.content_object.id, diamond.id)\n+\n     def test_query_content_type(self):\n         msg = \"Field 'content_object' does not generate an automatic reverse relation\"\n         with self.assertRaisesMessage(FieldError, msg):\ndiff --git a/tests/get_or_create/models.py b/tests/get_or_create/models.py\n--- a/tests/get_or_create/models.py\n+++ b/tests/get_or_create/models.py\n@@ -6,6 +6,7 @@ class Person(models.Model):\n     last_name = models.CharField(max_length=100)\n     birthday = models.DateField()\n     defaults = models.TextField()\n+    create_defaults = models.TextField()\n \n \n class DefaultPerson(models.Model):\ndiff --git a/tests/get_or_create/tests.py b/tests/get_or_create/tests.py\n--- a/tests/get_or_create/tests.py\n+++ b/tests/get_or_create/tests.py\n@@ -330,15 +330,24 @@ def test_create(self):\n         self.assertEqual(p.birthday, date(1940, 10, 10))\n \n     def test_create_twice(self):\n-        params = {\n-            \"first_name\": \"John\",\n-            \"last_name\": \"Lennon\",\n-            \"birthday\": date(1940, 10, 10),\n-        }\n-        Person.objects.update_or_create(**params)\n-        # If we execute the exact same statement, it won't create a Person.\n-        p, created = Person.objects.update_or_create(**params)\n-        self.assertFalse(created)\n+        p, created = Person.objects.update_or_create(\n+            first_name=\"John\",\n+            last_name=\"Lennon\",\n+            create_defaults={\"birthday\": date(1940, 10, 10)},\n+            defaults={\"birthday\": date(1950, 2, 2)},\n+        )\n+        self.assertIs(created, True)\n+        self.assertEqual(p.birthday, date(1940, 10, 10))\n+        # If we execute the exact same statement, it won't create a Person, but\n+        # will update the birthday.\n+        p, created = Person.objects.update_or_create(\n+            first_name=\"John\",\n+            last_name=\"Lennon\",\n+            create_defaults={\"birthday\": date(1940, 10, 10)},\n+            defaults={\"birthday\": date(1950, 2, 2)},\n+        )\n+        self.assertIs(created, False)\n+        self.assertEqual(p.birthday, date(1950, 2, 2))\n \n     def test_integrity(self):\n         \"\"\"\n@@ -391,8 +400,14 @@ def test_create_with_related_manager(self):\n         \"\"\"\n         p = Publisher.objects.create(name=\"Acme Publishing\")\n         book, created = p.books.update_or_create(name=\"The Book of Ed & Fred\")\n-        self.assertTrue(created)\n+        self.assertIs(created, True)\n         self.assertEqual(p.books.count(), 1)\n+        book, created = p.books.update_or_create(\n+            name=\"Basics of Django\", create_defaults={\"name\": \"Advanced Django\"}\n+        )\n+        self.assertIs(created, True)\n+        self.assertEqual(book.name, \"Advanced Django\")\n+        self.assertEqual(p.books.count(), 2)\n \n     def test_update_with_related_manager(self):\n         \"\"\"\n@@ -406,6 +421,14 @@ def test_update_with_related_manager(self):\n         book, created = p.books.update_or_create(defaults={\"name\": name}, id=book.id)\n         self.assertFalse(created)\n         self.assertEqual(book.name, name)\n+        # create_defaults should be ignored.\n+        book, created = p.books.update_or_create(\n+            create_defaults={\"name\": \"Basics of Django\"},\n+            defaults={\"name\": name},\n+            id=book.id,\n+        )\n+        self.assertIs(created, False)\n+        self.assertEqual(book.name, name)\n         self.assertEqual(p.books.count(), 1)\n \n     def test_create_with_many(self):\n@@ -418,8 +441,16 @@ def test_create_with_many(self):\n         book, created = author.books.update_or_create(\n             name=\"The Book of Ed & Fred\", publisher=p\n         )\n-        self.assertTrue(created)\n+        self.assertIs(created, True)\n         self.assertEqual(author.books.count(), 1)\n+        book, created = author.books.update_or_create(\n+            name=\"Basics of Django\",\n+            publisher=p,\n+            create_defaults={\"name\": \"Advanced Django\"},\n+        )\n+        self.assertIs(created, True)\n+        self.assertEqual(book.name, \"Advanced Django\")\n+        self.assertEqual(author.books.count(), 2)\n \n     def test_update_with_many(self):\n         \"\"\"\n@@ -437,6 +468,14 @@ def test_update_with_many(self):\n         )\n         self.assertFalse(created)\n         self.assertEqual(book.name, name)\n+        # create_defaults should be ignored.\n+        book, created = author.books.update_or_create(\n+            create_defaults={\"name\": \"Basics of Django\"},\n+            defaults={\"name\": name},\n+            id=book.id,\n+        )\n+        self.assertIs(created, False)\n+        self.assertEqual(book.name, name)\n         self.assertEqual(author.books.count(), 1)\n \n     def test_defaults_exact(self):\n@@ -467,6 +506,34 @@ def test_defaults_exact(self):\n         self.assertFalse(created)\n         self.assertEqual(obj.defaults, \"another testing\")\n \n+    def test_create_defaults_exact(self):\n+        \"\"\"\n+        If you have a field named create_defaults and want to use it as an\n+        exact lookup, you need to use 'create_defaults__exact'.\n+        \"\"\"\n+        obj, created = Person.objects.update_or_create(\n+            first_name=\"George\",\n+            last_name=\"Harrison\",\n+            create_defaults__exact=\"testing\",\n+            create_defaults={\n+                \"birthday\": date(1943, 2, 25),\n+                \"create_defaults\": \"testing\",\n+            },\n+        )\n+        self.assertIs(created, True)\n+        self.assertEqual(obj.create_defaults, \"testing\")\n+        obj, created = Person.objects.update_or_create(\n+            first_name=\"George\",\n+            last_name=\"Harrison\",\n+            create_defaults__exact=\"testing\",\n+            create_defaults={\n+                \"birthday\": date(1943, 2, 25),\n+                \"create_defaults\": \"another testing\",\n+            },\n+        )\n+        self.assertIs(created, False)\n+        self.assertEqual(obj.create_defaults, \"testing\")\n+\n     def test_create_callable_default(self):\n         obj, created = Person.objects.update_or_create(\n             first_name=\"George\",\n@@ -476,6 +543,16 @@ def test_create_callable_default(self):\n         self.assertIs(created, True)\n         self.assertEqual(obj.birthday, date(1943, 2, 25))\n \n+    def test_create_callable_create_defaults(self):\n+        obj, created = Person.objects.update_or_create(\n+            first_name=\"George\",\n+            last_name=\"Harrison\",\n+            defaults={},\n+            create_defaults={\"birthday\": lambda: date(1943, 2, 25)},\n+        )\n+        self.assertIs(created, True)\n+        self.assertEqual(obj.birthday, date(1943, 2, 25))\n+\n     def test_update_callable_default(self):\n         Person.objects.update_or_create(\n             first_name=\"George\",\n@@ -694,6 +771,12 @@ def test_update_or_create_with_invalid_defaults(self):\n         with self.assertRaisesMessage(FieldError, self.msg):\n             Thing.objects.update_or_create(name=\"a\", defaults={\"nonexistent\": \"b\"})\n \n+    def test_update_or_create_with_invalid_create_defaults(self):\n+        with self.assertRaisesMessage(FieldError, self.msg):\n+            Thing.objects.update_or_create(\n+                name=\"a\", create_defaults={\"nonexistent\": \"b\"}\n+            )\n+\n     def test_update_or_create_with_invalid_kwargs(self):\n         with self.assertRaisesMessage(FieldError, self.bad_field_msg):\n             Thing.objects.update_or_create(name=\"a\", nonexistent=\"b\")\n",
  "problem_statement": "Support create defaults for update_or_create\nDescription\n\t\nI proposed the idea of extending update_or_create to support specifying a different set of defaults for the create operation on the [forum](​https://forum.djangoproject.com/t/feature-idea-update-or-create-to-allow-different-defaults-for-create-and-update-operations/18300/15). There seems to be consensus it's a positive add to Django.\nAdam raised concerns with my proposed approach of adding a create_defaults parameter to the function since this would conflict with any fields on a model named, create_defaults. Jeff did a code search on github for that term and didn't find any matches. I suspect if someone where using a field named create_defaults, it would be a JSON or object type field. Those don't seem like reasonable candidates to be part of a UniqueConstraint, which should be underlying the look-up arguments to update_or_create.\nI do like the idea of having a separate parameter for create_defaults, but if we must preserve 100% backwards compatibility, Adam's suggestion of having defaults be set to another object makes the most sense.\nMy blocking question is, which approach should I take?\nFrom the forum post:\nI’ve run into a use-case in which it’d be helpful to have the ability to specify a different set of defaults for the update operation compared to the create operation. While I don’t expect my particular use case to translate, here’s a more generic one.\nGiven the following Record model:\nclass Record(models.Model):\n\tsome_id = models.CharField(unique=True)\n\tcreated_by = models.ForeignKey(User, ...)\n\tmodified_by = models.ForeignKey(User, null=True, blank=True, ...)\nWhen a record is created, we would want to set created_by, but if it’s being updated, we’d want to set modified_by. This use case can’t be solved by using update_or_create, unless it allows for us to specify a different set of default values.\nRecord.objects.update_or_create(\n\tsome_id=some_value,\n\tdefaults={\"modified_by\": user},\n\tcreate_defaults={\"created_by\": user},\n)\n",
  "hints_text": "",
  "created_at": "2023-01-31T02:40:31Z",
  "version": "5.0",
  "FAIL_TO_PASS": "[\"test_create_callable_create_defaults (get_or_create.tests.UpdateOrCreateTests.test_create_callable_create_defaults)\", \"If you have a field named create_defaults and want to use it as an\", \"test_create_twice (get_or_create.tests.UpdateOrCreateTests.test_create_twice)\", \"Should be able to use update_or_create from the m2m related manager to\", \"Should be able to use update_or_create from the related manager to\", \"test_update_or_create_with_invalid_create_defaults (get_or_create.tests.InvalidCreateArgumentsTests.test_update_or_create_with_invalid_create_defaults)\", \"test_aupdate_or_create (async.test_async_queryset.AsyncQuerySetTest.test_aupdate_or_create)\", \"test_aupdate_or_create (async.test_async_related_managers.AsyncRelatedManagersOperationTest.test_aupdate_or_create)\", \"test_generic_async_aupdate_or_create_with_create_defaults (generic_relations.tests.GenericRelationsTests.test_generic_async_aupdate_or_create_with_create_defaults)\", \"test_generic_update_or_create_when_created_with_create_defaults (generic_relations.tests.GenericRelationsTests.test_generic_update_or_create_when_created_with_create_defaults)\", \"test_generic_update_or_create_when_updated_with_defaults (generic_relations.tests.GenericRelationsTests.test_generic_update_or_create_when_updated_with_defaults)\", \"test_update_or_create_defaults_with_create_defaults (generic_relations.tests.GenericRelationsTests.test_update_or_create_defaults_with_create_defaults)\"]",
  "PASS_TO_PASS": "[\"test_none_allowed (generic_relations.tests.TestInitWithNoneArgument.test_none_allowed)\", \"If an existing primary key is specified with different values for other\", \"test_create_get_or_create (get_or_create.tests.GetOrCreateThroughManyToMany.test_create_get_or_create)\", \"test_get_get_or_create (get_or_create.tests.GetOrCreateThroughManyToMany.test_get_get_or_create)\", \"test_something (get_or_create.tests.GetOrCreateThroughManyToMany.test_something)\", \"If you specify an existing primary key, but different other fields,\", \"If all the attributes on a model have defaults, get_or_create() doesn't\", \"get_or_create should raise IntegrityErrors with the full traceback.\", \"The database connection is still usable after a DatabaseError in\", \"The default for for_concrete_model should be True\", \"test_generic_relation (generic_relations.tests.ProxyRelatedModelTest.test_generic_relation)\", \"test_generic_relation_set (generic_relations.tests.ProxyRelatedModelTest.test_generic_relation_set)\", \"Instances of the proxy should be returned when\", \"test_query (generic_relations.tests.ProxyRelatedModelTest.test_query)\", \"test_query_proxy (generic_relations.tests.ProxyRelatedModelTest.test_query_proxy)\", \"When for_concrete_model is False, we should still be able to get\", \"Callables in `defaults` are evaluated if the instance is created.\", \"test_callable_defaults_not_called (get_or_create.tests.GetOrCreateTests.test_callable_defaults_not_called)\", \"If you have a field named defaults and want to use it as an exact\", \"`defaults` aren't evaluated if the instance isn't created.\", \"If you don't specify a value or default value for all required\", \"test_get_or_create_method_with_create (get_or_create.tests.GetOrCreateTests.test_get_or_create_method_with_create)\", \"test_get_or_create_method_with_get (get_or_create.tests.GetOrCreateTests.test_get_or_create_method_with_get)\", \"test_get_or_create_on_related_manager (get_or_create.tests.GetOrCreateTests.test_get_or_create_on_related_manager)\", \"If we execute the exact same statement twice, the second time,\", \"Using a property with a setter implemented is allowed.\", \"Using the pk property of a model is allowed.\", \"Regression test for #15117. Requires a TransactionTestCase on\", \"test_create (get_or_create.tests.UpdateOrCreateTests.test_create)\", \"test_create_callable_default (get_or_create.tests.UpdateOrCreateTests.test_create_callable_default)\", \"update_or_create should raise IntegrityErrors with the full traceback.\", \"test_mti_update_non_local_concrete_fields (get_or_create.tests.UpdateOrCreateTests.test_mti_update_non_local_concrete_fields)\", \"test_update (get_or_create.tests.UpdateOrCreateTests.test_update)\", \"test_update_callable_default (get_or_create.tests.UpdateOrCreateTests.test_update_callable_default)\", \"test_update_only_defaults_and_pre_save_fields_when_local_fields (get_or_create.tests.UpdateOrCreateTests.test_update_only_defaults_and_pre_save_fields_when_local_fields)\", \"test_get_or_create_with_invalid_defaults (get_or_create.tests.InvalidCreateArgumentsTests.test_get_or_create_with_invalid_defaults)\", \"test_get_or_create_with_invalid_kwargs (get_or_create.tests.InvalidCreateArgumentsTests.test_get_or_create_with_invalid_kwargs)\", \"test_multiple_invalid_fields (get_or_create.tests.InvalidCreateArgumentsTests.test_multiple_invalid_fields)\", \"test_property_attribute_without_setter_defaults (get_or_create.tests.InvalidCreateArgumentsTests.test_property_attribute_without_setter_defaults)\", \"test_property_attribute_without_setter_kwargs (get_or_create.tests.InvalidCreateArgumentsTests.test_property_attribute_without_setter_kwargs)\", \"test_update_or_create_with_invalid_defaults (get_or_create.tests.InvalidCreateArgumentsTests.test_update_or_create_with_invalid_defaults)\", \"test_update_or_create_with_invalid_kwargs (get_or_create.tests.InvalidCreateArgumentsTests.test_update_or_create_with_invalid_kwargs)\", \"test_aaggregate (async.test_async_queryset.AsyncQuerySetTest.test_aaggregate)\", \"test_abulk_update (async.test_async_queryset.AsyncQuerySetTest.test_abulk_update)\", \"test_acontains (async.test_async_queryset.AsyncQuerySetTest.test_acontains)\", \"test_acount (async.test_async_queryset.AsyncQuerySetTest.test_acount)\", \"test_acount_cached_result (async.test_async_queryset.AsyncQuerySetTest.test_acount_cached_result)\", \"test_acreate (async.test_async_queryset.AsyncQuerySetTest.test_acreate)\", \"test_adelete (async.test_async_queryset.AsyncQuerySetTest.test_adelete)\", \"test_aearliest (async.test_async_queryset.AsyncQuerySetTest.test_aearliest)\", \"test_aexists (async.test_async_queryset.AsyncQuerySetTest.test_aexists)\", \"test_afirst (async.test_async_queryset.AsyncQuerySetTest.test_afirst)\", \"test_aget (async.test_async_queryset.AsyncQuerySetTest.test_aget)\", \"test_aget_or_create (async.test_async_queryset.AsyncQuerySetTest.test_aget_or_create)\", \"test_ain_bulk (async.test_async_queryset.AsyncQuerySetTest.test_ain_bulk)\", \"test_aiterator (async.test_async_queryset.AsyncQuerySetTest.test_aiterator)\", \"test_aiterator_invalid_chunk_size (async.test_async_queryset.AsyncQuerySetTest.test_aiterator_invalid_chunk_size)\", \"test_aiterator_prefetch_related (async.test_async_queryset.AsyncQuerySetTest.test_aiterator_prefetch_related)\", \"test_alast (async.test_async_queryset.AsyncQuerySetTest.test_alast)\", \"test_alatest (async.test_async_queryset.AsyncQuerySetTest.test_alatest)\", \"test_async_iteration (async.test_async_queryset.AsyncQuerySetTest.test_async_iteration)\", \"test_aupdate (async.test_async_queryset.AsyncQuerySetTest.test_aupdate)\", \"test_raw (async.test_async_queryset.AsyncQuerySetTest.test_raw)\", \"test_aadd (async.test_async_related_managers.AsyncRelatedManagersOperationTest.test_aadd)\", \"test_aadd_reverse (async.test_async_related_managers.AsyncRelatedManagersOperationTest.test_aadd_reverse)\", \"test_aclear (async.test_async_related_managers.AsyncRelatedManagersOperationTest.test_aclear)\", \"test_aclear_reverse (async.test_async_related_managers.AsyncRelatedManagersOperationTest.test_aclear_reverse)\", \"test_acreate (async.test_async_related_managers.AsyncRelatedManagersOperationTest.test_acreate)\", \"test_acreate_reverse (async.test_async_related_managers.AsyncRelatedManagersOperationTest.test_acreate_reverse)\", \"test_aget_or_create (async.test_async_related_managers.AsyncRelatedManagersOperationTest.test_aget_or_create)\", \"test_aget_or_create_reverse (async.test_async_related_managers.AsyncRelatedManagersOperationTest.test_aget_or_create_reverse)\", \"test_aremove (async.test_async_related_managers.AsyncRelatedManagersOperationTest.test_aremove)\", \"test_aremove_reverse (async.test_async_related_managers.AsyncRelatedManagersOperationTest.test_aremove_reverse)\", \"test_aset (async.test_async_related_managers.AsyncRelatedManagersOperationTest.test_aset)\", \"test_aset_reverse (async.test_async_related_managers.AsyncRelatedManagersOperationTest.test_aset_reverse)\", \"test_aupdate_or_create_reverse (async.test_async_related_managers.AsyncRelatedManagersOperationTest.test_aupdate_or_create_reverse)\", \"test_aadd (generic_relations.tests.GenericRelationsTests.test_aadd)\", \"Test accessing the content object like a foreign key.\", \"Test lookups through content type.\", \"test_aclear (generic_relations.tests.GenericRelationsTests.test_aclear)\", \"test_add_after_prefetch (generic_relations.tests.GenericRelationsTests.test_add_after_prefetch)\", \"test_add_bulk (generic_relations.tests.GenericRelationsTests.test_add_bulk)\", \"test_add_bulk_false (generic_relations.tests.GenericRelationsTests.test_add_bulk_false)\", \"test_add_rejects_unsaved_objects (generic_relations.tests.GenericRelationsTests.test_add_rejects_unsaved_objects)\", \"test_add_rejects_wrong_instances (generic_relations.tests.GenericRelationsTests.test_add_rejects_wrong_instances)\", \"test_add_then_remove_after_prefetch (generic_relations.tests.GenericRelationsTests.test_add_then_remove_after_prefetch)\", \"test_aremove (generic_relations.tests.GenericRelationsTests.test_aremove)\", \"test_aset (generic_relations.tests.GenericRelationsTests.test_aset)\", \"test_assign (generic_relations.tests.GenericRelationsTests.test_assign)\", \"test_assign_content_object_in_init (generic_relations.tests.GenericRelationsTests.test_assign_content_object_in_init)\", \"test_assign_with_queryset (generic_relations.tests.GenericRelationsTests.test_assign_with_queryset)\", \"test_cache_invalidation_for_content_type_id (generic_relations.tests.GenericRelationsTests.test_cache_invalidation_for_content_type_id)\", \"test_cache_invalidation_for_object_id (generic_relations.tests.GenericRelationsTests.test_cache_invalidation_for_object_id)\", \"test_clear (generic_relations.tests.GenericRelationsTests.test_clear)\", \"test_clear_after_prefetch (generic_relations.tests.GenericRelationsTests.test_clear_after_prefetch)\", \"test_create_after_prefetch (generic_relations.tests.GenericRelationsTests.test_create_after_prefetch)\", \"Test lookups over an object without GenericRelations.\", \"test_generic_async_acreate (generic_relations.tests.GenericRelationsTests.test_generic_async_acreate)\", \"test_generic_async_aget_or_create (generic_relations.tests.GenericRelationsTests.test_generic_async_aget_or_create)\", \"test_generic_async_aupdate_or_create (generic_relations.tests.GenericRelationsTests.test_generic_async_aupdate_or_create)\", \"Should be able to use get_or_create from the generic related manager\", \"test_generic_relation_related_name_default (generic_relations.tests.GenericRelationsTests.test_generic_relation_related_name_default)\", \"test_generic_relation_to_inherited_child (generic_relations.tests.GenericRelationsTests.test_generic_relation_to_inherited_child)\", \"Objects with declared GenericRelations can be tagged directly -- the\", \"Should be able to use update_or_create from the generic related manager\", \"test_get_or_create (generic_relations.tests.GenericRelationsTests.test_get_or_create)\", \"test_gfk_manager (generic_relations.tests.GenericRelationsTests.test_gfk_manager)\", \"test_gfk_subclasses (generic_relations.tests.GenericRelationsTests.test_gfk_subclasses)\", \"test_multiple_gfk (generic_relations.tests.GenericRelationsTests.test_multiple_gfk)\", \"If you delete an object with an explicit Generic relation, the related\", \"If Generic Relation is not explicitly defined, any related objects\", \"test_prefetch_related_custom_object_id (generic_relations.tests.GenericRelationsTests.test_prefetch_related_custom_object_id)\", \"test_prefetch_related_different_content_types (generic_relations.tests.GenericRelationsTests.test_prefetch_related_different_content_types)\", \"Queries across generic relations respect the content types. Even though\", \"Create another fatty tagged instance with different PK to ensure there\", \"test_query_content_object (generic_relations.tests.GenericRelationsTests.test_query_content_object)\", \"test_query_content_type (generic_relations.tests.GenericRelationsTests.test_query_content_type)\", \"test_remove (generic_relations.tests.GenericRelationsTests.test_remove)\", \"test_remove_after_prefetch (generic_relations.tests.GenericRelationsTests.test_remove_after_prefetch)\", \"test_set (generic_relations.tests.GenericRelationsTests.test_set)\", \"test_set_after_prefetch (generic_relations.tests.GenericRelationsTests.test_set_after_prefetch)\", \"You can set a generic foreign key in the way you'd expect.\", \"Concrete model subclasses with generic relations work\", \"Generic relations on a base class (Vegetable) work correctly in\", \"If you delete a tag, the objects using the tag are unaffected (other\", \"test_unsaved_generic_foreign_key_parent_bulk_create (generic_relations.tests.GenericRelationsTests.test_unsaved_generic_foreign_key_parent_bulk_create)\", \"test_unsaved_generic_foreign_key_parent_save (generic_relations.tests.GenericRelationsTests.test_unsaved_generic_foreign_key_parent_save)\", \"test_update_or_create_defaults (generic_relations.tests.GenericRelationsTests.test_update_or_create_defaults)\"]",
  "environment_setup_commit": "4a72da71001f154ea60906a2f74898d32b7322a7",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.760465",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}