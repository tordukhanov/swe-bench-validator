{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-21476",
  "base_commit": "f6b0190377be37f93f5e431951e66b562ef5dc35",
  "patch": "diff --git a/sympy/diffgeom/diffgeom.py b/sympy/diffgeom/diffgeom.py\n--- a/sympy/diffgeom/diffgeom.py\n+++ b/sympy/diffgeom/diffgeom.py\n@@ -193,8 +193,9 @@ class CoordSystem(Basic):\n \n     relations : dict, optional\n         Key is a tuple of two strings, who are the names of the systems where\n-        the coordinates transform from and transform to. Value is a tuple of\n-        transformed coordinates.\n+        the coordinates transform from and transform to.\n+        Value is a tuple of the symbols before transformation and a tuple of\n+        the expressions after transformation.\n \n     Examples\n     ========\n@@ -209,8 +210,8 @@ class CoordSystem(Basic):\n     >>> x, y = symbols('x y', real=True)\n     >>> r, theta = symbols('r theta', nonnegative=True)\n     >>> relation_dict = {\n-    ... ('Car2D', 'Pol'): (sqrt(x**2 + y**2), atan2(y, x)),\n-    ... ('Pol', 'Car2D'): (r*cos(theta), r*sin(theta))\n+    ... ('Car2D', 'Pol'): [(x, y), (sqrt(x**2 + y**2), atan2(y, x))],\n+    ... ('Pol', 'Car2D'): [(r, theta), (r*cos(theta), r*sin(theta))]\n     ... }\n     >>> Car2D = CoordSystem('Car2D', p, (x, y), relation_dict)\n     >>> Pol = CoordSystem('Pol', p, (r, theta), relation_dict)\n@@ -314,8 +315,12 @@ def __new__(cls, name, patch, symbols=None, relations={}, **kwargs):\n             if not isinstance(s2, Str):\n                 s2 = Str(s2)\n             key = Tuple(s1, s2)\n+\n+            # Old version used Lambda as a value.\n             if isinstance(v, Lambda):\n-                v = tuple(v(*symbols))\n+                v = (tuple(v.signature), tuple(v.expr))\n+            else:\n+                v = (tuple(v[0]), tuple(v[1]))\n             rel_temp[key] = v\n         relations = Dict(rel_temp)\n \n@@ -396,7 +401,7 @@ def transformation(self, sys):\n         if self == sys:\n             expr = Matrix(self.symbols)\n         elif key in self.relations:\n-            expr = Matrix(self.relations[key])\n+            expr = Matrix(self.relations[key][1])\n         elif key[::-1] in self.relations:\n             expr = Matrix(self._inverse_transformation(sys, self))\n         else:\n@@ -404,44 +409,58 @@ def transformation(self, sys):\n         return Lambda(signature, expr)\n \n     @staticmethod\n-    def _inverse_transformation(sys1, sys2):\n-        # Find the transformation relation from sys2 to sys1\n-        forward_transform_expressions = sys1.transform(sys2)\n-\n-        inv_results = solve(\n-            [t[0] - t[1] for t in zip(sys2.symbols, forward_transform_expressions)],\n-            list(sys1.symbols), dict=True)\n-        if len(inv_results) == 0:\n-            raise NotImplementedError(\n-                \"Cannot solve inverse of transformation from {} to {}\".format(sys1, sys2))\n-        elif len(inv_results) > 1:\n-            raise ValueError(\n-                \"Obtained multiple results for inverse of transformation from {} to {}\".format(sys1, sys2)\n-            )\n+    def _solve_inverse(sym1, sym2, exprs, sys1_name, sys2_name):\n+        ret = solve(\n+            [t[0] - t[1] for t in zip(sym2, exprs)],\n+            list(sym1), dict=True)\n+\n+        if len(ret) == 0:\n+            temp = \"Cannot solve inverse relation from {} to {}.\"\n+            raise NotImplementedError(temp.format(sys1_name, sys2_name))\n+        elif len(ret) > 1:\n+            temp = \"Obtained multiple inverse relation from {} to {}.\"\n+            raise ValueError(temp.format(sys1_name, sys2_name))\n+\n+        return ret[0]\n \n-        inv_results = inv_results[0]\n+    @classmethod\n+    def _inverse_transformation(cls, sys1, sys2):\n+        # Find the transformation relation from sys2 to sys1\n+        forward = sys1.transform(sys2)\n+        inv_results = cls._solve_inverse(sys1.symbols, sys2.symbols, forward,\n+                                         sys1.name, sys2.name)\n         signature = tuple(sys1.symbols)\n         return [inv_results[s] for s in signature]\n \n     @classmethod\n     @cacheit\n     def _indirect_transformation(cls, sys1, sys2):\n-        # Find the transformation relation between two indirectly connected coordinate systems\n+        # Find the transformation relation between two indirectly connected\n+        # coordinate systems\n+        rel = sys1.relations\n         path = cls._dijkstra(sys1, sys2)\n-        Lambdas = []\n-        for i in range(len(path) - 1):\n-            s1, s2 = path[i], path[i + 1]\n-            Lambdas.append(s1.transformation(s2))\n-        syms = Lambdas[-1].signature\n-        expr = syms\n-        for l in reversed(Lambdas):\n-            expr = l(*expr)\n-        return Lambda(syms, expr)\n+\n+        transforms = []\n+        for s1, s2 in zip(path, path[1:]):\n+            if (s1, s2) in rel:\n+                transforms.append(rel[(s1, s2)])\n+            else:\n+                sym2, inv_exprs = rel[(s2, s1)]\n+                sym1 = tuple(Dummy() for i in sym2)\n+                ret = cls._solve_inverse(sym2, sym1, inv_exprs, s2, s1)\n+                ret = tuple(ret[s] for s in sym2)\n+                transforms.append((sym1, ret))\n+        syms = sys1.args[2]\n+        exprs = syms\n+        for newsyms, newexprs in transforms:\n+            exprs = tuple(e.subs(zip(newsyms, exprs)) for e in newexprs)\n+        return exprs\n \n     @staticmethod\n     def _dijkstra(sys1, sys2):\n         # Use Dijkstra algorithm to find the shortest path between two indirectly-connected\n         # coordinate systems\n+        # return value is the list of the names of the systems.\n         relations = sys1.relations\n         graph = {}\n         for s1, s2 in relations.keys():\n@@ -465,7 +484,7 @@ def visit(sys):\n                     path_dict[newsys][1] = [i for i in path_dict[sys][1]]\n                     path_dict[newsys][1].append(sys)\n \n-        visit(sys1)\n+        visit(sys1.name)\n \n         while True:\n             min_distance = max(path_dict.values(), key=lambda x:x[0])[0]\n@@ -478,10 +497,10 @@ def visit(sys):\n                 break\n             visit(newsys)\n \n-        result = path_dict[sys2][1]\n-        result.append(sys2)\n+        result = path_dict[sys2.name][1]\n+        result.append(sys2.name)\n \n-        if result == [sys2]:\n+        if result == [sys2.name]:\n             raise KeyError(\"Two coordinate systems are not connected.\")\n         return result\n \ndiff --git a/sympy/diffgeom/rn.py b/sympy/diffgeom/rn.py\n--- a/sympy/diffgeom/rn.py\n+++ b/sympy/diffgeom/rn.py\n@@ -30,8 +30,8 @@\n r, theta = symbols('rho theta', nonnegative=True)\n \n relations_2d = {\n-    ('rectangular', 'polar'): (sqrt(x**2 + y**2), atan2(y, x)),\n-    ('polar', 'rectangular'): (r*cos(theta), r*sin(theta)),\n+    ('rectangular', 'polar'): [(x, y), (sqrt(x**2 + y**2), atan2(y, x))],\n+    ('polar', 'rectangular'): [(r, theta), (r*cos(theta), r*sin(theta))],\n }\n \n R2_r = CoordSystem('rectangular', R2_origin, (x, y), relations_2d)  # type: Any\n@@ -74,18 +74,24 @@\n rho, psi, r, theta, phi = symbols('rho psi r theta phi', nonnegative=True)\n \n relations_3d = {\n-    ('rectangular', 'cylindrical'): (sqrt(x**2 + y**2), atan2(y, x), z),\n-    ('cylindrical', 'rectangular'): (rho*cos(psi), rho*sin(psi), z),\n-    ('rectangular', 'spherical'): (sqrt(x**2 + y**2 + z**2),\n-                                   acos(z/sqrt(x**2 + y**2 + z**2)),\n-                                   atan2(y, x)),\n-    ('spherical', 'rectangular'): (r*sin(theta)*cos(phi),\n-                                   r*sin(theta)*sin(phi),\n-                                   r*cos(theta)),\n-    ('cylindrical', 'spherical'): (sqrt(rho**2 + z**2),\n-                                   acos(z/sqrt(rho**2 + z**2)),\n-                                   psi),\n-    ('spherical', 'cylindrical'): (r*sin(theta), phi, r*cos(theta)),\n+    ('rectangular', 'cylindrical'): [(x, y, z),\n+                                     (sqrt(x**2 + y**2), atan2(y, x), z)],\n+    ('cylindrical', 'rectangular'): [(rho, psi, z),\n+                                     (rho*cos(psi), rho*sin(psi), z)],\n+    ('rectangular', 'spherical'): [(x, y, z),\n+                                   (sqrt(x**2 + y**2 + z**2),\n+                                    acos(z/sqrt(x**2 + y**2 + z**2)),\n+                                    atan2(y, x))],\n+    ('spherical', 'rectangular'): [(r, theta, phi),\n+                                   (r*sin(theta)*cos(phi),\n+                                    r*sin(theta)*sin(phi),\n+                                    r*cos(theta))],\n+    ('cylindrical', 'spherical'): [(rho, psi, z),\n+                                   (sqrt(rho**2 + z**2),\n+                                    acos(z/sqrt(rho**2 + z**2)),\n+                                    psi)],\n+    ('spherical', 'cylindrical'): [(r, theta, phi),\n+                                   (r*sin(theta), phi, r*cos(theta))],\n }\n \n R3_r = CoordSystem('rectangular', R3_origin, (x, y, z), relations_3d)  # type: Any\n",
  "test_patch": "diff --git a/sympy/diffgeom/tests/test_diffgeom.py b/sympy/diffgeom/tests/test_diffgeom.py\n--- a/sympy/diffgeom/tests/test_diffgeom.py\n+++ b/sympy/diffgeom/tests/test_diffgeom.py\n@@ -1,10 +1,10 @@\n+from sympy.core import Lambda, Symbol, symbols\n from sympy.diffgeom.rn import R2, R2_p, R2_r, R3_r, R3_c, R3_s, R2_origin\n from sympy.diffgeom import (CoordSystem, Commutator, Differential, TensorProduct,\n         WedgeProduct, BaseCovarDerivativeOp, CovarDerivativeOp, LieDerivative,\n         covariant_order, contravariant_order, twoform_to_matrix, metric_to_Christoffel_1st,\n         metric_to_Christoffel_2nd, metric_to_Riemann_components,\n         metric_to_Ricci_components, intcurve_diffequ, intcurve_series)\n-from sympy.core import Symbol, symbols\n from sympy.simplify import trigsimp, simplify\n from sympy.functions import sqrt, atan2, sin\n from sympy.matrices import Matrix\n@@ -14,6 +14,78 @@\n TP = TensorProduct\n \n \n+def test_coordsys_transform():\n+    # test inverse transforms\n+    p, q, r, s = symbols('p q r s')\n+    rel = {('first', 'second'): [(p, q), (q, -p)]}\n+    R2_pq = CoordSystem('first', R2_origin, [p, q], rel)\n+    R2_rs = CoordSystem('second', R2_origin, [r, s], rel)\n+    r, s = R2_rs.symbols\n+    assert R2_rs.transform(R2_pq) == Matrix([[-s], [r]])\n+\n+    # inverse transform impossible case\n+    a, b = symbols('a b', positive=True)\n+    rel = {('first', 'second'): [(a,), (-a,)]}\n+    R2_a = CoordSystem('first', R2_origin, [a], rel)\n+    R2_b = CoordSystem('second', R2_origin, [b], rel)\n+    # This transformation is uninvertible because there is no positive a, b satisfying a = -b\n+    with raises(NotImplementedError):\n+        R2_b.transform(R2_a)\n+\n+    # inverse transform ambiguous case\n+    c, d = symbols('c d')\n+    rel = {('first', 'second'): [(c,), (c**2,)]}\n+    R2_c = CoordSystem('first', R2_origin, [c], rel)\n+    R2_d = CoordSystem('second', R2_origin, [d], rel)\n+    # The transform method should throw if it finds multiple inverses for a coordinate transformation.\n+    with raises(ValueError):\n+        R2_d.transform(R2_c)\n+\n+    # test indirect transformation\n+    a, b, c, d, e, f = symbols('a, b, c, d, e, f')\n+    rel = {('C1', 'C2'): [(a, b), (2*a, 3*b)],\n+        ('C2', 'C3'): [(c, d), (3*c, 2*d)]}\n+    C1 = CoordSystem('C1', R2_origin, (a, b), rel)\n+    C2 = CoordSystem('C2', R2_origin, (c, d), rel)\n+    C3 = CoordSystem('C3', R2_origin, (e, f), rel)\n+    a, b = C1.symbols\n+    c, d = C2.symbols\n+    e, f = C3.symbols\n+    assert C2.transform(C1) == Matrix([c/2, d/3])\n+    assert C1.transform(C3) == Matrix([6*a, 6*b])\n+    assert C3.transform(C1) == Matrix([e/6, f/6])\n+    assert C3.transform(C2) == Matrix([e/3, f/2])\n+\n+    a, b, c, d, e, f = symbols('a, b, c, d, e, f')\n+    rel = {('C1', 'C2'): [(a, b), (2*a, 3*b + 1)],\n+        ('C3', 'C2'): [(e, f), (-e - 2, 2*f)]}\n+    C1 = CoordSystem('C1', R2_origin, (a, b), rel)\n+    C2 = CoordSystem('C2', R2_origin, (c, d), rel)\n+    C3 = CoordSystem('C3', R2_origin, (e, f), rel)\n+    a, b = C1.symbols\n+    c, d = C2.symbols\n+    e, f = C3.symbols\n+    assert C2.transform(C1) == Matrix([c/2, (d - 1)/3])\n+    assert C1.transform(C3) == Matrix([-2*a - 2, (3*b + 1)/2])\n+    assert C3.transform(C1) == Matrix([-e/2 - 1, (2*f - 1)/3])\n+    assert C3.transform(C2) == Matrix([-e - 2, 2*f])\n+\n+    # old signature uses Lambda\n+    a, b, c, d, e, f = symbols('a, b, c, d, e, f')\n+    rel = {('C1', 'C2'): Lambda((a, b), (2*a, 3*b + 1)),\n+        ('C3', 'C2'): Lambda((e, f), (-e - 2, 2*f))}\n+    C1 = CoordSystem('C1', R2_origin, (a, b), rel)\n+    C2 = CoordSystem('C2', R2_origin, (c, d), rel)\n+    C3 = CoordSystem('C3', R2_origin, (e, f), rel)\n+    a, b = C1.symbols\n+    c, d = C2.symbols\n+    e, f = C3.symbols\n+    assert C2.transform(C1) == Matrix([c/2, (d - 1)/3])\n+    assert C1.transform(C3) == Matrix([-2*a - 2, (3*b + 1)/2])\n+    assert C3.transform(C1) == Matrix([-e/2 - 1, (2*f - 1)/3])\n+    assert C3.transform(C2) == Matrix([-e - 2, 2*f])\n+\n+\n def test_R2():\n     x0, y0, r0, theta0 = symbols('x0, y0, r0, theta0', real=True)\n     point_r = R2_r.point([x0, y0])\n@@ -37,45 +109,6 @@ def test_R2():\n             R2_r, R2_r.coord_tuple_transform_to(R2_p, m)).applyfunc(simplify)\n \n \n-def test_inverse_transformations():\n-    p, q, r, s = symbols('p q r s')\n-\n-    relations_quarter_rotation = {\n-        ('first', 'second'): (q, -p)\n-    }\n-\n-    R2_pq = CoordSystem('first', R2_origin, [p, q], relations_quarter_rotation)\n-    R2_rs = CoordSystem('second', R2_origin, [r, s], relations_quarter_rotation)\n-\n-    # The transform method should derive the inverse transformation if not given explicitly\n-    assert R2_rs.transform(R2_pq) == Matrix([[-R2_rs.symbols[1]], [R2_rs.symbols[0]]])\n-\n-    a, b = symbols('a b', positive=True)\n-    relations_uninvertible_transformation = {\n-        ('first', 'second'): (-a,)\n-    }\n-\n-    R2_a = CoordSystem('first', R2_origin, [a], relations_uninvertible_transformation)\n-    R2_b = CoordSystem('second', R2_origin, [b], relations_uninvertible_transformation)\n-\n-    # The transform method should throw if it cannot invert the coordinate transformation.\n-    # This transformation is uninvertible because there is no positive a, b satisfying a = -b\n-    with raises(NotImplementedError):\n-        R2_b.transform(R2_a)\n-\n-    c, d = symbols('c d')\n-    relations_ambiguous_inverse = {\n-        ('first', 'second'): (c**2,)\n-    }\n-\n-    R2_c = CoordSystem('first', R2_origin, [c], relations_ambiguous_inverse)\n-    R2_d = CoordSystem('second', R2_origin, [d], relations_ambiguous_inverse)\n-\n-    # The transform method should throw if it finds multiple inverses for a coordinate transformation.\n-    with raises(ValueError):\n-        R2_d.transform(R2_c)\n-\n-\n def test_R3():\n     a, b, c = symbols('a b c', positive=True)\n     m = Matrix([[a], [b], [c]])\n",
  "problem_statement": "diffgeom.CoordSystem.transform with indirect relation raises KeyError\nBelow code is a minimal example for an indirect transform via a temporary intermediate coordinate system. `parabolic2D.transform(poloidal)` raises a KeyError.\r\n\r\nMWE:\r\n```\r\n\"\"\"\r\n2D manifold coordinate systems\r\n\"\"\"\r\nimport sympy\r\nimport sympy.diffgeom\r\n\r\nCARTESIAN2D = \"cartesian2D\"\r\nPOLOIDAL = \"poloidal\"\r\nPARABOLIC2D = \"parabolic2D\"\r\n\r\nm = sympy.diffgeom.Manifold(\"M\", 2)\r\np = sympy.diffgeom.Patch(\"P\", m)\r\nRELATIONS = {}\r\n\r\n# #########\r\n# cartesian\r\n# #########\r\nx, y = sympy.symbols(\"x y\")\r\n\r\n# #########\r\n# poloidal\r\n# #########\r\nr, theta = sympy.symbols(\"r theta\", nonnegative=True)\r\nRELATIONS[(CARTESIAN2D, POLOIDAL)] = sympy.Lambda(\r\n    (x, y),\r\n    sympy.Matrix(\r\n        [\r\n            sympy.sqrt(x ** 2 + y ** 2),\r\n            sympy.atan2(y, x)\r\n        ]\r\n    )\r\n)\r\nRELATIONS[(POLOIDAL, CARTESIAN2D)] = sympy.Lambda(\r\n    (r, theta),\r\n    sympy.Matrix(\r\n        [\r\n            r * sympy.cos(theta),\r\n            r * sympy.sin(theta)\r\n        ]\r\n    )\r\n)\r\n\r\n# #########\r\n# parabolic\r\n# #########\r\nsigma, tau = sympy.symbols(\"sigma tau\")\r\nRELATIONS[(PARABOLIC2D, CARTESIAN2D)] = sympy.Lambda(\r\n    (sigma, tau),\r\n    sympy.Matrix(\r\n        [\r\n            sigma * tau,\r\n            1 / 2 * (tau**2 - sigma**2)\r\n        ]\r\n    )\r\n)\r\n\r\ncartesian2D = sympy.diffgeom.CoordSystem(CARTESIAN2D, p, [x, y], RELATIONS)\r\npoloidal = sympy.diffgeom.CoordSystem(POLOIDAL, p, [r, theta], RELATIONS)\r\nparabolic2D = sympy.diffgeom.CoordSystem(PARABOLIC2D, p, [sigma, tau], RELATIONS)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    print(parabolic2D.transform(poloidal))  # raises a KeyError\r\n    print(poloidal.transform(parabolic2D))  # raises a KeyError\r\n```\r\n\r\nThis raises a KeyError.\r\n\r\n> Traceback (most recent call last):\r\n>   File \"/opt/anaconda/envs/py38/lib/python3.8/pdb.py\", line 1703, in main\r\n>     pdb._runscript(mainpyfile)\r\n>   File \"/opt/anaconda/envs/py38/lib/python3.8/pdb.py\", line 1572, in _runscript\r\n>     self.run(statement)\r\n>   File \"/opt/anaconda/envs/py38/lib/python3.8/bdb.py\", line 580, in run\r\n>     exec(cmd, globals, locals)\r\n>   File \"<string>\", line 1, in <module>\r\n>   File \"/home/IPP-HGW/dboe/git/tfields/tfields/bases/manifold_2.py\", line 1, in <module>\r\n>     \"\"\"\r\n>   File \"/opt/anaconda/envs/py38/lib/python3.8/site-packages/sympy/diffgeom/diffgeom.py\", line 480, in transform\r\n>     transf = self.transformation(sys)\r\n>   File \"/opt/anaconda/envs/py38/lib/python3.8/site-packages/sympy/diffgeom/diffgeom.py\", line 354, in transformation\r\n>     return self._indirect_transformation(self, sys)\r\n>   File \"/opt/anaconda/envs/py38/lib/python3.8/site-packages/sympy/core/cache.py\", line 72, in wrapper\r\n>     retval = cfunc(*args, **kwargs)\r\n>   File \"/opt/anaconda/envs/py38/lib/python3.8/site-packages/sympy/diffgeom/diffgeom.py\", line 376, in _indirect_transformation\r\n>     path = cls._dijkstra(sys1, sys2)\r\n>   File \"/opt/anaconda/envs/py38/lib/python3.8/site-packages/sympy/diffgeom/diffgeom.py\", line 414, in _dijkstra\r\n>     visit(sys1)\r\n>   File \"/opt/anaconda/envs/py38/lib/python3.8/site-packages/sympy/diffgeom/diffgeom.py\", line 406, in visit\r\n>     path_dict[sys][2] = 1\r\n> KeyError: parabolic2D\r\n> \r\n\r\nI think I found the reson already: In dijkstra routing the comparison is done between a CoordSystem and sympy.Str\r\nDEBUGGING:\r\n\r\n```\r\nUncaught exception. Entering post mortem debugging\r\nRunning 'cont' or 'step' will restart the program\r\n> /opt/anaconda/envs/py38/lib/python3.8/site-packages/sympy/diffgeom/diffgeom.py(406)visit()\r\n-> path_dict[sys][2] = 1\r\n(Pdb) path_dict\r\n{cartesian2D: [0, [], 0], poloidal: [0, [], 0], parabolic2D: [0, [], 0]}\r\n(Pdb) sys\r\nparabolic2D\r\n(Pdb) hash(sys)\r\n-2150956724454717966\r\n(Pdb) [hash(k) for k in path_dict]\r\n[6233656281303402583, 5480353473597806494, -1340528192013030397]\r\n(Pdb) type(sys)\r\n<class 'sympy.diffgeom.diffgeom.CoordSystem'>\r\n(Pdb) [type(k) for k in path_dict]\r\n[<class 'sympy.core.symbol.Str'>, <class 'sympy.core.symbol.Str'>, <class 'sympy.core.symbol.Str'>]\r\n```\r\n\n",
  "hints_text": "I started looking into this, I noticed another bug in addition to the type mismatch in the Dijkstra algorithm.  Your example only gives the forward transformation from parabolic2D to cartesian2D, so in order to solve `poloidal.transform(parabolic2D)` the `transform `method will need to calculate the inverse transformation from cartesian2D to parabolic2D, which will raise an exception, see https://github.com/sympy/sympy/issues/21356",
  "created_at": "2021-05-16T07:53:41Z",
  "version": "1.9",
  "FAIL_TO_PASS": "[\"test_coordsys_transform\"]",
  "PASS_TO_PASS": "[\"test_R2\", \"test_R3\", \"test_point\", \"test_commutator\", \"test_differential\", \"test_products\", \"test_lie_derivative\", \"test_intcurve_diffequ\", \"test_helpers_and_coordinate_dependent\", \"test_correct_arguments\"]",
  "environment_setup_commit": "f9a6f50ec0c74d935c50a6e9c9b2cb0469570d91",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.143909",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}