{
  "repo": "django/django",
  "instance_id": "django__django-12953",
  "base_commit": "659a73bc0a2df9be856e23fcfc6cc66d0d1a35fd",
  "patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -28,7 +28,7 @@\n from django.db.models.functions import Coalesce\n from django.db.models.manager import Manager\n from django.db.models.options import Options\n-from django.db.models.query import Q\n+from django.db.models.query import F, Q\n from django.db.models.signals import (\n     class_prepared, post_init, post_save, pre_init, pre_save,\n )\n@@ -1878,6 +1878,22 @@ def _check_long_column_names(cls, databases):\n \n         return errors\n \n+    @classmethod\n+    def _get_expr_references(cls, expr):\n+        if isinstance(expr, Q):\n+            for child in expr.children:\n+                if isinstance(child, tuple):\n+                    lookup, value = child\n+                    yield tuple(lookup.split(LOOKUP_SEP))\n+                    yield from cls._get_expr_references(value)\n+                else:\n+                    yield from cls._get_expr_references(child)\n+        elif isinstance(expr, F):\n+            yield tuple(expr.name.split(LOOKUP_SEP))\n+        elif hasattr(expr, 'get_source_expressions'):\n+            for src_expr in expr.get_source_expressions():\n+                yield from cls._get_expr_references(src_expr)\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n@@ -1960,10 +1976,54 @@ def _check_constraints(cls, databases):\n                         id='models.W039',\n                     )\n                 )\n-            fields = chain.from_iterable(\n+            fields = set(chain.from_iterable(\n                 (*constraint.fields, *constraint.include)\n                 for constraint in cls._meta.constraints if isinstance(constraint, UniqueConstraint)\n-            )\n+            ))\n+            references = set()\n+            for constraint in cls._meta.constraints:\n+                if isinstance(constraint, UniqueConstraint):\n+                    if (\n+                        connection.features.supports_partial_indexes or\n+                        'supports_partial_indexes' not in cls._meta.required_db_features\n+                    ) and isinstance(constraint.condition, Q):\n+                        references.update(cls._get_expr_references(constraint.condition))\n+                elif isinstance(constraint, CheckConstraint):\n+                    if (\n+                        connection.features.supports_table_check_constraints or\n+                        'supports_table_check_constraints' not in cls._meta.required_db_features\n+                    ) and isinstance(constraint.check, Q):\n+                        references.update(cls._get_expr_references(constraint.check))\n+            for field_name, *lookups in references:\n+                # pk is an alias that won't be found by opts.get_field.\n+                if field_name != 'pk':\n+                    fields.add(field_name)\n+                if not lookups:\n+                    # If it has no lookups it cannot result in a JOIN.\n+                    continue\n+                try:\n+                    if field_name == 'pk':\n+                        field = cls._meta.pk\n+                    else:\n+                        field = cls._meta.get_field(field_name)\n+                    if not field.is_relation or field.many_to_many or field.one_to_many:\n+                        continue\n+                except FieldDoesNotExist:\n+                    continue\n+                # JOIN must happen at the first lookup.\n+                first_lookup = lookups[0]\n+                if (\n+                    field.get_transform(first_lookup) is None and\n+                    field.get_lookup(first_lookup) is None\n+                ):\n+                    errors.append(\n+                        checks.Error(\n+                            \"'constraints' refers to the joined field '%s'.\"\n+                            % LOOKUP_SEP.join([field_name] + lookups),\n+                            obj=cls,\n+                            id='models.E041',\n+                        )\n+                    )\n             errors.extend(cls._check_local_fields(fields, 'constraints'))\n         return errors\n \n",
  "test_patch": "diff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -1534,6 +1534,192 @@ class Meta:\n                 constraints = [models.CheckConstraint(check=models.Q(age__gte=18), name='is_adult')]\n         self.assertEqual(Model.check(databases=self.databases), [])\n \n+    def test_check_constraint_pointing_to_missing_field(self):\n+        class Model(models.Model):\n+            class Meta:\n+                required_db_features = {'supports_table_check_constraints'}\n+                constraints = [\n+                    models.CheckConstraint(\n+                        name='name', check=models.Q(missing_field=2),\n+                    ),\n+                ]\n+\n+        self.assertEqual(Model.check(databases=self.databases), [\n+            Error(\n+                \"'constraints' refers to the nonexistent field \"\n+                \"'missing_field'.\",\n+                obj=Model,\n+                id='models.E012',\n+            ),\n+        ] if connection.features.supports_table_check_constraints else [])\n+\n+    @skipUnlessDBFeature('supports_table_check_constraints')\n+    def test_check_constraint_pointing_to_reverse_fk(self):\n+        class Model(models.Model):\n+            parent = models.ForeignKey('self', models.CASCADE, related_name='parents')\n+\n+            class Meta:\n+                constraints = [\n+                    models.CheckConstraint(name='name', check=models.Q(parents=3)),\n+                ]\n+\n+        self.assertEqual(Model.check(databases=self.databases), [\n+            Error(\n+                \"'constraints' refers to the nonexistent field 'parents'.\",\n+                obj=Model,\n+                id='models.E012',\n+            ),\n+        ])\n+\n+    @skipUnlessDBFeature('supports_table_check_constraints')\n+    def test_check_constraint_pointing_to_m2m_field(self):\n+        class Model(models.Model):\n+            m2m = models.ManyToManyField('self')\n+\n+            class Meta:\n+                constraints = [\n+                    models.CheckConstraint(name='name', check=models.Q(m2m=2)),\n+                ]\n+\n+        self.assertEqual(Model.check(databases=self.databases), [\n+            Error(\n+                \"'constraints' refers to a ManyToManyField 'm2m', but \"\n+                \"ManyToManyFields are not permitted in 'constraints'.\",\n+                obj=Model,\n+                id='models.E013',\n+            ),\n+        ])\n+\n+    @skipUnlessDBFeature('supports_table_check_constraints')\n+    def test_check_constraint_pointing_to_fk(self):\n+        class Target(models.Model):\n+            pass\n+\n+        class Model(models.Model):\n+            fk_1 = models.ForeignKey(Target, models.CASCADE, related_name='target_1')\n+            fk_2 = models.ForeignKey(Target, models.CASCADE, related_name='target_2')\n+\n+            class Meta:\n+                constraints = [\n+                    models.CheckConstraint(\n+                        name='name',\n+                        check=models.Q(fk_1_id=2) | models.Q(fk_2=2),\n+                    ),\n+                ]\n+\n+        self.assertEqual(Model.check(databases=self.databases), [])\n+\n+    @skipUnlessDBFeature('supports_table_check_constraints')\n+    def test_check_constraint_pointing_to_pk(self):\n+        class Model(models.Model):\n+            age = models.SmallIntegerField()\n+\n+            class Meta:\n+                constraints = [\n+                    models.CheckConstraint(\n+                        name='name',\n+                        check=models.Q(pk__gt=5) & models.Q(age__gt=models.F('pk')),\n+                    ),\n+                ]\n+\n+        self.assertEqual(Model.check(databases=self.databases), [])\n+\n+    @skipUnlessDBFeature('supports_table_check_constraints')\n+    def test_check_constraint_pointing_to_non_local_field(self):\n+        class Parent(models.Model):\n+            field1 = models.IntegerField()\n+\n+        class Child(Parent):\n+            pass\n+\n+            class Meta:\n+                constraints = [\n+                    models.CheckConstraint(name='name', check=models.Q(field1=1)),\n+                ]\n+\n+        self.assertEqual(Child.check(databases=self.databases), [\n+            Error(\n+                \"'constraints' refers to field 'field1' which is not local to \"\n+                \"model 'Child'.\",\n+                hint='This issue may be caused by multi-table inheritance.',\n+                obj=Child,\n+                id='models.E016',\n+            ),\n+        ])\n+\n+    @skipUnlessDBFeature('supports_table_check_constraints')\n+    def test_check_constraint_pointing_to_joined_fields(self):\n+        class Model(models.Model):\n+            name = models.CharField(max_length=10)\n+            field1 = models.PositiveSmallIntegerField()\n+            field2 = models.PositiveSmallIntegerField()\n+            field3 = models.PositiveSmallIntegerField()\n+            parent = models.ForeignKey('self', models.CASCADE)\n+\n+            class Meta:\n+                constraints = [\n+                    models.CheckConstraint(\n+                        name='name1', check=models.Q(\n+                            field1__lt=models.F('parent__field1') + models.F('parent__field2')\n+                        )\n+                    ),\n+                    models.CheckConstraint(\n+                        name='name2', check=models.Q(name=Lower('parent__name'))\n+                    ),\n+                    models.CheckConstraint(\n+                        name='name3', check=models.Q(parent__field3=models.F('field1'))\n+                    ),\n+                ]\n+\n+        joined_fields = ['parent__field1', 'parent__field2', 'parent__field3', 'parent__name']\n+        errors = Model.check(databases=self.databases)\n+        expected_errors = [\n+            Error(\n+                \"'constraints' refers to the joined field '%s'.\" % field_name,\n+                obj=Model,\n+                id='models.E041',\n+            ) for field_name in joined_fields\n+        ]\n+        self.assertCountEqual(errors, expected_errors)\n+\n+    @skipUnlessDBFeature('supports_table_check_constraints')\n+    def test_check_constraint_pointing_to_joined_fields_complex_check(self):\n+        class Model(models.Model):\n+            name = models.PositiveSmallIntegerField()\n+            field1 = models.PositiveSmallIntegerField()\n+            field2 = models.PositiveSmallIntegerField()\n+            parent = models.ForeignKey('self', models.CASCADE)\n+\n+            class Meta:\n+                constraints = [\n+                    models.CheckConstraint(\n+                        name='name',\n+                        check=models.Q(\n+                            (\n+                                models.Q(name='test') &\n+                                models.Q(field1__lt=models.F('parent__field1'))\n+                            ) |\n+                            (\n+                                models.Q(name__startswith=Lower('parent__name')) &\n+                                models.Q(field1__gte=(\n+                                    models.F('parent__field1') + models.F('parent__field2')\n+                                ))\n+                            )\n+                        ) | (models.Q(name='test1'))\n+                    ),\n+                ]\n+\n+        joined_fields = ['parent__field1', 'parent__field2', 'parent__name']\n+        errors = Model.check(databases=self.databases)\n+        expected_errors = [\n+            Error(\n+                \"'constraints' refers to the joined field '%s'.\" % field_name,\n+                obj=Model,\n+                id='models.E041',\n+            ) for field_name in joined_fields\n+        ]\n+        self.assertCountEqual(errors, expected_errors)\n+\n     def test_unique_constraint_with_condition(self):\n         class Model(models.Model):\n             age = models.IntegerField()\n@@ -1578,6 +1764,52 @@ class Meta:\n \n         self.assertEqual(Model.check(databases=self.databases), [])\n \n+    def test_unique_constraint_condition_pointing_to_missing_field(self):\n+        class Model(models.Model):\n+            age = models.SmallIntegerField()\n+\n+            class Meta:\n+                required_db_features = {'supports_partial_indexes'}\n+                constraints = [\n+                    models.UniqueConstraint(\n+                        name='name',\n+                        fields=['age'],\n+                        condition=models.Q(missing_field=2),\n+                    ),\n+                ]\n+\n+        self.assertEqual(Model.check(databases=self.databases), [\n+            Error(\n+                \"'constraints' refers to the nonexistent field \"\n+                \"'missing_field'.\",\n+                obj=Model,\n+                id='models.E012',\n+            ),\n+        ] if connection.features.supports_partial_indexes else [])\n+\n+    def test_unique_constraint_condition_pointing_to_joined_fields(self):\n+        class Model(models.Model):\n+            age = models.SmallIntegerField()\n+            parent = models.ForeignKey('self', models.CASCADE)\n+\n+            class Meta:\n+                required_db_features = {'supports_partial_indexes'}\n+                constraints = [\n+                    models.UniqueConstraint(\n+                        name='name',\n+                        fields=['age'],\n+                        condition=models.Q(parent__age__lt=2),\n+                    ),\n+                ]\n+\n+        self.assertEqual(Model.check(databases=self.databases), [\n+            Error(\n+                \"'constraints' refers to the joined field 'parent__age__lt'.\",\n+                obj=Model,\n+                id='models.E041',\n+            )\n+        ] if connection.features.supports_partial_indexes else [])\n+\n     def test_deferrable_unique_constraint(self):\n         class Model(models.Model):\n             age = models.IntegerField()\n",
  "problem_statement": "Check that CheckConstraint.check and UniqueConstraint.condition don't span joins.\nDescription\n\t \n\t\t(last modified by Mariusz Felisiak)\n\t \nSimilar to #31410 but for check and condition.\nNot everyone is familiar with the fact database level constraint cannot span across tables and might be tempted to do\nclass Person(models.Model):\n\tage = models.PositiveSmallIntegerField()\n\tparent = models.ForeignKey(self)\n\tclass Meta:\n\t\tconstraints = {\n\t\t\tCheckConstraint(\n\t\t\t\tname='age_lt_parent', check=Q(age__lt=parent__age)\n\t\t\t),\n\t\t}\nWhich we'll happily create migrations for but we'll then crash because we prevent JOINs when resolving check.\n",
  "hints_text": "",
  "created_at": "2020-05-22T13:30:18Z",
  "version": "3.2",
  "FAIL_TO_PASS": "[\"test_check_constraint_pointing_to_joined_fields (invalid_models_tests.test_models.ConstraintsTests)\", \"test_check_constraint_pointing_to_joined_fields_complex_check (invalid_models_tests.test_models.ConstraintsTests)\", \"test_check_constraint_pointing_to_m2m_field (invalid_models_tests.test_models.ConstraintsTests)\", \"test_check_constraint_pointing_to_missing_field (invalid_models_tests.test_models.ConstraintsTests)\", \"test_check_constraint_pointing_to_non_local_field (invalid_models_tests.test_models.ConstraintsTests)\", \"test_check_constraint_pointing_to_reverse_fk (invalid_models_tests.test_models.ConstraintsTests)\", \"test_unique_constraint_condition_pointing_to_joined_fields (invalid_models_tests.test_models.ConstraintsTests)\", \"test_unique_constraint_condition_pointing_to_missing_field (invalid_models_tests.test_models.ConstraintsTests)\"]",
  "PASS_TO_PASS": "[\"test_db_column_clash (invalid_models_tests.test_models.FieldNamesTests)\", \"test_ending_with_underscore (invalid_models_tests.test_models.FieldNamesTests)\", \"test_including_separator (invalid_models_tests.test_models.FieldNamesTests)\", \"test_pk (invalid_models_tests.test_models.FieldNamesTests)\", \"test_check_jsonfield (invalid_models_tests.test_models.JSONFieldTests)\", \"test_check_jsonfield_required_db_features (invalid_models_tests.test_models.JSONFieldTests)\", \"test_ordering_pointing_to_json_field_value (invalid_models_tests.test_models.JSONFieldTests)\", \"test_index_with_condition (invalid_models_tests.test_models.IndexesTests)\", \"test_index_with_condition_required_db_features (invalid_models_tests.test_models.IndexesTests)\", \"test_index_with_include (invalid_models_tests.test_models.IndexesTests)\", \"test_index_with_include_required_db_features (invalid_models_tests.test_models.IndexesTests)\", \"test_max_name_length (invalid_models_tests.test_models.IndexesTests)\", \"test_name_constraints (invalid_models_tests.test_models.IndexesTests)\", \"test_pointing_to_fk (invalid_models_tests.test_models.IndexesTests)\", \"test_pointing_to_m2m_field (invalid_models_tests.test_models.IndexesTests)\", \"test_pointing_to_missing_field (invalid_models_tests.test_models.IndexesTests)\", \"test_pointing_to_non_local_field (invalid_models_tests.test_models.IndexesTests)\", \"test_list_containing_non_iterable (invalid_models_tests.test_models.IndexTogetherTests)\", \"test_non_iterable (invalid_models_tests.test_models.IndexTogetherTests)\", \"test_non_list (invalid_models_tests.test_models.IndexTogetherTests)\", \"test_pointing_to_fk (invalid_models_tests.test_models.IndexTogetherTests)\", \"test_pointing_to_m2m_field (invalid_models_tests.test_models.IndexTogetherTests)\", \"test_pointing_to_missing_field (invalid_models_tests.test_models.IndexTogetherTests)\", \"test_pointing_to_non_local_field (invalid_models_tests.test_models.IndexTogetherTests)\", \"test_list_containing_non_iterable (invalid_models_tests.test_models.UniqueTogetherTests)\", \"test_non_iterable (invalid_models_tests.test_models.UniqueTogetherTests)\", \"test_non_list (invalid_models_tests.test_models.UniqueTogetherTests)\", \"test_pointing_to_fk (invalid_models_tests.test_models.UniqueTogetherTests)\", \"test_pointing_to_m2m (invalid_models_tests.test_models.UniqueTogetherTests)\", \"test_pointing_to_missing_field (invalid_models_tests.test_models.UniqueTogetherTests)\", \"test_valid_model (invalid_models_tests.test_models.UniqueTogetherTests)\", \"test_field_name_clash_with_child_accessor (invalid_models_tests.test_models.ShadowingFieldsTests)\", \"test_id_clash (invalid_models_tests.test_models.ShadowingFieldsTests)\", \"test_inheritance_clash (invalid_models_tests.test_models.ShadowingFieldsTests)\", \"test_multigeneration_inheritance (invalid_models_tests.test_models.ShadowingFieldsTests)\", \"test_multiinheritance_clash (invalid_models_tests.test_models.ShadowingFieldsTests)\", \"test_check_constraint_pointing_to_fk (invalid_models_tests.test_models.ConstraintsTests)\", \"test_check_constraint_pointing_to_pk (invalid_models_tests.test_models.ConstraintsTests)\", \"test_check_constraints (invalid_models_tests.test_models.ConstraintsTests)\", \"test_check_constraints_required_db_features (invalid_models_tests.test_models.ConstraintsTests)\", \"test_deferrable_unique_constraint (invalid_models_tests.test_models.ConstraintsTests)\", \"test_deferrable_unique_constraint_required_db_features (invalid_models_tests.test_models.ConstraintsTests)\", \"test_unique_constraint_pointing_to_fk (invalid_models_tests.test_models.ConstraintsTests)\", \"test_unique_constraint_pointing_to_m2m_field (invalid_models_tests.test_models.ConstraintsTests)\", \"test_unique_constraint_pointing_to_missing_field (invalid_models_tests.test_models.ConstraintsTests)\", \"test_unique_constraint_pointing_to_non_local_field (invalid_models_tests.test_models.ConstraintsTests)\", \"test_unique_constraint_with_condition (invalid_models_tests.test_models.ConstraintsTests)\", \"test_unique_constraint_with_condition_required_db_features (invalid_models_tests.test_models.ConstraintsTests)\", \"test_unique_constraint_with_include (invalid_models_tests.test_models.ConstraintsTests)\", \"test_unique_constraint_with_include_required_db_features (invalid_models_tests.test_models.ConstraintsTests)\", \"test_just_order_with_respect_to_no_errors (invalid_models_tests.test_models.OtherModelTests)\", \"test_just_ordering_no_errors (invalid_models_tests.test_models.OtherModelTests)\", \"test_lazy_reference_checks (invalid_models_tests.test_models.OtherModelTests)\", \"test_m2m_autogenerated_table_name_clash (invalid_models_tests.test_models.OtherModelTests)\", \"test_m2m_autogenerated_table_name_clash_database_routers_installed (invalid_models_tests.test_models.OtherModelTests)\", \"test_m2m_field_table_name_clash (invalid_models_tests.test_models.OtherModelTests)\", \"test_m2m_field_table_name_clash_database_routers_installed (invalid_models_tests.test_models.OtherModelTests)\", \"test_m2m_table_name_clash (invalid_models_tests.test_models.OtherModelTests)\", \"test_m2m_table_name_clash_database_routers_installed (invalid_models_tests.test_models.OtherModelTests)\", \"test_m2m_to_concrete_and_proxy_allowed (invalid_models_tests.test_models.OtherModelTests)\", \"test_m2m_unmanaged_shadow_models_not_checked (invalid_models_tests.test_models.OtherModelTests)\", \"test_name_beginning_with_underscore (invalid_models_tests.test_models.OtherModelTests)\", \"test_name_contains_double_underscores (invalid_models_tests.test_models.OtherModelTests)\", \"test_name_ending_with_underscore (invalid_models_tests.test_models.OtherModelTests)\", \"test_non_valid (invalid_models_tests.test_models.OtherModelTests)\", \"test_onetoone_with_explicit_parent_link_parent_model (invalid_models_tests.test_models.OtherModelTests)\", \"test_onetoone_with_parent_model (invalid_models_tests.test_models.OtherModelTests)\", \"test_ordering_allows_registered_lookups (invalid_models_tests.test_models.OtherModelTests)\", \"test_ordering_non_iterable (invalid_models_tests.test_models.OtherModelTests)\", \"test_ordering_pointing_multiple_times_to_model_fields (invalid_models_tests.test_models.OtherModelTests)\", \"test_ordering_pointing_to_foreignkey_field (invalid_models_tests.test_models.OtherModelTests)\", \"test_ordering_pointing_to_lookup_not_transform (invalid_models_tests.test_models.OtherModelTests)\", \"test_ordering_pointing_to_missing_field (invalid_models_tests.test_models.OtherModelTests)\", \"test_ordering_pointing_to_missing_foreignkey_field (invalid_models_tests.test_models.OtherModelTests)\", \"test_ordering_pointing_to_missing_related_field (invalid_models_tests.test_models.OtherModelTests)\", \"test_ordering_pointing_to_missing_related_model_field (invalid_models_tests.test_models.OtherModelTests)\", \"test_ordering_pointing_to_non_related_field (invalid_models_tests.test_models.OtherModelTests)\", \"test_ordering_pointing_to_related_model_pk (invalid_models_tests.test_models.OtherModelTests)\", \"test_ordering_pointing_to_two_related_model_field (invalid_models_tests.test_models.OtherModelTests)\", \"test_ordering_with_order_with_respect_to (invalid_models_tests.test_models.OtherModelTests)\", \"test_property_and_related_field_accessor_clash (invalid_models_tests.test_models.OtherModelTests)\", \"test_single_primary_key (invalid_models_tests.test_models.OtherModelTests)\", \"test_swappable_missing_app (invalid_models_tests.test_models.OtherModelTests)\", \"test_swappable_missing_app_name (invalid_models_tests.test_models.OtherModelTests)\", \"test_two_m2m_through_same_model_with_different_through_fields (invalid_models_tests.test_models.OtherModelTests)\", \"test_two_m2m_through_same_relationship (invalid_models_tests.test_models.OtherModelTests)\", \"test_unique_primary_key (invalid_models_tests.test_models.OtherModelTests)\"]",
  "environment_setup_commit": "65dfb06a1ab56c238cc80f5e1c31f61210c4577d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.639451",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}