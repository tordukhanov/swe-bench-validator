{
  "repo": "sphinx-doc/sphinx",
  "instance_id": "sphinx-doc__sphinx-8117",
  "base_commit": "667a188e25cb70a1c673081b066a8a90c6e8eea7",
  "patch": "diff --git a/sphinx/domains/c.py b/sphinx/domains/c.py\n--- a/sphinx/domains/c.py\n+++ b/sphinx/domains/c.py\n@@ -32,7 +32,7 @@\n from sphinx.transforms.post_transforms import ReferencesResolver\n from sphinx.util import logging\n from sphinx.util.cfamily import (\n-    NoOldIdError, ASTBaseBase, ASTBaseParenExprList,\n+    NoOldIdError, ASTBaseBase, ASTAttribute, ASTBaseParenExprList,\n     verify_description_mode, StringifyTransform,\n     BaseParser, DefinitionError, UnsupportedMultiCharacterCharLiteral,\n     identifier_re, anon_identifier_re, integer_literal_re, octal_literal_re,\n@@ -652,8 +652,9 @@ def describe_signature(self, signode: Any, mode: str,\n \n \n class ASTParameters(ASTBase):\n-    def __init__(self, args: List[ASTFunctionParameter]) -> None:\n+    def __init__(self, args: List[ASTFunctionParameter], attrs: List[ASTAttribute]) -> None:\n         self.args = args\n+        self.attrs = attrs\n \n     @property\n     def function_params(self) -> List[ASTFunctionParameter]:\n@@ -669,6 +670,9 @@ def _stringify(self, transform: StringifyTransform) -> str:\n             first = False\n             res.append(str(a))\n         res.append(')')\n+        for attr in self.attrs:\n+            res.append(' ')\n+            res.append(transform(attr))\n         return ''.join(res)\n \n     def describe_signature(self, signode: TextElement, mode: str,\n@@ -683,6 +687,9 @@ def describe_signature(self, signode: TextElement, mode: str,\n                 arg.describe_signature(param, 'markType', env, symbol=symbol)\n             paramlist += param\n         signode += paramlist\n+        for attr in self.attrs:\n+            signode += nodes.Text(' ')\n+            attr.describe_signature(signode)\n \n \n class ASTDeclSpecsSimple(ASTBaseBase):\n@@ -2572,7 +2579,15 @@ def _parse_parameters(self, paramMode: str) -> ASTParameters:\n                     self.fail(\n                         'Expecting \",\" or \")\" in parameters, '\n                         'got \"%s\".' % self.current_char)\n-        return ASTParameters(args)\n+\n+        attrs = []\n+        while True:\n+            attr = self._parse_attribute()\n+            if attr is None:\n+                break\n+            attrs.append(attr)\n+\n+        return ASTParameters(args, attrs)\n \n     def _parse_decl_specs_simple(self, outer: str, typed: bool) -> ASTDeclSpecsSimple:\n         \"\"\"Just parse the simple ones.\"\"\"\ndiff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -1879,7 +1879,8 @@ def describe_signature(self, signode: TextElement, mode: str,\n class ASTParametersQualifiers(ASTBase):\n     def __init__(self, args: List[ASTFunctionParameter], volatile: bool, const: bool,\n                  refQual: str, exceptionSpec: ASTNoexceptSpec, trailingReturn: \"ASTType\",\n-                 override: bool, final: bool, initializer: str) -> None:\n+                 override: bool, final: bool, attrs: List[ASTAttribute],\n+                 initializer: str) -> None:\n         self.args = args\n         self.volatile = volatile\n         self.const = const\n@@ -1888,6 +1889,7 @@ def __init__(self, args: List[ASTFunctionParameter], volatile: bool, const: bool\n         self.trailingReturn = trailingReturn\n         self.override = override\n         self.final = final\n+        self.attrs = attrs\n         self.initializer = initializer\n \n     @property\n@@ -1947,6 +1949,9 @@ def _stringify(self, transform: StringifyTransform) -> str:\n             res.append(' final')\n         if self.override:\n             res.append(' override')\n+        for attr in self.attrs:\n+            res.append(' ')\n+            res.append(transform(attr))\n         if self.initializer:\n             res.append(' = ')\n             res.append(self.initializer)\n@@ -1988,6 +1993,9 @@ def _add_text(signode: TextElement, text: str) -> None:\n             _add_anno(signode, 'final')\n         if self.override:\n             _add_anno(signode, 'override')\n+        for attr in self.attrs:\n+            signode += nodes.Text(' ')\n+            attr.describe_signature(signode)\n         if self.initializer:\n             _add_text(signode, '= ' + str(self.initializer))\n \n@@ -5709,6 +5717,13 @@ def _parse_parameters_and_qualifiers(self, paramMode: str) -> ASTParametersQuali\n             override = self.skip_word_and_ws(\n                 'override')  # they can be permuted\n \n+        attrs = []\n+        while True:\n+            attr = self._parse_attribute()\n+            if attr is None:\n+                break\n+            attrs.append(attr)\n+\n         self.skip_ws()\n         initializer = None\n         if self.skip_string('='):\n@@ -5725,7 +5740,7 @@ def _parse_parameters_and_qualifiers(self, paramMode: str) -> ASTParametersQuali\n \n         return ASTParametersQualifiers(\n             args, volatile, const, refQual, exceptionSpec, trailingReturn,\n-            override, final, initializer)\n+            override, final, attrs, initializer)\n \n     def _parse_decl_specs_simple(self, outer: str, typed: bool) -> ASTDeclSpecsSimple:\n         \"\"\"Just parse the simple ones.\"\"\"\ndiff --git a/sphinx/util/cfamily.py b/sphinx/util/cfamily.py\n--- a/sphinx/util/cfamily.py\n+++ b/sphinx/util/cfamily.py\n@@ -391,7 +391,7 @@ def _parse_balanced_token_seq(self, end: List[str]) -> str:\n                       % startPos)\n         return self.definition[startPos:self.pos]\n \n-    def _parse_attribute(self) -> ASTAttribute:\n+    def _parse_attribute(self) -> Optional[ASTAttribute]:\n         self.skip_ws()\n         # try C++11 style\n         startPos = self.pos\n",
  "test_patch": "diff --git a/tests/test_domain_c.py b/tests/test_domain_c.py\n--- a/tests/test_domain_c.py\n+++ b/tests/test_domain_c.py\n@@ -497,17 +497,16 @@ def test_attributes():\n         parse('member', 'paren_attr({]}) int f')\n \n     # position: decl specs\n-    check('function', 'static inline __attribute__(()) void f()',\n-          {1: 'f'},\n+    check('function', 'static inline __attribute__(()) void f()', {1: 'f'},\n           output='__attribute__(()) static inline void f()')\n-    check('function', '[[attr1]] [[attr2]] void f()',\n-          {1: 'f'},\n-          output='[[attr1]] [[attr2]] void f()')\n+    check('function', '[[attr1]] [[attr2]] void f()', {1: 'f'})\n     # position: declarator\n     check('member', 'int *[[attr]] i', {1: 'i'})\n     check('member', 'int *const [[attr]] volatile i', {1: 'i'},\n           output='int *[[attr]] volatile const i')\n     check('member', 'int *[[attr]] *i', {1: 'i'})\n+    # position: parameters\n+    check('function', 'void f() [[attr1]] [[attr2]]', {1: 'f'})\n \n     # issue michaeljones/breathe#500\n     check('function', 'LIGHTGBM_C_EXPORT int LGBM_BoosterFree(int handle)',\ndiff --git a/tests/test_domain_cpp.py b/tests/test_domain_cpp.py\n--- a/tests/test_domain_cpp.py\n+++ b/tests/test_domain_cpp.py\n@@ -938,15 +938,15 @@ def test_attributes():\n     check('function', 'static inline __attribute__(()) void f()',\n           {1: 'f', 2: '1fv'},\n           output='__attribute__(()) static inline void f()')\n-    check('function', '[[attr1]] [[attr2]] void f()',\n-          {1: 'f', 2: '1fv'},\n-          output='[[attr1]] [[attr2]] void f()')\n+    check('function', '[[attr1]] [[attr2]] void f()', {1: 'f', 2: '1fv'})\n     # position: declarator\n     check('member', 'int *[[attr]] i', {1: 'i__iP', 2: '1i'})\n     check('member', 'int *const [[attr]] volatile i', {1: 'i__iPVC', 2: '1i'},\n           output='int *[[attr]] volatile const i')\n     check('member', 'int &[[attr]] i', {1: 'i__iR', 2: '1i'})\n     check('member', 'int *[[attr]] *i', {1: 'i__iPP', 2: '1i'})\n+    # position: parameters and qualifiers\n+    check('function', 'void f() [[attr1]] [[attr2]]', {1: 'f', 2: '1fv'})\n \n \n def test_xref_parsing():\n",
  "problem_statement": "\"Invalid C declaration\" on C function with macro after function arguments\n**Describe the bug**\r\nI have a C function definition with a trailing macro which specifies the function as \"noreturn\" and this gives an error during build, even when this keyword is defined in `c_id_attributes`.\r\n\r\n**To Reproduce**\r\nI have the following on an RST:\r\n\r\n    .. c:function:: void up_exit(int status) noreturn_function;\r\n\r\nAnd this on the config:\r\n<pre>\r\nc_id_attributes = [\r\n  'FAR',\r\n  'CODE',\r\n  'noreturn_function'\r\n]\r\n</pre>\r\n\r\nAnd during build I get:\r\n\r\n<pre>\r\n/home/v01d/coding/nuttx_docs/nuttx/doc/reference/os/arch.rst:225: WARNING: Invalid C declaration: Expected end of definition. [error at 25]\r\n  void up_exit(int status) noreturn_function;\r\n  -------------------------^\r\n</pre>\r\n\r\n**Expected behavior**\r\nThe macro should be ignored while parsing the function declaration.\r\n\r\n**Your project**\r\nhttps://github.com/v01d/incubator-nuttx/tree/docs/doc\r\n\r\n**Environment info**\r\n- OS: Ubuntu 20.04\r\n- Python version: 3.8.2\r\n- Sphinx version: 3.1.2\r\n- Sphinx extensions:  sphinx.ext.autodoc, recommonmark\n",
  "hints_text": "",
  "created_at": "2020-08-13T16:42:12Z",
  "version": "3.3",
  "FAIL_TO_PASS": "[\"tests/test_domain_c.py::test_attributes\", \"tests/test_domain_cpp.py::test_attributes\"]",
  "PASS_TO_PASS": "[\"tests/test_domain_c.py::test_expressions\", \"tests/test_domain_c.py::test_type_definitions\", \"tests/test_domain_c.py::test_macro_definitions\", \"tests/test_domain_c.py::test_member_definitions\", \"tests/test_domain_c.py::test_function_definitions\", \"tests/test_domain_c.py::test_nested_name\", \"tests/test_domain_c.py::test_union_definitions\", \"tests/test_domain_c.py::test_enum_definitions\", \"tests/test_domain_c.py::test_anon_definitions\", \"tests/test_domain_c.py::test_initializers\", \"tests/test_domain_c.py::test_build_domain_c\", \"tests/test_domain_c.py::test_build_domain_c_namespace\", \"tests/test_domain_c.py::test_build_domain_c_anon_dup_decl\", \"tests/test_domain_c.py::test_build_domain_c_semicolon\", \"tests/test_domain_c.py::test_cfunction\", \"tests/test_domain_c.py::test_cmember\", \"tests/test_domain_c.py::test_cvar\", \"tests/test_domain_c.py::test_noindexentry\", \"tests/test_domain_cpp.py::test_fundamental_types\", \"tests/test_domain_cpp.py::test_expressions\", \"tests/test_domain_cpp.py::test_type_definitions\", \"tests/test_domain_cpp.py::test_concept_definitions\", \"tests/test_domain_cpp.py::test_member_definitions\", \"tests/test_domain_cpp.py::test_function_definitions\", \"tests/test_domain_cpp.py::test_operators\", \"tests/test_domain_cpp.py::test_nested_name\", \"tests/test_domain_cpp.py::test_class_definitions\", \"tests/test_domain_cpp.py::test_union_definitions\", \"tests/test_domain_cpp.py::test_enum_definitions\", \"tests/test_domain_cpp.py::test_anon_definitions\", \"tests/test_domain_cpp.py::test_templates\", \"tests/test_domain_cpp.py::test_requires_clauses\", \"tests/test_domain_cpp.py::test_template_args\", \"tests/test_domain_cpp.py::test_initializers\", \"tests/test_domain_cpp.py::test_xref_parsing\", \"tests/test_domain_cpp.py::test_build_domain_cpp_multi_decl_lookup\", \"tests/test_domain_cpp.py::test_build_domain_cpp_warn_template_param_qualified_name\", \"tests/test_domain_cpp.py::test_build_domain_cpp_backslash_ok\", \"tests/test_domain_cpp.py::test_build_domain_cpp_semicolon\", \"tests/test_domain_cpp.py::test_build_domain_cpp_anon_dup_decl\", \"tests/test_domain_cpp.py::test_build_domain_cpp_misuse_of_roles\", \"tests/test_domain_cpp.py::test_build_domain_cpp_with_add_function_parentheses_is_True\", \"tests/test_domain_cpp.py::test_build_domain_cpp_with_add_function_parentheses_is_False\", \"tests/test_domain_cpp.py::test_xref_consistency\", \"tests/test_domain_cpp.py::test_noindexentry\"]",
  "environment_setup_commit": "3b85187ffa3401e88582073c23188c147857a8a3",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.051731",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}