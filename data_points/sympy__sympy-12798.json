{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-12798",
  "base_commit": "48c9393649be16f163799f8092c063aedc90b33f",
  "patch": "diff --git a/sympy/functions/combinatorial/factorials.py b/sympy/functions/combinatorial/factorials.py\n--- a/sympy/functions/combinatorial/factorials.py\n+++ b/sympy/functions/combinatorial/factorials.py\n@@ -13,9 +13,7 @@\n from sympy.core.compatibility import reduce, range, HAS_GMPY\n from sympy.core.cache import cacheit\n \n-from sympy.polys.polytools import poly_from_expr\n-from sympy.polys.polyerrors import PolificationFailed\n-\n+from sympy.polys.polytools import Poly\n \n class CombinatorialFunction(Function):\n     \"\"\"Base class for combinatorial functions. \"\"\"\n@@ -408,7 +406,8 @@ def _eval_rewrite_as_gamma(self, n):\n \n \n class RisingFactorial(CombinatorialFunction):\n-    \"\"\"Rising factorial (also called Pochhammer symbol) is a double valued\n+    \"\"\"\n+    Rising factorial (also called Pochhammer symbol) is a double valued\n     function arising in concrete mathematics, hypergeometric functions\n     and series expansions. It is defined by:\n \n@@ -418,15 +417,16 @@ class RisingFactorial(CombinatorialFunction):\n     more information check \"Concrete mathematics\" by Graham, pp. 66\n     or visit http://mathworld.wolfram.com/RisingFactorial.html page.\n \n-    When x is a polynomial f of a single variable y of order >= 1,\n-    rf(x,k) = f(y) * f(y+1) * ... * f(x+k-1) as described in\n-    Peter Paule, \"Greatest Factorial Factorization and Symbolic Summation\",\n-    Journal of Symbolic Computation, vol. 20, pp. 235-268, 1995.\n+    When x is a Poly instance of degree >= 1 with a single variable,\n+    rf(x,k) = x(y) * x(y+1) * ... * x(y+k-1), where y is the variable of x.\n+    This is as described in Peter Paule, \"Greatest Factorial Factorization and\n+    Symbolic Summation\", Journal of Symbolic Computation, vol. 20, pp.\n+    235-268, 1995.\n \n     Examples\n     ========\n \n-    >>> from sympy import rf, symbols, factorial, ff, binomial\n+    >>> from sympy import rf, symbols, factorial, ff, binomial, Poly\n     >>> from sympy.abc import x\n     >>> n, k = symbols('n k', integer=True)\n     >>> rf(x, 0)\n@@ -435,7 +435,7 @@ class RisingFactorial(CombinatorialFunction):\n     120\n     >>> rf(x, 5) == x*(1 + x)*(2 + x)*(3 + x)*(4 + x)\n     True\n-    >>> rf(x**3, 2)\n+    >>> rf(Poly(x**3, x), 2)\n     Poly(x**6 + 3*x**5 + 3*x**4 + x**3, x, domain='ZZ')\n \n     Rewrite\n@@ -456,6 +456,7 @@ class RisingFactorial(CombinatorialFunction):\n     ==========\n \n     .. [1] https://en.wikipedia.org/wiki/Pochhammer_symbol\n+\n     \"\"\"\n \n     @classmethod\n@@ -480,37 +481,34 @@ def eval(cls, x, k):\n                         else:\n                             return S.Infinity\n                     else:\n-                        try:\n-                            F, opt = poly_from_expr(x)\n-                        except PolificationFailed:\n-                            return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)\n-                        if len(opt.gens) > 1 or F.degree() <= 1:\n-                            return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)\n+                        if isinstance(x, Poly):\n+                            gens = x.gens\n+                            if len(gens)!= 1:\n+                                raise ValueError(\"rf only defined for polynomials on one generator\")\n+                            else:\n+                                return reduce(lambda r, i:\n+                                              r*(x.shift(i).expand()),\n+                                              range(0, int(k)), 1)\n                         else:\n-                            v = opt.gens[0]\n-                            return reduce(lambda r, i:\n-                                          r*(F.subs(v, v + i).expand()),\n-                                          range(0, int(k)), 1)\n+                            return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)\n+\n                 else:\n                     if x is S.Infinity:\n                         return S.Infinity\n                     elif x is S.NegativeInfinity:\n                         return S.Infinity\n                     else:\n-                        try:\n-                            F, opt = poly_from_expr(x)\n-                        except PolificationFailed:\n-                            return 1/reduce(lambda r, i:\n-                                            r*(x - i),\n-                                            range(1, abs(int(k)) + 1), 1)\n-                        if len(opt.gens) > 1 or F.degree() <= 1:\n-                            return 1/reduce(lambda r, i:\n-                                            r*(x - i),\n-                                            range(1, abs(int(k)) + 1), 1)\n+                        if isinstance(x, Poly):\n+                            gens = x.gens\n+                            if len(gens)!= 1:\n+                                raise ValueError(\"rf only defined for polynomials on one generator\")\n+                            else:\n+                                return 1/reduce(lambda r, i:\n+                                                r*(x.shift(-i).expand()),\n+                                                range(1, abs(int(k)) + 1), 1)\n                         else:\n-                            v = opt.gens[0]\n                             return 1/reduce(lambda r, i:\n-                                            r*(F.subs(v, v - i).expand()),\n+                                            r*(x - i),\n                                             range(1, abs(int(k)) + 1), 1)\n \n     def _eval_rewrite_as_gamma(self, x, k):\n@@ -538,7 +536,8 @@ def _sage_(self):\n \n \n class FallingFactorial(CombinatorialFunction):\n-    \"\"\"Falling factorial (related to rising factorial) is a double valued\n+    \"\"\"\n+    Falling factorial (related to rising factorial) is a double valued\n     function arising in concrete mathematics, hypergeometric functions\n     and series expansions. It is defined by\n \n@@ -548,12 +547,13 @@ class FallingFactorial(CombinatorialFunction):\n     more information check \"Concrete mathematics\" by Graham, pp. 66\n     or visit http://mathworld.wolfram.com/FallingFactorial.html page.\n \n-    When x is a polynomial f of a single variable y of order >= 1,\n-    ff(x,k) = f(y) * f(y-1) * ... * f(x-k+1) as described in\n-    Peter Paule, \"Greatest Factorial Factorization and Symbolic Summation\",\n-    Journal of Symbolic Computation, vol. 20, pp. 235-268, 1995.\n+    When x is a Poly instance of degree >= 1 with single variable,\n+    ff(x,k) = x(y) * x(y-1) * ... * x(y-k+1), where y is the variable of x.\n+    This is as described in Peter Paule, \"Greatest Factorial Factorization and\n+    Symbolic Summation\", Journal of Symbolic Computation, vol. 20, pp.\n+    235-268, 1995.\n \n-    >>> from sympy import ff, factorial, rf, gamma, polygamma, binomial, symbols\n+    >>> from sympy import ff, factorial, rf, gamma, polygamma, binomial, symbols, Poly\n     >>> from sympy.abc import x, k\n     >>> n, m = symbols('n m', integer=True)\n     >>> ff(x, 0)\n@@ -562,7 +562,7 @@ class FallingFactorial(CombinatorialFunction):\n     120\n     >>> ff(x, 5) == x*(x-1)*(x-2)*(x-3)*(x-4)\n     True\n-    >>> ff(x**2, 2)\n+    >>> ff(Poly(x**2, x), 2)\n     Poly(x**4 - 2*x**3 + x**2, x, domain='ZZ')\n     >>> ff(n, n)\n     factorial(n)\n@@ -587,6 +587,7 @@ class FallingFactorial(CombinatorialFunction):\n     ==========\n \n     .. [1] http://mathworld.wolfram.com/FallingFactorial.html\n+\n     \"\"\"\n \n     @classmethod\n@@ -611,18 +612,16 @@ def eval(cls, x, k):\n                         else:\n                             return S.Infinity\n                     else:\n-                        try:\n-                            F, opt = poly_from_expr(x)\n-                        except PolificationFailed:\n-                            return reduce(lambda r, i: r*(x - i),\n-                                          range(0, int(k)), 1)\n-                        if len(opt.gens) > 1 or F.degree() <= 1:\n-                            return reduce(lambda r, i: r*(x - i),\n-                                          range(0, int(k)), 1)\n+                        if isinstance(x, Poly):\n+                            gens = x.gens\n+                            if len(gens)!= 1:\n+                                raise ValueError(\"ff only defined for polynomials on one generator\")\n+                            else:\n+                                return reduce(lambda r, i:\n+                                              r*(x.shift(-i).expand()),\n+                                              range(0, int(k)), 1)\n                         else:\n-                            v = opt.gens[0]\n-                            return reduce(lambda r, i:\n-                                          r*(F.subs(v, v - i).expand()),\n+                            return reduce(lambda r, i: r*(x - i),\n                                           range(0, int(k)), 1)\n                 else:\n                     if x is S.Infinity:\n@@ -630,18 +629,16 @@ def eval(cls, x, k):\n                     elif x is S.NegativeInfinity:\n                         return S.Infinity\n                     else:\n-                        try:\n-                            F, opt = poly_from_expr(x)\n-                        except PolificationFailed:\n-                            return 1/reduce(lambda r, i: r*(x + i),\n-                                            range(1, abs(int(k)) + 1), 1)\n-                        if len(opt.gens) > 1 or F.degree() <= 1:\n-                            return 1/reduce(lambda r, i: r*(x + i),\n-                                            range(1, abs(int(k)) + 1), 1)\n+                        if isinstance(x, Poly):\n+                            gens = x.gens\n+                            if len(gens)!= 1:\n+                                raise ValueError(\"rf only defined for polynomials on one generator\")\n+                            else:\n+                                return 1/reduce(lambda r, i:\n+                                                r*(x.shift(i).expand()),\n+                                                range(1, abs(int(k)) + 1), 1)\n                         else:\n-                            v = opt.gens[0]\n-                            return 1/reduce(lambda r, i:\n-                                            r*(F.subs(v, v + i).expand()),\n+                            return 1/reduce(lambda r, i: r*(x + i),\n                                             range(1, abs(int(k)) + 1), 1)\n \n     def _eval_rewrite_as_gamma(self, x, k):\ndiff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -5604,27 +5604,30 @@ def gff_list(f, *gens, **args):\n     \"\"\"\n     Compute a list of greatest factorial factors of ``f``.\n \n+    Note that the input to ff() and rf() should be Poly instances to use the\n+    definitions here.\n+\n     Examples\n     ========\n \n-    >>> from sympy import gff_list, ff\n+    >>> from sympy import gff_list, ff, Poly\n     >>> from sympy.abc import x\n \n-    >>> f = x**5 + 2*x**4 - x**3 - 2*x**2\n+    >>> f = Poly(x**5 + 2*x**4 - x**3 - 2*x**2, x)\n \n     >>> gff_list(f)\n-    [(x, 1), (x + 2, 4)]\n+    [(Poly(x, x, domain='ZZ'), 1), (Poly(x + 2, x, domain='ZZ'), 4)]\n \n-    >>> (ff(x, 1)*ff(x + 2, 4)).expand() == f\n+    >>> (ff(Poly(x), 1)*ff(Poly(x + 2), 4)).expand() == f\n     True\n \n-    >>> f = x**12 + 6*x**11 - 11*x**10 - 56*x**9 + 220*x**8 + 208*x**7 - \\\n-        1401*x**6 + 1090*x**5 + 2715*x**4 - 6720*x**3 - 1092*x**2 + 5040*x\n+    >>> f = Poly(x**12 + 6*x**11 - 11*x**10 - 56*x**9 + 220*x**8 + 208*x**7 - \\\n+        1401*x**6 + 1090*x**5 + 2715*x**4 - 6720*x**3 - 1092*x**2 + 5040*x, x)\n \n     >>> gff_list(f)\n-    [(x**3 + 7, 2), (x**2 + 5*x, 3)]\n+    [(Poly(x**3 + 7, x, domain='ZZ'), 2), (Poly(x**2 + 5*x, x, domain='ZZ'), 3)]\n \n-    >>> ff(x**3 + 7, 2)*ff(x**2 + 5*x, 3) == f\n+    >>> ff(Poly(x**3 + 7, x), 2)*ff(Poly(x**2 + 5*x, x), 3) == f\n     True\n \n     \"\"\"\n",
  "test_patch": "diff --git a/sympy/functions/combinatorial/tests/test_comb_factorials.py b/sympy/functions/combinatorial/tests/test_comb_factorials.py\n--- a/sympy/functions/combinatorial/tests/test_comb_factorials.py\n+++ b/sympy/functions/combinatorial/tests/test_comb_factorials.py\n@@ -1,6 +1,7 @@\n from sympy import (S, Symbol, symbols, factorial, factorial2, binomial,\n                    rf, ff, gamma, polygamma, EulerGamma, O, pi, nan,\n-                   oo, zoo, simplify, expand_func, Product, I, Piecewise, Mod, Eq, sqrt)\n+                   oo, zoo, simplify, expand_func, Product, Mul, Piecewise, Mod,\n+                   Eq, sqrt, Poly)\n from sympy.functions.combinatorial.factorials import subfactorial\n from sympy.functions.special.gamma_functions import uppergamma\n from sympy.utilities.pytest import XFAIL, raises\n@@ -38,8 +39,15 @@ def test_rf_eval_apply():\n \n     assert rf(1, 100) == factorial(100)\n \n-    assert rf(x**2 + 3*x, 2) == x**4 + 8*x**3 + 19*x**2 + 12*x\n-    assert rf(x**3 + x, -2) == 1/(x**6 - 9*x**5 + 35*x**4 - 75*x**3 + 94*x**2 - 66*x + 20)\n+    assert rf(x**2 + 3*x, 2) == (x**2 + 3*x)*(x**2 + 3*x + 1)\n+    assert isinstance(rf(x**2 + 3*x, 2), Mul)\n+    assert rf(x**3 + x, -2) == 1/((x**3 + x - 1)*(x**3 + x - 2))\n+\n+    assert rf(Poly(x**2 + 3*x, x), 2) == Poly(x**4 + 8*x**3 + 19*x**2 + 12*x, x)\n+    assert isinstance(rf(Poly(x**2 + 3*x, x), 2), Poly)\n+    raises(ValueError, lambda: rf(Poly(x**2 + 3*x, x, y), 2))\n+    assert rf(Poly(x**3 + x, x), -2) == 1/(x**6 - 9*x**5 + 35*x**4 - 75*x**3 + 94*x**2 - 66*x + 20)\n+    raises(ValueError, lambda: rf(Poly(x**3 + x, x, y), -2))\n \n     assert rf(x, m).is_integer is None\n     assert rf(n, k).is_integer is None\n@@ -85,8 +93,16 @@ def test_ff_eval_apply():\n \n     assert ff(100, 100) == factorial(100)\n \n-    assert ff(2*x**2 - 5*x, 2) == 4*x**4 - 28*x**3 + 59*x**2 - 35*x\n-    assert ff(x**2 + 3*x, -2) == 1/(x**4 + 12*x**3 + 49*x**2 + 78*x + 40)\n+    assert ff(2*x**2 - 5*x, 2) == (2*x**2  - 5*x)*(2*x**2 - 5*x - 1)\n+    assert isinstance(ff(2*x**2 - 5*x, 2), Mul)\n+    assert ff(x**2 + 3*x, -2) == 1/((x**2 + 3*x + 1)*(x**2 + 3*x + 2))\n+\n+    assert ff(Poly(2*x**2 - 5*x, x), 2) == Poly(4*x**4 - 28*x**3 + 59*x**2 - 35*x, x)\n+    assert isinstance(ff(Poly(2*x**2 - 5*x, x), 2), Poly)\n+    raises(ValueError, lambda: ff(Poly(2*x**2 - 5*x, x, y), 2))\n+    assert ff(Poly(x**2 + 3*x, x), -2) == 1/(x**4 + 12*x**3 + 49*x**2 + 78*x + 40)\n+    raises(ValueError, lambda: ff(Poly(x**2 + 3*x, x, y), -2))\n+\n \n     assert ff(x, m).is_integer is None\n     assert ff(n, k).is_integer is None\n",
  "problem_statement": "ff and rf definitions changed in SymPy 1.0\nSee https://github.com/sympy/sympy/pull/8941. We should revert the change. \n\n",
  "hints_text": "",
  "created_at": "2017-06-24T02:23:36Z",
  "version": "1.0",
  "FAIL_TO_PASS": "[\"test_rf_eval_apply\", \"test_ff_eval_apply\"]",
  "PASS_TO_PASS": "[\"test_factorial_diff\", \"test_factorial_rewrite\", \"test_binomial_diff\", \"test_binomial_rewrite\"]",
  "environment_setup_commit": "50b81f9f6be151014501ffac44e5dc6b2416938f",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.078166",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}