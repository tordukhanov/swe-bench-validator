{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-13768",
  "base_commit": "38b233c605489d6e64738b2da99248f677f4a29f",
  "patch": "diff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py\n--- a/sympy/matrices/matrices.py\n+++ b/sympy/matrices/matrices.py\n@@ -25,6 +25,7 @@\n from sympy.core.compatibility import (is_sequence, default_sort_key, range,\n     NotIterable)\n \n+from sympy.utilities.exceptions import SymPyDeprecationWarning\n \n from types import FunctionType\n \n@@ -1703,6 +1704,38 @@ def limit(self, *args):\n # https://github.com/sympy/sympy/pull/12854\n class MatrixDeprecated(MatrixCommon):\n     \"\"\"A class to house deprecated matrix methods.\"\"\"\n+    def _legacy_array_dot(self, b):\n+        \"\"\"Compatibility function for deprecated behavior of ``matrix.dot(vector)``\n+        \"\"\"\n+        from .dense import Matrix\n+\n+        if not isinstance(b, MatrixBase):\n+            if is_sequence(b):\n+                if len(b) != self.cols and len(b) != self.rows:\n+                    raise ShapeError(\n+                        \"Dimensions incorrect for dot product: %s, %s\" % (\n+                            self.shape, len(b)))\n+                return self.dot(Matrix(b))\n+            else:\n+                raise TypeError(\n+                    \"`b` must be an ordered iterable or Matrix, not %s.\" %\n+                    type(b))\n+\n+        mat = self\n+        if mat.cols == b.rows:\n+            if b.cols != 1:\n+                mat = mat.T\n+                b = b.T\n+            prod = flatten((mat * b).tolist())\n+            return prod\n+        if mat.cols == b.cols:\n+            return mat.dot(b.T)\n+        elif mat.rows == b.rows:\n+            return mat.T.dot(b)\n+        else:\n+            raise ShapeError(\"Dimensions incorrect for dot product: %s, %s\" % (\n+                self.shape, b.shape))\n+\n \n     def berkowitz_charpoly(self, x=Dummy('lambda'), simplify=_simplify):\n         return self.charpoly(x=x)\n@@ -2398,25 +2431,23 @@ def diagonal_solve(self, rhs):\n         return self._diagonal_solve(rhs)\n \n     def dot(self, b):\n-        \"\"\"Return the dot product of Matrix self and b relaxing the condition\n-        of compatible dimensions: if either the number of rows or columns are\n-        the same as the length of b then the dot product is returned. If self\n-        is a row or column vector, a scalar is returned. Otherwise, a list\n-        of results is returned (and in that case the number of columns in self\n-        must match the length of b).\n+        \"\"\"Return the dot product of two vectors of equal length. ``self`` must\n+        be a ``Matrix`` of size 1 x n or n x 1, and ``b`` must be either a\n+        matrix of size 1 x n, n x 1, or a list/tuple of length n. A scalar is returned.\n \n         Examples\n         ========\n \n         >>> from sympy import Matrix\n         >>> M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n-        >>> v = [1, 1, 1]\n+        >>> v = Matrix([1, 1, 1])\n         >>> M.row(0).dot(v)\n         6\n         >>> M.col(0).dot(v)\n         12\n-        >>> M.dot(v)\n-        [6, 15, 24]\n+        >>> v = [3, 2, 1]\n+        >>> M.row(0).dot(v)\n+        10\n \n         See Also\n         ========\n@@ -2440,21 +2471,21 @@ def dot(self, b):\n                     type(b))\n \n         mat = self\n-        if mat.cols == b.rows:\n-            if b.cols != 1:\n-                mat = mat.T\n-                b = b.T\n-            prod = flatten((mat * b).tolist())\n-            if len(prod) == 1:\n-                return prod[0]\n-            return prod\n-        if mat.cols == b.cols:\n-            return mat.dot(b.T)\n-        elif mat.rows == b.rows:\n-            return mat.T.dot(b)\n-        else:\n-            raise ShapeError(\"Dimensions incorrect for dot product: %s, %s\" % (\n-                self.shape, b.shape))\n+        if (1 not in mat.shape) or (1 not in b.shape) :\n+            SymPyDeprecationWarning(\n+                feature=\"Dot product of non row/column vectors\",\n+                issue=13815,\n+                deprecated_since_version=\"1.2\").warn()\n+            return mat._legacy_array_dot(b)\n+        if len(mat) != len(b):\n+            raise ShapeError(\"Dimensions incorrect for dot product: %s, %s\" % (self.shape, b.shape))\n+        n = len(mat)\n+        if mat.shape != (1, n):\n+            mat = mat.reshape(1, n)\n+        if b.shape != (n, 1):\n+            b = b.reshape(n, 1)\n+        # Now ``mat`` is a row vector and ``b`` is a column vector.\n+        return (mat * b)[0]\n \n     def dual(self):\n         \"\"\"Returns the dual of a matrix, which is:\n",
  "test_patch": "diff --git a/sympy/matrices/tests/test_matrices.py b/sympy/matrices/tests/test_matrices.py\n--- a/sympy/matrices/tests/test_matrices.py\n+++ b/sympy/matrices/tests/test_matrices.py\n@@ -1897,6 +1897,8 @@ def test_errors():\n     raises(ShapeError, lambda: Matrix([1, 2, 3]).dot(Matrix([1, 2])))\n     raises(ShapeError, lambda: Matrix([1, 2]).dot([]))\n     raises(TypeError, lambda: Matrix([1, 2]).dot('a'))\n+    raises(SymPyDeprecationWarning, lambda: Matrix([[1, 2], [3, 4]]).dot(Matrix([[4, 3], [1, 2]])))\n+    raises(ShapeError, lambda: Matrix([1, 2]).dot([1, 2, 3]))\n     raises(NonSquareMatrixError, lambda: Matrix([1, 2, 3]).exp())\n     raises(ShapeError, lambda: Matrix([[1, 2], [3, 4]]).normalized())\n     raises(ValueError, lambda: Matrix([1, 2]).inv(method='not a method'))\n@@ -2516,6 +2518,7 @@ def test_is_Identity():\n def test_dot():\n     assert ones(1, 3).dot(ones(3, 1)) == 3\n     assert ones(1, 3).dot([1, 1, 1]) == 3\n+    assert Matrix([1, 2, 3]).dot(Matrix([1, 2, 3])) == 14\n \n \n def test_dual():\n@@ -3082,6 +3085,8 @@ def test_deprecated():\n         P, Jcells = m.jordan_cells()\n         assert Jcells[1] == Matrix(1, 1, [2])\n         assert Jcells[0] == Matrix(2, 2, [2, 1, 0, 2])\n+        assert Matrix([[1,2],[3,4]]).dot(Matrix([[1,3],[4,5]])) == [10, 19, 14, 28]\n+\n \n def test_issue_14489():\n     from sympy import Mod\n",
  "problem_statement": "  fix the dimension mismatches when using (dot)\nfix #13765 the dimension mismatched when using A.dot(B) where A is matrix  B is\r\n1 x m or n x 1  matrix before fixing it, if we used B as m x n matrix where\r\nn or m != 1 it gives a strange answer, but after fixing it raises error if m or\r\nn not equal 1\r\n\r\n\r\n\n",
  "hints_text": "",
  "created_at": "2017-12-19T05:32:15Z",
  "version": "1.1",
  "FAIL_TO_PASS": "[\"test_errors\"]",
  "PASS_TO_PASS": "[\"test_args\", \"test_division\", \"test_sum\", \"test_abs\", \"test_addition\", \"test_fancy_index_matrix\", \"test_multiplication\", \"test_power\", \"test_creation\", \"test_tolist\", \"test_as_mutable\", \"test_determinant\", \"test_det_LU_decomposition\", \"test_slicing\", \"test_submatrix_assignment\", \"test_extract\", \"test_reshape\", \"test_applyfunc\", \"test_expand\", \"test_random\", \"test_LUdecomp\", \"test_LUsolve\", \"test_QRsolve\", \"test_inverse\", \"test_matrix_inverse_mod\", \"test_util\", \"test_jacobian_hessian\", \"test_QR\", \"test_QR_non_square\", \"test_nullspace\", \"test_columnspace\", \"test_wronskian\", \"test_eigen\", \"test_subs\", \"test_xreplace\", \"test_simplify\", \"test_transpose\", \"test_conjugate\", \"test_conj_dirac\", \"test_trace\", \"test_shape\", \"test_col_row_op\", \"test_zip_row_op\", \"test_issue_3950\", \"test_issue_3981\", \"test_evalf\", \"test_is_symbolic\", \"test_is_upper\", \"test_is_lower\", \"test_is_nilpotent\", \"test_zeros_ones_fill\", \"test_empty_zeros\", \"test_issue_3749\", \"test_inv_iszerofunc\", \"test_jacobian_metrics\", \"test_jacobian2\", \"test_issue_4564\", \"test_nonvectorJacobian\", \"test_vec\", \"test_vech\", \"test_vech_errors\", \"test_diag\", \"test_get_diag_blocks1\", \"test_get_diag_blocks2\", \"test_inv_block\", \"test_creation_args\", \"test_diagonal_symmetrical\", \"test_diagonalization\", \"test_jordan_form\", \"test_jordan_form_complex_issue_9274\", \"test_issue_10220\", \"test_Matrix_berkowitz_charpoly\", \"test_exp\", \"test_has\", \"test_LUdecomposition_Simple_iszerofunc\", \"test_LUdecomposition_iszerofunc\", \"test_find_reasonable_pivot_naive_finds_guaranteed_nonzero1\", \"test_find_reasonable_pivot_naive_finds_guaranteed_nonzero2\", \"test_find_reasonable_pivot_naive_simplifies\", \"test_len\", \"test_integrate\", \"test_limit\", \"test_diff\", \"test_getattr\", \"test_hessenberg\", \"test_cholesky\", \"test_LDLdecomposition\", \"test_cholesky_solve\", \"test_LDLsolve\", \"test_lower_triangular_solve\", \"test_upper_triangular_solve\", \"test_diagonal_solve\", \"test_matrix_norm\", \"test_condition_number\", \"test_equality\", \"test_col_join\", \"test_row_insert\", \"test_col_insert\", \"test_normalized\", \"test_print_nonzero\", \"test_zeros_eye\", \"test_is_zero\", \"test_rotation_matrices\", \"test_DeferredVector\", \"test_DeferredVector_not_iterable\", \"test_DeferredVector_Matrix\", \"test_GramSchmidt\", \"test_casoratian\", \"test_zero_dimension_multiply\", \"test_slice_issue_2884\", \"test_slice_issue_3401\", \"test_copyin\", \"test_invertible_check\", \"test_issue_5964\", \"test_issue_7604\", \"test_is_Identity\", \"test_dot\", \"test_dual\", \"test_anti_symmetric\", \"test_normalize_sort_diogonalization\", \"test_issue_5321\", \"test_issue_5320\", \"test_issue_11944\", \"test_cross\", \"test_hash\", \"test_adjoint\", \"test_simplify_immutable\", \"test_rank\", \"test_issue_11434\", \"test_rank_regression_from_so\", \"test_replace\", \"test_replace_map\", \"test_atoms\", \"test_pinv_solve\", \"test_gauss_jordan_solve\", \"test_issue_7201\", \"test_free_symbols\", \"test_hermitian\", \"test_doit\", \"test_issue_9457_9467_9876\", \"test_issue_9422\", \"test_issue_10770\", \"test_issue_10658\", \"test_opportunistic_simplification\", \"test_partial_pivoting\", \"test_iszero_substitution\", \"test_as_real_imag\", \"test_deprecated\", \"test_issue_14489\"]",
  "environment_setup_commit": "ec9e3c0436fbff934fa84e22bf07f1b3ef5bfac3",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.087025",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}