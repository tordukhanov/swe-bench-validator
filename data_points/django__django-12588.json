{
  "repo": "django/django",
  "instance_id": "django__django-12588",
  "base_commit": "13993e0f38d5f272236887ef22b491eb1b20dce9",
  "patch": "diff --git a/django/contrib/contenttypes/management/commands/remove_stale_contenttypes.py b/django/contrib/contenttypes/management/commands/remove_stale_contenttypes.py\n--- a/django/contrib/contenttypes/management/commands/remove_stale_contenttypes.py\n+++ b/django/contrib/contenttypes/management/commands/remove_stale_contenttypes.py\n@@ -1,11 +1,11 @@\n+import itertools\n+\n from django.apps import apps\n from django.contrib.contenttypes.models import ContentType\n from django.core.management import BaseCommand\n from django.db import DEFAULT_DB_ALIAS, router\n from django.db.models.deletion import Collector\n \n-from ...management import get_contenttypes_and_models\n-\n \n class Command(BaseCommand):\n \n@@ -18,18 +18,32 @@ def add_arguments(self, parser):\n             '--database', default=DEFAULT_DB_ALIAS,\n             help='Nominates the database to use. Defaults to the \"default\" database.',\n         )\n+        parser.add_argument(\n+            '--include-stale-apps', action='store_true', default=False,\n+            help=(\n+                \"Deletes stale content types including ones from previously \"\n+                \"installed apps that have been removed from INSTALLED_APPS.\"\n+            ),\n+        )\n \n     def handle(self, **options):\n         db = options['database']\n+        include_stale_apps = options['include_stale_apps']\n         interactive = options['interactive']\n         verbosity = options['verbosity']\n \n-        for app_config in apps.get_app_configs():\n-            content_types, app_models = get_contenttypes_and_models(app_config, db, ContentType)\n-            to_remove = [\n-                ct for (model_name, ct) in content_types.items()\n-                if model_name not in app_models\n-            ]\n+        if not router.allow_migrate_model(db, ContentType):\n+            return\n+        ContentType.objects.clear_cache()\n+\n+        apps_content_types = itertools.groupby(\n+            ContentType.objects.using(db).order_by('app_label', 'model'),\n+            lambda obj: obj.app_label,\n+        )\n+        for app_label, content_types in apps_content_types:\n+            if not include_stale_apps and app_label not in apps.app_configs:\n+                continue\n+            to_remove = [ct for ct in content_types if ct.model_class() is None]\n             # Confirm that the content type is stale before deletion.\n             using = router.db_for_write(ContentType)\n             if to_remove:\n",
  "test_patch": "diff --git a/tests/contenttypes_tests/test_management.py b/tests/contenttypes_tests/test_management.py\n--- a/tests/contenttypes_tests/test_management.py\n+++ b/tests/contenttypes_tests/test_management.py\n@@ -10,10 +10,15 @@\n from .models import ModelWithNullFKToSite, Post\n \n \n-@modify_settings(INSTALLED_APPS={'append': ['no_models']})\n+@modify_settings(INSTALLED_APPS={'append': ['empty_models', 'no_models']})\n class RemoveStaleContentTypesTests(TestCase):\n     # Speed up tests by avoiding retrieving ContentTypes for all test apps.\n-    available_apps = ['contenttypes_tests', 'no_models', 'django.contrib.contenttypes']\n+    available_apps = [\n+        'contenttypes_tests',\n+        'empty_models',\n+        'no_models',\n+        'django.contrib.contenttypes',\n+    ]\n \n     def setUp(self):\n         self.before_count = ContentType.objects.count()\n@@ -65,9 +70,34 @@ def test_unavailable_content_type_model(self):\n             contenttypes_management.create_contenttypes(self.app_config, interactive=False, verbosity=0, apps=apps)\n         self.assertEqual(ContentType.objects.count(), self.before_count + 1)\n \n-    def test_contenttypes_removed_in_apps_without_models(self):\n-        ContentType.objects.create(app_label='no_models', model='Fake')\n+    @modify_settings(INSTALLED_APPS={'remove': ['empty_models']})\n+    def test_contenttypes_removed_in_installed_apps_without_models(self):\n+        ContentType.objects.create(app_label='empty_models', model='Fake 1')\n+        ContentType.objects.create(app_label='no_models', model='Fake 2')\n         with mock.patch('builtins.input', return_value='yes'), captured_stdout() as stdout:\n             call_command('remove_stale_contenttypes', verbosity=2)\n-        self.assertIn(\"Deleting stale content type 'no_models | Fake'\", stdout.getvalue())\n+        self.assertNotIn(\n+            \"Deleting stale content type 'empty_models | Fake 1'\",\n+            stdout.getvalue(),\n+        )\n+        self.assertIn(\n+            \"Deleting stale content type 'no_models | Fake 2'\",\n+            stdout.getvalue(),\n+        )\n+        self.assertEqual(ContentType.objects.count(), self.before_count + 1)\n+\n+    @modify_settings(INSTALLED_APPS={'remove': ['empty_models']})\n+    def test_contenttypes_removed_for_apps_not_in_installed_apps(self):\n+        ContentType.objects.create(app_label='empty_models', model='Fake 1')\n+        ContentType.objects.create(app_label='no_models', model='Fake 2')\n+        with mock.patch('builtins.input', return_value='yes'), captured_stdout() as stdout:\n+            call_command('remove_stale_contenttypes', include_stale_apps=True, verbosity=2)\n+        self.assertIn(\n+            \"Deleting stale content type 'empty_models | Fake 1'\",\n+            stdout.getvalue(),\n+        )\n+        self.assertIn(\n+            \"Deleting stale content type 'no_models | Fake 2'\",\n+            stdout.getvalue(),\n+        )\n         self.assertEqual(ContentType.objects.count(), self.before_count)\n",
  "problem_statement": "Add option to remove_stale_contenttypes to remove entries for nonexistent apps.\nDescription\n\t \n\t\t(last modified by Javier Buzzi)\n\t \nAdd an option (disabled by default) to remove_stale_contenttypes command to remove entries also for nonexistent apps.\nBased on ​discussion.\n​PR\n",
  "hints_text": "I don't think that remove_stale_contenttypes should remove content types for nonexistent apps. We don't automatically remove models for nonexistent apps and I don't think we should do this with content types. This can also cause a data loss for a custom content types (not related to real apps). You can start a discussion on DevelopersMailingList if you don't agree.\nAccepted based on ​discussion .",
  "created_at": "2020-03-19T10:20:11Z",
  "version": "3.1",
  "FAIL_TO_PASS": "[\"test_contenttypes_removed_for_apps_not_in_installed_apps (contenttypes_tests.test_management.RemoveStaleContentTypesTests)\"]",
  "PASS_TO_PASS": "[\"test_contenttypes_removed_in_installed_apps_without_models (contenttypes_tests.test_management.RemoveStaleContentTypesTests)\", \"non-interactive mode deletes stale content types.\", \"test_interactive_true_with_dependent_objects (contenttypes_tests.test_management.RemoveStaleContentTypesTests)\", \"test_interactive_true_without_dependent_objects (contenttypes_tests.test_management.RemoveStaleContentTypesTests)\", \"A ContentType isn't created if the model isn't available.\"]",
  "environment_setup_commit": "0668164b4ac93a5be79f5b87fae83c657124d9ab",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.630985",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}