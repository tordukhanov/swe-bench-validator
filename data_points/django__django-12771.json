{
  "repo": "django/django",
  "instance_id": "django__django-12771",
  "base_commit": "0f2885e3f6e0c73c9f455dcbc0326ac11ba4b84c",
  "patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -93,7 +93,7 @@ def only_relation_agnostic_fields(self, fields):\n         of course, the related fields change during renames).\n         \"\"\"\n         fields_def = []\n-        for name, field in sorted(fields):\n+        for name, field in sorted(fields.items()):\n             deconstruction = self.deep_deconstruct(field)\n             if field.remote_field and field.remote_field.model:\n                 del deconstruction[2]['to']\n@@ -208,17 +208,17 @@ def _prepare_field_lists(self):\n         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n         self.through_users = {}\n         self.old_field_keys = {\n-            (app_label, model_name, x)\n+            (app_label, model_name, field_name)\n             for app_label, model_name in self.kept_model_keys\n-            for x, y in self.from_state.models[\n+            for field_name in self.from_state.models[\n                 app_label,\n                 self.renamed_models.get((app_label, model_name), model_name)\n             ].fields\n         }\n         self.new_field_keys = {\n-            (app_label, model_name, x)\n+            (app_label, model_name, field_name)\n             for app_label, model_name in self.kept_model_keys\n-            for x, y in self.to_state.models[app_label, model_name].fields\n+            for field_name in self.to_state.models[app_label, model_name].fields\n         }\n \n     def _generate_through_model_map(self):\n@@ -226,7 +226,7 @@ def _generate_through_model_map(self):\n         for app_label, model_name in sorted(self.old_model_keys):\n             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n             old_model_state = self.from_state.models[app_label, old_model_name]\n-            for field_name, field in old_model_state.fields:\n+            for field_name in old_model_state.fields:\n                 old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(field_name)\n                 if (hasattr(old_field, \"remote_field\") and getattr(old_field.remote_field, \"through\", None) and\n                         not old_field.remote_field.through._meta.auto_created):\n@@ -576,7 +576,7 @@ def generate_created_models(self):\n                 app_label,\n                 operations.CreateModel(\n                     name=model_state.name,\n-                    fields=[d for d in model_state.fields if d[0] not in related_fields],\n+                    fields=[d for d in model_state.fields.items() if d[0] not in related_fields],\n                     options=model_state.options,\n                     bases=model_state.bases,\n                     managers=model_state.managers,\n@@ -820,7 +820,7 @@ def generate_renamed_fields(self):\n             field_dec = self.deep_deconstruct(field)\n             for rem_app_label, rem_model_name, rem_field_name in sorted(self.old_field_keys - self.new_field_keys):\n                 if rem_app_label == app_label and rem_model_name == model_name:\n-                    old_field = old_model_state.get_field_by_name(rem_field_name)\n+                    old_field = old_model_state.fields[rem_field_name]\n                     old_field_dec = self.deep_deconstruct(old_field)\n                     if field.remote_field and field.remote_field.model and 'to' in old_field_dec[2]:\n                         old_rel_to = old_field_dec[2]['to']\ndiff --git a/django/db/migrations/operations/fields.py b/django/db/migrations/operations/fields.py\n--- a/django/db/migrations/operations/fields.py\n+++ b/django/db/migrations/operations/fields.py\n@@ -89,7 +89,7 @@ def state_forwards(self, app_label, state):\n             field.default = NOT_PROVIDED\n         else:\n             field = self.field\n-        state.models[app_label, self.model_name_lower].fields.append((self.name, field))\n+        state.models[app_label, self.model_name_lower].fields[self.name] = field\n         # Delay rendering of relationships if it's not a relational field\n         delay = not field.is_relation\n         state.reload_model(app_label, self.model_name_lower, delay=delay)\n@@ -154,14 +154,8 @@ def deconstruct(self):\n         )\n \n     def state_forwards(self, app_label, state):\n-        new_fields = []\n-        old_field = None\n-        for name, instance in state.models[app_label, self.model_name_lower].fields:\n-            if name != self.name:\n-                new_fields.append((name, instance))\n-            else:\n-                old_field = instance\n-        state.models[app_label, self.model_name_lower].fields = new_fields\n+        model_state = state.models[app_label, self.model_name_lower]\n+        old_field = model_state.fields.pop(self.name)\n         # Delay rendering of relationships if it's not a relational field\n         delay = not old_field.is_relation\n         state.reload_model(app_label, self.model_name_lower, delay=delay)\n@@ -217,11 +211,8 @@ def state_forwards(self, app_label, state):\n             field.default = NOT_PROVIDED\n         else:\n             field = self.field\n-        state.models[app_label, self.model_name_lower].fields = [\n-            (n, field if n == self.name else f)\n-            for n, f in\n-            state.models[app_label, self.model_name_lower].fields\n-        ]\n+        model_state = state.models[app_label, self.model_name_lower]\n+        model_state.fields[self.name] = field\n         # TODO: investigate if old relational fields must be reloaded or if it's\n         # sufficient if the new field is (#27737).\n         # Delay rendering of relationships if it's not a relational field and\n@@ -299,11 +290,14 @@ def state_forwards(self, app_label, state):\n         model_state = state.models[app_label, self.model_name_lower]\n         # Rename the field\n         fields = model_state.fields\n-        found = None\n-        for index, (name, field) in enumerate(fields):\n-            if not found and name == self.old_name:\n-                fields[index] = (self.new_name, field)\n-                found = field\n+        try:\n+            found = fields.pop(self.old_name)\n+        except KeyError:\n+            raise FieldDoesNotExist(\n+                \"%s.%s has no field named '%s'\" % (app_label, self.model_name, self.old_name)\n+            )\n+        fields[self.new_name] = found\n+        for field in fields.values():\n             # Fix from_fields to refer to the new field.\n             from_fields = getattr(field, 'from_fields', None)\n             if from_fields:\n@@ -311,10 +305,6 @@ def state_forwards(self, app_label, state):\n                     self.new_name if from_field_name == self.old_name else from_field_name\n                     for from_field_name in from_fields\n                 ])\n-        if found is None:\n-            raise FieldDoesNotExist(\n-                \"%s.%s has no field named '%s'\" % (app_label, self.model_name, self.old_name)\n-            )\n         # Fix index/unique_together to refer to the new field\n         options = model_state.options\n         for option in ('index_together', 'unique_together'):\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -310,7 +310,7 @@ def state_forwards(self, app_label, state):\n         old_model_tuple = (app_label, self.old_name_lower)\n         new_remote_model = '%s.%s' % (app_label, self.new_name)\n         to_reload = set()\n-        for model_state, index, name, field, reference in get_references(state, old_model_tuple):\n+        for model_state, name, field, reference in get_references(state, old_model_tuple):\n             changed_field = None\n             if reference.to:\n                 changed_field = field.clone()\n@@ -320,7 +320,7 @@ def state_forwards(self, app_label, state):\n                     changed_field = field.clone()\n                 changed_field.remote_field.through = new_remote_model\n             if changed_field:\n-                model_state.fields[index] = name, changed_field\n+                model_state.fields[name] = changed_field\n                 to_reload.add((model_state.app_label, model_state.name_lower))\n         # Reload models related to old model before removing the old model.\n         state.reload_models(to_reload, delay=True)\ndiff --git a/django/db/migrations/operations/utils.py b/django/db/migrations/operations/utils.py\n--- a/django/db/migrations/operations/utils.py\n+++ b/django/db/migrations/operations/utils.py\n@@ -83,17 +83,17 @@ def field_references(\n \n def get_references(state, model_tuple, field_tuple=()):\n     \"\"\"\n-    Generator of (model_state, index, name, field, reference) referencing\n+    Generator of (model_state, name, field, reference) referencing\n     provided context.\n \n     If field_tuple is provided only references to this particular field of\n     model_tuple will be generated.\n     \"\"\"\n     for state_model_tuple, model_state in state.models.items():\n-        for index, (name, field) in enumerate(model_state.fields):\n+        for name, field in model_state.fields.items():\n             reference = field_references(state_model_tuple, field, model_tuple, *field_tuple)\n             if reference:\n-                yield model_state, index, name, field, reference\n+                yield model_state, name, field, reference\n \n \n def field_is_referenced(state, model_tuple, field_tuple):\ndiff --git a/django/db/migrations/state.py b/django/db/migrations/state.py\n--- a/django/db/migrations/state.py\n+++ b/django/db/migrations/state.py\n@@ -125,7 +125,7 @@ def _find_reload_model(self, app_label, model_name, delay=False):\n         # Directly related models are the models pointed to by ForeignKeys,\n         # OneToOneFields, and ManyToManyFields.\n         direct_related_models = set()\n-        for name, field in model_state.fields:\n+        for field in model_state.fields.values():\n             if field.is_relation:\n                 if field.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT:\n                     continue\n@@ -359,16 +359,13 @@ class ModelState:\n     def __init__(self, app_label, name, fields, options=None, bases=None, managers=None):\n         self.app_label = app_label\n         self.name = name\n-        self.fields = fields\n+        self.fields = dict(fields)\n         self.options = options or {}\n         self.options.setdefault('indexes', [])\n         self.options.setdefault('constraints', [])\n         self.bases = bases or (models.Model,)\n         self.managers = managers or []\n-        # Sanity-check that fields is NOT a dict. It must be ordered.\n-        if isinstance(self.fields, dict):\n-            raise ValueError(\"ModelState.fields cannot be a dict - it must be a list of 2-tuples.\")\n-        for name, field in fields:\n+        for name, field in self.fields.items():\n             # Sanity-check that fields are NOT already bound to a model.\n             if hasattr(field, 'model'):\n                 raise ValueError(\n@@ -544,7 +541,7 @@ def clone(self):\n         return self.__class__(\n             app_label=self.app_label,\n             name=self.name,\n-            fields=list(self.fields),\n+            fields=dict(self.fields),\n             # Since options are shallow-copied here, operations such as\n             # AddIndex must replace their option (e.g 'indexes') rather\n             # than mutating it.\n@@ -566,8 +563,8 @@ def render(self, apps):\n             )\n         except LookupError:\n             raise InvalidBasesError(\"Cannot resolve one or more bases from %r\" % (self.bases,))\n-        # Turn fields into a dict for the body, add other bits\n-        body = {name: field.clone() for name, field in self.fields}\n+        # Clone fields for the body, add other bits.\n+        body = {name: field.clone() for name, field in self.fields.items()}\n         body['Meta'] = meta\n         body['__module__'] = \"__fake__\"\n \n@@ -576,12 +573,6 @@ def render(self, apps):\n         # Then, make a Model object (apps.register_model is called in __new__)\n         return type(self.name, bases, body)\n \n-    def get_field_by_name(self, name):\n-        for fname, field in self.fields:\n-            if fname == name:\n-                return field\n-        raise ValueError(\"No field called %s on model %s\" % (name, self.name))\n-\n     def get_index_by_name(self, name):\n         for index in self.options['indexes']:\n             if index.name == name:\n@@ -602,8 +593,13 @@ def __eq__(self, other):\n             (self.app_label == other.app_label) and\n             (self.name == other.name) and\n             (len(self.fields) == len(other.fields)) and\n-            all((k1 == k2 and (f1.deconstruct()[1:] == f2.deconstruct()[1:]))\n-                for (k1, f1), (k2, f2) in zip(self.fields, other.fields)) and\n+            all(\n+                k1 == k2 and f1.deconstruct()[1:] == f2.deconstruct()[1:]\n+                for (k1, f1), (k2, f2) in zip(\n+                    sorted(self.fields.items()),\n+                    sorted(other.fields.items()),\n+                )\n+            ) and\n             (self.options == other.options) and\n             (self.bases == other.bases) and\n             (self.managers == other.managers)\n",
  "test_patch": "diff --git a/tests/migrations/test_executor.py b/tests/migrations/test_executor.py\n--- a/tests/migrations/test_executor.py\n+++ b/tests/migrations/test_executor.py\n@@ -516,13 +516,13 @@ def test_unrelated_applied_migrations_mutate_state(self):\n         state = executor.migrate([\n             ('mutate_state_a', '0001_initial'),\n         ])\n-        self.assertIn('added', dict(state.models['mutate_state_b', 'b'].fields))\n+        self.assertIn('added', state.models['mutate_state_b', 'b'].fields)\n         executor.loader.build_graph()\n         # Migrate backward.\n         state = executor.migrate([\n             ('mutate_state_a', None),\n         ])\n-        self.assertIn('added', dict(state.models['mutate_state_b', 'b'].fields))\n+        self.assertIn('added', state.models['mutate_state_b', 'b'].fields)\n         executor.migrate([\n             ('mutate_state_b', None),\n         ])\ndiff --git a/tests/migrations/test_loader.py b/tests/migrations/test_loader.py\n--- a/tests/migrations/test_loader.py\n+++ b/tests/migrations/test_loader.py\n@@ -73,15 +73,12 @@ def test_load(self):\n \n         author_state = project_state.models[\"migrations\", \"author\"]\n         self.assertEqual(\n-            [x for x, y in author_state.fields],\n+            list(author_state.fields),\n             [\"id\", \"name\", \"slug\", \"age\", \"rating\"]\n         )\n \n         book_state = project_state.models[\"migrations\", \"book\"]\n-        self.assertEqual(\n-            [x for x, y in book_state.fields],\n-            [\"id\", \"author\"]\n-        )\n+        self.assertEqual(list(book_state.fields), ['id', 'author'])\n \n         # Ensure we've included unmigrated apps in there too\n         self.assertIn(\"basic\", project_state.real_apps)\n@@ -122,10 +119,7 @@ def test_load_unmigrated_dependency(self):\n         self.assertEqual(len([m for a, m in project_state.models if a == \"migrations\"]), 1)\n \n         book_state = project_state.models[\"migrations\", \"book\"]\n-        self.assertEqual(\n-            [x for x, y in book_state.fields],\n-            [\"id\", \"user\"]\n-        )\n+        self.assertEqual(list(book_state.fields), ['id', 'user'])\n \n     @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_run_before\"})\n     def test_run_before(self):\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -521,7 +521,10 @@ def test_rename_model(self):\n         self.assertNotIn((\"test_rnmo\", \"pony\"), new_state.models)\n         self.assertIn((\"test_rnmo\", \"horse\"), new_state.models)\n         # RenameModel also repoints all incoming FKs and M2Ms\n-        self.assertEqual(\"test_rnmo.Horse\", new_state.models[\"test_rnmo\", \"rider\"].fields[1][1].remote_field.model)\n+        self.assertEqual(\n+            new_state.models['test_rnmo', 'rider'].fields['pony'].remote_field.model,\n+            'test_rnmo.Horse',\n+        )\n         self.assertTableNotExists(\"test_rnmo_pony\")\n         self.assertTableExists(\"test_rnmo_horse\")\n         if connection.features.supports_foreign_keys:\n@@ -532,7 +535,10 @@ def test_rename_model(self):\n         # Test original state and database\n         self.assertIn((\"test_rnmo\", \"pony\"), original_state.models)\n         self.assertNotIn((\"test_rnmo\", \"horse\"), original_state.models)\n-        self.assertEqual(\"Pony\", original_state.models[\"test_rnmo\", \"rider\"].fields[1][1].remote_field.model)\n+        self.assertEqual(\n+            original_state.models['test_rnmo', 'rider'].fields['pony'].remote_field.model,\n+            'Pony',\n+        )\n         self.assertTableExists(\"test_rnmo_pony\")\n         self.assertTableNotExists(\"test_rnmo_horse\")\n         if connection.features.supports_foreign_keys:\n@@ -579,7 +585,7 @@ def test_rename_model_with_self_referential_fk(self):\n         # Remember, RenameModel also repoints all incoming FKs and M2Ms\n         self.assertEqual(\n             'self',\n-            new_state.models[\"test_rmwsrf\", \"horserider\"].fields[2][1].remote_field.model\n+            new_state.models[\"test_rmwsrf\", \"horserider\"].fields['friend'].remote_field.model\n         )\n         HorseRider = new_state.apps.get_model('test_rmwsrf', 'horserider')\n         self.assertIs(HorseRider._meta.get_field('horserider').remote_field.model, HorseRider)\n@@ -621,8 +627,8 @@ def test_rename_model_with_superclass_fk(self):\n         self.assertIn((\"test_rmwsc\", \"littlehorse\"), new_state.models)\n         # RenameModel shouldn't repoint the superclass's relations, only local ones\n         self.assertEqual(\n-            project_state.models[\"test_rmwsc\", \"rider\"].fields[1][1].remote_field.model,\n-            new_state.models[\"test_rmwsc\", \"rider\"].fields[1][1].remote_field.model\n+            project_state.models['test_rmwsc', 'rider'].fields['pony'].remote_field.model,\n+            new_state.models['test_rmwsc', 'rider'].fields['pony'].remote_field.model,\n         )\n         # Before running the migration we have a table for Shetland Pony, not Little Horse\n         self.assertTableExists(\"test_rmwsc_shetlandpony\")\n@@ -797,10 +803,7 @@ def test_add_field(self):\n         self.assertEqual(operation.describe(), \"Add field height to Pony\")\n         project_state, new_state = self.make_test_state(\"test_adfl\", operation)\n         self.assertEqual(len(new_state.models[\"test_adfl\", \"pony\"].fields), 4)\n-        field = [\n-            f for n, f in new_state.models[\"test_adfl\", \"pony\"].fields\n-            if n == \"height\"\n-        ][0]\n+        field = new_state.models['test_adfl', 'pony'].fields['height']\n         self.assertEqual(field.default, 5)\n         # Test the database alteration\n         self.assertColumnNotExists(\"test_adfl_pony\", \"height\")\n@@ -974,10 +977,7 @@ def test_add_field_preserve_default(self):\n         new_state = project_state.clone()\n         operation.state_forwards(\"test_adflpd\", new_state)\n         self.assertEqual(len(new_state.models[\"test_adflpd\", \"pony\"].fields), 4)\n-        field = [\n-            f for n, f in new_state.models[\"test_adflpd\", \"pony\"].fields\n-            if n == \"height\"\n-        ][0]\n+        field = new_state.models['test_adflpd', 'pony'].fields['height']\n         self.assertEqual(field.default, models.NOT_PROVIDED)\n         # Test the database alteration\n         project_state.apps.get_model(\"test_adflpd\", \"pony\").objects.create(\n@@ -1234,8 +1234,8 @@ def test_alter_field(self):\n         self.assertEqual(operation.describe(), \"Alter field pink on Pony\")\n         new_state = project_state.clone()\n         operation.state_forwards(\"test_alfl\", new_state)\n-        self.assertIs(project_state.models[\"test_alfl\", \"pony\"].get_field_by_name(\"pink\").null, False)\n-        self.assertIs(new_state.models[\"test_alfl\", \"pony\"].get_field_by_name(\"pink\").null, True)\n+        self.assertIs(project_state.models['test_alfl', 'pony'].fields['pink'].null, False)\n+        self.assertIs(new_state.models['test_alfl', 'pony'].fields['pink'].null, True)\n         # Test the database alteration\n         self.assertColumnNotNull(\"test_alfl_pony\", \"pink\")\n         with connection.schema_editor() as editor:\n@@ -1260,8 +1260,14 @@ def test_alter_field_pk(self):\n         operation = migrations.AlterField(\"Pony\", \"id\", models.IntegerField(primary_key=True))\n         new_state = project_state.clone()\n         operation.state_forwards(\"test_alflpk\", new_state)\n-        self.assertIsInstance(project_state.models[\"test_alflpk\", \"pony\"].get_field_by_name(\"id\"), models.AutoField)\n-        self.assertIsInstance(new_state.models[\"test_alflpk\", \"pony\"].get_field_by_name(\"id\"), models.IntegerField)\n+        self.assertIsInstance(\n+            project_state.models['test_alflpk', 'pony'].fields['id'],\n+            models.AutoField,\n+        )\n+        self.assertIsInstance(\n+            new_state.models['test_alflpk', 'pony'].fields['id'],\n+            models.IntegerField,\n+        )\n         # Test the database alteration\n         with connection.schema_editor() as editor:\n             operation.database_forwards(\"test_alflpk\", editor, project_state, new_state)\n@@ -1289,8 +1295,14 @@ def test_alter_field_pk_fk(self):\n         operation = migrations.AlterField(\"Pony\", \"id\", models.FloatField(primary_key=True))\n         new_state = project_state.clone()\n         operation.state_forwards(\"test_alflpkfk\", new_state)\n-        self.assertIsInstance(project_state.models[\"test_alflpkfk\", \"pony\"].get_field_by_name(\"id\"), models.AutoField)\n-        self.assertIsInstance(new_state.models[\"test_alflpkfk\", \"pony\"].get_field_by_name(\"id\"), models.FloatField)\n+        self.assertIsInstance(\n+            project_state.models['test_alflpkfk', 'pony'].fields['id'],\n+            models.AutoField,\n+        )\n+        self.assertIsInstance(\n+            new_state.models['test_alflpkfk', 'pony'].fields['id'],\n+            models.FloatField,\n+        )\n \n         def assertIdTypeEqualsFkType():\n             with connection.cursor() as cursor:\n@@ -1479,8 +1491,8 @@ def test_rename_field(self):\n         self.assertEqual(operation.describe(), \"Rename field pink on Pony to blue\")\n         new_state = project_state.clone()\n         operation.state_forwards(\"test_rnfl\", new_state)\n-        self.assertIn(\"blue\", [n for n, f in new_state.models[\"test_rnfl\", \"pony\"].fields])\n-        self.assertNotIn(\"pink\", [n for n, f in new_state.models[\"test_rnfl\", \"pony\"].fields])\n+        self.assertIn(\"blue\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n+        self.assertNotIn(\"pink\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n         # Make sure the unique_together has the renamed column too\n         self.assertIn(\"blue\", new_state.models[\"test_rnfl\", \"pony\"].options['unique_together'][0])\n         self.assertNotIn(\"pink\", new_state.models[\"test_rnfl\", \"pony\"].options['unique_together'][0])\n@@ -1536,19 +1548,19 @@ def test_rename_referenced_field_state_forward(self):\n         operation = migrations.RenameField('Model', 'field', 'renamed')\n         new_state = state.clone()\n         operation.state_forwards('app', new_state)\n-        self.assertEqual(new_state.models['app', 'othermodel'].fields[1][1].remote_field.field_name, 'renamed')\n-        self.assertEqual(new_state.models['app', 'othermodel'].fields[1][1].from_fields, ['self'])\n-        self.assertEqual(new_state.models['app', 'othermodel'].fields[1][1].to_fields, ('renamed',))\n-        self.assertEqual(new_state.models['app', 'othermodel'].fields[2][1].from_fields, ('fk',))\n-        self.assertEqual(new_state.models['app', 'othermodel'].fields[2][1].to_fields, ('renamed',))\n+        self.assertEqual(new_state.models['app', 'othermodel'].fields['fk'].remote_field.field_name, 'renamed')\n+        self.assertEqual(new_state.models['app', 'othermodel'].fields['fk'].from_fields, ['self'])\n+        self.assertEqual(new_state.models['app', 'othermodel'].fields['fk'].to_fields, ('renamed',))\n+        self.assertEqual(new_state.models['app', 'othermodel'].fields['fo'].from_fields, ('fk',))\n+        self.assertEqual(new_state.models['app', 'othermodel'].fields['fo'].to_fields, ('renamed',))\n         operation = migrations.RenameField('OtherModel', 'fk', 'renamed_fk')\n         new_state = state.clone()\n         operation.state_forwards('app', new_state)\n-        self.assertEqual(new_state.models['app', 'othermodel'].fields[1][1].remote_field.field_name, 'renamed')\n-        self.assertEqual(new_state.models['app', 'othermodel'].fields[1][1].from_fields, ('self',))\n-        self.assertEqual(new_state.models['app', 'othermodel'].fields[1][1].to_fields, ('renamed',))\n-        self.assertEqual(new_state.models['app', 'othermodel'].fields[2][1].from_fields, ('renamed_fk',))\n-        self.assertEqual(new_state.models['app', 'othermodel'].fields[2][1].to_fields, ('renamed',))\n+        self.assertEqual(new_state.models['app', 'othermodel'].fields['renamed_fk'].remote_field.field_name, 'renamed')\n+        self.assertEqual(new_state.models['app', 'othermodel'].fields['renamed_fk'].from_fields, ('self',))\n+        self.assertEqual(new_state.models['app', 'othermodel'].fields['renamed_fk'].to_fields, ('renamed',))\n+        self.assertEqual(new_state.models['app', 'othermodel'].fields['fo'].from_fields, ('renamed_fk',))\n+        self.assertEqual(new_state.models['app', 'othermodel'].fields['fo'].to_fields, ('renamed',))\n \n     def test_alter_unique_together(self):\n         \"\"\"\ndiff --git a/tests/migrations/test_state.py b/tests/migrations/test_state.py\n--- a/tests/migrations/test_state.py\n+++ b/tests/migrations/test_state.py\n@@ -121,10 +121,10 @@ class Meta:\n \n         self.assertEqual(author_state.app_label, \"migrations\")\n         self.assertEqual(author_state.name, \"Author\")\n-        self.assertEqual([x for x, y in author_state.fields], [\"id\", \"name\", \"bio\", \"age\"])\n-        self.assertEqual(author_state.fields[1][1].max_length, 255)\n-        self.assertIs(author_state.fields[2][1].null, False)\n-        self.assertIs(author_state.fields[3][1].null, True)\n+        self.assertEqual(list(author_state.fields), [\"id\", \"name\", \"bio\", \"age\"])\n+        self.assertEqual(author_state.fields['name'].max_length, 255)\n+        self.assertIs(author_state.fields['bio'].null, False)\n+        self.assertIs(author_state.fields['age'].null, True)\n         self.assertEqual(\n             author_state.options,\n             {\n@@ -138,10 +138,10 @@ class Meta:\n \n         self.assertEqual(book_state.app_label, \"migrations\")\n         self.assertEqual(book_state.name, \"Book\")\n-        self.assertEqual([x for x, y in book_state.fields], [\"id\", \"title\", \"author\", \"contributors\"])\n-        self.assertEqual(book_state.fields[1][1].max_length, 1000)\n-        self.assertIs(book_state.fields[2][1].null, False)\n-        self.assertEqual(book_state.fields[3][1].__class__.__name__, \"ManyToManyField\")\n+        self.assertEqual(list(book_state.fields), [\"id\", \"title\", \"author\", \"contributors\"])\n+        self.assertEqual(book_state.fields['title'].max_length, 1000)\n+        self.assertIs(book_state.fields['author'].null, False)\n+        self.assertEqual(book_state.fields['contributors'].__class__.__name__, 'ManyToManyField')\n         self.assertEqual(\n             book_state.options,\n             {\"verbose_name\": \"tome\", \"db_table\": \"test_tome\", \"indexes\": [book_index], \"constraints\": []},\n@@ -150,7 +150,7 @@ class Meta:\n \n         self.assertEqual(author_proxy_state.app_label, \"migrations\")\n         self.assertEqual(author_proxy_state.name, \"AuthorProxy\")\n-        self.assertEqual(author_proxy_state.fields, [])\n+        self.assertEqual(author_proxy_state.fields, {})\n         self.assertEqual(\n             author_proxy_state.options,\n             {\"proxy\": True, \"ordering\": [\"name\"], \"indexes\": [], \"constraints\": []},\n@@ -923,7 +923,7 @@ class Meta:\n         project_state.add_model(ModelState.from_model(Author))\n         project_state.add_model(ModelState.from_model(Book))\n         self.assertEqual(\n-            [name for name, field in project_state.models[\"migrations\", \"book\"].fields],\n+            list(project_state.models['migrations', 'book'].fields),\n             [\"id\", \"author\"],\n         )\n \n@@ -1042,6 +1042,28 @@ def test_repr(self):\n         with self.assertRaisesMessage(InvalidBasesError, \"Cannot resolve bases for [<ModelState: 'app.Model'>]\"):\n             project_state.apps\n \n+    def test_fields_ordering_equality(self):\n+        state = ModelState(\n+            'migrations',\n+            'Tag',\n+            [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('name', models.CharField(max_length=100)),\n+                ('hidden', models.BooleanField()),\n+            ],\n+        )\n+        reordered_state = ModelState(\n+            'migrations',\n+            'Tag',\n+            [\n+                ('id', models.AutoField(primary_key=True)),\n+                # Purposedly re-ordered.\n+                ('hidden', models.BooleanField()),\n+                ('name', models.CharField(max_length=100)),\n+            ],\n+        )\n+        self.assertEqual(state, reordered_state)\n+\n     @override_settings(TEST_SWAPPABLE_MODEL='migrations.SomeFakeModel')\n     def test_create_swappable(self):\n         \"\"\"\n@@ -1062,10 +1084,10 @@ class Meta:\n         author_state = ModelState.from_model(Author)\n         self.assertEqual(author_state.app_label, 'migrations')\n         self.assertEqual(author_state.name, 'Author')\n-        self.assertEqual([x for x, y in author_state.fields], ['id', 'name', 'bio', 'age'])\n-        self.assertEqual(author_state.fields[1][1].max_length, 255)\n-        self.assertIs(author_state.fields[2][1].null, False)\n-        self.assertIs(author_state.fields[3][1].null, True)\n+        self.assertEqual(list(author_state.fields), ['id', 'name', 'bio', 'age'])\n+        self.assertEqual(author_state.fields['name'].max_length, 255)\n+        self.assertIs(author_state.fields['bio'].null, False)\n+        self.assertIs(author_state.fields['age'].null, True)\n         self.assertEqual(author_state.options, {'swappable': 'TEST_SWAPPABLE_MODEL', 'indexes': [], \"constraints\": []})\n         self.assertEqual(author_state.bases, (models.Model,))\n         self.assertEqual(author_state.managers, [])\n@@ -1104,11 +1126,11 @@ class Meta(Station.Meta):\n         self.assertEqual(station_state.app_label, 'migrations')\n         self.assertEqual(station_state.name, 'BusStation')\n         self.assertEqual(\n-            [x for x, y in station_state.fields],\n+            list(station_state.fields),\n             ['searchablelocation_ptr', 'name', 'bus_routes', 'inbound']\n         )\n-        self.assertEqual(station_state.fields[1][1].max_length, 128)\n-        self.assertIs(station_state.fields[2][1].null, False)\n+        self.assertEqual(station_state.fields['name'].max_length, 128)\n+        self.assertIs(station_state.fields['bus_routes'].null, False)\n         self.assertEqual(\n             station_state.options,\n             {'abstract': False, 'swappable': 'TEST_SWAPPABLE_MODEL', 'indexes': [], 'constraints': []}\n",
  "problem_statement": "Store ModeState.fields into a dict.\nDescription\n\t\nModeState initially stored its fields into a List[Tuple[str, models.Field]] because ​it wanted to preserve ordering.\nHowever the auto-detector doesn't consider field re-ordering as a state change and Django doesn't support table column reordering in the first place. The only reason I'm aware of for keeping field ordering is to generate model forms out of them which is unlikely to happen during migrations and if it was the case the only the order in which field are ordered and validated would change if Meta.fields = '__all__ is used ​which is discouraged.\nGiven storing fields this way results in awkward and inefficient lookup by name for no apparent benefits and that dict now preserves insertion ordering I suggest we switch ModelState.fields to Dict[str, models.Field]. I suggest we do the same for ModelState.indexes and .constraints since they suggest from the same awkwardness which was likely cargo culted from ModelState.fields design decision.\n",
  "hints_text": "​PR",
  "created_at": "2020-04-22T03:21:43Z",
  "version": "3.1",
  "FAIL_TO_PASS": "[\"test_create_swappable (migrations.test_state.ModelStateTests)\", \"test_create_swappable_from_abstract (migrations.test_state.ModelStateTests)\", \"test_fields_ordering_equality (migrations.test_state.ModelStateTests)\", \"test_create (migrations.test_state.StateTests)\", \"test_ignore_order_wrt (migrations.test_state.StateTests)\", \"test_add_field (migrations.test_operations.OperationTests)\", \"test_add_field_preserve_default (migrations.test_operations.OperationTests)\", \"test_alter_field (migrations.test_operations.OperationTests)\", \"test_alter_field_pk (migrations.test_operations.OperationTests)\", \"test_alter_field_pk_fk (migrations.test_operations.OperationTests)\", \"test_rename_field (migrations.test_operations.OperationTests)\", \"test_rename_model (migrations.test_operations.OperationTests)\", \"test_rename_model_with_self_referential_fk (migrations.test_operations.OperationTests)\", \"test_rename_model_with_superclass_fk (migrations.test_operations.OperationTests)\", \"test_rename_referenced_field_state_forward (migrations.test_operations.OperationTests)\", \"test_load (migrations.test_loader.LoaderTests)\", \"test_load_unmigrated_dependency (migrations.test_loader.LoaderTests)\", \"test_unrelated_applied_migrations_mutate_state (migrations.test_executor.ExecutorTests)\"]",
  "PASS_TO_PASS": "[\"test_references_model_mixin (migrations.test_operations.TestCreateModel)\", \"test_reference_field_by_through_fields (migrations.test_operations.FieldOperationTests)\", \"test_references_field_by_from_fields (migrations.test_operations.FieldOperationTests)\", \"test_references_field_by_name (migrations.test_operations.FieldOperationTests)\", \"test_references_field_by_remote_field_model (migrations.test_operations.FieldOperationTests)\", \"test_references_field_by_through (migrations.test_operations.FieldOperationTests)\", \"test_references_field_by_to_fields (migrations.test_operations.FieldOperationTests)\", \"test_references_model (migrations.test_operations.FieldOperationTests)\", \"test_apply (migrations.test_loader.RecorderTests)\", \"test_abstract_model_children_inherit_indexes (migrations.test_state.ModelStateTests)\", \"test_bound_field_sanity_check (migrations.test_state.ModelStateTests)\", \"test_custom_manager_swappable (migrations.test_state.ModelStateTests)\", \"test_custom_model_base (migrations.test_state.ModelStateTests)\", \"test_explicit_index_name (migrations.test_state.ModelStateTests)\", \"test_fields_immutability (migrations.test_state.ModelStateTests)\", \"test_from_model_constraints (migrations.test_state.ModelStateTests)\", \"test_order_with_respect_to_private_field (migrations.test_state.ModelStateTests)\", \"test_repr (migrations.test_state.ModelStateTests)\", \"test_sanity_check_through (migrations.test_state.ModelStateTests)\", \"test_sanity_check_to (migrations.test_state.ModelStateTests)\", \"test_sanity_index_name (migrations.test_state.ModelStateTests)\", \"test_backwards_nothing_to_do (migrations.test_executor.ExecutorUnitTests)\", \"test_minimize_rollbacks (migrations.test_executor.ExecutorUnitTests)\", \"test_minimize_rollbacks_branchy (migrations.test_executor.ExecutorUnitTests)\", \"test_add_relations (migrations.test_state.StateTests)\", \"test_apps_bulk_update (migrations.test_state.StateTests)\", \"test_choices_iterator (migrations.test_state.StateTests)\", \"test_custom_base_manager (migrations.test_state.StateTests)\", \"test_custom_default_manager (migrations.test_state.StateTests)\", \"test_custom_default_manager_added_to_the_model_state (migrations.test_state.StateTests)\", \"test_custom_default_manager_named_objects_with_false_migration_flag (migrations.test_state.StateTests)\", \"test_dangling_references_throw_error (migrations.test_state.StateTests)\", \"test_equality (migrations.test_state.StateTests)\", \"test_manager_refer_correct_model_version (migrations.test_state.StateTests)\", \"test_no_duplicate_managers (migrations.test_state.StateTests)\", \"test_real_apps (migrations.test_state.StateTests)\", \"test_reload_model_relationship_consistency (migrations.test_state.StateTests)\", \"test_reload_related_model_on_non_relational_fields (migrations.test_state.StateTests)\", \"test_remove_relations (migrations.test_state.StateTests)\", \"test_render (migrations.test_state.StateTests)\", \"test_render_model_inheritance (migrations.test_state.StateTests)\", \"test_render_model_with_multiple_inheritance (migrations.test_state.StateTests)\", \"test_render_project_dependencies (migrations.test_state.StateTests)\", \"test_render_unique_app_labels (migrations.test_state.StateTests)\", \"test_self_relation (migrations.test_state.StateTests)\", \"test_add_field_ignore_swapped (migrations.test_operations.SwappableOperationTests)\", \"test_create_ignore_swapped (migrations.test_operations.SwappableOperationTests)\", \"test_delete_ignore_swapped (migrations.test_operations.SwappableOperationTests)\", \"test_indexes_ignore_swapped (migrations.test_operations.SwappableOperationTests)\", \"test_abstract_base (migrations.test_state.RelatedModelsTests)\", \"test_base (migrations.test_state.RelatedModelsTests)\", \"test_base_to_base_fk (migrations.test_state.RelatedModelsTests)\", \"test_base_to_subclass_fk (migrations.test_state.RelatedModelsTests)\", \"test_circle (migrations.test_state.RelatedModelsTests)\", \"test_direct_fk (migrations.test_state.RelatedModelsTests)\", \"test_direct_hidden_fk (migrations.test_state.RelatedModelsTests)\", \"test_direct_m2m (migrations.test_state.RelatedModelsTests)\", \"test_direct_m2m_self (migrations.test_state.RelatedModelsTests)\", \"test_fk_through_proxy (migrations.test_state.RelatedModelsTests)\", \"test_generic_fk (migrations.test_state.RelatedModelsTests)\", \"test_intermediate_m2m (migrations.test_state.RelatedModelsTests)\", \"test_intermediate_m2m_base (migrations.test_state.RelatedModelsTests)\", \"test_intermediate_m2m_extern_fk (migrations.test_state.RelatedModelsTests)\", \"test_intermediate_m2m_self (migrations.test_state.RelatedModelsTests)\", \"test_multiple_bases (migrations.test_state.RelatedModelsTests)\", \"test_multiple_mixed_bases (migrations.test_state.RelatedModelsTests)\", \"test_multiple_nested_bases (migrations.test_state.RelatedModelsTests)\", \"test_nested_abstract_base (migrations.test_state.RelatedModelsTests)\", \"test_nested_base (migrations.test_state.RelatedModelsTests)\", \"test_nested_fk (migrations.test_state.RelatedModelsTests)\", \"test_nested_proxy_base (migrations.test_state.RelatedModelsTests)\", \"test_proxy_base (migrations.test_state.RelatedModelsTests)\", \"test_two_sided (migrations.test_state.RelatedModelsTests)\", \"test_unrelated (migrations.test_state.RelatedModelsTests)\", \"test_invalid (migrations.test_loader.PycLoaderTests)\", \"test_add_binaryfield (migrations.test_operations.OperationTests)\", \"test_add_charfield (migrations.test_operations.OperationTests)\", \"test_add_constraint (migrations.test_operations.OperationTests)\", \"test_add_constraint_combinable (migrations.test_operations.OperationTests)\", \"test_add_constraint_percent_escaping (migrations.test_operations.OperationTests)\", \"test_add_field_m2m (migrations.test_operations.OperationTests)\", \"test_add_index (migrations.test_operations.OperationTests)\", \"test_add_index_state_forwards (migrations.test_operations.OperationTests)\", \"test_add_or_constraint (migrations.test_operations.OperationTests)\", \"test_add_partial_unique_constraint (migrations.test_operations.OperationTests)\", \"test_add_textfield (migrations.test_operations.OperationTests)\", \"test_alter_field_m2m (migrations.test_operations.OperationTests)\", \"test_alter_field_reloads_state_on_fk_target_changes (migrations.test_operations.OperationTests)\", \"test_alter_field_reloads_state_on_fk_with_to_field_related_name_target_type_change (migrations.test_operations.OperationTests)\", \"test_alter_field_reloads_state_on_fk_with_to_field_target_changes (migrations.test_operations.OperationTests)\", \"test_alter_field_reloads_state_on_fk_with_to_field_target_type_change (migrations.test_operations.OperationTests)\", \"test_alter_field_with_index (migrations.test_operations.OperationTests)\", \"test_alter_fk (migrations.test_operations.OperationTests)\", \"test_alter_fk_non_fk (migrations.test_operations.OperationTests)\", \"test_alter_index_together (migrations.test_operations.OperationTests)\", \"test_alter_index_together_remove (migrations.test_operations.OperationTests)\", \"test_alter_model_managers (migrations.test_operations.OperationTests)\", \"test_alter_model_managers_emptying (migrations.test_operations.OperationTests)\", \"test_alter_model_options (migrations.test_operations.OperationTests)\", \"test_alter_model_options_emptying (migrations.test_operations.OperationTests)\", \"test_alter_model_table (migrations.test_operations.OperationTests)\", \"test_alter_model_table_m2m (migrations.test_operations.OperationTests)\", \"test_alter_model_table_none (migrations.test_operations.OperationTests)\", \"test_alter_model_table_noop (migrations.test_operations.OperationTests)\", \"test_alter_order_with_respect_to (migrations.test_operations.OperationTests)\", \"test_alter_unique_together (migrations.test_operations.OperationTests)\", \"test_alter_unique_together_remove (migrations.test_operations.OperationTests)\", \"A field may be migrated from AutoField to BigAutoField.\", \"test_column_name_quoting (migrations.test_operations.OperationTests)\", \"test_create_model (migrations.test_operations.OperationTests)\", \"test_create_model_inheritance (migrations.test_operations.OperationTests)\", \"test_create_model_m2m (migrations.test_operations.OperationTests)\", \"test_create_model_managers (migrations.test_operations.OperationTests)\", \"test_create_model_with_constraint (migrations.test_operations.OperationTests)\", \"test_create_model_with_duplicate_base (migrations.test_operations.OperationTests)\", \"test_create_model_with_duplicate_field_name (migrations.test_operations.OperationTests)\", \"test_create_model_with_duplicate_manager_name (migrations.test_operations.OperationTests)\", \"test_create_model_with_partial_unique_constraint (migrations.test_operations.OperationTests)\", \"test_create_model_with_unique_after (migrations.test_operations.OperationTests)\", \"test_create_proxy_model (migrations.test_operations.OperationTests)\", \"test_create_unmanaged_model (migrations.test_operations.OperationTests)\", \"test_delete_model (migrations.test_operations.OperationTests)\", \"test_delete_mti_model (migrations.test_operations.OperationTests)\", \"test_delete_proxy_model (migrations.test_operations.OperationTests)\", \"test_model_with_bigautofield (migrations.test_operations.OperationTests)\", \"test_remove_constraint (migrations.test_operations.OperationTests)\", \"test_remove_field (migrations.test_operations.OperationTests)\", \"test_remove_field_m2m (migrations.test_operations.OperationTests)\", \"test_remove_field_m2m_with_through (migrations.test_operations.OperationTests)\", \"test_remove_fk (migrations.test_operations.OperationTests)\", \"test_remove_index (migrations.test_operations.OperationTests)\", \"test_remove_index_state_forwards (migrations.test_operations.OperationTests)\", \"test_remove_partial_unique_constraint (migrations.test_operations.OperationTests)\", \"test_rename_field_reloads_state_on_fk_target_changes (migrations.test_operations.OperationTests)\", \"RenameModel renames a many-to-many column after a RenameField.\", \"test_rename_m2m_target_model (migrations.test_operations.OperationTests)\", \"test_rename_m2m_through_model (migrations.test_operations.OperationTests)\", \"test_rename_missing_field (migrations.test_operations.OperationTests)\", \"test_rename_model_state_forwards (migrations.test_operations.OperationTests)\", \"test_rename_model_with_m2m (migrations.test_operations.OperationTests)\", \"test_rename_model_with_self_referential_m2m (migrations.test_operations.OperationTests)\", \"test_repoint_field_m2m (migrations.test_operations.OperationTests)\", \"test_run_python (migrations.test_operations.OperationTests)\", \"test_run_python_atomic (migrations.test_operations.OperationTests)\", \"test_run_python_noop (migrations.test_operations.OperationTests)\", \"test_run_python_related_assignment (migrations.test_operations.OperationTests)\", \"test_run_sql (migrations.test_operations.OperationTests)\", \"test_run_sql_noop (migrations.test_operations.OperationTests)\", \"test_run_sql_params (migrations.test_operations.OperationTests)\", \"test_run_sql_params_invalid (migrations.test_operations.OperationTests)\", \"test_separate_database_and_state (migrations.test_operations.OperationTests)\", \"test_separate_database_and_state2 (migrations.test_operations.OperationTests)\", \"A field may be migrated from SmallAutoField to AutoField.\", \"A field may be migrated from SmallAutoField to BigAutoField.\", \"test_check_consistent_history (migrations.test_loader.LoaderTests)\", \"test_check_consistent_history_squashed (migrations.test_loader.LoaderTests)\", \"test_explicit_missing_module (migrations.test_loader.LoaderTests)\", \"test_first (migrations.test_loader.LoaderTests)\", \"Files prefixed with underscore, tilde, or dot aren't loaded.\", \"test_load_empty_dir (migrations.test_loader.LoaderTests)\", \"test_load_import_error (migrations.test_loader.LoaderTests)\", \"test_load_module_file (migrations.test_loader.LoaderTests)\", \"Migration directories without an __init__.py file are loaded.\", \"Tests loading a squashed migration\", \"Tests loading a complex set of squashed migrations\", \"test_loading_squashed_complex_multi_apps (migrations.test_loader.LoaderTests)\", \"test_loading_squashed_complex_multi_apps_partially_applied (migrations.test_loader.LoaderTests)\", \"Tests loading a complex but erroneous set of squashed migrations\", \"Tests loading a squashed migration with a new migration referencing it\", \"test_marked_as_migrated (migrations.test_loader.LoaderTests)\", \"test_marked_as_unmigrated (migrations.test_loader.LoaderTests)\", \"Tests prefix name matching\", \"test_plan_handles_repeated_migrations (migrations.test_loader.LoaderTests)\", \"test_run_before (migrations.test_loader.LoaderTests)\", \"test_alter_id_type_with_fk (migrations.test_executor.ExecutorTests)\", \"test_apply_all_replaced_marks_replacement_as_applied (migrations.test_executor.ExecutorTests)\", \"test_atomic_operation_in_non_atomic_migration (migrations.test_executor.ExecutorTests)\", \"test_custom_user (migrations.test_executor.ExecutorTests)\", \"test_detect_soft_applied_add_field_manytomanyfield (migrations.test_executor.ExecutorTests)\", \"test_empty_plan (migrations.test_executor.ExecutorTests)\", \"test_migrate_marks_replacement_applied_even_if_it_did_nothing (migrations.test_executor.ExecutorTests)\", \"Migrations are applied and recorded atomically.\", \"test_mixed_plan_not_supported (migrations.test_executor.ExecutorTests)\", \"test_non_atomic_migration (migrations.test_executor.ExecutorTests)\", \"test_process_callback (migrations.test_executor.ExecutorTests)\", \"test_run (migrations.test_executor.ExecutorTests)\", \"test_run_with_squashed (migrations.test_executor.ExecutorTests)\", \"test_soft_apply (migrations.test_executor.ExecutorTests)\", \"test_unrelated_model_lookups_backwards (migrations.test_executor.ExecutorTests)\", \"test_unrelated_model_lookups_forwards (migrations.test_executor.ExecutorTests)\"]",
  "environment_setup_commit": "0668164b4ac93a5be79f5b87fae83c657124d9ab",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.634733",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}