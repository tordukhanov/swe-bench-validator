{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-17813",
  "base_commit": "21183076095704d7844a832d2e7f387555934f0c",
  "patch": "diff --git a/sympy/sets/handlers/intersection.py b/sympy/sets/handlers/intersection.py\n--- a/sympy/sets/handlers/intersection.py\n+++ b/sympy/sets/handlers/intersection.py\n@@ -223,39 +223,31 @@ def intersection_sets(self, other):\n         return None\n     base_set = self.base_sets[0]\n \n+    # Intersection between ImageSets with Integers as base set\n+    # For {f(n) : n in Integers} & {g(m) : m in Integers} we solve the\n+    # diophantine equations f(n)=g(m).\n+    # If the solutions for n are {h(t) : t in Integers} then we return\n+    # {f(h(t)) : t in integers}.\n     if base_set is S.Integers:\n-        g = None\n+        gm = None\n         if isinstance(other, ImageSet) and other.base_sets == (S.Integers,):\n-            g = other.lamda.expr\n+            gm = other.lamda.expr\n             m = other.lamda.variables[0]\n         elif other is S.Integers:\n-            m = g = Dummy('x')\n-        if g is not None:\n-            f = self.lamda.expr\n+            m = gm = Dummy('x')\n+        if gm is not None:\n+            fn = self.lamda.expr\n             n = self.lamda.variables[0]\n-            # Diophantine sorts the solutions according to the alphabetic\n-            # order of the variable names, since the result should not depend\n-            # on the variable name, they are replaced by the dummy variables\n-            # below\n-            a, b = Dummy('a'), Dummy('b')\n-            fa, ga = f.subs(n, a), g.subs(m, b)\n-            solns = list(diophantine(fa - ga))\n-            if not solns:\n+            solns = list(diophantine(fn - gm, syms=(n, m)))\n+            if len(solns) == 0:\n                 return EmptySet()\n-\n-            if len(solns) != 1:\n+            elif len(solns) != 1:\n                 return\n-            nsol = solns[0][0]  # since 'a' < 'b', nsol is first\n-            t = nsol.free_symbols.pop()  # diophantine supplied symbol\n-            nsol = nsol.subs(t, n)\n-            if nsol != n:\n-                # if nsol == n and we know were are working with\n-                # a base_set of Integers then this was an unevaluated\n-                # ImageSet representation of Integers, otherwise\n-                # it is a new ImageSet intersection with a subset\n-                # of integers\n-                nsol = f.subs(n, nsol)\n-            return imageset(Lambda(n, nsol), S.Integers)\n+            else:\n+                soln, solm = solns[0]\n+                (t,) = soln.free_symbols\n+                expr = fn.subs(n, soln.subs(t, n))\n+                return imageset(Lambda(n, expr), S.Integers)\n \n     if other == S.Reals:\n         from sympy.solvers.solveset import solveset_real\n",
  "test_patch": "diff --git a/sympy/sets/tests/test_fancysets.py b/sympy/sets/tests/test_fancysets.py\n--- a/sympy/sets/tests/test_fancysets.py\n+++ b/sympy/sets/tests/test_fancysets.py\n@@ -528,6 +528,10 @@ def test_infinitely_indexed_set_1():\n     assert imageset(x, x/2 + Rational(1, 3), S.Integers).intersect(S.Integers) is S.EmptySet\n     assert imageset(x, x/2 + S.Half, S.Integers).intersect(S.Integers) is S.Integers\n \n+    # https://github.com/sympy/sympy/issues/17355\n+    S53 = ImageSet(Lambda(n, 5*n + 3), S.Integers)\n+    assert S53.intersect(S.Integers) == S53\n+\n \n def test_infinitely_indexed_set_2():\n     from sympy.abc import n\n",
  "problem_statement": "Intersection of ImageSet gives incorrect answer.\nAfter git bisecting by @gschintgen this [commit ](https://github.com/sympy/sympy/commit/f54aa8d4593bbc107af91f6f033a363dd3a440db) has changed the output of \r\n```python\r\n>>> Intersection(S.Integers, ImageSet(Lambda(n, 5*n + 3), S.Integers))\r\nS.Integers\r\n# expected ImageSet(Lambda(n, 5*n + 3), S.Integers)\r\n```\r\nping - @smichr \n",
  "hints_text": "That commit is from this PR https://github.com/sympy/sympy/pull/16864\nThis is a regression since 1.4\nIt goes wrong here:\r\nhttps://github.com/sympy/sympy/blob/21183076095704d7844a832d2e7f387555934f0c/sympy/sets/handlers/intersection.py#L231\r\nI'm not sure what that code is trying to do but we only hit that branch when calculating the intersection of the an ImageSet with Integers as base set and the Integers so ~~at that point the result of the intersection is just self~~.",
  "created_at": "2019-10-28T01:18:58Z",
  "version": "1.5",
  "FAIL_TO_PASS": "[\"test_infinitely_indexed_set_1\"]",
  "PASS_TO_PASS": "[\"test_naturals\", \"test_naturals0\", \"test_integers\", \"test_ImageSet\", \"test_image_is_ImageSet\", \"test_halfcircle\", \"test_ImageSet_iterator_not_injective\", \"test_inf_Range_len\", \"test_Range_set\", \"test_range_range_intersection\", \"test_range_interval_intersection\", \"test_Integers_eval_imageset\", \"test_Range_eval_imageset\", \"test_fun\", \"test_Reals\", \"test_Complex\", \"test_intersections\", \"test_infinitely_indexed_set_2\", \"test_imageset_intersect_real\", \"test_imageset_intersect_interval\", \"test_infinitely_indexed_set_3\", \"test_ImageSet_simplification\", \"test_ImageSet_contains\", \"test_ComplexRegion_contains\", \"test_ComplexRegion_intersect\", \"test_ComplexRegion_union\", \"test_ComplexRegion_from_real\", \"test_ComplexRegion_measure\", \"test_normalize_theta_set\", \"test_ComplexRegion_FiniteSet\", \"test_union_RealSubSet\", \"test_issue_9980\", \"test_issue_11732\", \"test_issue_11730\", \"test_issue_11938\", \"test_issue_11914\", \"test_issue_9543\", \"test_issue_16871\", \"test_no_mod_on_imaginary\", \"test_Rationals\"]",
  "environment_setup_commit": "70381f282f2d9d039da860e391fe51649df2779d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.118375",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}