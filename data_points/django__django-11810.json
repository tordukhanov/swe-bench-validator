{
  "repo": "django/django",
  "instance_id": "django__django-11810",
  "base_commit": "e8ad265ac882f8f118d2c4a7618bd3e3916fc13e",
  "patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -6,6 +6,7 @@\n databases). The abstraction barrier only works one way: this module has to know\n all about the internals of models in order to get the information it needs.\n \"\"\"\n+import copy\n import difflib\n import functools\n import inspect\n@@ -324,6 +325,10 @@ def clone(self):\n             obj._extra_select_cache = None\n         else:\n             obj._extra_select_cache = self._extra_select_cache.copy()\n+        if self.select_related is not False:\n+            # Use deepcopy because select_related stores fields in nested\n+            # dicts.\n+            obj.select_related = copy.deepcopy(obj.select_related)\n         if 'subq_aliases' in self.__dict__:\n             obj.subq_aliases = self.subq_aliases.copy()\n         obj.used_aliases = self.used_aliases.copy()\n",
  "test_patch": "diff --git a/tests/queries/test_query.py b/tests/queries/test_query.py\n--- a/tests/queries/test_query.py\n+++ b/tests/queries/test_query.py\n@@ -106,3 +106,10 @@ def test_foreign_key_exclusive(self):\n         self.assertIsInstance(b_isnull, RelatedIsNull)\n         self.assertIsInstance(b_isnull.lhs, SimpleCol)\n         self.assertEqual(b_isnull.lhs.target, ObjectC._meta.get_field('objectb'))\n+\n+    def test_clone_select_related(self):\n+        query = Query(Item)\n+        query.add_select_related(['creator'])\n+        clone = query.clone()\n+        clone.add_select_related(['note', 'creator__extra'])\n+        self.assertEqual(query.select_related, {'creator': {}})\n",
  "problem_statement": "Chaining select_related mutates original QuerySet.\nDescription\n\t \n\t\t(last modified by Darren Maki)\n\t \nWhen creating a new QuerySet from an existing QuerySet that has had 'select_related' applied, if you apply another 'select_related' to the new QuerySet it will mutate the original QuerySet to also have the extra 'select_related'.\nmodels.py\nfrom django.db import models\nclass ModelA(models.Model):\n\tpass\nclass ModelB(models.Model):\n\tpass\nclass ModelC(models.Model):\n\tmodel_a = models.ForeignKey('foobar.ModelA', on_delete=models.CASCADE)\n\tmodel_b = models.ForeignKey('foobar.ModelB', on_delete=models.CASCADE)\ntest.py\nquery_1 = ModelC.objects.select_related('model_a')\nprint('QUERY 1:', str(query_1.query))\nquery_2 = query_1.select_related('model_b')\nprint('QUERY 2:', str(query_2.query))\nprint('QUERY 1:', str(query_1.query))\nif str(query_1.query) == str(query_2.query):\n\tprint('\\n!!! The two queries are the same !!!\\n')\noutput\nQUERY 1: SELECT \"foobar_modelc\".\"id\", \"foobar_modelc\".\"model_a_id\", \"foobar_modelc\".\"model_b_id\", \"foobar_modela\".\"id\" FROM \"foobar_modelc\" INNER JOIN \"foobar_modela\" ON (\"foobar_modelc\".\"model_a_id\" = \"foobar_modela\".\"id\")\nQUERY 2: SELECT \"foobar_modelc\".\"id\", \"foobar_modelc\".\"model_a_id\", \"foobar_modelc\".\"model_b_id\", \"foobar_modela\".\"id\", \"foobar_modelb\".\"id\" FROM \"foobar_modelc\" INNER JOIN \"foobar_modela\" ON (\"foobar_modelc\".\"model_a_id\" = \"foobar_modela\".\"id\") INNER JOIN \"foobar_modelb\" ON (\"foobar_modelc\".\"model_b_id\" = \"foobar_modelb\".\"id\")\nQUERY 1: SELECT \"foobar_modelc\".\"id\", \"foobar_modelc\".\"model_a_id\", \"foobar_modelc\".\"model_b_id\", \"foobar_modela\".\"id\", \"foobar_modelb\".\"id\" FROM \"foobar_modelc\" INNER JOIN \"foobar_modela\" ON (\"foobar_modelc\".\"model_a_id\" = \"foobar_modela\".\"id\") INNER JOIN \"foobar_modelb\" ON (\"foobar_modelc\".\"model_b_id\" = \"foobar_modelb\".\"id\")\n!!! The two queries are the same !!!\nThe expectation is that the original QuerySet is not mutated, and the two queries are different. This behavior also happens with 'prefetch_related'.\nSince the QuerySet methods call 'self._clone()', and state that they return 'a new QuerySet instance', this behavior does not seem correct.\n",
  "hints_text": "This seems to have been happening forever. sql.Query.select_related is made a dict on .add_select_related but never copied on .clone.",
  "created_at": "2019-09-23T19:56:25Z",
  "version": "3.1",
  "FAIL_TO_PASS": "[\"test_clone_select_related (queries.test_query.TestQuery)\"]",
  "PASS_TO_PASS": "[\"test_complex_query (queries.test_query.TestQuery)\", \"test_foreign_key (queries.test_query.TestQuery)\", \"test_foreign_key_exclusive (queries.test_query.TestQuery)\", \"test_foreign_key_f (queries.test_query.TestQuery)\", \"test_multiple_fields (queries.test_query.TestQuery)\", \"test_negated_nullable (queries.test_query.TestQuery)\", \"test_simple_query (queries.test_query.TestQuery)\", \"test_simplecol_query (queries.test_query.TestQuery)\", \"test_transform (queries.test_query.TestQuery)\"]",
  "environment_setup_commit": "0668164b4ac93a5be79f5b87fae83c657124d9ab",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.585031",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}