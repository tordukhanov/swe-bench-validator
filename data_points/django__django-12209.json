{
  "repo": "django/django",
  "instance_id": "django__django-12209",
  "base_commit": "5a68f024987e6d16c2626a31bf653a2edddea579",
  "patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -849,6 +849,7 @@ def _save_table(self, raw=False, cls=None, force_insert=False,\n         updated = False\n         # Skip an UPDATE when adding an instance and primary key has a default.\n         if (\n+            not raw and\n             not force_insert and\n             self._state.adding and\n             self._meta.pk.default and\n",
  "test_patch": "diff --git a/tests/serializers/models/data.py b/tests/serializers/models/data.py\n--- a/tests/serializers/models/data.py\n+++ b/tests/serializers/models/data.py\n@@ -4,6 +4,8 @@\n NULL values, where allowed.\n The basic idea is to have a model for each Django data type.\n \"\"\"\n+import uuid\n+\n from django.contrib.contenttypes.fields import (\n     GenericForeignKey, GenericRelation,\n )\n@@ -257,6 +259,10 @@ class UUIDData(models.Model):\n     data = models.UUIDField(primary_key=True)\n \n \n+class UUIDDefaultData(models.Model):\n+    data = models.UUIDField(primary_key=True, default=uuid.uuid4)\n+\n+\n class FKToUUID(models.Model):\n     data = models.ForeignKey(UUIDData, models.CASCADE)\n \ndiff --git a/tests/serializers/test_data.py b/tests/serializers/test_data.py\n--- a/tests/serializers/test_data.py\n+++ b/tests/serializers/test_data.py\n@@ -26,7 +26,7 @@\n     ModifyingSaveData, NullBooleanData, O2OData, PositiveBigIntegerData,\n     PositiveIntegerData, PositiveIntegerPKData, PositiveSmallIntegerData,\n     PositiveSmallIntegerPKData, SlugData, SlugPKData, SmallData, SmallPKData,\n-    Tag, TextData, TimeData, UniqueAnchor, UUIDData,\n+    Tag, TextData, TimeData, UniqueAnchor, UUIDData, UUIDDefaultData,\n )\n from .tests import register_tests\n \n@@ -351,6 +351,7 @@ def inherited_compare(testcase, pk, klass, data):\n     # (pk_obj, 790, XMLPKData, \"<foo></foo>\"),\n     (pk_obj, 791, UUIDData, uuid_obj),\n     (fk_obj, 792, FKToUUID, uuid_obj),\n+    (pk_obj, 793, UUIDDefaultData, uuid_obj),\n \n     (data_obj, 800, AutoNowDateTimeData, datetime.datetime(2006, 6, 16, 10, 42, 37)),\n     (data_obj, 810, ModifyingSaveData, 42),\n",
  "problem_statement": "Change in behaviour when saving a model instance with an explcit pk value if the pk field has a default\nDescription\n\t \n\t\t(last modified by Reupen Shah)\n\t \nConsider the following model:\nfrom uuid import uuid4\nfrom django.db import models\nclass Sample(models.Model):\n\tid = models.UUIDField(primary_key=True, default=uuid4)\n\tname = models.CharField(blank=True, max_length=100)\nIn Django 2.2 and earlier, the following commands would result in an INSERT followed by an UPDATE:\ns0 = Sample.objects.create()\ns1 = Sample(pk=s0.pk, name='Test 1')\ns1.save()\nHowever, in Django 3.0, this results in two INSERTs (naturally the second one fails). The behaviour also changes if default=uuid4 is removed from the id field.\nThis seems related to https://code.djangoproject.com/ticket/29260.\nThe change in behaviour also has the side effect of changing the behaviour of the loaddata management command when the fixture contains explicit pk values and the objects already exist (e.g. when loading the fixture multiple times).\nPerhaps the intention was to only change the behaviour if an explicit pk value was not set on the model instance being saved? (At least, that would be more backwards-compatible behaviour...)\n",
  "hints_text": "It looks like ​the logic in _save_table should not force an insert if an explicit pk value is provided. The logic should likely take pk_set into account if ( not pk_set and self._state.adding and self._meta.pk.default and self._meta.pk.default is not NOT_PROVIDED ): force_insert = True I'm surprised this was not caught by the suite if this breaks fixtures loading.\nI bisected the regression down to 85458e94e38c20e57939947ee515a1a53689659f if that helps.\nI'm afraid we'll have to revert 85458e94e38c20e57939947ee515a1a53689659f if we want this pattern to work because we assign field defaults on Model.__init__ without tracking whether or not they were generated from field defaults or not which makes both Sample() and Sample(pk=s0.pk) have pk_set=True in _save_table. Note that this limitation was mentioned in https://code.djangoproject.com/ticket/29260#comment:3 so another option could be to document that force_update must be used in this particular case. I feel like this would be good compromise. Regarding the fixture loading we should branch of raw ​which is passed by the serialization framework to disable the optimiation. Happy to provide a patch for whatever solution we choose. I think it's worth adjusting the feature given it does reduce the number of queries significantly when using primary key defaults and documenting it as a backward incompatible change that can be worked around by passing force_update but simply reverting the feature and reopening #29260 to target the next release is likely less trouble.\nIf it helps, I noticed this through the changed behaviour of loaddata in such cases (rather than the example code given). (I don't think we have any code that directly looks like the example.)\nReplying to Simon Charette: Note that this limitation was mentioned in https://code.djangoproject.com/ticket/29260#comment:3 so another option could be to document that force_update must be used in this particular case. I feel like this would be good compromise. Regarding the fixture loading we should branch of raw ​which is passed by the serialization framework to disable the optimiation. Happy to provide a patch for whatever solution we choose. I think it's worth adjusting the feature given it does reduce the number of queries significantly when using primary key defaults and documenting it as a backward incompatible change that can be worked around by passing force_update... I really like this proposition and I think it's fine to adjust the current fix and backport it to the Django 3.0.",
  "created_at": "2019-12-12T04:11:05Z",
  "version": "3.1",
  "FAIL_TO_PASS": "[\"partial(func, *args, **keywords) - new function with partial application\"]",
  "PASS_TO_PASS": "[]",
  "environment_setup_commit": "0668164b4ac93a5be79f5b87fae83c657124d9ab",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.618481",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}