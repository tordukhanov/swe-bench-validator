{
  "repo": "matplotlib/matplotlib",
  "instance_id": "matplotlib__matplotlib-25551",
  "base_commit": "5b85655c84fb2e149a548374d7259230577b6181",
  "patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3985,35 +3985,30 @@ def _get_view(self):\n         \"\"\"\n         Save information required to reproduce the current view.\n \n-        Called before a view is changed, such as during a pan or zoom\n-        initiated by the user. You may return any information you deem\n-        necessary to describe the view.\n+        This method is called before a view is changed, such as during a pan or zoom\n+        initiated by the user.  It returns an opaque object that describes the current\n+        view, in a format compatible with :meth:`_set_view`.\n \n-        .. note::\n-\n-            Intended to be overridden by new projection types, but if not, the\n-            default implementation saves the view limits. You *must* implement\n-            :meth:`_set_view` if you implement this method.\n+        The default implementation saves the view limits and autoscaling state.\n+        Subclasses may override this as needed, as long as :meth:`_set_view` is also\n+        adjusted accordingly.\n         \"\"\"\n-        xmin, xmax = self.get_xlim()\n-        ymin, ymax = self.get_ylim()\n-        return xmin, xmax, ymin, ymax\n+        return {\n+            \"xlim\": self.get_xlim(), \"autoscalex_on\": self.get_autoscalex_on(),\n+            \"ylim\": self.get_ylim(), \"autoscaley_on\": self.get_autoscaley_on(),\n+        }\n \n     def _set_view(self, view):\n         \"\"\"\n         Apply a previously saved view.\n \n-        Called when restoring a view, such as with the navigation buttons.\n+        This method is called when restoring a view (with the return value of\n+        :meth:`_get_view` as argument), such as with the navigation buttons.\n \n-        .. note::\n-\n-            Intended to be overridden by new projection types, but if not, the\n-            default implementation restores the view limits. You *must*\n-            implement :meth:`_get_view` if you implement this method.\n+        Subclasses that override :meth:`_get_view` also need to override this method\n+        accordingly.\n         \"\"\"\n-        xmin, xmax, ymin, ymax = view\n-        self.set_xlim((xmin, xmax))\n-        self.set_ylim((ymin, ymax))\n+        self.set(**view)\n \n     def _prepare_view_from_bbox(self, bbox, direction='in',\n                                 mode=None, twinx=False, twiny=False):\ndiff --git a/lib/mpl_toolkits/mplot3d/axes3d.py b/lib/mpl_toolkits/mplot3d/axes3d.py\n--- a/lib/mpl_toolkits/mplot3d/axes3d.py\n+++ b/lib/mpl_toolkits/mplot3d/axes3d.py\n@@ -1000,13 +1000,16 @@ def _button_release(self, event):\n \n     def _get_view(self):\n         # docstring inherited\n-        return (self.get_xlim(), self.get_ylim(), self.get_zlim(),\n-                self.elev, self.azim, self.roll)\n+        return {\n+            \"xlim\": self.get_xlim(), \"autoscalex_on\": self.get_autoscalex_on(),\n+            \"ylim\": self.get_ylim(), \"autoscaley_on\": self.get_autoscaley_on(),\n+            \"zlim\": self.get_zlim(), \"autoscalez_on\": self.get_autoscalez_on(),\n+        }, (self.elev, self.azim, self.roll)\n \n     def _set_view(self, view):\n         # docstring inherited\n-        xlim, ylim, zlim, elev, azim, roll = view\n-        self.set(xlim=xlim, ylim=ylim, zlim=zlim)\n+        props, (elev, azim, roll) = view\n+        self.set(**props)\n         self.elev = elev\n         self.azim = azim\n         self.roll = roll\n",
  "test_patch": "diff --git a/lib/matplotlib/tests/test_backend_bases.py b/lib/matplotlib/tests/test_backend_bases.py\n--- a/lib/matplotlib/tests/test_backend_bases.py\n+++ b/lib/matplotlib/tests/test_backend_bases.py\n@@ -280,6 +280,36 @@ def test_toolbar_zoompan():\n     assert ax.get_navigate_mode() == \"PAN\"\n \n \n+def test_toolbar_home_restores_autoscale():\n+    fig, ax = plt.subplots()\n+    ax.plot(range(11), range(11))\n+\n+    tb = NavigationToolbar2(fig.canvas)\n+    tb.zoom()\n+\n+    # Switch to log.\n+    KeyEvent(\"key_press_event\", fig.canvas, \"k\", 100, 100)._process()\n+    KeyEvent(\"key_press_event\", fig.canvas, \"l\", 100, 100)._process()\n+    assert ax.get_xlim() == ax.get_ylim() == (1, 10)  # Autolimits excluding 0.\n+    # Switch back to linear.\n+    KeyEvent(\"key_press_event\", fig.canvas, \"k\", 100, 100)._process()\n+    KeyEvent(\"key_press_event\", fig.canvas, \"l\", 100, 100)._process()\n+    assert ax.get_xlim() == ax.get_ylim() == (0, 10)  # Autolimits.\n+\n+    # Zoom in from (x, y) = (2, 2) to (5, 5).\n+    start, stop = ax.transData.transform([(2, 2), (5, 5)])\n+    MouseEvent(\"button_press_event\", fig.canvas, *start, MouseButton.LEFT)._process()\n+    MouseEvent(\"button_release_event\", fig.canvas, *stop, MouseButton.LEFT)._process()\n+    # Go back to home.\n+    KeyEvent(\"key_press_event\", fig.canvas, \"h\")._process()\n+\n+    assert ax.get_xlim() == ax.get_ylim() == (0, 10)\n+    # Switch to log.\n+    KeyEvent(\"key_press_event\", fig.canvas, \"k\", 100, 100)._process()\n+    KeyEvent(\"key_press_event\", fig.canvas, \"l\", 100, 100)._process()\n+    assert ax.get_xlim() == ax.get_ylim() == (1, 10)  # Autolimits excluding 0.\n+\n+\n @pytest.mark.parametrize(\n     \"backend\", ['svg', 'ps', 'pdf',\n                 pytest.param('pgf', marks=needs_pgf_xelatex)]\n",
  "problem_statement": "handling of zeros in log-scale changes irreversibly after user zoom\nmatplotlib 2.0b1 (but also present before that)\nCall e.g.\n\n```\nplt.plot(np.arange(10), np.arange(10)[::-1])\n```\n\nand type \"k\" and \"l\" to switch both axes to log scale.  The points at the two ends, where one of the coordinate is zero, are cropped out.  This has been the behavior for a long time and seems reasonable.\nNow come back to linear scale (\"k\", \"l\") and zoom in with the zoom tool to one of the ends of the segment, e.g. xlims=(-0.1, 0.4), ylims=(8.6, 9.1) or something similar.  Switching again to log scale now leads to a badly scaled plot, because the `x` axis now goes all the way to `10**-301` (float epsilon).\nEven this is not unreasonable: the user effectively set his own axes limits, rather than the autocomputed ones, and these limits are invalid in log scale.\nThe problem comes when you go back to the original limits (either \"back\" or \"h\" (\"home\")): even then, log-scale is broken (both axes to to `10**-301` instead of cropping the extremities); in fact, it seems impossible to restore the original behavior of autocomputed axes limits.\n\n",
  "hints_text": "This seems to have improved; \"back\" or \"h\" both work reasonably well.\nUh, no?  To me the same issue remains?\nIt took me a while to understand the issue. The main point seems to be that after messing around with zooming and linear/log changes you *can* press \"home\" and you will be back at the original view for linear scale. But when you *then* press the \"l\" key *again*, the view is distorted. \nThis issue has been marked \"inactive\" because it has been 365 days since the last comment. If this issue is still present in recent Matplotlib releases, or the feature request is still wanted, please leave a comment and this label will be removed. If there are no updates in another 30 days, this issue will be automatically closed, but you are free to re-open or create a new issue if needed. We value issue reports, and this procedure is meant to help us resurface and prioritize issues that have not been addressed yet, not make them disappear.  Thanks for your help!",
  "created_at": "2023-03-26T13:51:14Z",
  "version": "3.7",
  "FAIL_TO_PASS": "[\"lib/matplotlib/tests/test_backend_bases.py::test_toolbar_home_restores_autoscale\"]",
  "PASS_TO_PASS": "[\"lib/matplotlib/tests/test_backend_bases.py::test_uses_per_path\", \"lib/matplotlib/tests/test_backend_bases.py::test_canvas_ctor\", \"lib/matplotlib/tests/test_backend_bases.py::test_get_default_filename\", \"lib/matplotlib/tests/test_backend_bases.py::test_canvas_change\", \"lib/matplotlib/tests/test_backend_bases.py::test_non_gui_warning\", \"lib/matplotlib/tests/test_backend_bases.py::test_grab_clear\", \"lib/matplotlib/tests/test_backend_bases.py::test_location_event_position[42-24]\", \"lib/matplotlib/tests/test_backend_bases.py::test_location_event_position[None-42]\", \"lib/matplotlib/tests/test_backend_bases.py::test_location_event_position[None-None]\", \"lib/matplotlib/tests/test_backend_bases.py::test_location_event_position[200-100.01]\", \"lib/matplotlib/tests/test_backend_bases.py::test_location_event_position[205.75-2.0]\", \"lib/matplotlib/tests/test_backend_bases.py::test_pick\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_zoom\", \"lib/matplotlib/tests/test_backend_bases.py::test_widgetlock_zoompan\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_colorbar[zoom-1-expected0-vertical-imshow]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_colorbar[zoom-1-expected0-vertical-contourf]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_colorbar[zoom-1-expected0-horizontal-imshow]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_colorbar[zoom-1-expected0-horizontal-contourf]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_colorbar[zoom-3-expected1-vertical-imshow]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_colorbar[zoom-3-expected1-vertical-contourf]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_colorbar[zoom-3-expected1-horizontal-imshow]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_colorbar[zoom-3-expected1-horizontal-contourf]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_colorbar[pan-1-expected2-vertical-imshow]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_colorbar[pan-1-expected2-vertical-contourf]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_colorbar[pan-1-expected2-horizontal-imshow]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_colorbar[pan-1-expected2-horizontal-contourf]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_colorbar[pan-3-expected3-vertical-imshow]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_colorbar[pan-3-expected3-vertical-contourf]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_colorbar[pan-3-expected3-horizontal-imshow]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_colorbar[pan-3-expected3-horizontal-contourf]\", \"lib/matplotlib/tests/test_backend_bases.py::test_toolbar_zoompan\", \"lib/matplotlib/tests/test_backend_bases.py::test_draw[svg]\", \"lib/matplotlib/tests/test_backend_bases.py::test_draw[ps]\", \"lib/matplotlib/tests/test_backend_bases.py::test_draw[pdf]\", \"lib/matplotlib/tests/test_backend_bases.py::test_draw[pgf]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[None-mouseend0-expectedxlim0-expectedylim0]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[None-mouseend1-expectedxlim1-expectedylim1]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[None-mouseend2-expectedxlim2-expectedylim2]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[None-mouseend3-expectedxlim3-expectedylim3]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[None-mouseend4-expectedxlim4-expectedylim4]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[None-mouseend5-expectedxlim5-expectedylim5]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[None-mouseend6-expectedxlim6-expectedylim6]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[None-mouseend7-expectedxlim7-expectedylim7]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[shift-mouseend8-expectedxlim8-expectedylim8]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[shift-mouseend9-expectedxlim9-expectedylim9]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[shift-mouseend10-expectedxlim10-expectedylim10]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[shift-mouseend11-expectedxlim11-expectedylim11]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[shift-mouseend12-expectedxlim12-expectedylim12]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[shift-mouseend13-expectedxlim13-expectedylim13]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[x-mouseend14-expectedxlim14-expectedylim14]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[y-mouseend15-expectedxlim15-expectedylim15]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[control-mouseend16-expectedxlim16-expectedylim16]\", \"lib/matplotlib/tests/test_backend_bases.py::test_interactive_pan[control-mouseend17-expectedxlim17-expectedylim17]\", \"lib/matplotlib/tests/test_backend_bases.py::test_toolmanager_remove\", \"lib/matplotlib/tests/test_backend_bases.py::test_toolmanager_get_tool\", \"lib/matplotlib/tests/test_backend_bases.py::test_toolmanager_update_keymap\"]",
  "environment_setup_commit": "0849036fd992a2dd133a0cffc3f84f58ccf1840f",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.822624",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}