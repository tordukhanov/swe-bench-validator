{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-22402",
  "base_commit": "3241ed16de45c67fa5ec50ecd0b77a712b1ae5f9",
  "patch": "diff --git a/sympy/functions/elementary/complexes.py b/sympy/functions/elementary/complexes.py\n--- a/sympy/functions/elementary/complexes.py\n+++ b/sympy/functions/elementary/complexes.py\n@@ -689,15 +689,20 @@ def _eval_rewrite_as_conjugate(self, arg, **kwargs):\n \n class arg(Function):\n     \"\"\"\n-    returns the argument (in radians) of a complex number.  The argument is\n+    returns the argument (in radians) of a complex number. The argument is\n     evaluated in consistent convention with atan2 where the branch-cut is\n     taken along the negative real axis and arg(z) is in the interval\n-    (-pi,pi].  For a positive number, the argument is always 0.\n+    (-pi,pi]. For a positive number, the argument is always 0; the\n+    argument of a negative number is pi; and the argument of 0\n+    is undefined and returns nan. So the ``arg`` function will never nest\n+    greater than 3 levels since at the 4th application, the result must be\n+    nan; for a real number, nan is returned on the 3rd application.\n \n     Examples\n     ========\n \n-    >>> from sympy import arg, I, sqrt\n+    >>> from sympy import arg, I, sqrt, Dummy\n+    >>> from sympy.abc import x\n     >>> arg(2.0)\n     0\n     >>> arg(I)\n@@ -710,6 +715,11 @@ class arg(Function):\n     atan(3/4)\n     >>> arg(0.8 + 0.6*I)\n     0.643501108793284\n+    >>> arg(arg(arg(arg(x))))\n+    nan\n+    >>> real = Dummy(real=True)\n+    >>> arg(arg(arg(real)))\n+    nan\n \n     Parameters\n     ==========\n@@ -732,6 +742,16 @@ class arg(Function):\n \n     @classmethod\n     def eval(cls, arg):\n+        a = arg\n+        for i in range(3):\n+            if isinstance(a, cls):\n+                a = a.args[0]\n+            else:\n+                if i == 2 and a.is_extended_real:\n+                    return S.NaN\n+                break\n+        else:\n+            return S.NaN\n         if isinstance(arg, exp_polar):\n             return periodic_argument(arg, oo)\n         if not arg.is_Atom:\n",
  "test_patch": "diff --git a/sympy/functions/elementary/tests/test_complexes.py b/sympy/functions/elementary/tests/test_complexes.py\n--- a/sympy/functions/elementary/tests/test_complexes.py\n+++ b/sympy/functions/elementary/tests/test_complexes.py\n@@ -608,16 +608,25 @@ def test_arg():\n     f = Function('f')\n     assert not arg(f(0) + I*f(1)).atoms(re)\n \n+    # check nesting\n     x = Symbol('x')\n+    assert arg(arg(arg(x))) is not S.NaN\n+    assert arg(arg(arg(arg(x)))) is S.NaN\n+    r = Symbol('r', extended_real=True)\n+    assert arg(arg(r)) is not S.NaN\n+    assert arg(arg(arg(r))) is S.NaN\n+\n     p = Function('p', extended_positive=True)\n     assert arg(p(x)) == 0\n     assert arg((3 + I)*p(x)) == arg(3  + I)\n \n     p = Symbol('p', positive=True)\n     assert arg(p) == 0\n+    assert arg(p*I) == pi/2\n \n     n = Symbol('n', negative=True)\n     assert arg(n) == pi\n+    assert arg(n*I) == -pi/2\n \n     x = Symbol('x')\n     assert conjugate(arg(x)) == arg(x)\n",
  "problem_statement": "can `arg` denest?\n```python\r\n>>> arg(arg(x))\r\narg(arg(x))  <-- should it just be arg(x)?\r\n>>> arg(x).is_real\r\nTrue\r\n```\n",
  "hints_text": "It can't denest:\r\n```python\r\nIn [4]: arg(I)\r\nOut[4]: \r\nπ\r\n─\r\n2\r\n\r\nIn [5]: arg(arg(I))\r\nOut[5]: 0\r\n```\r\nAlso it's different for positive and negative inputs:\r\n```python\r\nIn [8]: arg(arg(I))\r\nOut[8]: 0\r\n\r\nIn [9]: arg(arg(-I))\r\nOut[9]: π\r\n```\nCan the maximum level before stability be 2?\r\n```python\r\n>>> arg(arg(arg(x)))\r\narg(arg(arg(x)))\r\n```\n```python\r\nIn [8]: arg(arg(I))\r\nOut[8]: 0\r\n\r\nIn [9]: arg(arg(-I))\r\nOut[9]: π\r\n\r\nIn [10]: arg(arg(arg(I)))\r\nOut[10]: nan\r\n\r\nIn [11]: arg(arg(arg(-I)))\r\nOut[11]: 0\r\n```\nI suppose that once we have 4 args we're guaranteed a nan but that doesn't seem like an especially useful simplification:\r\n```python\r\nIn [13]: arg(arg(arg(arg(-I))))\r\nOut[13]: nan\r\n```\nok - a low-priority limit of 4",
  "created_at": "2021-11-01T09:15:12Z",
  "version": "1.10",
  "FAIL_TO_PASS": "[\"test_arg\"]",
  "PASS_TO_PASS": "[\"test_re\", \"test_im\", \"test_sign\", \"test_as_real_imag\", \"test_Abs\", \"test_Abs_rewrite\", \"test_Abs_real\", \"test_Abs_properties\", \"test_abs\", \"test_arg_rewrite\", \"test_adjoint\", \"test_conjugate\", \"test_conjugate_transpose\", \"test_transpose\", \"test_polarify\", \"test_unpolarify\", \"test_issue_4035\", \"test_issue_3206\", \"test_issue_4754_derivative_conjugate\", \"test_derivatives_issue_4757\", \"test_issue_11413\", \"test_periodic_argument\", \"test_principal_branch\", \"test_issue_14216\", \"test_issue_14238\", \"test_issue_22189\", \"test_zero_assumptions\"]",
  "environment_setup_commit": "fd40404e72921b9e52a5f9582246e4a6cd96c431",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.149570",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}