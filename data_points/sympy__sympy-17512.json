{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-17512",
  "base_commit": "3d8a56298c71a67dedb0472f94e3746d04ddd117",
  "patch": "diff --git a/sympy/sets/fancysets.py b/sympy/sets/fancysets.py\n--- a/sympy/sets/fancysets.py\n+++ b/sympy/sets/fancysets.py\n@@ -4,11 +4,11 @@\n from sympy.core.compatibility import as_int, with_metaclass, range, PY3\n from sympy.core.expr import Expr\n from sympy.core.function import Lambda\n+from sympy.core.numbers import oo, Integer\n from sympy.core.logic import fuzzy_or\n-from sympy.core.numbers import oo\n from sympy.core.relational import Eq\n from sympy.core.singleton import Singleton, S\n-from sympy.core.symbol import Dummy, symbols\n+from sympy.core.symbol import Dummy, symbols, Symbol\n from sympy.core.sympify import _sympify, sympify, converter\n from sympy.logic.boolalg import And\n from sympy.sets.sets import (Set, Interval, Union, FiniteSet,\n@@ -509,6 +509,26 @@ class Range(Set):\n         >>> Range(3).intersect(Range(4, oo))\n         EmptySet()\n \n+    Range will accept symbolic arguments but has very limited support\n+    for doing anything other than displaying the Range:\n+\n+        >>> from sympy import Symbol, pprint\n+        >>> from sympy.abc import i, j, k\n+        >>> Range(i, j, k).start\n+        i\n+        >>> Range(i, j, k).inf\n+        Traceback (most recent call last):\n+        ...\n+        ValueError: invalid method for symbolic range\n+\n+    Better success will be had when using integer symbols:\n+\n+        >>> n = Symbol('n', integer=True)\n+        >>> r = Range(n, n + 20, 3)\n+        >>> r.inf\n+        n\n+        >>> pprint(r)\n+        {n, n + 3, ..., n + 17}\n     \"\"\"\n \n     is_iterable = True\n@@ -517,7 +537,8 @@ def __new__(cls, *args):\n         from sympy.functions.elementary.integers import ceiling\n         if len(args) == 1:\n             if isinstance(args[0], range if PY3 else xrange):\n-                args = args[0].__reduce__()[1]  # use pickle method\n+                raise TypeError(\n+                    'use sympify(%s) to convert range to Range' % args[0])\n \n         # expand range\n         slc = slice(*args)\n@@ -527,42 +548,53 @@ def __new__(cls, *args):\n \n         start, stop, step = slc.start or 0, slc.stop, slc.step or 1\n         try:\n-            start, stop, step = [\n-                w if w in [S.NegativeInfinity, S.Infinity]\n-                else sympify(as_int(w))\n-                for w in (start, stop, step)]\n+            ok = []\n+            for w in (start, stop, step):\n+                w = sympify(w)\n+                if w in [S.NegativeInfinity, S.Infinity] or (\n+                        w.has(Symbol) and w.is_integer != False):\n+                    ok.append(w)\n+                elif not w.is_Integer:\n+                    raise ValueError\n+                else:\n+                    ok.append(w)\n         except ValueError:\n             raise ValueError(filldedent('''\n     Finite arguments to Range must be integers; `imageset` can define\n     other cases, e.g. use `imageset(i, i/10, Range(3))` to give\n     [0, 1/10, 1/5].'''))\n+        start, stop, step = ok\n \n-        if not step.is_Integer:\n-            raise ValueError(filldedent('''\n-    Ranges must have a literal integer step.'''))\n-\n-        if all(i.is_infinite for i in  (start, stop)):\n+        null = False\n+        if any(i.has(Symbol) for i in (start, stop, step)):\n             if start == stop:\n-                # canonical null handled below\n-                start = stop = S.One\n+                null = True\n             else:\n+                end = stop\n+        elif start.is_infinite:\n+            span = step*(stop - start)\n+            if span is S.NaN or span <= 0:\n+                null = True\n+            elif step.is_Integer and stop.is_infinite and abs(step) != 1:\n                 raise ValueError(filldedent('''\n-    Either the start or end value of the Range must be finite.'''))\n-\n-        if start.is_infinite:\n-            if step*(stop - start) < 0:\n-                start = stop = S.One\n+                    Step size must be %s in this case.''' % (1 if step > 0 else -1)))\n             else:\n                 end = stop\n-        if not start.is_infinite:\n-            ref = start if start.is_finite else stop\n-            n = ceiling((stop - ref)/step)\n+        else:\n+            oostep = step.is_infinite\n+            if oostep:\n+                step = S.One if step > 0 else S.NegativeOne\n+            n = ceiling((stop - start)/step)\n             if n <= 0:\n-                # null Range\n-                start = end = S.Zero\n-                step = S.One\n+                null = True\n+            elif oostep:\n+                end = start + 1\n+                step = S.One  # make it a canonical single step\n             else:\n-                end = ref + n*step\n+                end = start + n*step\n+        if null:\n+            start = end = S.Zero\n+            step = S.One\n         return Basic.__new__(cls, start, end, step)\n \n     start = property(lambda self: self.args[0])\n@@ -580,6 +612,8 @@ def reversed(self):\n         >>> Range(10).reversed\n         Range(9, -1, -1)\n         \"\"\"\n+        if self.has(Symbol):\n+            _ = self.size  # validate\n         if not self:\n             return self\n         return self.func(\n@@ -592,12 +626,19 @@ def _contains(self, other):\n             return S.false\n         if not other.is_integer:\n             return other.is_integer\n+        if self.has(Symbol):\n+            try:\n+                _ = self.size  # validate\n+            except ValueError:\n+                return\n         ref = self.start if self.start.is_finite else self.stop\n         if (ref - other) % self.step:  # off sequence\n             return S.false\n         return _sympify(other >= self.inf and other <= self.sup)\n \n     def __iter__(self):\n+        if self.has(Symbol):\n+            _ = self.size  # validate\n         if self.start in [S.NegativeInfinity, S.Infinity]:\n             raise ValueError(\"Cannot iterate over Range with infinite start\")\n         elif self:\n@@ -612,20 +653,23 @@ def __iter__(self):\n                 i += step\n \n     def __len__(self):\n-        if not self:\n-            return 0\n-        dif = self.stop - self.start\n-        if dif.is_infinite:\n-            raise ValueError(\n-                \"Use .size to get the length of an infinite Range\")\n-        return abs(dif//self.step)\n+        rv = self.size\n+        if rv is S.Infinity:\n+            raise ValueError('Use .size to get the length of an infinite Range')\n+        return int(rv)\n \n     @property\n     def size(self):\n-        try:\n-            return _sympify(len(self))\n-        except ValueError:\n+        if not self:\n+            return S.Zero\n+        dif = self.stop - self.start\n+        if self.has(Symbol):\n+            if dif.has(Symbol) or self.step.has(Symbol) or (\n+                    not self.start.is_integer and not self.stop.is_integer):\n+                raise ValueError('invalid method for symbolic range')\n+        if dif.is_infinite:\n             return S.Infinity\n+        return Integer(abs(dif//self.step))\n \n     def __nonzero__(self):\n         return self.start != self.stop\n@@ -642,7 +686,7 @@ def __getitem__(self, i):\n         ambiguous = \"cannot unambiguously re-stride from the end \" + \\\n             \"with an infinite value\"\n         if isinstance(i, slice):\n-            if self.size.is_finite:\n+            if self.size.is_finite:  # validates, too\n                 start, stop, step = i.indices(self.size)\n                 n = ceiling((stop - start)/step)\n                 if n <= 0:\n@@ -740,9 +784,24 @@ def __getitem__(self, i):\n             if not self:\n                 raise IndexError('Range index out of range')\n             if i == 0:\n+                if self.start.is_infinite:\n+                    raise ValueError(ooslice)\n+                if self.has(Symbol):\n+                    if (self.stop > self.start) == self.step.is_positive and self.step.is_positive is not None:\n+                        pass\n+                    else:\n+                        _ = self.size  # validate\n                 return self.start\n-            if i == -1 or i is S.Infinity:\n-                return self.stop - self.step\n+            if i == -1:\n+                if self.stop.is_infinite:\n+                    raise ValueError(ooslice)\n+                n = self.stop - self.step\n+                if n.is_Integer or (\n+                        n.is_integer and (\n+                            (n - self.start).is_nonnegative ==\n+                            self.step.is_positive)):\n+                    return n\n+            _ = self.size  # validate\n             rv = (self.stop if i < 0 else self.start) + i*self.step\n             if rv.is_infinite:\n                 raise ValueError(ooslice)\n@@ -754,6 +813,12 @@ def __getitem__(self, i):\n     def _inf(self):\n         if not self:\n             raise NotImplementedError\n+        if self.has(Symbol):\n+            if self.step.is_positive:\n+                return self[0]\n+            elif self.step.is_negative:\n+                return self[-1]\n+            _ = self.size  # validate\n         if self.step > 0:\n             return self.start\n         else:\n@@ -763,6 +828,12 @@ def _inf(self):\n     def _sup(self):\n         if not self:\n             raise NotImplementedError\n+        if self.has(Symbol):\n+            if self.step.is_positive:\n+                return self[-1]\n+            elif self.step.is_negative:\n+                return self[0]\n+            _ = self.size  # validate\n         if self.step > 0:\n             return self.stop - self.step\n         else:\n@@ -775,17 +846,17 @@ def _boundary(self):\n     def as_relational(self, x):\n         \"\"\"Rewrite a Range in terms of equalities and logic operators. \"\"\"\n         from sympy.functions.elementary.integers import floor\n-        i = (x - (self.inf if self.inf.is_finite else self.sup))/self.step\n         return And(\n-            Eq(i, floor(i)),\n+            Eq(x, floor(x)),\n             x >= self.inf if self.inf in self else x > self.inf,\n             x <= self.sup if self.sup in self else x < self.sup)\n \n \n if PY3:\n-    converter[range] = Range\n+    converter[range] = lambda r: Range(r.start, r.stop, r.step)\n else:\n-    converter[xrange] = Range\n+    converter[xrange] = lambda r: Range(*r.__reduce__()[1])\n+\n \n def normalize_theta_set(theta):\n     \"\"\"\n",
  "test_patch": "diff --git a/sympy/sets/tests/test_fancysets.py b/sympy/sets/tests/test_fancysets.py\n--- a/sympy/sets/tests/test_fancysets.py\n+++ b/sympy/sets/tests/test_fancysets.py\n@@ -189,12 +189,14 @@ def test_Range_set():\n     assert Range(-oo, 1, -1) == empty\n     assert Range(1, oo, -1) == empty\n     assert Range(1, -oo, 1) == empty\n-    raises(ValueError, lambda: Range(1, 4, oo))\n-    raises(ValueError, lambda: Range(-oo, oo))\n-    raises(ValueError, lambda: Range(oo, -oo, -1))\n+    assert Range(1, -4, oo) == empty\n+    assert Range(1, -4, -oo) == Range(1, 2)\n+    assert Range(1, 4, oo) == Range(1, 2)\n+    assert Range(-oo, oo).size == oo\n+    assert Range(oo, -oo, -1).size == oo\n     raises(ValueError, lambda: Range(-oo, oo, 2))\n-    raises(ValueError, lambda: Range(0, pi, 1))\n-    raises(ValueError, lambda: Range(1, 10, 0))\n+    raises(ValueError, lambda: Range(x, pi, y))\n+    raises(ValueError, lambda: Range(x, y, 0))\n \n     assert 5 in Range(0, oo, 5)\n     assert -5 in Range(-oo, 0, 5)\n@@ -204,13 +206,11 @@ def test_Range_set():\n     u = symbols('u', integer=None)\n     assert Range(oo).contains(u) is not False\n     inf = symbols('inf', infinite=True)\n-    assert inf not in Range(oo)\n-    inf = symbols('inf', infinite=True)\n-    assert inf not in Range(oo)\n-    assert Range(0, oo, 2)[-1] == oo\n+    assert inf not in Range(-oo, oo)\n+    raises(ValueError, lambda: Range(0, oo, 2)[-1])\n+    raises(ValueError, lambda: Range(0, -oo, -2)[-1])\n     assert Range(-oo, 1, 1)[-1] is S.Zero\n     assert Range(oo, 1, -1)[-1] == 2\n-    assert Range(0, -oo, -2)[-1] == -oo\n     assert Range(1, 10, 1)[-1] == 9\n     assert all(i.is_Integer for i in Range(0, -1, 1))\n \n@@ -222,7 +222,6 @@ def test_Range_set():\n     assert Range(-1, 10, 1).intersect(S.Naturals) == Range(1, 10, 1)\n     assert Range(-1, 10, 1).intersect(S.Naturals0) == Range(0, 10, 1)\n \n-\n     # test slicing\n     assert Range(1, 10, 1)[5] == 6\n     assert Range(1, 12, 2)[5] == 11\n@@ -262,6 +261,7 @@ def test_Range_set():\n     raises(ValueError, lambda: Range(oo, 0, -2)[:1:-1])\n \n     # test empty Range\n+    assert Range(x, x, y) == empty\n     assert empty.reversed == empty\n     assert 0 not in empty\n     assert list(empty) == []\n@@ -305,16 +305,67 @@ def test_Range_set():\n     else:\n         builtin_range = xrange\n \n-    assert Range(builtin_range(10)) == Range(10)\n-    assert Range(builtin_range(1, 10)) == Range(1, 10)\n-    assert Range(builtin_range(1, 10, 2)) == Range(1, 10, 2)\n+    raises(TypeError, lambda: Range(builtin_range(1)))\n+    assert S(builtin_range(10)) == Range(10)\n     if PY3:\n-        assert Range(builtin_range(1000000000000)) == \\\n+        assert S(builtin_range(1000000000000)) == \\\n             Range(1000000000000)\n \n     # test Range.as_relational\n-    assert Range(1, 4).as_relational(x) == (x >= 1) & (x <= 3) & Eq(x - 1, floor(x) - 1)\n-    assert Range(oo, 1, -2).as_relational(x) == (x >= 3) & (x < oo) & Eq((3 - x)/2, floor((3 - x)/2))\n+    assert Range(1, 4).as_relational(x) == (x >= 1) & (x <= 3) & Eq(x, floor(x))\n+    assert Range(oo, 1, -2).as_relational(x) == (x >= 3) & (x < oo) & Eq(x, floor(x))\n+\n+    # symbolic Range\n+    sr = Range(x, y, t)\n+    i = Symbol('i', integer=True)\n+    ip = Symbol('i', integer=True, positive=True)\n+    ir = Range(i, i + 20, 2)\n+    # args\n+    assert sr.args == (x, y, t)\n+    assert ir.args == (i, i + 20, 2)\n+    # reversed\n+    raises(ValueError, lambda: sr.reversed)\n+    assert ir.reversed == Range(i + 18, i - 2, -2)\n+    # contains\n+    assert inf not in sr\n+    assert inf not in ir\n+    assert .1 not in sr\n+    assert .1 not in ir\n+    assert i + 1 not in ir\n+    assert i + 2 in ir\n+    raises(TypeError, lambda: 1 in sr)  # XXX is this what contains is supposed to do?\n+    # iter\n+    raises(ValueError, lambda: next(iter(sr)))\n+    assert next(iter(ir)) == i\n+    assert sr.intersect(S.Integers) == sr\n+    assert sr.intersect(FiniteSet(x)) == Intersection({x}, sr)\n+    raises(ValueError, lambda: sr[:2])\n+    raises(ValueError, lambda: sr[0])\n+    raises(ValueError, lambda: sr.as_relational(x))\n+    # len\n+    assert len(ir) == ir.size == 10\n+    raises(ValueError, lambda: len(sr))\n+    raises(ValueError, lambda: sr.size)\n+    # bool\n+    assert bool(ir) == bool(sr) == True\n+    # getitem\n+    raises(ValueError, lambda: sr[0])\n+    raises(ValueError, lambda: sr[-1])\n+    raises(ValueError, lambda: sr[:2])\n+    assert ir[:2] == Range(i, i + 4, 2)\n+    assert ir[0] == i\n+    assert ir[-2] == i + 16\n+    assert ir[-1] == i + 18\n+    raises(ValueError, lambda: Range(i)[-1])\n+    assert Range(ip)[-1] == ip - 1\n+    assert ir.inf == i\n+    assert ir.sup == i + 18\n+    assert Range(ip).inf == 0\n+    assert Range(ip).sup == ip - 1\n+    raises(ValueError, lambda: Range(i).inf)\n+    raises(ValueError, lambda: sr.as_relational(x))\n+    assert ir.as_relational(x) == (\n+        x >= i) & Eq(x, floor(x)) & (x <= i + 18)\n \n \n def test_range_range_intersection():\n",
  "problem_statement": "Range(range(10)) shouldn't be allowed\nThis comes from working on #17280.\r\n\r\nRange converts a range into a Range and this is tested behaviour:\r\n```julia\r\nIn [1]: Range(range(10))                                                                                                          \r\nOut[1]: {0, 1, …, 9}\r\n```\r\nI don't think that this should be allowed though. SymPy objects should not act as converters beyond sympification. In this particular example the sympified object is `Range(10)` but passing that raises:\r\n```julia\r\nIn [2]: Range(Range(10))\r\n...\r\nValueError: \r\nFinite arguments to Range must be integers; `imageset` can define\r\nother cases, e.g. use `imageset(i, i/10, Range(3))` to give [0, 1/10,\r\n1/5].\r\n```\r\nThis is because `Range(10)` is not a valid object in the .args of Range. I think it's reasonable that simpify(range) works and that should be sufficient to use range in place of Range because of automatic sympification.\r\n\r\nThe reason I don't think `Range(range(10))` is reasonable is that that *should* imply\r\n```python\r\nRange(range(10), evaluate=False).args = (range(10),)\r\n```\r\nbut that would give a nonsensical Range object whose `.start` attribute is `range(10)`.\r\n\r\nI notice also that automatic sympification doesn't happen in ImageSet which should be fixed:\r\n```julia\r\nIn [8]: ImageSet(Lambda(x, x**2), Range(10))                                                                                      \r\nOut[8]: \r\n⎧ 2                   ⎫\r\n⎨x  | x ∊ {0, 1, …, 9}⎬\r\n⎩                     ⎭\r\n\r\nIn [9]: ImageSet(Lambda(x, x**2), range(10))                                                                                      \r\nOut[9]: \r\n⎧ 2                   ⎫\r\n⎨x  | x ∊ range(0, 10)⎬\r\n⎩                     ⎭\r\n```\r\nImageSet should sympify its arguments and should raise if the 2nd argument is not a Set (after sympification).\r\n\n",
  "hints_text": "",
  "created_at": "2019-08-25T17:17:51Z",
  "version": "1.5",
  "FAIL_TO_PASS": "[\"test_Range_set\"]",
  "PASS_TO_PASS": "[\"test_naturals\", \"test_naturals0\", \"test_integers\", \"test_ImageSet\", \"test_image_is_ImageSet\", \"test_halfcircle\", \"test_ImageSet_iterator_not_injective\", \"test_inf_Range_len\", \"test_range_range_intersection\", \"test_range_interval_intersection\", \"test_Integers_eval_imageset\", \"test_Range_eval_imageset\", \"test_fun\", \"test_Reals\", \"test_Complex\", \"test_intersections\", \"test_infinitely_indexed_set_1\", \"test_infinitely_indexed_set_2\", \"test_imageset_intersect_real\", \"test_imageset_intersect_interval\", \"test_infinitely_indexed_set_3\", \"test_ImageSet_simplification\", \"test_ImageSet_contains\", \"test_ComplexRegion_contains\", \"test_ComplexRegion_intersect\", \"test_ComplexRegion_union\", \"test_ComplexRegion_from_real\", \"test_ComplexRegion_measure\", \"test_normalize_theta_set\", \"test_ComplexRegion_FiniteSet\", \"test_union_RealSubSet\", \"test_issue_9980\", \"test_issue_11732\", \"test_issue_11730\", \"test_issue_11938\", \"test_issue_11914\", \"test_issue_9543\", \"test_issue_16871\", \"test_no_mod_on_imaginary\", \"test_Rationals\"]",
  "environment_setup_commit": "70381f282f2d9d039da860e391fe51649df2779d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.116697",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}