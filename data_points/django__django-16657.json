{
  "repo": "django/django",
  "instance_id": "django__django-16657",
  "base_commit": "d2b688b966f5d30414899549412d370e1317ddb8",
  "patch": "diff --git a/django/db/backends/mysql/features.py b/django/db/backends/mysql/features.py\n--- a/django/db/backends/mysql/features.py\n+++ b/django/db/backends/mysql/features.py\n@@ -108,6 +108,7 @@ def django_test_skips(self):\n                 \"update.tests.AdvancedTests.\"\n                 \"test_update_ordered_by_inline_m2m_annotation\",\n                 \"update.tests.AdvancedTests.test_update_ordered_by_m2m_annotation\",\n+                \"update.tests.AdvancedTests.test_update_ordered_by_m2m_annotation_desc\",\n             },\n         }\n         if self.connection.mysql_is_mariadb and (\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1190,11 +1190,18 @@ def update(self, **kwargs):\n         # Inline annotations in order_by(), if possible.\n         new_order_by = []\n         for col in query.order_by:\n-            if annotation := query.annotations.get(col):\n+            alias = col\n+            descending = False\n+            if isinstance(alias, str) and alias.startswith(\"-\"):\n+                alias = alias.removeprefix(\"-\")\n+                descending = True\n+            if annotation := query.annotations.get(alias):\n                 if getattr(annotation, \"contains_aggregate\", False):\n                     raise exceptions.FieldError(\n                         f\"Cannot update when ordering by an aggregate: {annotation}\"\n                     )\n+                if descending:\n+                    annotation = annotation.desc()\n                 new_order_by.append(annotation)\n             else:\n                 new_order_by.append(col)\n",
  "test_patch": "diff --git a/tests/update/tests.py b/tests/update/tests.py\n--- a/tests/update/tests.py\n+++ b/tests/update/tests.py\n@@ -249,6 +249,13 @@ def test_update_ordered_by_m2m_annotation(self):\n         Bar.objects.annotate(abs_id=Abs(\"m2m_foo\")).order_by(\"abs_id\").update(x=3)\n         self.assertEqual(Bar.objects.get().x, 3)\n \n+    def test_update_ordered_by_m2m_annotation_desc(self):\n+        foo = Foo.objects.create(target=\"test\")\n+        Bar.objects.create(foo=foo)\n+\n+        Bar.objects.annotate(abs_id=Abs(\"m2m_foo\")).order_by(\"-abs_id\").update(x=4)\n+        self.assertEqual(Bar.objects.get().x, 4)\n+\n     def test_update_negated_f(self):\n         DataPoint.objects.update(is_active=~F(\"is_active\"))\n         self.assertCountEqual(\n@@ -309,6 +316,14 @@ def test_order_by_update_on_unique_constraint_annotation(self):\n         )\n         self.assertEqual(updated, 2)\n \n+    def test_order_by_update_on_unique_constraint_annotation_desc(self):\n+        updated = (\n+            UniqueNumber.objects.annotate(number_annotation=F(\"number\"))\n+            .order_by(\"-number_annotation\")\n+            .update(number=F(\"number\") + 1)\n+        )\n+        self.assertEqual(updated, 2)\n+\n     def test_order_by_update_on_parent_unique_constraint(self):\n         # Ordering by inherited fields is omitted because joined fields cannot\n         # be used in the ORDER BY clause.\n",
  "problem_statement": "QuerySet.update() on querysets in descending order by annotations.\nDescription\n\t\nWhen I execute \nModel.objects.annotate(message_length=Length('message')).order_by('-message_length').update(text=\"Can I come on board?\")\nI get the error \nFieldError: Cannot resolve keyword 'message_length' into field. Choices are: message, id, text, x\nbecause the code ignores the descending case.\n",
  "hints_text": "",
  "created_at": "2023-03-16T17:01:14Z",
  "version": "5.0",
  "FAIL_TO_PASS": "[\"test_update_ordered_by_m2m_annotation_desc (update.tests.AdvancedTests.test_update_ordered_by_m2m_annotation_desc)\"]",
  "PASS_TO_PASS": "[\"Objects are updated by first filtering the candidates into a queryset\", \"In the rare case you want to update every instance of a model, update()\", \"Update of a queryset that's been annotated and involves multiple tables.\", \"Update of a queryset that's been annotated.\", \"Foreign key fields can also be updated, although you can only update\", \"test_update_m2m_field (update.tests.AdvancedTests.test_update_m2m_field)\", \"Multiple fields can be updated at once\", \"We can update multiple objects at once.\", \"test_update_negated_f (update.tests.AdvancedTests.test_update_negated_f)\", \"test_update_negated_f_conditional_annotation (update.tests.AdvancedTests.test_update_negated_f_conditional_annotation)\", \"test_update_ordered_by_inline_m2m_annotation (update.tests.AdvancedTests.test_update_ordered_by_inline_m2m_annotation)\", \"test_update_ordered_by_m2m_aggregation_annotation (update.tests.AdvancedTests.test_update_ordered_by_m2m_aggregation_annotation)\", \"test_update_ordered_by_m2m_annotation (update.tests.AdvancedTests.test_update_ordered_by_m2m_annotation)\", \"Update of an FK field which specifies a to_field works.\", \"We do not support update on already sliced query sets.\", \"test_update_transformed_field (update.tests.AdvancedTests.test_update_transformed_field)\", \"test_update_with_joined_field_annotation (update.tests.AdvancedTests.test_update_with_joined_field_annotation)\", \"test_updating_non_conditional_field (update.tests.AdvancedTests.test_updating_non_conditional_field)\", \"Update changes the right number of rows for an empty queryset\", \"Update works using <field>_id for foreign keys\", \"Update changes the right number of rows for a nonempty queryset\"]",
  "environment_setup_commit": "4a72da71001f154ea60906a2f74898d32b7322a7",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.766632",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}