{
  "repo": "django/django",
  "instance_id": "django__django-11446",
  "base_commit": "d6ea4898c44f75a25bc0b7a60b54fd6dddc69eb5",
  "patch": "diff --git a/django/views/defaults.py b/django/views/defaults.py\n--- a/django/views/defaults.py\n+++ b/django/views/defaults.py\n@@ -11,6 +11,17 @@\n ERROR_403_TEMPLATE_NAME = '403.html'\n ERROR_400_TEMPLATE_NAME = '400.html'\n ERROR_500_TEMPLATE_NAME = '500.html'\n+ERROR_PAGE_TEMPLATE = \"\"\"\n+<!doctype html>\n+<html lang=\"en\">\n+<head>\n+  <title>%(title)s</title>\n+</head>\n+<body>\n+  <h1>%(title)s</h1><p>%(details)s</p>\n+</body>\n+</html>\n+\"\"\"\n \n \n # This can be called when CsrfViewMiddleware.process_view has not run,\n@@ -55,8 +66,11 @@ def page_not_found(request, exception, template_name=ERROR_404_TEMPLATE_NAME):\n         # Render template (even though there are no substitutions) to allow\n         # inspecting the context in tests.\n         template = Engine().from_string(\n-            '<h1>Not Found</h1>'\n-            '<p>The requested resource was not found on this server.</p>')\n+            ERROR_PAGE_TEMPLATE % {\n+                'title': 'Not Found',\n+                'details': 'The requested resource was not found on this server.',\n+            },\n+        )\n         body = template.render(Context(context))\n         content_type = 'text/html'\n     return HttpResponseNotFound(body, content_type=content_type)\n@@ -76,7 +90,10 @@ def server_error(request, template_name=ERROR_500_TEMPLATE_NAME):\n         if template_name != ERROR_500_TEMPLATE_NAME:\n             # Reraise if it's a missing custom template.\n             raise\n-        return HttpResponseServerError('<h1>Server Error (500)</h1>', content_type='text/html')\n+        return HttpResponseServerError(\n+            ERROR_PAGE_TEMPLATE % {'title': 'Server Error (500)', 'details': ''},\n+            content_type='text/html',\n+        )\n     return HttpResponseServerError(template.render())\n \n \n@@ -94,7 +111,10 @@ def bad_request(request, exception, template_name=ERROR_400_TEMPLATE_NAME):\n         if template_name != ERROR_400_TEMPLATE_NAME:\n             # Reraise if it's a missing custom template.\n             raise\n-        return HttpResponseBadRequest('<h1>Bad Request (400)</h1>', content_type='text/html')\n+        return HttpResponseBadRequest(\n+            ERROR_PAGE_TEMPLATE % {'title': 'Bad Request (400)', 'details': ''},\n+            content_type='text/html',\n+        )\n     # No exception content is passed to the template, to not disclose any sensitive information.\n     return HttpResponseBadRequest(template.render())\n \n@@ -119,7 +139,10 @@ def permission_denied(request, exception, template_name=ERROR_403_TEMPLATE_NAME)\n         if template_name != ERROR_403_TEMPLATE_NAME:\n             # Reraise if it's a missing custom template.\n             raise\n-        return HttpResponseForbidden('<h1>403 Forbidden</h1>', content_type='text/html')\n+        return HttpResponseForbidden(\n+            ERROR_PAGE_TEMPLATE % {'title': '403 Forbidden', 'details': ''},\n+            content_type='text/html',\n+        )\n     return HttpResponseForbidden(\n         template.render(request=request, context={'exception': str(exception)})\n     )\n",
  "test_patch": "diff --git a/tests/view_tests/tests/test_defaults.py b/tests/view_tests/tests/test_defaults.py\n--- a/tests/view_tests/tests/test_defaults.py\n+++ b/tests/view_tests/tests/test_defaults.py\n@@ -47,6 +47,11 @@ def test_page_not_found(self):\n         for url in self.nonexistent_urls:\n             response = self.client.get(url)\n             self.assertEqual(response.status_code, 404)\n+        self.assertIn(b'<h1>Not Found</h1>', response.content)\n+        self.assertIn(\n+            b'<p>The requested resource was not found on this server.</p>',\n+            response.content,\n+        )\n \n     @override_settings(TEMPLATES=[{\n         'BACKEND': 'django.template.backends.django.DjangoTemplates',\n@@ -71,13 +76,12 @@ def test_csrf_token_in_404(self):\n     def test_server_error(self):\n         \"The server_error view raises a 500 status\"\n         response = self.client.get('/server_error/')\n-        self.assertEqual(response.status_code, 500)\n+        self.assertContains(response, b'<h1>Server Error (500)</h1>', status_code=500)\n \n     def test_bad_request(self):\n         request = self.request_factory.get('/')\n         response = bad_request(request, Exception())\n-        self.assertEqual(response.status_code, 400)\n-        self.assertEqual(response.content, b'<h1>Bad Request (400)</h1>')\n+        self.assertContains(response, b'<h1>Bad Request (400)</h1>', status_code=400)\n \n     @override_settings(TEMPLATES=[{\n         'BACKEND': 'django.template.backends.django.DjangoTemplates',\n@@ -129,3 +133,18 @@ def test_custom_templates_wrong(self):\n \n         with self.assertRaises(TemplateDoesNotExist):\n             server_error(request, template_name='nonexistent')\n+\n+    def test_error_pages(self):\n+        request = self.request_factory.get('/')\n+        for response, title in (\n+            (bad_request(request, Exception()), b'Bad Request (400)'),\n+            (permission_denied(request, Exception()), b'403 Forbidden'),\n+            (page_not_found(request, Http404()), b'Not Found'),\n+            (server_error(request), b'Server Error (500)'),\n+        ):\n+            with self.subTest(title=title):\n+                self.assertIn(b'<!doctype html>', response.content)\n+                self.assertIn(b'<html lang=\"en\">', response.content)\n+                self.assertIn(b'<head>', response.content)\n+                self.assertIn(b'<title>%s</title>' % title, response.content)\n+                self.assertIn(b'<body>', response.content)\n",
  "problem_statement": "Default error webpages are not correctly-formed html pages.\nDescription\n\t\nThe default page served for the 404 error in \"DEBUG=False\" mode is (django 2.2.1):\n<h1>Not Found</h1><p>The requested resource was not found on this server.</p>\nI would expect that by default, a full webpage is sent to the user, thus:\n<html>\n<body>\n<h1>Not Found</h1><p>The requested resource was not found on this server.</p>\n</body>\n</html>\nIn \"DEBUG=True\" mode, the webpage served is correct html:\n<!DOCTYPE html>\n<html lang=\"en\">\n...\n</html>\n",
  "hints_text": "Thanks for the report. I'm not sure if we should complicate all default error pages. It is ​documented that by default error views produce a very simple messages and it is also still recommended as good practice to provide custom templates in order to present pretty error pages to the user. You can also ​customize error views. To sum up default error pages are just a fallback, but OK we can accept this as a simple cleanup.\nI'll start working on this ticket. Following @felixxm comment I'll see if a *simple* solution can be applied. My opinion is that Django should use the corresponding format or at least to be consistent with other responses.\nHere's my patch ​PR. It adds html to the response of all default error pages. Any comments?",
  "created_at": "2019-06-05T18:57:08Z",
  "version": "3.0",
  "FAIL_TO_PASS": "[\"test_error_pages (view_tests.tests.test_defaults.DefaultsTests)\"]",
  "PASS_TO_PASS": "[\"test_bad_request (view_tests.tests.test_defaults.DefaultsTests)\", \"test_csrf_token_in_404 (view_tests.tests.test_defaults.DefaultsTests)\", \"test_custom_templates (view_tests.tests.test_defaults.DefaultsTests)\", \"test_custom_templates_wrong (view_tests.tests.test_defaults.DefaultsTests)\", \"A model can set attributes on the get_absolute_url method\", \"A 404 status is returned by the page_not_found view\", \"The server_error view raises a 500 status\"]",
  "environment_setup_commit": "419a78300f7cd27611196e1e464d50fd0385ff27",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.572920",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}