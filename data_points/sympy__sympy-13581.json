{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-13581",
  "base_commit": "a531dfdf2c536620fdaf080f7470dde08c257e92",
  "patch": "diff --git a/sympy/core/mod.py b/sympy/core/mod.py\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -107,6 +107,38 @@ def doit(p, q):\n             elif (qinner*(q + qinner)).is_nonpositive:\n                 # |qinner| < |q| and have different sign\n                 return p\n+        elif isinstance(p, Add):\n+            # separating into modulus and non modulus\n+            both_l = non_mod_l, mod_l = [], []\n+            for arg in p.args:\n+                both_l[isinstance(arg, cls)].append(arg)\n+            # if q same for all\n+            if mod_l and all(inner.args[1] == q for inner in mod_l):\n+                net = Add(*non_mod_l) + Add(*[i.args[0] for i in mod_l])\n+                return cls(net, q)\n+\n+        elif isinstance(p, Mul):\n+            # separating into modulus and non modulus\n+            both_l = non_mod_l, mod_l = [], []\n+            for arg in p.args:\n+                both_l[isinstance(arg, cls)].append(arg)\n+\n+            if mod_l and all(inner.args[1] == q for inner in mod_l):\n+                # finding distributive term\n+                non_mod_l = [cls(x, q) for x in non_mod_l]\n+                mod = []\n+                non_mod = []\n+                for j in non_mod_l:\n+                    if isinstance(j, cls):\n+                        mod.append(j.args[0])\n+                    else:\n+                        non_mod.append(j)\n+                prod_mod = Mul(*mod)\n+                prod_non_mod = Mul(*non_mod)\n+                prod_mod1 = Mul(*[i.args[0] for i in mod_l])\n+                net = prod_mod1*prod_mod\n+                return prod_non_mod*cls(net, q)\n+\n         # XXX other possibilities?\n \n         # extract gcd; any further simplification should be done by the user\n",
  "test_patch": "diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1655,6 +1655,12 @@ def test_Mod():\n     # issue 10963\n     assert (x**6000%400).args[1] == 400\n \n+    #issue 13543\n+    assert Mod(Mod(x + 1, 2) + 1 , 2) == Mod(x,2)\n+\n+    assert Mod(Mod(x + 2, 4)*(x + 4), 4) == Mod(x*(x + 2), 4)\n+    assert Mod(Mod(x + 2, 4)*4, 4) == 0\n+\n \n def test_Mod_is_integer():\n     p = Symbol('p', integer=True)\n",
  "problem_statement": "Mod(Mod(x + 1, 2) + 1, 2) should simplify to Mod(x, 2)\nFrom [stackoverflow](https://stackoverflow.com/questions/46914006/modulo-computations-in-sympy-fail)\r\n\r\nAlso, something like `Mod(foo*Mod(x + 1, 2) + non_mod_terms + 1, 2)` could be simplified. Recursively.\n",
  "hints_text": "",
  "created_at": "2017-11-09T19:53:47Z",
  "version": "1.1",
  "FAIL_TO_PASS": "[\"test_Mod\"]",
  "PASS_TO_PASS": "[\"test_bug1\", \"test_Symbol\", \"test_arit0\", \"test_div\", \"test_pow\", \"test_pow2\", \"test_pow3\", \"test_mod_pow\", \"test_pow_E\", \"test_pow_issue_3516\", \"test_pow_im\", \"test_real_mul\", \"test_ncmul\", \"test_ncpow\", \"test_powerbug\", \"test_Mul_doesnt_expand_exp\", \"test_Add_Mul_is_integer\", \"test_Add_Mul_is_finite\", \"test_Mul_is_even_odd\", \"test_evenness_in_ternary_integer_product_with_even\", \"test_oddness_in_ternary_integer_product_with_even\", \"test_Mul_is_rational\", \"test_Add_is_rational\", \"test_Add_is_even_odd\", \"test_Mul_is_negative_positive\", \"test_Mul_is_negative_positive_2\", \"test_Mul_is_nonpositive_nonnegative\", \"test_Add_is_negative_positive\", \"test_Add_is_nonpositive_nonnegative\", \"test_Pow_is_integer\", \"test_Pow_is_real\", \"test_Pow_is_finite\", \"test_Pow_is_even_odd\", \"test_Pow_is_negative_positive\", \"test_Pow_is_zero\", \"test_Pow_is_nonpositive_nonnegative\", \"test_Mul_is_imaginary_real\", \"test_Mul_hermitian_antihermitian\", \"test_Add_is_comparable\", \"test_Mul_is_comparable\", \"test_Pow_is_comparable\", \"test_Add_is_positive_2\", \"test_Add_is_irrational\", \"test_issue_3531b\", \"test_bug3\", \"test_suppressed_evaluation\", \"test_Add_as_coeff_mul\", \"test_Pow_as_coeff_mul_doesnt_expand\", \"test_issue_3514\", \"test_make_args\", \"test_issue_5126\", \"test_Rational_as_content_primitive\", \"test_Add_as_content_primitive\", \"test_Mul_as_content_primitive\", \"test_Pow_as_content_primitive\", \"test_issue_5460\", \"test_product_irrational\", \"test_issue_5919\", \"test_Mod_is_integer\", \"test_Mod_is_nonposneg\", \"test_issue_6001\", \"test_polar\", \"test_issue_6040\", \"test_issue_6082\", \"test_issue_6077\", \"test_mul_flatten_oo\", \"test_add_flatten\", \"test_issue_5160_6087_6089_6090\", \"test_float_int\", \"test_issue_6611a\", \"test_denest_add_mul\", \"test_mul_zero_detection\", \"test_Mul_with_zero_infinite\", \"test_issue_8247_8354\"]",
  "environment_setup_commit": "ec9e3c0436fbff934fa84e22bf07f1b3ef5bfac3",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.084965",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}