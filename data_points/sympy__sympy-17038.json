{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-17038",
  "base_commit": "ffa2a22cb06ecd7de1b95875f5d732ea37b990ac",
  "patch": "diff --git a/sympy/core/power.py b/sympy/core/power.py\n--- a/sympy/core/power.py\n+++ b/sympy/core/power.py\n@@ -22,9 +22,21 @@\n \n def isqrt(n):\n     \"\"\"Return the largest integer less than or equal to sqrt(n).\"\"\"\n-    if n < 17984395633462800708566937239552:\n-        return int(_sqrt(n))\n-    return integer_nthroot(int(n), 2)[0]\n+    if n < 0:\n+        raise ValueError(\"n must be nonnegative\")\n+    n = int(n)\n+\n+    # Fast path: with IEEE 754 binary64 floats and a correctly-rounded\n+    # math.sqrt, int(math.sqrt(n)) works for any integer n satisfying 0 <= n <\n+    # 4503599761588224 = 2**52 + 2**27. But Python doesn't guarantee either\n+    # IEEE 754 format floats *or* correct rounding of math.sqrt, so check the\n+    # answer and fall back to the slow method if necessary.\n+    if n < 4503599761588224:\n+        s = int(_sqrt(n))\n+        if 0 <= n - s*s <= 2*s:\n+            return s\n+\n+    return integer_nthroot(n, 2)[0]\n \n \n def integer_nthroot(y, n):\n",
  "test_patch": "diff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py\n--- a/sympy/core/tests/test_numbers.py\n+++ b/sympy/core/tests/test_numbers.py\n@@ -1026,12 +1026,38 @@ def test_integer_log():\n \n def test_isqrt():\n     from math import sqrt as _sqrt\n-    limit = 17984395633462800708566937239551\n+    limit = 4503599761588223\n     assert int(_sqrt(limit)) == integer_nthroot(limit, 2)[0]\n     assert int(_sqrt(limit + 1)) != integer_nthroot(limit + 1, 2)[0]\n     assert isqrt(limit + 1) == integer_nthroot(limit + 1, 2)[0]\n-    assert isqrt(limit + 1 - S.Half) == integer_nthroot(limit + 1, 2)[0]\n+    assert isqrt(limit + S.Half) == integer_nthroot(limit, 2)[0]\n     assert isqrt(limit + 1 + S.Half) == integer_nthroot(limit + 1, 2)[0]\n+    assert isqrt(limit + 2 + S.Half) == integer_nthroot(limit + 2, 2)[0]\n+\n+    # Regression tests for https://github.com/sympy/sympy/issues/17034\n+    assert isqrt(4503599761588224) == 67108864\n+    assert isqrt(9999999999999999) == 99999999\n+\n+    # Other corner cases, especially involving non-integers.\n+    raises(ValueError, lambda: isqrt(-1))\n+    raises(ValueError, lambda: isqrt(-10**1000))\n+    raises(ValueError, lambda: isqrt(-S.Half))\n+\n+    tiny = Rational(1, 10**1000)\n+    raises(ValueError, lambda: isqrt(-tiny))\n+    assert isqrt(1-tiny) == 0\n+    assert isqrt(4503599761588224-tiny) == 67108864\n+    assert isqrt(10**100 - tiny) == 10**50 - 1\n+\n+    # Check that using an inaccurate math.sqrt doesn't affect the results.\n+    from sympy.core import power\n+    old_sqrt = power._sqrt\n+    power._sqrt = lambda x: 2.999999999\n+    try:\n+        assert isqrt(9) == 3\n+        assert isqrt(10000) == 100\n+    finally:\n+        power._sqrt = old_sqrt\n \n \n def test_powers_Integer():\n",
  "problem_statement": "isqrt gives incorrect results\nThe `isqrt` function in `sympy.core.power` gives incorrect results for some inputs. For example:\r\n\r\n```\r\n>>> from sympy.core.power import isqrt\r\n>>> n = 4503599761588224\r\n>>> s = isqrt(n)\r\n>>> s  # correct result is 67108864\r\n67108865\r\n>>> s**2 <= n  # expect True\r\nFalse\r\n```\r\n\r\nor\r\n\r\n```\r\n>>> isqrt(9999999999999999)  # should be 99999999\r\n100000000\r\n```\r\n\r\nVersions: Python 3.7.3, SymPy 1.4, macOS 10.14.5\r\n\r\n## Analysis\r\n\r\nFor small values of `n`, the [current implementation](https://github.com/sympy/sympy/blob/3febfc43ca0aa23d916ef06057e8c6d396a955e7/sympy/core/power.py#L23-L27) uses `math.sqrt` (aliased to `_sqrt`):\r\n\r\n```\r\n    if n < 17984395633462800708566937239552:\r\n        return int(_sqrt(n))\r\n```\r\n\r\nThe main problem is that the bound used for `n` here is much too large, at almost `2**104`.\r\n\r\n*If* (and it's quite a big if) we can assume that Python floats are IEEE 754 binary64 format _and_ that `math.sqrt` supplies a correctly-rounded (using round-ties-to-even) square root function, then the largest bound that can safely be used here is `4503599761588224`, or `2**52 + 2**27`.\r\n\r\nIf we can assume IEEE 754 binary64 `float`s but can't assume a correctly-rounded `math.sqrt`, then `int(_sqrt(n + 0.5))` is still safe for smallish `n`, where the definition of \"smallish\" depends on how accurate `math.sqrt` is. For example, if `_sqrt(n)` is known to be accurate to within 2 ulps, then it's possible to show that `int(_sqrt(n + 0.5))` is safe for `n < 2**50`. (The `+0.5` is necessary here: `int(_sqrt(n))` wouldn't be safe even for tiny `n`, since e.g. if the result of `_sqrt(25)` is off by a single ulp downwards, `int(_sqrt(25))` would produce `4` instead of `5`.)\r\n\r\nWhether `math.sqrt` is correctly rounded or not will depend on the platform: Python's `math.sqrt` just wraps the `sqrt` function from C's math library. On modern x64 hardware, one would expect and hope that C's `sqrt` gets mapped to the appropriate SSE2 instruction, in which case it'll be correctly rounded. But on ARM there may well not be a hardware sqrt instruction to map to, and a hand-implemented libm sqrt could easily be incorrectly rounded for some inputs.\r\n\r\nIn the unlikely (but possible) case of non-IEEE 754 binary64 `float`s, it's probably safer to avoid using `math.sqrt` at all. But this case is likely to be exceedingly rare, and doesn't seem worth worrying about in practice.\r\n\r\nI guess one option for fixing this while retaining performance for small `n` would be to continue to use the `int(_sqrt(n))` code, but then to check the result is correct before returning it, falling back to the slow integer-only path if that check doesn't pass.\r\n\r\n\n",
  "hints_text": "Thanks @mdickinson for reporting and looking into this.\r\n\r\nI think that the simple fix is that we should reduce the threshold to 4503599761588224 and check the result before returning it with\r\n```\r\nif s**2 <= n and (s+1)**2 > n:\r\n    return s\r\n# Fall back to integer_nthroot\r\n```\r\nUsing sqrt as a potential speed-boost is fine but the correctness of integer calculations in SymPy should not depend in any way on the underlying floating point configuration.\r\n\r\nIt might also be worth using a sqrt-specific integer root finder if timings show that it can be faster than integer_nthroot (for large or small integers):\r\nhttps://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division",
  "created_at": "2019-06-16T15:28:03Z",
  "version": "1.5",
  "FAIL_TO_PASS": "[\"test_isqrt\"]",
  "PASS_TO_PASS": "[\"test_seterr\", \"test_mod\", \"test_divmod\", \"test_igcd\", \"test_igcd_lehmer\", \"test_igcd2\", \"test_ilcm\", \"test_igcdex\", \"test_Integer_new\", \"test_Rational_new\", \"test_Number_new\", \"test_Number_cmp\", \"test_Rational_cmp\", \"test_Float\", \"test_float_mpf\", \"test_Float_RealElement\", \"test_Float_default_to_highprec_from_str\", \"test_Float_eval\", \"test_Float_issue_2107\", \"test_issue_14289\", \"test_Float_from_tuple\", \"test_Infinity\", \"test_Infinity_2\", \"test_Mul_Infinity_Zero\", \"test_Div_By_Zero\", \"test_Infinity_inequations\", \"test_NaN\", \"test_special_numbers\", \"test_powers\", \"test_integer_nthroot_overflow\", \"test_integer_log\", \"test_powers_Integer\", \"test_powers_Rational\", \"test_powers_Float\", \"test_abs1\", \"test_accept_int\", \"test_dont_accept_str\", \"test_int\", \"test_long\", \"test_real_bug\", \"test_bug_sqrt\", \"test_pi_Pi\", \"test_no_len\", \"test_issue_3321\", \"test_issue_3692\", \"test_issue_3423\", \"test_issue_3449\", \"test_issue_13890\", \"test_Integer_factors\", \"test_Rational_factors\", \"test_issue_4107\", \"test_IntegerInteger\", \"test_Rational_gcd_lcm_cofactors\", \"test_Float_gcd_lcm_cofactors\", \"test_issue_4611\", \"test_conversion_to_mpmath\", \"test_relational\", \"test_Integer_as_index\", \"test_Rational_int\", \"test_zoo\", \"test_issue_4122\", \"test_GoldenRatio_expand\", \"test_TribonacciConstant_expand\", \"test_as_content_primitive\", \"test_hashing_sympy_integers\", \"test_rounding_issue_4172\", \"test_Catalan_EulerGamma_prec\", \"test_bool_eq\", \"test_Float_eq\", \"test_int_NumberSymbols\", \"test_issue_6640\", \"test_issue_6349\", \"test_mpf_norm\", \"test_latex\", \"test_issue_7742\", \"test_simplify_AlgebraicNumber\", \"test_Float_idempotence\", \"test_comp1\", \"test_issue_9491\", \"test_issue_10063\", \"test_issue_10020\", \"test_invert_numbers\", \"test_mod_inverse\", \"test_golden_ratio_rewrite_as_sqrt\", \"test_tribonacci_constant_rewrite_as_sqrt\", \"test_comparisons_with_unknown_type\", \"test_NumberSymbol_comparison\", \"test_Integer_precision\", \"test_Integer_ceiling_floor\", \"test_ComplexInfinity\", \"test_Infinity_floor_ceiling_power\", \"test_One_power\", \"test_NegativeInfinity\", \"test_issue_6133\", \"test_abc\"]",
  "environment_setup_commit": "70381f282f2d9d039da860e391fe51649df2779d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.112609",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}