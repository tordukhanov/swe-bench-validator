{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-18062",
  "base_commit": "7501960ea18912f9055a32be50bda30805fc0c95",
  "patch": "diff --git a/sympy/sets/handlers/functions.py b/sympy/sets/handlers/functions.py\n--- a/sympy/sets/handlers/functions.py\n+++ b/sympy/sets/handlers/functions.py\n@@ -7,6 +7,7 @@\n from sympy.sets import (imageset, Interval, FiniteSet, Union, ImageSet,\n                         EmptySet, Intersection, Range)\n from sympy.sets.fancysets import Integers, Naturals, Reals\n+from sympy.functions.elementary.exponential import match_real_imag\n \n \n _x, _y = symbols(\"x y\")\n@@ -189,21 +190,27 @@ def _set_function(f, self):\n     match = expr.match(a*n + b)\n     if match and match[a]:\n         # canonical shift\n-        b = match[b]\n-        if abs(match[a]) == 1:\n+        a, b = match[a], match[b]\n+        if a in [1, -1]:\n+            # drop integer addends in b\n             nonint = []\n             for bi in Add.make_args(b):\n                 if not bi.is_integer:\n                     nonint.append(bi)\n             b = Add(*nonint)\n-        if b.is_number and match[a].is_real:\n-            mod = b % match[a]\n-            reps = dict([(m, m.args[0]) for m in mod.atoms(Mod)\n-                if not m.args[0].is_real])\n-            mod = mod.xreplace(reps)\n-            expr = match[a]*n + mod\n-        else:\n-            expr = match[a]*n + b\n+        if b.is_number and a.is_real:\n+            # avoid Mod for complex numbers, #11391\n+            br, bi = match_real_imag(b)\n+            if br and br.is_comparable and a.is_comparable:\n+                br %= a\n+                b = br + S.ImaginaryUnit*bi\n+        elif b.is_number and a.is_imaginary:\n+            br, bi = match_real_imag(b)\n+            ai = a/S.ImaginaryUnit\n+            if bi and bi.is_comparable and ai.is_comparable:\n+                bi %= ai\n+                b = br + S.ImaginaryUnit*bi\n+        expr = a*n + b\n \n     if expr != f.expr:\n         return ImageSet(Lambda(n, expr), S.Integers)\n",
  "test_patch": "diff --git a/sympy/sets/tests/test_fancysets.py b/sympy/sets/tests/test_fancysets.py\n--- a/sympy/sets/tests/test_fancysets.py\n+++ b/sympy/sets/tests/test_fancysets.py\n@@ -914,9 +914,20 @@ def test_issue_16871b():\n     assert ImageSet(Lambda(x, x - 3), S.Integers).is_subset(S.Integers)\n \n \n-def test_no_mod_on_imaginary():\n+def test_issue_18050():\n+    assert imageset(Lambda(x, I*x + 1), S.Integers\n+        ) == ImageSet(Lambda(x, I*x + 1), S.Integers)\n+    assert imageset(Lambda(x, 3*I*x + 4 + 8*I), S.Integers\n+        ) == ImageSet(Lambda(x, 3*I*x + 4 + 2*I), S.Integers)\n+    # no 'Mod' for next 2 tests:\n     assert imageset(Lambda(x, 2*x + 3*I), S.Integers\n-        ) == ImageSet(Lambda(x, 2*x + I), S.Integers)\n+        ) == ImageSet(Lambda(x, 2*x + 3*I), S.Integers)\n+    r = Symbol('r', positive=True)\n+    assert imageset(Lambda(x, r*x + 10), S.Integers\n+        ) == ImageSet(Lambda(x, r*x + 10), S.Integers)\n+    # reduce real part:\n+    assert imageset(Lambda(x, 3*x + 8 + 5*I), S.Integers\n+        ) == ImageSet(Lambda(x, 3*x + 2 + 5*I), S.Integers)\n \n \n def test_Rationals():\ndiff --git a/sympy/sets/tests/test_setexpr.py b/sympy/sets/tests/test_setexpr.py\n--- a/sympy/sets/tests/test_setexpr.py\n+++ b/sympy/sets/tests/test_setexpr.py\n@@ -1,9 +1,8 @@\n from sympy.sets.setexpr import SetExpr\n from sympy.sets import Interval, FiniteSet, Intersection, ImageSet, Union\n-from sympy import (Expr, Set, exp, log, cos, Symbol, Min, Max, S, oo,\n+from sympy import (Expr, Set, exp, log, cos, Symbol, Min, Max, S, oo, I,\n         symbols, Lambda, Dummy, Rational)\n \n-I = Interval(0, 2)\n a, x = symbols(\"a, x\")\n _d = Dummy(\"d\")\n \n@@ -285,3 +284,17 @@ def test_SetExpr_Interval_pow():\n     assert SetExpr(Interval(2, 3))**(-oo) == SetExpr(FiniteSet(0))\n     assert SetExpr(Interval(0, 2))**(-oo) == SetExpr(Interval(0, oo))\n     assert (SetExpr(Interval(-1, 2))**(-oo)).dummy_eq(SetExpr(ImageSet(Lambda(_d, _d**(-oo)), Interval(-1, 2))))\n+\n+\n+def test_SetExpr_Integers():\n+    assert SetExpr(S.Integers) + 1 == SetExpr(S.Integers)\n+    assert SetExpr(S.Integers) + I == SetExpr(ImageSet(Lambda(_d, _d + I), S.Integers))\n+    assert SetExpr(S.Integers)*(-1) == SetExpr(S.Integers)\n+    assert SetExpr(S.Integers)*2 == SetExpr(ImageSet(Lambda(_d, 2*_d), S.Integers))\n+    assert SetExpr(S.Integers)*I == SetExpr(ImageSet(Lambda(_d, I*_d), S.Integers))\n+    # issue #18050:\n+    assert SetExpr(S.Integers)._eval_func(Lambda(x, I*x + 1)) == SetExpr(\n+            ImageSet(Lambda(_d, I*_d + 1), S.Integers))\n+    # needs improvement:\n+    assert SetExpr(S.Integers)*I + 1 == SetExpr(\n+            ImageSet(Lambda(x, x + 1), ImageSet(Lambda(_d, _d*I), S.Integers)))\n",
  "problem_statement": "imageset broken for complex numbers\nWith current master:\r\n```\r\nIn [4]: imageset(Lambda(n, 1 + I*n), Integers)\r\nOut[4]: {ⅈ⋅n | n ∊ ℤ}\r\n```\r\nThe `1` (or any other value) is simply dropped.\n",
  "hints_text": "It works with `ImageSet`:\r\n```\r\nIn [1]: ImageSet(Lambda(n, 1 + I*n), Integers)                                                                                    \r\nOut[1]: {ⅈ⋅n + 1 | n ∊ ℤ}\r\n```\r\nThere are already issues but the `imageset` function should be stripped: the logic should go into `ImageSet` so that `imageset` is more or less `ImageSet(...).doit()`.\n```\r\nIn [8]: ImageSet(Lambda(n, 1 + I*n), Integers)\r\nOut[8]: {ⅈ⋅n + 1 | n ∊ ℤ}\r\n\r\nIn [9]: _.doit()\r\nOut[9]: {ⅈ⋅n | n ∊ ℤ}\r\n```\r\nI suppose the canonicalization code is similar for `imageset` and `.doit()`. (Didn't check)\n`ImageSet.doit` hands over to `SetExpr` so I would guess the problem is there.\nIt goes wrong here:\r\nhttps://github.com/sympy/sympy/blob/3d2537a0a774e2842562c1cd54f4acaab8054be3/sympy/sets/handlers/functions.py#L206\r\nAt that point b should be 1 but it is zero because of this\r\nhttps://github.com/sympy/sympy/blob/3d2537a0a774e2842562c1cd54f4acaab8054be3/sympy/sets/handlers/functions.py#L198\nThanks for tracking it down, so what goes wrong here is that this block:\r\nhttps://github.com/sympy/sympy/blob/3d2537a0a774e2842562c1cd54f4acaab8054be3/sympy/sets/handlers/functions.py#L193-L198\r\nshould remove integer addends from `b`in case the variable's coefficient is +1 or -1, but it's erroneously executed for complex numbers with modulus=1. So changing the check to `if match[a] in [1, -1]:` is the correct fix for the present issue. So far so good.\r\n\r\nBut I'm also wondering about the intent of the next block:\r\nhttps://github.com/sympy/sympy/blob/3d2537a0a774e2842562c1cd54f4acaab8054be3/sympy/sets/handlers/functions.py#L199-L204\r\nIs my understanding correct, that lines 201-203 should remove unevaluated Mods introduced by line 200? If so, a good start would be to not call `b % match[a]` for non-real `b` in the first place :-)\r\n\r\nFinally, there's a test that actually asserts the following:\r\nhttps://github.com/sympy/sympy/blob/3d2537a0a774e2842562c1cd54f4acaab8054be3/sympy/sets/tests/test_fancysets.py#L917-L919\r\nBut that's plain wrong?\r\n\r\nI'll submit a PR.\n> But that's plain wrong?\r\n\r\nLooks plain wrong to me",
  "created_at": "2019-12-17T12:44:33Z",
  "version": "1.6",
  "FAIL_TO_PASS": "[\"test_issue_18050\"]",
  "PASS_TO_PASS": "[\"test_naturals\", \"test_naturals0\", \"test_integers\", \"test_ImageSet\", \"test_image_is_ImageSet\", \"test_halfcircle\", \"test_ImageSet_iterator_not_injective\", \"test_inf_Range_len\", \"test_Range_set\", \"test_range_range_intersection\", \"test_range_interval_intersection\", \"test_Integers_eval_imageset\", \"test_Range_eval_imageset\", \"test_fun\", \"test_Reals\", \"test_Complex\", \"test_intersections\", \"test_infinitely_indexed_set_1\", \"test_infinitely_indexed_set_2\", \"test_imageset_intersect_real\", \"test_imageset_intersect_interval\", \"test_infinitely_indexed_set_3\", \"test_ImageSet_simplification\", \"test_ImageSet_contains\", \"test_ComplexRegion_contains\", \"test_ComplexRegion_intersect\", \"test_ComplexRegion_union\", \"test_ComplexRegion_from_real\", \"test_ComplexRegion_measure\", \"test_normalize_theta_set\", \"test_ComplexRegion_FiniteSet\", \"test_union_RealSubSet\", \"test_issue_9980\", \"test_issue_11732\", \"test_issue_11730\", \"test_issue_11938\", \"test_issue_11914\", \"test_issue_9543\", \"test_issue_16871\", \"test_Rationals\", \"test_imageset_intersection\", \"test_setexpr\", \"test_scalar_funcs\", \"test_Add_Mul\", \"test_Pow\", \"test_compound\", \"test_Interval_Interval\", \"test_FiniteSet_FiniteSet\", \"test_Interval_FiniteSet\", \"test_Many_Sets\", \"test_same_setexprs_are_not_identical\", \"test_Interval_arithmetic\", \"test_SetExpr_Intersection\", \"test_SetExpr_Interval_div\", \"test_SetExpr_Interval_pow\"]",
  "environment_setup_commit": "28b41c73c12b70d6ad9f6e45109a80649c4456da",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.119727",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}