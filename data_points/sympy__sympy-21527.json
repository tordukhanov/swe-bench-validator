{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-21527",
  "base_commit": "31d469a5335c81ec4a437e36a861945a6b43d916",
  "patch": "diff --git a/sympy/polys/constructor.py b/sympy/polys/constructor.py\n--- a/sympy/polys/constructor.py\n+++ b/sympy/polys/constructor.py\n@@ -48,7 +48,7 @@ def _construct_simple(coeffs, opt):\n                         float_numbers.append(x)\n                     if y.is_Float:\n                         float_numbers.append(y)\n-            if is_algebraic(coeff):\n+            elif is_algebraic(coeff):\n                 if floats:\n                     # there are both algebraics and reals -> EX\n                     return False\ndiff --git a/sympy/polys/matrices/ddm.py b/sympy/polys/matrices/ddm.py\n--- a/sympy/polys/matrices/ddm.py\n+++ b/sympy/polys/matrices/ddm.py\n@@ -284,7 +284,9 @@ def applyfunc(self, func, domain):\n     def rref(a):\n         \"\"\"Reduced-row echelon form of a and list of pivots\"\"\"\n         b = a.copy()\n-        pivots = ddm_irref(b)\n+        K = a.domain\n+        partial_pivot = K.is_RealField or K.is_ComplexField\n+        pivots = ddm_irref(b, _partial_pivot=partial_pivot)\n         return b, pivots\n \n     def nullspace(a):\ndiff --git a/sympy/polys/matrices/dense.py b/sympy/polys/matrices/dense.py\n--- a/sympy/polys/matrices/dense.py\n+++ b/sympy/polys/matrices/dense.py\n@@ -85,7 +85,7 @@ def ddm_imatmul(a, b, c):\n             ai[j] = sum(map(mul, bi, cTj), ai[j])\n \n \n-def ddm_irref(a):\n+def ddm_irref(a, _partial_pivot=False):\n     \"\"\"a  <--  rref(a)\"\"\"\n     # a is (m x n)\n     m = len(a)\n@@ -97,6 +97,15 @@ def ddm_irref(a):\n     pivots = []\n \n     for j in range(n):\n+        # Proper pivoting should be used for all domains for performance\n+        # reasons but it is only strictly needed for RR and CC (and possibly\n+        # other domains like RR(x)). This path is used by DDM.rref() if the\n+        # domain is RR or CC. It uses partial (row) pivoting based on the\n+        # absolute value of the pivot candidates.\n+        if _partial_pivot:\n+            ip = max(range(i, m), key=lambda ip: abs(a[ip][j]))\n+            a[i], a[ip] = a[ip], a[i]\n+\n         # pivot\n         aij = a[i][j]\n \ndiff --git a/sympy/polys/matrices/linsolve.py b/sympy/polys/matrices/linsolve.py\n--- a/sympy/polys/matrices/linsolve.py\n+++ b/sympy/polys/matrices/linsolve.py\n@@ -73,6 +73,12 @@ def _linsolve(eqs, syms):\n     Aaug = sympy_dict_to_dm(eqsdict, rhs, syms)\n     K = Aaug.domain\n \n+    # sdm_irref has issues with float matrices. This uses the ddm_rref()\n+    # function. When sdm_rref() can handle float matrices reasonably this\n+    # should be removed...\n+    if K.is_RealField or K.is_ComplexField:\n+        Aaug = Aaug.to_ddm().rref()[0].to_sdm()\n+\n     # Compute reduced-row echelon form (RREF)\n     Arref, pivots, nzcols = sdm_irref(Aaug)\n \ndiff --git a/sympy/polys/matrices/sdm.py b/sympy/polys/matrices/sdm.py\n--- a/sympy/polys/matrices/sdm.py\n+++ b/sympy/polys/matrices/sdm.py\n@@ -904,6 +904,8 @@ def sdm_irref(A):\n             Ajnz = set(Aj)\n             for k in Ajnz - Ainz:\n                 Ai[k] = - Aij * Aj[k]\n+            Ai.pop(j)\n+            Ainz.remove(j)\n             for k in Ajnz & Ainz:\n                 Aik = Ai[k] - Aij * Aj[k]\n                 if Aik:\n@@ -938,6 +940,8 @@ def sdm_irref(A):\n             for l in Ainz - Aknz:\n                 Ak[l] = - Akj * Ai[l]\n                 nonzero_columns[l].add(k)\n+            Ak.pop(j)\n+            Aknz.remove(j)\n             for l in Ainz & Aknz:\n                 Akl = Ak[l] - Akj * Ai[l]\n                 if Akl:\n",
  "test_patch": "diff --git a/sympy/polys/matrices/tests/test_linsolve.py b/sympy/polys/matrices/tests/test_linsolve.py\n--- a/sympy/polys/matrices/tests/test_linsolve.py\n+++ b/sympy/polys/matrices/tests/test_linsolve.py\n@@ -7,7 +7,7 @@\n from sympy.testing.pytest import raises\n \n from sympy import S, Eq, I\n-from sympy.abc import x, y\n+from sympy.abc import x, y, z\n \n from sympy.polys.matrices.linsolve import _linsolve\n from sympy.polys.solvers import PolyNonlinearError\n@@ -23,6 +23,83 @@ def test__linsolve():\n     raises(PolyNonlinearError, lambda: _linsolve([x*(1 + x)], [x]))\n \n \n+def test__linsolve_float():\n+\n+    # This should give the exact answer:\n+    eqs = [\n+        y - x,\n+        y - 0.0216 * x\n+    ]\n+    sol = {x:0.0, y:0.0}\n+    assert _linsolve(eqs, (x, y)) == sol\n+\n+    # Other cases should be close to eps\n+\n+    def all_close(sol1, sol2, eps=1e-15):\n+        close = lambda a, b: abs(a - b) < eps\n+        assert sol1.keys() == sol2.keys()\n+        return all(close(sol1[s], sol2[s]) for s in sol1)\n+\n+    eqs = [\n+        0.8*x +         0.8*z + 0.2,\n+        0.9*x + 0.7*y + 0.2*z + 0.9,\n+        0.7*x + 0.2*y + 0.2*z + 0.5\n+    ]\n+    sol_exact = {x:-29/42, y:-11/21, z:37/84}\n+    sol_linsolve = _linsolve(eqs, [x,y,z])\n+    assert all_close(sol_exact, sol_linsolve)\n+\n+    eqs = [\n+        0.9*x + 0.3*y + 0.4*z + 0.6,\n+        0.6*x + 0.9*y + 0.1*z + 0.7,\n+        0.4*x + 0.6*y + 0.9*z + 0.5\n+    ]\n+    sol_exact = {x:-88/175, y:-46/105, z:-1/25}\n+    sol_linsolve = _linsolve(eqs, [x,y,z])\n+    assert all_close(sol_exact, sol_linsolve)\n+\n+    eqs = [\n+        0.4*x + 0.3*y + 0.6*z + 0.7,\n+        0.4*x + 0.3*y + 0.9*z + 0.9,\n+        0.7*x + 0.9*y,\n+    ]\n+    sol_exact = {x:-9/5, y:7/5, z:-2/3}\n+    sol_linsolve = _linsolve(eqs, [x,y,z])\n+    assert all_close(sol_exact, sol_linsolve)\n+\n+    eqs = [\n+        x*(0.7 + 0.6*I) + y*(0.4 + 0.7*I) + z*(0.9 + 0.1*I) + 0.5,\n+        0.2*I*x + 0.2*I*y + z*(0.9 + 0.2*I) + 0.1,\n+        x*(0.9 + 0.7*I) + y*(0.9 + 0.7*I) + z*(0.9 + 0.4*I) + 0.4,\n+    ]\n+    sol_exact = {\n+        x:-6157/7995 - 411/5330*I,\n+        y:8519/15990 + 1784/7995*I,\n+        z:-34/533 + 107/1599*I,\n+    }\n+    sol_linsolve = _linsolve(eqs, [x,y,z])\n+    assert all_close(sol_exact, sol_linsolve)\n+\n+    # XXX: This system for x and y over RR(z) is problematic.\n+    #\n+    # eqs = [\n+    #     x*(0.2*z + 0.9) + y*(0.5*z + 0.8) + 0.6,\n+    #     0.1*x*z + y*(0.1*z + 0.6) + 0.9,\n+    # ]\n+    #\n+    # linsolve(eqs, [x, y])\n+    # The solution for x comes out as\n+    #\n+    #       -3.9e-5*z**2 - 3.6e-5*z - 8.67361737988404e-20\n+    #  x =  ----------------------------------------------\n+    #           3.0e-6*z**3 - 1.3e-5*z**2 - 5.4e-5*z\n+    #\n+    # The 8e-20 in the numerator should be zero which would allow z to cancel\n+    # from top and bottom. It should be possible to avoid this somehow because\n+    # the inverse of the matrix only has a quadratic factor (the determinant)\n+    # in the denominator.\n+\n+\n def test__linsolve_deprecated():\n     assert _linsolve([Eq(x**2, x**2+y)], [x, y]) == {x:x, y:S.Zero}\n     assert _linsolve([(x+y)**2-x**2], [x]) == {x:-y/2}\ndiff --git a/sympy/polys/tests/test_constructor.py b/sympy/polys/tests/test_constructor.py\n--- a/sympy/polys/tests/test_constructor.py\n+++ b/sympy/polys/tests/test_constructor.py\n@@ -27,6 +27,9 @@ def test_construct_domain():\n     assert isinstance(result[0], ComplexField)\n     assert result[1] == [CC(3.14), CC(1.0j), CC(0.5)]\n \n+    assert construct_domain([1.0+I]) == (CC, [CC(1.0, 1.0)])\n+    assert construct_domain([2.0+3.0*I]) == (CC, [CC(2.0, 3.0)])\n+\n     assert construct_domain([1, I]) == (ZZ_I, [ZZ_I(1, 0), ZZ_I(0, 1)])\n     assert construct_domain([1, I/2]) == (QQ_I, [QQ_I(1, 0), QQ_I(0, S.Half)])\n \ndiff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\n--- a/sympy/polys/tests/test_polytools.py\n+++ b/sympy/polys/tests/test_polytools.py\n@@ -51,6 +51,7 @@\n from sympy.polys.fields import field\n from sympy.polys.domains import FF, ZZ, QQ, ZZ_I, QQ_I, RR, EX\n from sympy.polys.domains.realfield import RealField\n+from sympy.polys.domains.complexfield import ComplexField\n from sympy.polys.orderings import lex, grlex, grevlex\n \n from sympy import (\n@@ -387,6 +388,7 @@ def test_Poly__new__():\n              modulus=65537, symmetric=False)\n \n     assert isinstance(Poly(x**2 + x + 1.0).get_domain(), RealField)\n+    assert isinstance(Poly(x**2 + x + I + 1.0).get_domain(), ComplexField)\n \n \n def test_Poly__args():\n",
  "problem_statement": "linsolve fails simple system of two equations\n```\r\nimport sympy\r\nx,y = sympy.symbols('x, y')\r\n\r\nsympy.linsolve([sympy.Eq(y, x), sympy.Eq(y, 0.0215 * x)], (x, y))\r\n>> FiniteSet((0, 0))\r\n\r\nsympy.linsolve([sympy.Eq(y, x), sympy.Eq(y, 0.0216 * x)], (x, y))\r\n>> FiniteSet((-4.07992766242527e+17*y, 1.0*y))\r\n\r\nsympy.linsolve([sympy.Eq(y, x), sympy.Eq(y, 0.0217 * x)], (x, y))\r\n>> FiniteSet((0, 0))\r\n```\r\n\r\nAny thoughts on why these don't all return the same solution? Thanks!\n",
  "hints_text": "It seems that in rref the pivot is not fully cancelled due to a rounding error so e.g. we have something like:\r\n```python\r\nIn [1]: M = Matrix([[1.0, 1.0], [3.1, 1.0]])\r\n\r\nIn [2]: M\r\nOut[2]: \r\n⎡1.0  1.0⎤\r\n⎢        ⎥\r\n⎣3.1  1.0⎦\r\n```\r\nThen one step of row reduction gives:\r\n```python\r\nIn [3]: M = Matrix([[1.0, 1.0], [1e-16, -2.1]])\r\n\r\nIn [4]: M\r\nOut[4]: \r\n⎡  1.0    1.0 ⎤\r\n⎢             ⎥\r\n⎣1.0e-16  -2.1⎦\r\n```\r\nWith exact arithmetic the 1e-16 would have been 0 but the rounding error makes it not zero and then it throws off subsequent steps. I think that the solution is to make it exactly zero:\r\n```diff\r\ndiff --git a/sympy/polys/matrices/sdm.py b/sympy/polys/matrices/sdm.py\r\nindex cfa624185a..647eb6af3d 100644\r\n--- a/sympy/polys/matrices/sdm.py\r\n+++ b/sympy/polys/matrices/sdm.py\r\n@@ -904,6 +904,8 @@ def sdm_irref(A):\r\n             Ajnz = set(Aj)\r\n             for k in Ajnz - Ainz:\r\n                 Ai[k] = - Aij * Aj[k]\r\n+            Ai.pop(j)\r\n+            Ainz.remove(j)\r\n             for k in Ajnz & Ainz:\r\n                 Aik = Ai[k] - Aij * Aj[k]\r\n                 if Aik:\r\n```\r\nThat gives:\r\n```python\r\nIn [1]: import sympy\r\n\r\nIn [2]: sympy.linsolve([sympy.Eq(y, x), sympy.Eq(y, 0.0215 * x)], (x, y))\r\nOut[2]: {(0, 0)}\r\n\r\nIn [3]: sympy.linsolve([sympy.Eq(y, x), sympy.Eq(y, 0.0216 * x)], (x, y))\r\nOut[3]: {(0, 0)}\r\n\r\nIn [4]: sympy.linsolve([sympy.Eq(y, x), sympy.Eq(y, 0.0217 * x)], (x, y))\r\nOut[4]: {(0, 0)}\r\n```\r\n@tyler-herzer-volumetric can you try out that diff?\nHaven't been able to replicate the issue after making that change. Thanks a lot @oscarbenjamin!\nThis example still fails with the diff:\r\n```python\r\nIn [1]: linsolve([0.4*x + 0.3*y + 0.2, 0.4*x + 0.3*y + 0.3], [x, y])\r\nOut[1]: {(1.35107988821115e+15, -1.8014398509482e+15)}\r\n```\r\nIn this case although the pivot is set to zero actually the matrix is singular but row reduction leads to something like:\r\n```python\r\nIn [3]: Matrix([[1, 1], [0, 1e-17]])\r\nOut[3]: \r\n⎡1     1   ⎤\r\n⎢          ⎥\r\n⎣0  1.0e-17⎦\r\n```\r\nThat's a trickier case. It seems that numpy can pick up on it e.g.:\r\n```python\r\nIn [52]: M = np.array([[0.4, 0.3], [0.4, 0.3]])\r\n\r\nIn [53]: b = np.array([0.2, 0.3])\r\n\r\nIn [54]: np.linalg.solve(M, b)\r\n---------------------------------------------------------------------------\r\nLinAlgError: Singular matrix \r\n```\r\nA slight modification or rounding error leads to the same large result though:\r\n```python\r\nIn [55]: M = np.array([[0.4, 0.3], [0.4, 0.3-3e-17]])\r\n\r\nIn [56]: np.linalg.solve(M, b)\r\nOut[56]: array([ 1.35107989e+15, -1.80143985e+15])\r\n```\r\nI'm not sure it's possible to arrange the floating point calculation so that cases like this are picked up as being singular without introducing some kind of heuristic threshold for the determinant. This fails in numpy with even fairly simple examples:\r\n```python\r\nIn [83]: b\r\nOut[83]: array([0.2, 0.3, 0.5])\r\n\r\nIn [84]: M\r\nOut[84]: \r\narray([[0.1, 0.2, 0.3],\r\n       [0.4, 0.5, 0.6],\r\n       [0.7, 0.8, 0.9]])\r\n\r\nIn [85]: np.linalg.solve(M, b)\r\nOut[85]: array([-4.50359963e+14,  9.00719925e+14, -4.50359963e+14])\r\n\r\nIn [86]: np.linalg.det(M)\r\nOut[86]: 6.661338147750926e-18\r\n```\r\nMaybe the not full-rank case for float matrices isn't so important since it can't be done reliably with floats. I guess that the diff shown above is good enough then since it fixes the calculation in the full rank case.\nThere is another problematic case. This should have a unique solution but a parametric solution is returned instead:\r\n```python\r\nIn [21]: eqs = [0.8*x + 0.8*z + 0.2, 0.9*x + 0.7*y + 0.2*z + 0.9, 0.7*x + 0.2*y + 0.2*z + 0.5]\r\n\r\nIn [22]: linsolve(eqs, [x, y, z])\r\nOut[22]: {(-0.32258064516129⋅z - 0.548387096774194, 1.22033022161007e+16⋅z - 5.37526407137769e+15, 1.0⋅z)}\r\n```\r\nThat seems to be another bug in the sparse rref routine somehow:\r\n```python\r\nIn [34]: M = Matrix([\r\n    ...: [0.8,   0, 0.8, -0.2],\r\n    ...: [0.9, 0.7, 0.2, -0.9],\r\n    ...: [0.7, 0.2, 0.2, -0.5]])\r\n\r\nIn [35]: from sympy.polys.matrices import DomainMatrix\r\n\r\nIn [36]: dM = DomainMatrix.from_Matrix(M)\r\n\r\nIn [37]: M.rref()\r\nOut[37]: \r\n⎛⎡1  0  0  -0.690476190476191⎤           ⎞\r\n⎜⎢                           ⎥           ⎟\r\n⎜⎢0  1  0  -0.523809523809524⎥, (0, 1, 2)⎟\r\n⎜⎢                           ⎥           ⎟\r\n⎝⎣0  0  1  0.440476190476191 ⎦           ⎠\r\n\r\nIn [38]: dM.rref()[0].to_Matrix()\r\nOut[38]: \r\n⎡1.0  5.55111512312578e-17    0.32258064516129      -0.548387096774194  ⎤\r\n⎢                                                                       ⎥\r\n⎢0.0          1.0           -1.22033022161007e+16  -5.37526407137769e+15⎥\r\n⎢                                                                       ⎥\r\n⎣0.0          0.0                    0.0                    0.0         ⎦\r\n\r\nIn [39]: dM.to_dense().rref()[0].to_Matrix()\r\nOut[39]: \r\n⎡1.0  0.0  0.0  -0.69047619047619 ⎤\r\n⎢                                 ⎥\r\n⎢0.0  1.0  0.0  -0.523809523809524⎥\r\n⎢                                 ⎥\r\n⎣0.0  0.0  1.0   0.44047619047619 ⎦\r\n```\nThe last one was a similar problem to do with cancelling above the pivot:\r\n```diff\r\ndiff --git a/sympy/polys/matrices/sdm.py b/sympy/polys/matrices/sdm.py\r\nindex cfa624185a..7c4ad43660 100644\r\n--- a/sympy/polys/matrices/sdm.py\r\n+++ b/sympy/polys/matrices/sdm.py\r\n@@ -904,6 +904,8 @@ def sdm_irref(A):\r\n             Ajnz = set(Aj)\r\n             for k in Ajnz - Ainz:\r\n                 Ai[k] = - Aij * Aj[k]\r\n+            Ai.pop(j)\r\n+            Ainz.remove(j)\r\n             for k in Ajnz & Ainz:\r\n                 Aik = Ai[k] - Aij * Aj[k]\r\n                 if Aik:\r\n@@ -938,6 +940,8 @@ def sdm_irref(A):\r\n             for l in Ainz - Aknz:\r\n                 Ak[l] = - Akj * Ai[l]\r\n                 nonzero_columns[l].add(k)\r\n+            Ak.pop(j)\r\n+            Aknz.remove(j)\r\n             for l in Ainz & Aknz:\r\n                 Akl = Ak[l] - Akj * Ai[l]\r\n                 if Akl:\r\ndiff --git a/sympy/polys/matrices/tests/test_linsolve.py b/sympy/polys/matrices/tests/test_linsolve.py\r\nindex eda4cdbdf3..6b79842fa7 100644\r\n--- a/sympy/polys/matrices/tests/test_linsolve.py\r\n+++ b/sympy/polys/matrices/tests/test_linsolve.py\r\n@@ -7,7 +7,7 @@\r\n from sympy.testing.pytest import raises\r\n \r\n from sympy import S, Eq, I\r\n-from sympy.abc import x, y\r\n+from sympy.abc import x, y, z\r\n \r\n from sympy.polys.matrices.linsolve import _linsolve\r\n from sympy.polys.solvers import PolyNonlinearError\r\n@@ -23,6 +23,14 @@ def test__linsolve():\r\n     raises(PolyNonlinearError, lambda: _linsolve([x*(1 + x)], [x]))\r\n \r\n \r\n+def test__linsolve_float():\r\n+    assert _linsolve([Eq(y, x), Eq(y, 0.0216 * x)], (x, y)) == {x:0, y:0}\r\n+\r\n+    eqs = [0.8*x + 0.8*z + 0.2, 0.9*x + 0.7*y + 0.2*z + 0.9, 0.7*x + 0.2*y + 0.2*z + 0.5]\r\n+    sol = {x:-0.69047619047619047, y:-0.52380952380952395, z:0.44047619047619047}\r\n+    assert _linsolve(eqs, [x,y,z]) == sol\r\n+\r\n+\r\n def test__linsolve_deprecated():\r\n     assert _linsolve([Eq(x**2, x**2+y)], [x, y]) == {x:x, y:S.Zero}\r\n     assert _linsolve([(x+y)**2-x**2], [x]) == {x:-y/2}\r\n```\r\nAnother problem has emerged though:\r\n```python\r\nIn [1]: eqs = [0.9*x + 0.3*y + 0.4*z + 0.6, 0.6*x + 0.9*y + 0.1*z + 0.7, 0.4*x + 0.6*y + 0.9*z + 0.5]\r\n\r\nIn [2]: linsolve(eqs, [x, y, z])\r\nOut[2]: {(-0.5, -0.4375, -0.0400000000000001)}\r\n\r\nIn [3]: solve(eqs, [x, y, z])\r\nOut[3]: {x: -0.502857142857143, y: -0.438095238095238, z: -0.04}\r\n```\n> Another problem has emerged though:\r\n> \r\n> ```python\r\n> In [1]: eqs = [0.9*x + 0.3*y + 0.4*z + 0.6, 0.6*x + 0.9*y + 0.1*z + 0.7, 0.4*x + 0.6*y + 0.9*z + 0.5]\r\n> ```\r\n\r\nIn this case the problem is that something like `1e-17` is chosen (incorrectly) as a pivot. It doesn't look easy to resolve this because the `sdm_rref` routine doesn't have an easy way of incorporating pivoting and is really designed for exact domains.\r\n\r\nProbably float matrices should be handled by mpmath or at least a separate routine.",
  "created_at": "2021-05-26T23:53:16Z",
  "version": "1.9",
  "FAIL_TO_PASS": "[\"test__linsolve_float\", \"test_construct_domain\", \"test_Poly__new__\"]",
  "PASS_TO_PASS": "[\"test__linsolve\", \"test_complex_exponential\", \"test_composite_option\", \"test_precision\", \"test_Poly_mixed_operations\", \"test_Poly_from_dict\", \"test_Poly_from_list\", \"test_Poly_from_poly\", \"test_Poly_from_expr\", \"test_poly_from_domain_element\", \"test_Poly__args\", \"test_Poly__gens\", \"test_Poly_zero\", \"test_Poly_one\", \"test_Poly__unify\", \"test_Poly_free_symbols\", \"test_PurePoly_free_symbols\", \"test_Poly__eq__\", \"test_PurePoly__eq__\", \"test_PurePoly_Poly\", \"test_Poly_get_domain\", \"test_Poly_set_domain\", \"test_Poly_get_modulus\", \"test_Poly_set_modulus\", \"test_Poly_add_ground\", \"test_Poly_sub_ground\", \"test_Poly_mul_ground\", \"test_Poly_quo_ground\", \"test_Poly_exquo_ground\", \"test_Poly_abs\", \"test_Poly_neg\", \"test_Poly_add\", \"test_Poly_sub\", \"test_Poly_mul\", \"test_issue_13079\", \"test_Poly_sqr\", \"test_Poly_pow\", \"test_Poly_divmod\", \"test_Poly_eq_ne\", \"test_Poly_nonzero\", \"test_Poly_properties\", \"test_Poly_is_irreducible\", \"test_Poly_subs\", \"test_Poly_replace\", \"test_Poly_reorder\", \"test_Poly_ltrim\", \"test_Poly_has_only_gens\", \"test_Poly_to_ring\", \"test_Poly_to_field\", \"test_Poly_to_exact\", \"test_Poly_retract\", \"test_Poly_slice\", \"test_Poly_coeffs\", \"test_Poly_monoms\", \"test_Poly_terms\", \"test_Poly_all_coeffs\", \"test_Poly_all_monoms\", \"test_Poly_all_terms\", \"test_Poly_termwise\", \"test_Poly_length\", \"test_Poly_as_dict\", \"test_Poly_as_expr\", \"test_Poly_lift\", \"test_Poly_deflate\", \"test_Poly_inject\", \"test_Poly_eject\", \"test_Poly_exclude\", \"test_Poly__gen_to_level\", \"test_Poly_degree\", \"test_Poly_degree_list\", \"test_Poly_total_degree\", \"test_Poly_homogenize\", \"test_Poly_homogeneous_order\", \"test_Poly_LC\", \"test_Poly_TC\", \"test_Poly_EC\", \"test_Poly_coeff\", \"test_Poly_nth\", \"test_Poly_LM\", \"test_Poly_LM_custom_order\", \"test_Poly_EM\", \"test_Poly_LT\", \"test_Poly_ET\", \"test_Poly_max_norm\", \"test_Poly_l1_norm\", \"test_Poly_clear_denoms\", \"test_Poly_rat_clear_denoms\", \"test_issue_20427\", \"test_Poly_integrate\", \"test_Poly_diff\", \"test_issue_9585\", \"test_Poly_eval\", \"test_Poly___call__\", \"test_parallel_poly_from_expr\", \"test_pdiv\", \"test_div\", \"test_issue_7864\", \"test_gcdex\", \"test_revert\", \"test_subresultants\", \"test_resultant\", \"test_discriminant\", \"test_dispersion\", \"test_gcd_list\", \"test_lcm_list\", \"test_gcd\", \"test_gcd_numbers_vs_polys\", \"test_terms_gcd\", \"test_trunc\", \"test_monic\", \"test_content\", \"test_primitive\", \"test_compose\", \"test_shift\", \"test_transform\", \"test_sturm\", \"test_gff\", \"test_norm\", \"test_sqf_norm\", \"test_sqf\", \"test_factor\", \"test_factor_large\", \"test_factor_noeval\", \"test_intervals\", \"test_refine_root\", \"test_count_roots\", \"test_Poly_root\", \"test_real_roots\", \"test_all_roots\", \"test_nroots\", \"test_ground_roots\", \"test_nth_power_roots_poly\", \"test_torational_factor_list\", \"test_cancel\", \"test_reduced\", \"test_groebner\", \"test_fglm\", \"test_is_zero_dimensional\", \"test_GroebnerBasis\", \"test_poly\", \"test_keep_coeff\", \"test_poly_matching_consistency\", \"test_issue_5786\", \"test_noncommutative\", \"test_to_rational_coeffs\", \"test_factor_terms\", \"test_as_list\", \"test_issue_11198\", \"test_Poly_precision\", \"test_issue_12400\", \"test_issue_14364\", \"test_issue_15669\", \"test_issue_17988\", \"test_issue_18205\", \"test_issue_8695\", \"test_issue_19113\", \"test_issue_19360\", \"test_poly_copy_equals_original\", \"test_deserialized_poly_equals_original\", \"test_issue_20389\"]",
  "environment_setup_commit": "f9a6f50ec0c74d935c50a6e9c9b2cb0469570d91",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.144100",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}