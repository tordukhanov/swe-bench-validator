{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-21436",
  "base_commit": "45d4e5f7fe1ac8bcdfa425bbac722481d2ec183f",
  "patch": "diff --git a/sympy/physics/vector/frame.py b/sympy/physics/vector/frame.py\n--- a/sympy/physics/vector/frame.py\n+++ b/sympy/physics/vector/frame.py\n@@ -4,6 +4,8 @@\n from sympy.physics.vector.vector import Vector, _check_vector\n from sympy.utilities.misc import translate\n \n+from warnings import warn\n+\n __all__ = ['CoordinateSym', 'ReferenceFrame']\n \n \n@@ -554,6 +556,25 @@ def _dcm(self, parent, parent_orient):\n             self._dcm_dict = self._dlist[0] = {}\n         # Reset the _dcm_cache\n             self._dcm_cache = {}\n+\n+        else:\n+        #Check for loops and raise warning accordingly.\n+            visited = []\n+            queue = list(frames)\n+            cont = True #Flag to control queue loop.\n+            while queue and cont:\n+                node = queue.pop(0)\n+                if node not in visited:\n+                    visited.append(node)\n+                    neighbors = node._dcm_dict.keys()\n+                    for neighbor in neighbors:\n+                        if neighbor == parent:\n+                            warn('Loops are defined among the orientation of frames.' + \\\n+                                ' This is likely not desired and may cause errors in your calculations.')\n+                            cont = False\n+                            break\n+                        queue.append(neighbor)\n+\n         # Add the dcm relationship to _dcm_dict\n         self._dcm_dict.update({parent: parent_orient.T})\n         parent._dcm_dict.update({self: parent_orient})\n@@ -579,6 +600,12 @@ def orient_axis(self, parent, axis, angle):\n         angle : sympifiable\n             Angle in radians by which it the frame is to be rotated.\n \n+        Warns\n+        ======\n+\n+        UserWarning\n+            If the orientation creates a kinematic loop.\n+\n         Examples\n         ========\n \n@@ -657,6 +684,12 @@ def orient_explicit(self, parent, dcm):\n             Direction cosine matrix that specifies the relative rotation\n             between the two reference frames.\n \n+        Warns\n+        ======\n+\n+        UserWarning\n+            If the orientation creates a kinematic loop.\n+\n         Examples\n         ========\n \n@@ -761,6 +794,12 @@ def orient_body_fixed(self, parent, angles, rotation_order):\n             Tait-Bryan): zxz, xyx, yzy, zyz, xzx, yxy, xyz, yzx, zxy, xzy, zyx,\n             and yxz.\n \n+        Warns\n+        ======\n+\n+        UserWarning\n+            If the orientation creates a kinematic loop.\n+\n         Examples\n         ========\n \n@@ -773,6 +812,7 @@ def orient_body_fixed(self, parent, angles, rotation_order):\n         >>> B = ReferenceFrame('B')\n         >>> B1 = ReferenceFrame('B1')\n         >>> B2 = ReferenceFrame('B2')\n+        >>> B3 = ReferenceFrame('B3')\n \n         For example, a classic Euler Angle rotation can be done by:\n \n@@ -790,8 +830,8 @@ def orient_body_fixed(self, parent, angles, rotation_order):\n \n         >>> B1.orient_axis(N, N.x, q1)\n         >>> B2.orient_axis(B1, B1.y, q2)\n-        >>> B.orient_axis(B2, B2.x, q3)\n-        >>> B.dcm(N)\n+        >>> B3.orient_axis(B2, B2.x, q3)\n+        >>> B3.dcm(N)\n         Matrix([\n         [        cos(q2),                            sin(q1)*sin(q2),                           -sin(q2)*cos(q1)],\n         [sin(q2)*sin(q3), -sin(q1)*sin(q3)*cos(q2) + cos(q1)*cos(q3),  sin(q1)*cos(q3) + sin(q3)*cos(q1)*cos(q2)],\n@@ -871,6 +911,12 @@ def orient_space_fixed(self, parent, angles, rotation_order):\n             ``'131'``, or the integer ``131``. There are 12 unique valid\n             rotation orders.\n \n+        Warns\n+        ======\n+\n+        UserWarning\n+            If the orientation creates a kinematic loop.\n+\n         Examples\n         ========\n \n@@ -883,6 +929,7 @@ def orient_space_fixed(self, parent, angles, rotation_order):\n         >>> B = ReferenceFrame('B')\n         >>> B1 = ReferenceFrame('B1')\n         >>> B2 = ReferenceFrame('B2')\n+        >>> B3 = ReferenceFrame('B3')\n \n         >>> B.orient_space_fixed(N, (q1, q2, q3), '312')\n         >>> B.dcm(N)\n@@ -895,8 +942,8 @@ def orient_space_fixed(self, parent, angles, rotation_order):\n \n         >>> B1.orient_axis(N, N.z, q1)\n         >>> B2.orient_axis(B1, N.x, q2)\n-        >>> B.orient_axis(B2, N.y, q3)\n-        >>> B.dcm(N).simplify()\n+        >>> B3.orient_axis(B2, N.y, q3)\n+        >>> B3.dcm(N).simplify()\n         Matrix([\n         [ sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3), sin(q1)*cos(q2), sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1)],\n         [-sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1), cos(q1)*cos(q2), sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3)],\n@@ -992,6 +1039,12 @@ def orient_quaternion(self, parent, numbers):\n             The four quaternion scalar numbers as defined above: ``q0``,\n             ``q1``, ``q2``, ``q3``.\n \n+        Warns\n+        ======\n+\n+        UserWarning\n+            If the orientation creates a kinematic loop.\n+\n         Examples\n         ========\n \n@@ -1098,6 +1151,12 @@ def orient(self, parent, rot_type, amounts, rot_order=''):\n             ``'123'`` and integer ``123`` are equivalent, for example. Required\n             for ``'Body'`` and ``'Space'``.\n \n+        Warns\n+        ======\n+\n+        UserWarning\n+            If the orientation creates a kinematic loop.\n+\n         \"\"\"\n \n         _check_frame(parent)\n",
  "test_patch": "diff --git a/sympy/physics/vector/tests/test_frame.py b/sympy/physics/vector/tests/test_frame.py\n--- a/sympy/physics/vector/tests/test_frame.py\n+++ b/sympy/physics/vector/tests/test_frame.py\n@@ -6,6 +6,7 @@\n from sympy.physics.vector.frame import _check_frame\n from sympy.physics.vector.vector import VectorTypeError\n from sympy.testing.pytest import raises\n+import warnings\n \n Vector.simp = True\n \n@@ -472,6 +473,22 @@ def test_orient_quaternion():\n     B.orient_quaternion(A, (0,0,0,0))\n     assert B.dcm(A) == Matrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]])\n \n+def test_looped_frame_warning():\n+    A = ReferenceFrame('A')\n+    B = ReferenceFrame('B')\n+    C = ReferenceFrame('C')\n+\n+    a, b, c = symbols('a b c')\n+    B.orient_axis(A, A.x, a)\n+    C.orient_axis(B, B.x, b)\n+\n+    with warnings.catch_warnings(record = True) as w:\n+        warnings.simplefilter(\"always\")\n+        A.orient_axis(C, C.x, c)\n+        assert issubclass(w[-1].category, UserWarning)\n+        assert 'Loops are defined among the orientation of frames. ' + \\\n+            'This is likely not desired and may cause errors in your calculations.' in str(w[-1].message)\n+\n def test_frame_dict():\n     A = ReferenceFrame('A')\n     B = ReferenceFrame('B')\n",
  "problem_statement": "Support orienting adjacent reference frames in arbitrary orders\nSuppose you want to establish relative orientation among frames A, B, C, D, and E as such:\r\n\r\n```\r\nA ----- B\r\n|\r\n|-------C----D\r\n        |\r\n        |----E\r\n```\r\n\r\nA is the root of the tree, B, D, and E are leaves. You do this now with code that looks like:\r\n\r\n```python\r\nB.orient(A)\r\nC.orient(A)\r\nD.orient(C)\r\nE.orient(C)\r\n```\r\n\r\nThis will establish rotation matrices for each connection in the above graph. But a user may, for whatever reason, do something like (call this the alternative use case):\r\n\r\n```python\r\nB.orient(A)\r\nA.orient(C)\r\nC.orient(D)\r\nE.orient(C)\r\n```\r\nThis currently does not work because with every call of `X.orient()` all adjacent relationships to `X` will be cleared. That is, calling `.orient()` assumes `self`'s orientation relationships should be overwritten. This is sometimes needed, for example if I do:\r\n\r\n```python\r\nB.orient(A, ...)\r\nA.orient(B, ...)\r\n```\r\n\r\nAnything that was defined in `B.orient(A, ...)` should be fully replaced with the relationships established with `A.orient(B, ...)` because they may be inconsistent with each other. Or if a user tries to do a loop:\r\n\r\n```python\r\nB.orient(A)\r\nC.orient(B)\r\nA.orient(C)\r\n```\r\n\r\nThe last line should raise an error and say something like \"Loops in graph not allowed\", but what it does is overwrites all relationships to `A` in the last line, effectively undoing the first line.\r\n\r\nThe alternative use case should work. There is no reason we shouldn't allow construction of the graph in any sequence. Overwriting the relationships to `self` in calls to `orient()` is unnecessary. I think it was implemented like that because it was easier than checking the graph for consistency in a more thorough way.\r\n\r\nI think the relationships between points do not have this issue and you can establish them in any order you like. It would be nice if frames also allowed that.\r\n\r\nHere is some code that shows how the method `ReferenceFrame._dcm()` wipes relationships of `self`:\r\n\r\n```ipython\r\nIPython 7.21.0 -- An enhanced Interactive Python. Type '?' for help.\r\n\r\nIn [1]: import sympy as sm\r\n\r\nIn [2]: import sympy.physics.mechanics as me\r\n\r\nIn [3]: A, B, C = sm.symbols(\"A, B, C\", cls=me.ReferenceFrame)\r\n\r\nIn [4]: a, b, c = sm.symbols('a, b, c')\r\n\r\nIn [5]: B.orient(A, 'Axis', (a, A.x))\r\n\r\nIn [6]: A._dcm_dict\r\nOut[6]: \r\n{B: Matrix([\r\n [1,      0,       0],\r\n [0, cos(a), -sin(a)],\r\n [0, sin(a),  cos(a)]])}\r\n\r\nIn [7]: B._dcm_dict\r\nOut[7]: \r\n{A: Matrix([\r\n [1,       0,      0],\r\n [0,  cos(a), sin(a)],\r\n [0, -sin(a), cos(a)]])}\r\n\r\nIn [8]: C._dcm_dict\r\nOut[8]: {}\r\n\r\nIn [9]: B.orient(C, 'Axis', (b, C.x))\r\n\r\nIn [10]: A._dcm_dict\r\nOut[10]: {}\r\n\r\nIn [11]: B._dcm_dict\r\nOut[11]: \r\n{C: Matrix([\r\n [1,       0,      0],\r\n [0,  cos(b), sin(b)],\r\n [0, -sin(b), cos(b)]])}\r\n\r\nIn [12]: C._dcm_dict\r\nOut[12]: \r\n{B: Matrix([\r\n [1,      0,       0],\r\n [0, cos(b), -sin(b)],\r\n [0, sin(b),  cos(b)]])}\r\n\r\nIn [13]: sm.__version__\r\nOut[13]: '1.7.1'\r\n```\n",
  "hints_text": "@angadhn I've opened an issue for this topic that we discussed last night.\nA minimum enhancement here would be to explain in the various `.orient*()` documentation that any call to `X.orient*()` will remove any prior relationships to `X` and that to construct a chain or tree of relative oriented reference frames requires that only un-oriented  frames can be added to the ends of the chain/branches.\nI'm adding a reference to a previously closed/rejected pull request here. #13824\r\nIt is very similar, however, the solution there was to allow loops in a graph.\r\n\n> Or if a user tries to do a loop:\n> \n> ```python\n> B.orient(A)\n> C.orient(B)\n> A.orient(C)\n> ```\n> \n> The last line should raise an error and say something like \"Loops in graph not allowed\", but what it does is overwrites all relationships to `A` in the last line, effectively undoing the first line.\n> \n> The alternative use case should work. There is no reason we shouldn't allow construction of the graph in any sequence. Overwriting the relationships to `self` in calls to `orient()` is unnecessary. I think it was implemented like that because it was easier than checking the graph for consistency in a more thorough way.\n> \n> I think the relationships between points do not have this issue and you can establish them in any order you like. It would be nice if frames also allowed that.\n\n\n#21271 fixed almost all of the problems mentioned here. Only this part is left to be done.\n@moorepants I was wondering if instead of giving error in case of loops in frames, shouldn't we raise `warning`  as we did in velocity.\n> @moorepants I was wondering if instead of giving error in case of loops in frames, shouldn't we raise `warning`  as we did in velocity.\n\n@moorepants So it should be a warning or an error?\nI guess we should be consistent with what we did with point relationships.",
  "created_at": "2021-05-06T06:38:29Z",
  "version": "1.9",
  "FAIL_TO_PASS": "[\"test_looped_frame_warning\"]",
  "PASS_TO_PASS": "[\"test_dict_list\", \"test_coordinate_vars\", \"test_ang_vel\", \"test_dcm\", \"test_w_diff_dcm1\", \"test_w_diff_dcm2\", \"test_orientnew_respects_parent_class\", \"test_orientnew_respects_input_indices\", \"test_orientnew_respects_input_latexs\", \"test_orientnew_respects_input_variables\", \"test_issue_10348\", \"test_issue_11503\", \"test_partial_velocity\", \"test_issue_11498\", \"test_reference_frame\", \"test_check_frame\", \"test_dcm_diff_16824\", \"test_orient_explicit\", \"test_orient_axis\", \"test_orient_body\", \"test_orient_space\", \"test_orient_quaternion\", \"test_frame_dict\"]",
  "environment_setup_commit": "f9a6f50ec0c74d935c50a6e9c9b2cb0469570d91",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.143704",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}