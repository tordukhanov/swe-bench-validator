{
  "repo": "matplotlib/matplotlib",
  "instance_id": "matplotlib__matplotlib-25772",
  "base_commit": "558f111d6f112fde91431be9f222e9359d4291ae",
  "patch": "diff --git a/lib/matplotlib/backends/qt_compat.py b/lib/matplotlib/backends/qt_compat.py\n--- a/lib/matplotlib/backends/qt_compat.py\n+++ b/lib/matplotlib/backends/qt_compat.py\n@@ -133,7 +133,8 @@ def _isdeleted(obj):\n     else:\n         raise ImportError(\n             \"Failed to import any of the following Qt binding modules: {}\"\n-            .format(\", \".join(_ETS.values())))\n+            .format(\", \".join([QT_API for _, QT_API in _candidates]))\n+        )\n else:  # We should not get there.\n     raise AssertionError(f\"Unexpected QT_API: {QT_API}\")\n _version_info = tuple(QtCore.QLibraryInfo.version().segments())\n",
  "test_patch": "diff --git a/lib/matplotlib/tests/test_backends_interactive.py b/lib/matplotlib/tests/test_backends_interactive.py\n--- a/lib/matplotlib/tests/test_backends_interactive.py\n+++ b/lib/matplotlib/tests/test_backends_interactive.py\n@@ -343,6 +343,26 @@ def test_qt5backends_uses_qt5():\n     _run_helper(_implcore, timeout=_test_timeout)\n \n \n+def _impl_missing():\n+    import sys\n+    # Simulate uninstalled\n+    sys.modules[\"PyQt6\"] = None\n+    sys.modules[\"PyQt5\"] = None\n+    sys.modules[\"PySide2\"] = None\n+    sys.modules[\"PySide6\"] = None\n+\n+    import matplotlib.pyplot as plt\n+    with pytest.raises(ImportError, match=\"Failed to import any of the following Qt\"):\n+        plt.switch_backend(\"qtagg\")\n+    # Specifically ensure that Pyside6/Pyqt6 are not in the error message for qt5agg\n+    with pytest.raises(ImportError, match=\"^(?:(?!(PySide6|PyQt6)).)*$\"):\n+        plt.switch_backend(\"qt5agg\")\n+\n+\n+def test_qt_missing():\n+    _run_helper(_impl_missing, timeout=_test_timeout)\n+\n+\n def _impl_test_cross_Qt_imports():\n     import sys\n     import importlib\n",
  "problem_statement": "[Bug]: VSCode matplotlib interactive mode cannot import Qt bindings\n### Bug summary\r\n\r\nRunning in VS Code interactive mode, `%matplotlib qt` throws an exception `ImportError: Failed to import any of the following Qt binding modules: PyQt6, PySide6, PyQt5, PySide2`. However, PySide6 is installed. \r\n\r\n<details>\r\n<summary>Error trace</summary>\r\n\r\n```\r\n---------------------------------------------------------------------------\r\nImportError                               Traceback (most recent call last)\r\n[c:\\Users\\nhl08\\code\\oct-invivo-analysis\\flatten.py](file:///C:/Users/nhl08/code/oct-invivo-analysis/flatten.py) in line 12\r\n      [13](file:///c%3A/Users/nhl08/code/oct-invivo-analysis/flatten.py?line=12) import matplotlib.pyplot as plt\r\n     [15](file:///c%3A/Users/nhl08/code/oct-invivo-analysis/flatten.py?line=14) from oct_utils import imshow, imshow2\r\n---> [17](file:///c%3A/Users/nhl08/code/oct-invivo-analysis/flatten.py?line=16) get_ipython().run_line_magic('matplotlib', 'qt')\r\n\r\nFile [c:\\Users\\nhl08\\miniconda3\\envs\\sim\\lib\\site-packages\\IPython\\core\\interactiveshell.py:2414](file:///C:/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/interactiveshell.py:2414), in InteractiveShell.run_line_magic(self, magic_name, line, _stack_depth)\r\n   [2412](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/interactiveshell.py?line=2411)     kwargs['local_ns'] = self.get_local_scope(stack_depth)\r\n   [2413](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/interactiveshell.py?line=2412) with self.builtin_trap:\r\n-> [2414](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/interactiveshell.py?line=2413)     result = fn(*args, **kwargs)\r\n   [2416](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/interactiveshell.py?line=2415) # The code below prevents the output from being displayed\r\n   [2417](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/interactiveshell.py?line=2416) # when using magics with decodator @output_can_be_silenced\r\n   [2418](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/interactiveshell.py?line=2417) # when the last Python token in the expression is a ';'.\r\n   [2419](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/interactiveshell.py?line=2418) if getattr(fn, magic.MAGIC_OUTPUT_CAN_BE_SILENCED, False):\r\n\r\nFile [c:\\Users\\nhl08\\miniconda3\\envs\\sim\\lib\\site-packages\\IPython\\core\\magics\\pylab.py:99](file:///C:/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/magics/pylab.py:99), in PylabMagics.matplotlib(self, line)\r\n     [97](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/magics/pylab.py?line=96)     print(\"Available matplotlib backends: %s\" % backends_list)\r\n     [98](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/magics/pylab.py?line=97) else:\r\n---> [99](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/magics/pylab.py?line=98)     gui, backend = self.shell.enable_matplotlib(args.gui.lower() if isinstance(args.gui, str) else args.gui)\r\n    [100](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/magics/pylab.py?line=99)     self._show_matplotlib_backend(args.gui, backend)\r\n\r\nFile [c:\\Users\\nhl08\\miniconda3\\envs\\sim\\lib\\site-packages\\IPython\\core\\interactiveshell.py:3600](file:///C:/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/interactiveshell.py:3600), in InteractiveShell.enable_matplotlib(self, gui)\r\n   [3596](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/interactiveshell.py?line=3595)         print('Warning: Cannot change to a different GUI toolkit: %s.'\r\n   [3597](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/interactiveshell.py?line=3596)                 ' Using %s instead.' % (gui, self.pylab_gui_select))\r\n   [3598](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/interactiveshell.py?line=3597)         gui, backend = pt.find_gui_and_backend(self.pylab_gui_select)\r\n-> [3600](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/interactiveshell.py?line=3599) pt.activate_matplotlib(backend)\r\n   [3601](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/interactiveshell.py?line=3600) configure_inline_support(self, backend)\r\n   [3603](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/interactiveshell.py?line=3602) # Now we must activate the gui pylab wants to use, and fix %run to take\r\n   [3604](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/interactiveshell.py?line=3603) # plot updates into account\r\n\r\nFile [c:\\Users\\nhl08\\miniconda3\\envs\\sim\\lib\\site-packages\\IPython\\core\\pylabtools.py:360](file:///C:/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/pylabtools.py:360), in activate_matplotlib(backend)\r\n    [355](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/pylabtools.py?line=354) # Due to circular imports, pyplot may be only partially initialised\r\n    [356](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/pylabtools.py?line=355) # when this function runs.\r\n    [357](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/pylabtools.py?line=356) # So avoid needing matplotlib attribute-lookup to access pyplot.\r\n    [358](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/pylabtools.py?line=357) from matplotlib import pyplot as plt\r\n--> [360](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/pylabtools.py?line=359) plt.switch_backend(backend)\r\n    [362](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/pylabtools.py?line=361) plt.show._needmain = False\r\n    [363](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/pylabtools.py?line=362) # We need to detect at runtime whether show() is called by the user.\r\n    [364](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/IPython/core/pylabtools.py?line=363) # For this, we wrap it into a decorator which adds a 'called' flag.\r\n\r\nFile [c:\\Users\\nhl08\\miniconda3\\envs\\sim\\lib\\site-packages\\matplotlib\\pyplot.py:271](file:///C:/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/pyplot.py:271), in switch_backend(newbackend)\r\n    [268](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/pyplot.py?line=267) # have to escape the switch on access logic\r\n    [269](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/pyplot.py?line=268) old_backend = dict.__getitem__(rcParams, 'backend')\r\n--> [271](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/pyplot.py?line=270) backend_mod = importlib.import_module(\r\n    [272](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/pyplot.py?line=271)     cbook._backend_module_name(newbackend))\r\n    [274](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/pyplot.py?line=273) required_framework = _get_required_interactive_framework(backend_mod)\r\n    [275](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/pyplot.py?line=274) if required_framework is not None:\r\n\r\nFile [c:\\Users\\nhl08\\miniconda3\\envs\\sim\\lib\\importlib\\__init__.py:126](file:///C:/Users/nhl08/miniconda3/envs/sim/lib/importlib/__init__.py:126), in import_module(name, package)\r\n    [124](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/importlib/__init__.py?line=123)             break\r\n    [125](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/importlib/__init__.py?line=124)         level += 1\r\n--> [126](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/importlib/__init__.py?line=125) return _bootstrap._gcd_import(name[level:], package, level)\r\n\r\nFile :1050, in _gcd_import(name, package, level)\r\n\r\nFile :1027, in _find_and_load(name, import_)\r\n\r\nFile :1006, in _find_and_load_unlocked(name, import_)\r\n\r\nFile :688, in _load_unlocked(spec)\r\n\r\nFile :883, in exec_module(self, module)\r\n\r\nFile :241, in _call_with_frames_removed(f, *args, **kwds)\r\n\r\nFile [c:\\Users\\nhl08\\miniconda3\\envs\\sim\\lib\\site-packages\\matplotlib\\backends\\backend_qt5agg.py:7](file:///C:/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/backend_qt5agg.py:7)\r\n      [4](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/backend_qt5agg.py?line=3) from .. import backends\r\n      [6](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/backend_qt5agg.py?line=5) backends._QT_FORCE_QT5_BINDING = True\r\n----> [7](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/backend_qt5agg.py?line=6) from .backend_qtagg import (    # noqa: F401, E402 # pylint: disable=W0611\r\n      [8](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/backend_qt5agg.py?line=7)     _BackendQTAgg, FigureCanvasQTAgg, FigureManagerQT, NavigationToolbar2QT,\r\n      [9](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/backend_qt5agg.py?line=8)     FigureCanvasAgg, FigureCanvasQT)\r\n     [12](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/backend_qt5agg.py?line=11) @_BackendQTAgg.export\r\n     [13](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/backend_qt5agg.py?line=12) class _BackendQT5Agg(_BackendQTAgg):\r\n     [14](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/backend_qt5agg.py?line=13)     pass\r\n\r\nFile [c:\\Users\\nhl08\\miniconda3\\envs\\sim\\lib\\site-packages\\matplotlib\\backends\\backend_qtagg.py:9](file:///C:/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/backend_qtagg.py:9)\r\n      [5](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/backend_qtagg.py?line=4) import ctypes\r\n      [7](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/backend_qtagg.py?line=6) from matplotlib.transforms import Bbox\r\n----> [9](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/backend_qtagg.py?line=8) from .qt_compat import QT_API, _enum\r\n     [10](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/backend_qtagg.py?line=9) from .backend_agg import FigureCanvasAgg\r\n     [11](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/backend_qtagg.py?line=10) from .backend_qt import QtCore, QtGui, _BackendQT, FigureCanvasQT\r\n\r\nFile [c:\\Users\\nhl08\\miniconda3\\envs\\sim\\lib\\site-packages\\matplotlib\\backends\\qt_compat.py:135](file:///C:/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/qt_compat.py:135)\r\n    [133](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/qt_compat.py?line=132)         break\r\n    [134](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/qt_compat.py?line=133)     else:\r\n--> [135](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/qt_compat.py?line=134)         raise ImportError(\r\n    [136](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/qt_compat.py?line=135)             \"Failed to import any of the following Qt binding modules: {}\"\r\n    [137](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/qt_compat.py?line=136)             .format(\", \".join(_ETS.values())))\r\n    [138](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/qt_compat.py?line=137) else:  # We should not get there.\r\n    [139](file:///c%3A/Users/nhl08/miniconda3/envs/sim/lib/site-packages/matplotlib/backends/qt_compat.py?line=138)     raise AssertionError(f\"Unexpected QT_API: {QT_API}\")\r\n\r\nImportError: Failed to import any of the following Qt binding modules: PyQt6, PySide6, PyQt5, PySide2\r\n```\r\n\r\n</details>\r\n\r\n### Code for reproduction\r\n\r\nRun in a VS Code interactive cell\r\n\r\n```python\r\n\r\n\r\n# %%\r\nimport matplotlib.pyplot as plt\r\n\r\n%matplotlib qt\r\n```\r\n\r\n### Additional information\r\n\r\nipykernel: 6.22.0\r\nipython: 8.12.0\r\nipywidgets: 8.0.6\r\n\r\n### Operating system\r\n\r\nWindows 10 and Windows 11 (2 separate computers)\r\n\r\n### Matplotlib Version\r\n\r\n3.7.1\r\n\r\n### Matplotlib Backend\r\n\r\nQt5Agg\r\n\r\n### Python version\r\n\r\n3.10.10\r\n\r\n### Jupyter version\r\n\r\n_No response_\r\n\r\n### Installation\r\n\r\npip\n",
  "hints_text": "Are you sure that pyside6 is installed in the environment that is being used for the terminal.\nYes. In the same interactive shell, I can run the following cell\r\n\r\n```python\r\n# %%\r\nimport PySide6\r\nprint(PySide6.__version__)  # Prints 6.5.0\r\n```\nWhen I start python from the command line and try to plot things, interactive plots work. It's only in VS Code interactive mode, when I try to enable interactive plots with `%matplotlib qt` does this happen.\nIf you import `pyside6` before you do `%matplotlib qt` does it work?\nIt does not unfortunately. Just tested in a fresh shell:\r\n\r\n```python\r\n# %%\r\nimport PySide6\r\nimport matplotlib.pyplot as plt\r\n\r\n%matplotlib qt\r\n```\r\n\r\n```\r\nImportError: Failed to import any of the following Qt binding modules: PyQt6, PySide6, PyQt5, PySide2\r\n```\r\n\r\nI also want to add that this has been happening to me for many months, on two separate machines (Windows 10 and Windows 11).\nCan you try the code in https://github.com/matplotlib/matplotlib/blob/bff46815c9b6b2300add1ed25f18b3d788b816de/lib/matplotlib/backends/qt_compat.py#L82-L89 to verify that works as expected?\r\n\r\ndoes `%gui qt` work?\r\n\r\nDoes\r\n\r\n```\r\nimport PySide6\r\nimport matplotlib.pyplot as plt\r\nplt.ion()\r\nfig, ax = plt.subplots()\r\n```\r\n\r\nwork?\r\n\r\nWhat version of pyside6?\r\n\r\nIn the shells where it works can you check\r\n\r\n```\r\nfig = plt.gcf() # or get a Figure object however you want\r\nprint(type(fig.canvas).mro()\r\n```\r\n\r\nto make sure it really is using pyside6 in those cases.\r\n\r\nSorry for asking many questions, I do not have a window system set up to reproduce this.\r\n\r\n\n> Can you try the code in\r\n> \r\n> https://github.com/matplotlib/matplotlib/blob/bff46815c9b6b2300add1ed25f18b3d788b816de/lib/matplotlib/backends/qt_compat.py#L82-L89\r\n> \r\n> to verify that works as expected?\r\n\r\n\r\nThis works if I run directly in the shell.\r\n\r\n> does `%gui qt` work?\r\n\r\nThis line runs without exception, but matplotlib would still use the Agg backend.\r\n\r\n> \r\n> Does\r\n> \r\n> ```\r\n> import PySide6\r\n> import matplotlib.pyplot as plt\r\n> plt.ion()\r\n> fig, ax = plt.subplots()\r\n> ```\r\n> \r\n> work?\r\n\r\nThis executes without exception, but the result plot is still `inline`.\r\n\r\n> \r\n> What version of pyside6?\r\n\r\n6.5.0\r\n\r\n> \r\n> In the shells where it works can you check\r\n> \r\n> ```\r\n> fig = plt.gcf() # or get a Figure object however you want\r\n> print(type(fig.canvas).mro()\r\n> ```\r\n> \r\n> to make sure it really is using pyside6 in those cases.\r\n\r\nIt's not using the PySide6 backend: `[<class 'matplotlib.backends.backend_agg.FigureCanvasAgg'>, <class 'matplotlib.backend_bases.FigureCanvasBase'>, <class 'object'>]`\r\n\r\n> Sorry for asking many questions, I do not have a window system set up to reproduce this.\r\n\r\nNo I understand. Thanks for your help. I'm an absolute noob with Windows but I need to develop native Windows apps for work :(\r\n\nCan you get a Pyside6 \"hello world\" app to work in the vscode terminal?\r\n\r\nAnother thing I just noticed is that there is \"conda\" in your paths, but you said you installed via pip.\r\n\r\nTry making a fresh environment and installing everything from conda.  Mixing conda and wheels can go bad in odd ways (see https://pypackaging-native.github.io).\r\n\r\nCan you try older versions of pyside?  \r\n\r\nIf you use\r\n\r\n```\r\nplt.switch('qtagg')\r\n```\r\n\r\nearly does that make any difference?\n`plt.switch_backend('qtagg')` gave the same error: `ImportError: Failed to import any of the following Qt binding modules: PyQt6, PySide6, PyQt5, PySide2`\r\n\r\nIn the same VS Code interactive shell, I can run the following hello world program with PySide6 and a Qt window pops up.\r\n\r\n```python\r\nfrom PySide6 import QtWidgets\r\n\r\napp = QtWidgets.QApplication()\r\nwin = QtWidgets.QWidget()\r\nwin.show()\r\napp.exec()\r\n```\r\n\r\nThis actually isn't specific to Windows and the above results are from an Ubuntu 22.04 machine.\nThe reason I'm using conda + pip: \r\n\r\n1. Conda is great at managing virtual environments. pip doesn't do that.\r\n2. My packages are all declared with a `pyproject.toml` file. I can then easily install my packages with `pip install .` and have `pip` manage the dependencies for me. I have yet to find a painless way to manage my own packages with `conda`. \r\n\r\nThat said, in this case, I'm exclusively using `pip` to manage packages in this environment and only using `conda` as the python version/virtual environment manager, which I heard is innocuous.\r\n\r\nRe: mixing conda env and pip - I just took a look, even `matplotlib` (when using `conda` virtual environments) needs to use `pip install -e .` to install `matplotlib`...: https://matplotlib.org/devdocs/devel/development_setup.html#create-a-dedicated-environment\nI can not reproduce this (I got the interactive window by right click -> \"run in interactive window\" on an empty file and selected the system Python (which on my system has enough of the stack installed) for the Python that vscode is using).\r\n\r\nLooking at the code in `qt_compat.py` can you sort out exactly what is failing when we try each of the bindings? \nI looked into `qt_compat.py`, and when I execute \r\n\r\n```python\r\nimport matplotlib.backends.qt_compat\r\nmatplotlib.backends.qt_compat._setup_pyqt5plus()\r\n```\r\n\r\nI get the same exception. \r\n\r\nHowever, I just found a fix! Since I know I'm using `PySide6`, I can run this line https://github.com/matplotlib/matplotlib/blob/bff46815c9b6b2300add1ed25f18b3d788b816de/lib/matplotlib/backends/qt_compat.py#L83 no problem, since `PySide6` has always been installed. Once I do that, the above imports of `qt_compat._setup_pyqt5plus()` works and `%matplotlib qt` works.\r\n\r\n```python\r\nfrom PySide6 import QtCore, QtGui, QtWidgets, __version__\r\nimport shiboken6\r\n```\nOk I stepped through `qt_compat.py` with a debugger and found the issue. \r\n\r\nWhen I run `%matplotlib qt`, mpl loads `qt_compat.py` which in turn executes the file. \r\n\r\n\r\n\r\nhttps://github.com/matplotlib/matplotlib/blob/bff46815c9b6b2300add1ed25f18b3d788b816de/lib/matplotlib/backends/qt_compat.py#L39-L46\r\n\r\nAfter this, `QT_API` remains undefined because no Qt bindings have been imported yet. So, we fall through to this case:\r\n\r\nhttps://github.com/matplotlib/matplotlib/blob/bff46815c9b6b2300add1ed25f18b3d788b816de/lib/matplotlib/backends/qt_compat.py#L47-L59\r\n\r\nFor my environment, `mpl.rcParams._get_backend_or_none()` returns `Qt5Agg`, even though I have no Qt5 bindings installed. Still, we run into this case\r\n\r\nhttps://github.com/matplotlib/matplotlib/blob/bff46815c9b6b2300add1ed25f18b3d788b816de/lib/matplotlib/backends/qt_compat.py#L56\r\n\r\nSo now, `QT_API = None` and `_QT_FORCE_QT5_BINDING = True`, and we fall though to this case while `_setup_qt5plus()` is never executed. \r\n\r\nhttps://github.com/matplotlib/matplotlib/blob/bff46815c9b6b2300add1ed25f18b3d788b816de/lib/matplotlib/backends/qt_compat.py#L115 \r\n\r\nObviously, we now get to this line since no Qt5 bindings are installed. \r\n\r\nhttps://github.com/matplotlib/matplotlib/blob/bff46815c9b6b2300add1ed25f18b3d788b816de/lib/matplotlib/backends/qt_compat.py#L134\r\n\r\nMy work around of importing `PySide6.QtCore` manually above basically negates this issue because once Qt6 bindings are in `sys.modules`, `qt_compat.py` would set `QT_API = QT_API_PYSIDE6`.\nOn a first pass look, it seems for me this is caused by https://github.com/matplotlib/matplotlib/blob/bff46815c9b6b2300add1ed25f18b3d788b816de/lib/matplotlib/backends/qt_compat.py#L56\r\n\r\nwhich if I check git blame, you committed https://github.com/matplotlib/matplotlib/commit/2bc0c1c4b97d00c0f6e849f799cc9a670a736238 \r\n\r\nSo the question is: is this line of forcing Qt5 causing this bug, or is it the fact that MPL is using `Qt5Agg` in my environment when I only have `Qt6` bindings installed the problem? Am not familiar with `Agg` backends and what they mean so would love your input\n> For my environment, mpl.rcParams._get_backend_or_none() returns Qt5Agg, even though I have no Qt5 bindings installed.\r\n\r\n\r\nThis says something in your system is setting the backend to 'qt5agg' which we take to mean \"I want to us Qt5\" (see https://github.com/matplotlib/matplotlib/pull/22005 and the linked issuse).  Is there something in your environment forcing the backend to `'qt5agg'`? Could be an `matplotlibrc` or a `mpl.use` in a start up script.\r\n\r\nThe bug to fix here is that if we are restricting to Qt5 then the error message should not list the Qt6 bindings!\r\n\nI doubt its an environment issue, since I can reproduce this problem on 3 separate machines (Windows 10, Windows 11, Ubuntu 22.04) with a clean conda environment. Could you point me to how mpl selects the default backend? I'm curious to see where in code MPL decides to use the `Qt5Agg` backend by default. I just tested again in a clean conda environment on Windows 10, with just `matplotlib` and `PySide6` installed, and trying `%matplotlib qt` still gives me that exception. Here's my pip list\r\n\r\n```\r\n(test) PS C:\\Users\\tnie\\code\\tmp> pip list\r\nPackage                       Version\r\n----------------------------- -------\r\nasttokens                     2.2.1\r\nbackcall                      0.2.0\r\nbackports.functools-lru-cache 1.6.4\r\ncolorama                      0.4.6\r\ncontourpy                     1.0.7\r\ncycler                        0.11.0\r\ndebugpy                       1.5.1\r\ndecorator                     5.1.1\r\nexecuting                     1.2.0\r\nfonttools                     4.39.3\r\nimportlib-metadata            6.6.0\r\nipykernel                     6.15.0\r\nipython                       8.12.0\r\njedi                          0.18.2\r\njupyter_client                8.2.0\r\njupyter_core                  5.3.0\r\nkiwisolver                    1.4.4\r\nmatplotlib                    3.7.1\r\nmatplotlib-inline             0.1.6\r\nnest-asyncio                  1.5.6\r\nnumpy                         1.24.3\r\npackaging                     23.1\r\nparso                         0.8.3\r\npickleshare                   0.7.5\r\nPillow                        9.5.0\r\npip                           23.0.1\r\nplatformdirs                  3.3.0\r\nprompt-toolkit                3.0.38\r\npsutil                        5.9.0\r\npure-eval                     0.2.2\r\nPygments                      2.15.1\r\npyparsing                     3.0.9\r\nPySide6                       6.5.0\r\nPySide6-Addons                6.5.0\r\nPySide6-Essentials            6.5.0\r\npython-dateutil               2.8.2\r\npywin32                       305.1\r\npyzmq                         23.2.0\r\nsetuptools                    66.0.0\r\nshiboken6                     6.5.0\r\nsix                           1.16.0\r\nstack-data                    0.6.2\r\ntornado                       6.2\r\ntraitlets                     5.9.0\r\ntyping_extensions             4.5.0\r\nwcwidth                       0.2.6\r\nwheel                         0.38.4\r\nzipp                          3.15.0\r\n```\n> I'm curious to see where in code MPL decides to use the Qt5Agg backend by default. \r\n\r\nIt should not, https://github.com/matplotlib/matplotlib/blob/b3bd929cf07ea35479fded8f739126ccc39edd6d/lib/matplotlib/pyplot.py#L233-L267 is our fallback logic which is why I think it is something else setting the backend to `'qt5agg'`. \nHere's are the exact steps to reproduce on Windows 10 and Windows 11.\r\n\r\n## 1. Create a clean Conda environment and install deps\r\n\r\n```\r\nconda create -y -n test python=3.10\r\nconda activate test\r\n# make sure env is actually active and make sure pip comes from this env.\r\npip install matplotlib ipykernel PySide6  # all packages are pip installed.\r\n```\r\n\r\n## 2. In VS Code interactive, run the following cells step by step\r\n\r\n```python\r\n# %%\r\nimport matplotlib.pyplot as plt\r\nimport matplotlib as mpl\r\n\r\n# %%\r\nmpl.get_backend()  # returns 'module://matplotlib_inline.backend_inline'\r\n\r\n# %%\r\nplt.plot(range(10))  # Plots inline OK\r\n\r\n# %%\r\nmpl.get_backend()  # Still returns 'module://matplotlib_inline.backend_inline'\r\n\r\n# %%\r\n%matplotlib qt\r\nplt.plot(range(10))  # ImportError: Failed to import any of the following Qt binding modules...\r\n\r\n# %%\r\nmpl.get_backend()  # returns 'Qt5Agg'\r\n\r\n```\n> > I'm curious to see where in code MPL decides to use the Qt5Agg backend by default.\r\n> \r\n> It should not,\r\n> \r\n> https://github.com/matplotlib/matplotlib/blob/b3bd929cf07ea35479fded8f739126ccc39edd6d/lib/matplotlib/pyplot.py#L233-L267\r\n> \r\n> is our fallback logic which is why I think it is something else setting the backend to `'qt5agg'`.\r\n\r\nI set a breakpoint on line 234 here, stepped through the code that raised the `ImportError`, and confirmed this branch was never hit.\nOk what the hell. The problem isn't with matplotlib, but IPython. I hardcore stepped through the code this time, and it turns out if you do **`%matplotlib qt`, `qt` always maps to `Qt5Agg`**. So if I only have Qt6 bindings, this would always break because IPython tells matplotlibto use `Qt5Agg` first, before matplotlib tries to actually import bindings.\r\n\r\nhttps://github.com/ipython/ipython/blob/main/IPython/core/pylabtools.py#L26\r\n\r\nhttps://github.com/ipython/ipython/blob/main/IPython/core/pylabtools.py#L301-L322\n(I was about to post the same link, in fact just for posterity, I'll post the permalink rather than the main branch which can change: https://github.com/ipython/ipython/blob/396593e7ad8cab3a9c36fb0f3e26cbf79cff069c/IPython/core/pylabtools.py#L26)\r\n\r\nShort term, you should be resolved by doing `%matplotlib qt6` instead... longer term, perhaps IPython should update that mapping.\r\n\r\nRegardless, going to close as this is not a change we can do, as far as I can tell",
  "created_at": "2023-04-26T16:12:12Z",
  "version": "3.7",
  "FAIL_TO_PASS": "[\"lib/matplotlib/tests/test_backends_interactive.py::test_qt_missing\"]",
  "PASS_TO_PASS": "[\"lib/matplotlib/tests/test_backends_interactive.py::test_lazy_auto_backend_selection\"]",
  "environment_setup_commit": "0849036fd992a2dd133a0cffc3f84f58ccf1840f",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.824825",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}