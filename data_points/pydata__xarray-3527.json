{
  "repo": "pydata/xarray",
  "instance_id": "pydata__xarray-3527",
  "base_commit": "c0ef2f616e87e9f924425bcd373ac265f14203cb",
  "patch": "diff --git a/xarray/core/groupby.py b/xarray/core/groupby.py\n--- a/xarray/core/groupby.py\n+++ b/xarray/core/groupby.py\n@@ -557,6 +557,59 @@ def fillna(self, value):\n         out = ops.fillna(self, value)\n         return out\n \n+    def quantile(self, q, dim=None, interpolation=\"linear\", keep_attrs=None):\n+        \"\"\"Compute the qth quantile over each array in the groups and\n+        concatenate them together into a new array.\n+\n+        Parameters\n+        ----------\n+        q : float in range of [0,1] (or sequence of floats)\n+            Quantile to compute, which must be between 0 and 1\n+            inclusive.\n+        dim : `...`, str or sequence of str, optional\n+            Dimension(s) over which to apply quantile.\n+            Defaults to the grouped dimension.\n+        interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n+            This optional parameter specifies the interpolation method to\n+            use when the desired quantile lies between two data points\n+            ``i < j``:\n+                * linear: ``i + (j - i) * fraction``, where ``fraction`` is\n+                  the fractional part of the index surrounded by ``i`` and\n+                  ``j``.\n+                * lower: ``i``.\n+                * higher: ``j``.\n+                * nearest: ``i`` or ``j``, whichever is nearest.\n+                * midpoint: ``(i + j) / 2``.\n+\n+        Returns\n+        -------\n+        quantiles : Variable\n+            If `q` is a single quantile, then the result is a\n+            scalar. If multiple percentiles are given, first axis of\n+            the result corresponds to the quantile. In either case a\n+            quantile dimension is added to the return array. The other\n+            dimensions are the dimensions that remain after the\n+            reduction of the array.\n+\n+        See Also\n+        --------\n+        numpy.nanpercentile, pandas.Series.quantile, Dataset.quantile,\n+        DataArray.quantile\n+        \"\"\"\n+        if dim is None:\n+            dim = self._group_dim\n+\n+        out = self.map(\n+            self._obj.__class__.quantile,\n+            shortcut=False,\n+            q=q,\n+            dim=dim,\n+            interpolation=interpolation,\n+            keep_attrs=keep_attrs,\n+        )\n+\n+        return out\n+\n     def where(self, cond, other=dtypes.NA):\n         \"\"\"Return elements from `self` or `other` depending on `cond`.\n \n@@ -737,60 +790,6 @@ def _combine(self, applied, restore_coord_dims=False, shortcut=False):\n         combined = self._maybe_unstack(combined)\n         return combined\n \n-    def quantile(self, q, dim=None, interpolation=\"linear\", keep_attrs=None):\n-        \"\"\"Compute the qth quantile over each array in the groups and\n-        concatenate them together into a new array.\n-\n-        Parameters\n-        ----------\n-        q : float in range of [0,1] (or sequence of floats)\n-            Quantile to compute, which must be between 0 and 1\n-            inclusive.\n-        dim : `...`, str or sequence of str, optional\n-            Dimension(s) over which to apply quantile.\n-            Defaults to the grouped dimension.\n-        interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n-            This optional parameter specifies the interpolation method to\n-            use when the desired quantile lies between two data points\n-            ``i < j``:\n-                * linear: ``i + (j - i) * fraction``, where ``fraction`` is\n-                  the fractional part of the index surrounded by ``i`` and\n-                  ``j``.\n-                * lower: ``i``.\n-                * higher: ``j``.\n-                * nearest: ``i`` or ``j``, whichever is nearest.\n-                * midpoint: ``(i + j) / 2``.\n-\n-        Returns\n-        -------\n-        quantiles : Variable\n-            If `q` is a single quantile, then the result\n-            is a scalar. If multiple percentiles are given, first axis of\n-            the result corresponds to the quantile and a quantile dimension\n-            is added to the return array. The other dimensions are the\n-            dimensions that remain after the reduction of the array.\n-\n-        See Also\n-        --------\n-        numpy.nanpercentile, pandas.Series.quantile, Dataset.quantile,\n-        DataArray.quantile\n-        \"\"\"\n-        if dim is None:\n-            dim = self._group_dim\n-\n-        out = self.map(\n-            self._obj.__class__.quantile,\n-            shortcut=False,\n-            q=q,\n-            dim=dim,\n-            interpolation=interpolation,\n-            keep_attrs=keep_attrs,\n-        )\n-\n-        if np.asarray(q, dtype=np.float64).ndim == 0:\n-            out = out.drop_vars(\"quantile\")\n-        return out\n-\n     def reduce(\n         self, func, dim=None, axis=None, keep_attrs=None, shortcut=True, **kwargs\n     ):\n",
  "test_patch": "diff --git a/xarray/tests/test_groupby.py b/xarray/tests/test_groupby.py\n--- a/xarray/tests/test_groupby.py\n+++ b/xarray/tests/test_groupby.py\n@@ -137,42 +137,58 @@ def test_da_groupby_empty():\n \n def test_da_groupby_quantile():\n \n-    array = xr.DataArray([1, 2, 3, 4, 5, 6], [(\"x\", [1, 1, 1, 2, 2, 2])])\n+    array = xr.DataArray(\n+        data=[1, 2, 3, 4, 5, 6], coords={\"x\": [1, 1, 1, 2, 2, 2]}, dims=\"x\"\n+    )\n \n     # Scalar quantile\n-    expected = xr.DataArray([2, 5], [(\"x\", [1, 2])])\n+    expected = xr.DataArray(\n+        data=[2, 5], coords={\"x\": [1, 2], \"quantile\": 0.5}, dims=\"x\"\n+    )\n     actual = array.groupby(\"x\").quantile(0.5)\n     assert_identical(expected, actual)\n \n     # Vector quantile\n-    expected = xr.DataArray([[1, 3], [4, 6]], [(\"x\", [1, 2]), (\"quantile\", [0, 1])])\n+    expected = xr.DataArray(\n+        data=[[1, 3], [4, 6]],\n+        coords={\"x\": [1, 2], \"quantile\": [0, 1]},\n+        dims=(\"x\", \"quantile\"),\n+    )\n     actual = array.groupby(\"x\").quantile([0, 1])\n     assert_identical(expected, actual)\n \n     # Multiple dimensions\n     array = xr.DataArray(\n-        [[1, 11, 26], [2, 12, 22], [3, 13, 23], [4, 16, 24], [5, 15, 25]],\n-        [(\"x\", [1, 1, 1, 2, 2]), (\"y\", [0, 0, 1])],\n+        data=[[1, 11, 26], [2, 12, 22], [3, 13, 23], [4, 16, 24], [5, 15, 25]],\n+        coords={\"x\": [1, 1, 1, 2, 2], \"y\": [0, 0, 1]},\n+        dims=(\"x\", \"y\"),\n     )\n \n     actual_x = array.groupby(\"x\").quantile(0, dim=...)\n-    expected_x = xr.DataArray([1, 4], [(\"x\", [1, 2])])\n+    expected_x = xr.DataArray(\n+        data=[1, 4], coords={\"x\": [1, 2], \"quantile\": 0}, dims=\"x\"\n+    )\n     assert_identical(expected_x, actual_x)\n \n     actual_y = array.groupby(\"y\").quantile(0, dim=...)\n-    expected_y = xr.DataArray([1, 22], [(\"y\", [0, 1])])\n+    expected_y = xr.DataArray(\n+        data=[1, 22], coords={\"y\": [0, 1], \"quantile\": 0}, dims=\"y\"\n+    )\n     assert_identical(expected_y, actual_y)\n \n     actual_xx = array.groupby(\"x\").quantile(0)\n     expected_xx = xr.DataArray(\n-        [[1, 11, 22], [4, 15, 24]], [(\"x\", [1, 2]), (\"y\", [0, 0, 1])]\n+        data=[[1, 11, 22], [4, 15, 24]],\n+        coords={\"x\": [1, 2], \"y\": [0, 0, 1], \"quantile\": 0},\n+        dims=(\"x\", \"y\"),\n     )\n     assert_identical(expected_xx, actual_xx)\n \n     actual_yy = array.groupby(\"y\").quantile(0)\n     expected_yy = xr.DataArray(\n-        [[1, 26], [2, 22], [3, 23], [4, 24], [5, 25]],\n-        [(\"x\", [1, 1, 1, 2, 2]), (\"y\", [0, 1])],\n+        data=[[1, 26], [2, 22], [3, 23], [4, 24], [5, 25]],\n+        coords={\"x\": [1, 1, 1, 2, 2], \"y\": [0, 1], \"quantile\": 0},\n+        dims=(\"x\", \"y\"),\n     )\n     assert_identical(expected_yy, actual_yy)\n \n@@ -180,14 +196,14 @@ def test_da_groupby_quantile():\n     x = [0, 1]\n     foo = xr.DataArray(\n         np.reshape(np.arange(365 * 2), (365, 2)),\n-        coords=dict(time=times, x=x),\n+        coords={\"time\": times, \"x\": x},\n         dims=(\"time\", \"x\"),\n     )\n     g = foo.groupby(foo.time.dt.month)\n \n     actual = g.quantile(0, dim=...)\n     expected = xr.DataArray(\n-        [\n+        data=[\n             0.0,\n             62.0,\n             120.0,\n@@ -201,12 +217,111 @@ def test_da_groupby_quantile():\n             610.0,\n             670.0,\n         ],\n-        [(\"month\", np.arange(1, 13))],\n+        coords={\"month\": np.arange(1, 13), \"quantile\": 0},\n+        dims=\"month\",\n     )\n     assert_identical(expected, actual)\n \n     actual = g.quantile(0, dim=\"time\")[:2]\n-    expected = xr.DataArray([[0.0, 1], [62.0, 63]], [(\"month\", [1, 2]), (\"x\", [0, 1])])\n+    expected = xr.DataArray(\n+        data=[[0.0, 1], [62.0, 63]],\n+        coords={\"month\": [1, 2], \"x\": [0, 1], \"quantile\": 0},\n+        dims=(\"month\", \"x\"),\n+    )\n+    assert_identical(expected, actual)\n+\n+\n+def test_ds_groupby_quantile():\n+    ds = xr.Dataset(\n+        data_vars={\"a\": (\"x\", [1, 2, 3, 4, 5, 6])}, coords={\"x\": [1, 1, 1, 2, 2, 2]}\n+    )\n+\n+    # Scalar quantile\n+    expected = xr.Dataset(\n+        data_vars={\"a\": (\"x\", [2, 5])}, coords={\"quantile\": 0.5, \"x\": [1, 2]}\n+    )\n+    actual = ds.groupby(\"x\").quantile(0.5)\n+    assert_identical(expected, actual)\n+\n+    # Vector quantile\n+    expected = xr.Dataset(\n+        data_vars={\"a\": ((\"x\", \"quantile\"), [[1, 3], [4, 6]])},\n+        coords={\"x\": [1, 2], \"quantile\": [0, 1]},\n+    )\n+    actual = ds.groupby(\"x\").quantile([0, 1])\n+    assert_identical(expected, actual)\n+\n+    # Multiple dimensions\n+    ds = xr.Dataset(\n+        data_vars={\n+            \"a\": (\n+                (\"x\", \"y\"),\n+                [[1, 11, 26], [2, 12, 22], [3, 13, 23], [4, 16, 24], [5, 15, 25]],\n+            )\n+        },\n+        coords={\"x\": [1, 1, 1, 2, 2], \"y\": [0, 0, 1]},\n+    )\n+\n+    actual_x = ds.groupby(\"x\").quantile(0, dim=...)\n+    expected_x = xr.Dataset({\"a\": (\"x\", [1, 4])}, coords={\"x\": [1, 2], \"quantile\": 0})\n+    assert_identical(expected_x, actual_x)\n+\n+    actual_y = ds.groupby(\"y\").quantile(0, dim=...)\n+    expected_y = xr.Dataset({\"a\": (\"y\", [1, 22])}, coords={\"y\": [0, 1], \"quantile\": 0})\n+    assert_identical(expected_y, actual_y)\n+\n+    actual_xx = ds.groupby(\"x\").quantile(0)\n+    expected_xx = xr.Dataset(\n+        {\"a\": ((\"x\", \"y\"), [[1, 11, 22], [4, 15, 24]])},\n+        coords={\"x\": [1, 2], \"y\": [0, 0, 1], \"quantile\": 0},\n+    )\n+    assert_identical(expected_xx, actual_xx)\n+\n+    actual_yy = ds.groupby(\"y\").quantile(0)\n+    expected_yy = xr.Dataset(\n+        {\"a\": ((\"x\", \"y\"), [[1, 26], [2, 22], [3, 23], [4, 24], [5, 25]])},\n+        coords={\"x\": [1, 1, 1, 2, 2], \"y\": [0, 1], \"quantile\": 0},\n+    ).transpose()\n+    assert_identical(expected_yy, actual_yy)\n+\n+    times = pd.date_range(\"2000-01-01\", periods=365)\n+    x = [0, 1]\n+    foo = xr.Dataset(\n+        {\"a\": ((\"time\", \"x\"), np.reshape(np.arange(365 * 2), (365, 2)))},\n+        coords=dict(time=times, x=x),\n+    )\n+    g = foo.groupby(foo.time.dt.month)\n+\n+    actual = g.quantile(0, dim=...)\n+    expected = xr.Dataset(\n+        {\n+            \"a\": (\n+                \"month\",\n+                [\n+                    0.0,\n+                    62.0,\n+                    120.0,\n+                    182.0,\n+                    242.0,\n+                    304.0,\n+                    364.0,\n+                    426.0,\n+                    488.0,\n+                    548.0,\n+                    610.0,\n+                    670.0,\n+                ],\n+            )\n+        },\n+        coords={\"month\": np.arange(1, 13), \"quantile\": 0},\n+    )\n+    assert_identical(expected, actual)\n+\n+    actual = g.quantile(0, dim=\"time\").isel(month=slice(None, 2))\n+    expected = xr.Dataset(\n+        data_vars={\"a\": ((\"month\", \"x\"), [[0.0, 1], [62.0, 63]])},\n+        coords={\"month\": [1, 2], \"x\": [0, 1], \"quantile\": 0},\n+    )\n     assert_identical(expected, actual)\n \n \n",
  "problem_statement": "DatasetGroupBy does not implement quantile\nThe docs claim `quantile` works on grouped datasets, but that does not seem to be the case:\r\n```python\r\n>>> import xarray as xr\r\n>>> ds = xr.Dataset(data_vars={\"a\": (\"x\", list(\"abcd\"))}, coords={\"x\": range(4)})\r\n>>> ds.a.groupby(ds.x % 2 == 0).quantile\r\n<bound method DataArrayGroupBy.quantile of DataArrayGroupBy, grouped over 'x' \r\n2 groups with labels False, True.>\r\n>>> ds.groupby(ds.x % 2 == 0).quantile\r\nAttributeError: 'DatasetGroupBy' object has no attribute 'quantile'\r\n```\r\nthis was found while trying to silence the nit-picky sphinx warnings in #3516\n",
  "hints_text": "while looking for related issues, I found #3018, so this seems to be known?\nOK, fine to leave this open since that's closed\nactually, I think the fix proposed in the old issue (move `DataArrayGroupBy.quantile` to `GroupBy`) should also silence the warnings, since the other methods in `GroupBy` work just fine?\nThat would be great if it's really that simple!\nthe warnings are still there, but at least the quantile works (assuming the tests cover it). I'll submit this as a PR.\nThank you!",
  "created_at": "2019-11-13T23:03:07Z",
  "version": "0.12",
  "FAIL_TO_PASS": "[\"xarray/tests/test_groupby.py::test_da_groupby_quantile\", \"xarray/tests/test_groupby.py::test_ds_groupby_quantile\"]",
  "PASS_TO_PASS": "[\"xarray/tests/test_groupby.py::test_consolidate_slices\", \"xarray/tests/test_groupby.py::test_groupby_dims_property\", \"xarray/tests/test_groupby.py::test_multi_index_groupby_map\", \"xarray/tests/test_groupby.py::test_multi_index_groupby_sum\", \"xarray/tests/test_groupby.py::test_groupby_da_datetime\", \"xarray/tests/test_groupby.py::test_groupby_duplicate_coordinate_labels\", \"xarray/tests/test_groupby.py::test_groupby_input_mutation\", \"xarray/tests/test_groupby.py::test_da_groupby_map_func_args\", \"xarray/tests/test_groupby.py::test_ds_groupby_map_func_args\", \"xarray/tests/test_groupby.py::test_da_groupby_empty\", \"xarray/tests/test_groupby.py::test_da_groupby_assign_coords\", \"xarray/tests/test_groupby.py::test_groupby_repr[obj0-z]\", \"xarray/tests/test_groupby.py::test_groupby_repr[obj1-z]\", \"xarray/tests/test_groupby.py::test_groupby_drops_nans\", \"xarray/tests/test_groupby.py::test_groupby_grouping_errors\", \"xarray/tests/test_groupby.py::test_groupby_reduce_dimension_error\", \"xarray/tests/test_groupby.py::test_groupby_bins_timeseries\"]",
  "environment_setup_commit": "1c198a191127c601d091213c4b3292a8bb3054e1",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.871671",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}