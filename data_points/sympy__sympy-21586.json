{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-21586",
  "base_commit": "1808affb21ee0dd5226134ad7b3bb9f1785d2e56",
  "patch": "diff --git a/sympy/abc.py b/sympy/abc.py\n--- a/sympy/abc.py\n+++ b/sympy/abc.py\n@@ -98,10 +98,10 @@\n while ns:\n     _k, _ = ns.popitem()\n     if _k in _greek:\n-        _clash2[_k] = Symbol(_k)\n+        _clash2[_k] = None\n         _greek.remove(_k)\n     elif _k in _latin:\n-        _clash1[_k] = Symbol(_k)\n+        _clash1[_k] = None\n         _latin.remove(_k)\n _clash = {}\n _clash.update(_clash1)\ndiff --git a/sympy/core/assumptions.py b/sympy/core/assumptions.py\n--- a/sympy/core/assumptions.py\n+++ b/sympy/core/assumptions.py\n@@ -385,6 +385,14 @@ def check_assumptions(expr, against=None, **assume):\n     >>> check_assumptions(2*x + 1, x)\n     True\n \n+    To see if a number matches the assumptions of an expression, pass\n+    the number as the first argument, else its specific assumptions\n+    may not have a non-None value in the expression:\n+\n+    >>> check_assumptions(x, 3)\n+    >>> check_assumptions(3, x)\n+    True\n+\n     ``None`` is returned if ``check_assumptions()`` could not conclude.\n \n     >>> check_assumptions(2*x - 1, x)\n@@ -399,8 +407,8 @@ def check_assumptions(expr, against=None, **assume):\n \n     \"\"\"\n     expr = sympify(expr)\n-    if against:\n-        if against is not None and assume:\n+    if against is not None:\n+        if assume:\n             raise ValueError(\n                 'Expecting `against` or `assume`, not both.')\n         assume = assumptions(against)\ndiff --git a/sympy/core/sympify.py b/sympy/core/sympify.py\n--- a/sympy/core/sympify.py\n+++ b/sympy/core/sympify.py\n@@ -180,8 +180,8 @@ def sympify(a, locals=None, convert_xor=True, strict=False, rational=False,\n     names that are defined in abc).\n \n     >>> from sympy.abc import _clash1\n-    >>> _clash1\n-    {'E': E, 'I': I, 'N': N, 'O': O, 'Q': Q, 'S': S}\n+    >>> set(_clash1)\n+    {'E', 'I', 'N', 'O', 'Q', 'S'}\n     >>> sympify('I & Q', _clash1)\n     I & Q\n \ndiff --git a/sympy/parsing/sympy_parser.py b/sympy/parsing/sympy_parser.py\n--- a/sympy/parsing/sympy_parser.py\n+++ b/sympy/parsing/sympy_parser.py\n@@ -13,7 +13,7 @@\n from sympy.core.compatibility import iterable\n from sympy.core.basic import Basic\n from sympy.core import Symbol\n-from sympy.core.function import arity\n+from sympy.core.function import arity, Function\n from sympy.utilities.misc import filldedent, func_name\n \n \n@@ -550,22 +550,23 @@ def auto_symbol(tokens, local_dict, global_dict):\n             name = tokVal\n \n             if (name in ['True', 'False', 'None']\n-                or iskeyword(name)\n-                # Don't convert attribute access\n-                or (prevTok[0] == OP and prevTok[1] == '.')\n-                # Don't convert keyword arguments\n-                or (prevTok[0] == OP and prevTok[1] in ('(', ',')\n-                    and nextTokNum == OP and nextTokVal == '=')):\n+                    or iskeyword(name)\n+                    # Don't convert attribute access\n+                    or (prevTok[0] == OP and prevTok[1] == '.')\n+                    # Don't convert keyword arguments\n+                    or (prevTok[0] == OP and prevTok[1] in ('(', ',')\n+                        and nextTokNum == OP and nextTokVal == '=')\n+                    # the name has already been defined\n+                    or name in local_dict and local_dict[name] is not None):\n                 result.append((NAME, name))\n                 continue\n             elif name in local_dict:\n-                if isinstance(local_dict[name], Symbol) and nextTokVal == '(':\n-                    result.extend([(NAME, 'Function'),\n-                                   (OP, '('),\n-                                   (NAME, repr(str(local_dict[name]))),\n-                                   (OP, ')')])\n+                local_dict.setdefault(None, set()).add(name)\n+                if nextTokVal == '(':\n+                    local_dict[name] = Function(name)\n                 else:\n-                    result.append((NAME, name))\n+                    local_dict[name] = Symbol(name)\n+                result.append((NAME, name))\n                 continue\n             elif name in global_dict:\n                 obj = global_dict[name]\n@@ -1013,8 +1014,15 @@ def parse_expr(s, local_dict=None, transformations=standard_transformations,\n         code = compile(evaluateFalse(code), '<string>', 'eval')\n \n     try:\n-        return eval_expr(code, local_dict, global_dict)\n+        rv = eval_expr(code, local_dict, global_dict)\n+        # restore neutral definitions for names\n+        for i in local_dict.pop(None, ()):\n+            local_dict[i] = None\n+        return rv\n     except Exception as e:\n+        # restore neutral definitions for names\n+        for i in local_dict.pop(None, ()):\n+            local_dict[i] = None\n         raise e from ValueError(f\"Error from parse_expr with transformed code: {code!r}\")\n \n \n",
  "test_patch": "diff --git a/sympy/core/tests/test_assumptions.py b/sympy/core/tests/test_assumptions.py\n--- a/sympy/core/tests/test_assumptions.py\n+++ b/sympy/core/tests/test_assumptions.py\n@@ -1238,6 +1238,7 @@ def test_assumptions_copy():\n \n \n def test_check_assumptions():\n+    assert check_assumptions(1, 0) is False\n     x = Symbol('x', positive=True)\n     assert check_assumptions(1, x) is True\n     assert check_assumptions(1, 1) is True\ndiff --git a/sympy/core/tests/test_sympify.py b/sympy/core/tests/test_sympify.py\n--- a/sympy/core/tests/test_sympify.py\n+++ b/sympy/core/tests/test_sympify.py\n@@ -530,10 +530,16 @@ def test_issue_6540_6552():\n def test_issue_6046():\n     assert str(S(\"Q & C\", locals=_clash1)) == 'C & Q'\n     assert str(S('pi(x)', locals=_clash2)) == 'pi(x)'\n-    assert str(S('pi(C, Q)', locals=_clash)) == 'pi(C, Q)'\n     locals = {}\n     exec(\"from sympy.abc import Q, C\", locals)\n     assert str(S('C&Q', locals)) == 'C & Q'\n+    # clash can act as Symbol or Function\n+    assert str(S('pi(C, Q)', locals=_clash)) == 'pi(C, Q)'\n+    assert len(S('pi + x', locals=_clash2).free_symbols) == 2\n+    # but not both\n+    raises(TypeError, lambda: S('pi + pi(x)', locals=_clash2))\n+    assert all(set(i.values()) == {None} for i in (\n+        _clash, _clash1, _clash2))\n \n \n def test_issue_8821_highprec_from_str():\ndiff --git a/sympy/parsing/tests/test_sympy_parser.py b/sympy/parsing/tests/test_sympy_parser.py\n--- a/sympy/parsing/tests/test_sympy_parser.py\n+++ b/sympy/parsing/tests/test_sympy_parser.py\n@@ -131,9 +131,8 @@ def test_local_dict_symbol_to_fcn():\n     x = Symbol('x')\n     d = {'foo': Function('bar')}\n     assert parse_expr('foo(x)', local_dict=d) == d['foo'](x)\n-    # XXX: bit odd, but would be error if parser left the Symbol\n     d = {'foo': Symbol('baz')}\n-    assert parse_expr('foo(x)', local_dict=d) == Function('baz')(x)\n+    raises(TypeError, lambda: parse_expr('foo(x)', local_dict=d))\n \n \n def test_global_dict():\n@@ -270,3 +269,11 @@ def test_python3_features():\n     assert parse_expr('.[3_4]') == parse_expr('.[34]') == Rational(34, 99)\n     assert parse_expr('.1[3_4]') == parse_expr('.1[34]') == Rational(133, 990)\n     assert parse_expr('123_123.123_123[3_4]') == parse_expr('123123.123123[34]') == Rational(12189189189211, 99000000)\n+\n+\n+def test_issue_19501():\n+    x = Symbol('x')\n+    eq = parse_expr('E**x(1+x)', local_dict={'x': x}, transformations=(\n+        standard_transformations +\n+        (implicit_multiplication_application,)))\n+    assert eq.free_symbols == {x}\n",
  "problem_statement": "parse_expr with local_dict\nI have 2 expressions that differ only in `*` after `E**x` and I want to parse it:\r\n```\r\n>>> from sympy.abc import x\r\n>>> transformations = (standard_transformations +\r\n                   (implicit_multiplication_application,))\r\n\r\n>>> expr1 = 'E**x*(1+2*x+(x+1)log(x+1))'\r\n>>> expr2 = 'E**x(1+2*x+(x+1)log(x+1))'\r\n\r\n>>> p1 = parse_expr(expr1, transformations=transformations)\r\n(2*x + (x + 1)*log(x + 1) + 1)*exp(x)\r\n>>> p1.subs(x, 1)\r\nE*(2*log(2) + 3)\r\n\r\n>>> p2 = parse_expr(expr2, transformations=transformations)\r\n(2*x + (x + 1)*log(x + 1) + 1)*exp(x)\r\n>>> p2.subs(x, 1)\r\nE*(2*log(2) + 3)\r\n\r\n>>> p2.subs(x, 1) - p1.subs(x, 1)\r\n0\r\n```\r\nRight, but if\r\n```\r\n>>> x = var('x', real=True)\r\n\r\n>>> p1 = parse_expr(expr1, transformations=transformations, local_dict={'x': x})\r\n(2*x + (x + 1)*log(x + 1) + 1)*exp(x)\r\n>>> p1.subs(x, 1)\r\nE*(2*log(2) + 3)\r\n\r\n>>> p2 = parse_expr(expr2, transformations=transformations, local_dict={'x': x})\r\n(2*x + (x + 1)*log(x + 1) + 1)*exp(x)\r\n>>> p2.subs(x, 1)\r\n(2*log(2) + 3)*exp(x)          ???\r\n\r\n>>> p2.subs(x, 1) - p1.subs(x, 1)\r\n(2*log(2) + 3)*exp(x) - E*(2*log(2) + 3)\r\n```\r\nAnd\r\n```\r\n>>> p1.atoms(Symbol)\r\n{x}\r\n>>> p2.atoms(Symbol)\r\n{x, x}\r\n```\r\nThank you!\n",
  "hints_text": "hmmm...how is that `x` in `exp` not making a request to locals -- or maybe during the parsing at that point the locals was not passed to the parsing subroutine. Not sure.\n@smichr any news?\nThis issue is important for me.\r\n\r\nI think there will be a wrong result after this:\r\n\r\nhttps://github.com/sympy/sympy/blob/dc54b1b44f5693772fc4ac698366a424a0845e6e/sympy/parsing/sympy_parser.py#L562\r\n\r\nWhy if is in `local_dict` this `Symbol` and next token is `(` â€” this is `Function`? Maybe it should be if this token in `local_dict` is `Function`?\r\n\r\n```python\r\nif isinstance(local_dict[name], Function) and nextTokVal == '(':\r\n```\r\n\r\nI could fix it myself, but maybe I just don't understand the author's idea. Thanks!\r\n\r\n@smichr \nIf anyone has the same problem, here is some code that might solve it:\r\n```python\r\na = parse_expr(\r\n    expr,\r\n    transformations=transformations,\r\n    local_dict=local_dict\r\n)\r\nsymbols = a.atoms(Symbol)\r\nfor symbol in symbols:\r\n    str_symbol = str(symbol)\r\n    if str_symbol in local_dict:\r\n        a = a.subs(symbol, local_dict[str_symbol])\r\n```\nI think this is a legacy issue -- formerly, Symbol would cast to a Function when followed by a left paren. Your proposal looks good.\nWith your change,\r\n```python\r\n>>> transformations = (standard_transformations +\r\n...                    (implicit_multiplication_application,))\r\n>>> expr2 = 'E**x(1+2*x+(x+1)log(x+1))'\r\n>>> x = var('x', real=True)\r\n>>> p22 = parse_expr(expr2, transformations=transformations, local_dict={'x': x}\r\n)\r\n>>> from sympy.core.symbol import disambiguate as f\r\n>>> f(p22)\r\n((2*x + (x + 1)*log(x + 1) + 1)*exp(x),)  <----- only one symbol, now\r\n```\nThere is one parsing failure (and there should be) in `test_local_dict_symbol_to_fcn`:\r\n```python\r\n>>> d = {'foo': Symbol('baz')}\r\n>>> parse_expr('foo(x)', transformations=transformations, local_dict=d)\r\nbaz*x\r\n>>> parse_expr('foo(x)', local_dict=d)\r\nValueError: Error from parse_expr with transformed code: \"foo (Symbol ('x' ))\"\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTraceback (most recent call last):\r\n...\r\nTypeError: 'Symbol' object is not callable\r\n```\nYes, why should a Symbol be a Function? If it is necessary to parse `foo` as a function, I think you need to specify it in the local_dict: `d = {'foo': Function('baz')}`\nI think the I line comment was a rationalization for allowing the legacy behaviour to continue. I think the proper thing to do is raise an error, not to override what the user has declared.\nI agree that the transformer shouldn't assume that Symbol()() creates a function since that behavior has been removed, but in general, parse_expr('f(x)') should parse as `Function('f')(Symbol('x'))` if `f` is not already defined. If you want the implicit multiplication to take precedence, you should move that transformer earlier, like `transformations = ((implicit_multiplication_application,) + standard_transformations)`.\nDoes it make sense for auto_symbol to just skip names entirely if they are already defined in the passed in namespace, or does that break something? \nThe error only raises if a name is encountered that is defined as a symbol that is being used as a function, or vice versa:\r\n\r\n```python\r\n>>> from sympy import *\r\n>>> from sympy.parsing import *\r\n>>> var('x')\r\nx\r\n>>> from sympy.parsing.sympy_parser import *\r\n>>> transformations = (standard_transformations +(implicit_multiplication_applic\r\nation,))\r\n>>> parse_expr('f(x)')\r\nf(x)\r\n>>> parse_expr('f(x)',local_dict={'x': Function('y')})\r\nValueError: Error from parse_expr with transformed code: \"Function ('f' )(x )\"\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTraceback (most recent call last):\r\n...\r\nTypeError: Invalid argument: expecting an expression, not UndefinedFunction: y\r\n>>> parse_expr('f(x)',local_dict={'f': Symbol('y')})\r\nValueError: Error from parse_expr with transformed code: \"f (Symbol ('x' ))\"\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTraceback (most recent call last):\r\n...\r\nTypeError: 'Symbol' object is not callable\r\n```\r\nThat with the diff\r\n```diff\r\ndiff --git a/sympy/parsing/sympy_parser.py b/sympy/parsing/sympy_parser.py\r\nindex a74e3a6540..2506663c02 100644\r\n--- a/sympy/parsing/sympy_parser.py\r\n+++ b/sympy/parsing/sympy_parser.py\r\n@@ -13,7 +13,7 @@\r\n from sympy.core.compatibility import iterable\r\n from sympy.core.basic import Basic\r\n from sympy.core import Symbol\r\n-from sympy.core.function import arity\r\n+from sympy.core.function import arity, Function\r\n from sympy.utilities.misc import filldedent, func_name\r\n \r\n \r\n@@ -559,7 +559,7 @@ def auto_symbol(tokens, local_dict, global_dict):\r\n                 result.append((NAME, name))\r\n                 continue\r\n             elif name in local_dict:\r\n-                if isinstance(local_dict[name], Symbol) and nextTokVal == '(':\r\n+                if isinstance(local_dict[name], Function) and nextTokVal == '(':\r\n                     result.extend([(NAME, 'Function'),\r\n                                    (OP, '('),\r\n                                    (NAME, repr(str(local_dict[name]))),\r\n```",
  "created_at": "2021-06-08T03:10:57Z",
  "version": "1.9",
  "FAIL_TO_PASS": "[\"test_check_assumptions\", \"test_issue_6046\", \"test_local_dict_symbol_to_fcn\"]",
  "PASS_TO_PASS": "[\"test_symbol_unset\", \"test_zero\", \"test_one\", \"test_negativeone\", \"test_infinity\", \"test_neg_infinity\", \"test_zoo\", \"test_nan\", \"test_pos_rational\", \"test_neg_rational\", \"test_pi\", \"test_E\", \"test_I\", \"test_symbol_real_false\", \"test_symbol_extended_real_false\", \"test_symbol_imaginary\", \"test_symbol_zero\", \"test_symbol_positive\", \"test_neg_symbol_positive\", \"test_symbol_nonpositive\", \"test_neg_symbol_nonpositive\", \"test_symbol_falsepositive\", \"test_symbol_falsepositive_mul\", \"test_neg_symbol_falsepositive\", \"test_neg_symbol_falsenegative\", \"test_symbol_falsepositive_real\", \"test_neg_symbol_falsepositive_real\", \"test_symbol_falsenonnegative\", \"test_symbol_falsenonnegative_real\", \"test_neg_symbol_falsenonnegative_real\", \"test_prime\", \"test_composite\", \"test_prime_symbol\", \"test_symbol_noncommutative\", \"test_other_symbol\", \"test_issue_3825\", \"test_issue_4822\", \"test_hash_vs_typeinfo\", \"test_hash_vs_typeinfo_2\", \"test_hash_vs_eq\", \"test_Add_is_pos_neg\", \"test_Add_is_imaginary\", \"test_Add_is_algebraic\", \"test_Mul_is_algebraic\", \"test_Pow_is_algebraic\", \"test_Mul_is_prime_composite\", \"test_Pow_is_pos_neg\", \"test_Pow_is_prime_composite\", \"test_Mul_is_infinite\", \"test_Add_is_infinite\", \"test_special_is_rational\", \"test_sanitize_assumptions\", \"test_special_assumptions\", \"test_inconsistent\", \"test_issue_6631\", \"test_issue_2730\", \"test_issue_4149\", \"test_issue_2920\", \"test_issue_7899\", \"test_issue_8075\", \"test_issue_8642\", \"test_issues_8632_8633_8638_8675_8992\", \"test_issue_9115_9150\", \"test_issue_9165\", \"test_issue_10024\", \"test_issue_10302\", \"test_complex_reciprocal_imaginary\", \"test_issue_16313\", \"test_issue_16579\", \"test_issue_17556\", \"test_assumptions_copy\", \"test_failing_assumptions\", \"test_issue_3538\", \"test_sympify1\", \"test_sympify_Fraction\", \"test_sympify_gmpy\", \"test_sympify_mpmath\", \"test_sympify2\", \"test_sympify3\", \"test_sympify_keywords\", \"test_sympify_float\", \"test_sympify_bool\", \"test_sympyify_iterables\", \"test_issue_16859\", \"test_sympify4\", \"test_sympify_text\", \"test_sympify_function\", \"test_sympify_poly\", \"test_sympify_factorial\", \"test_sage\", \"test_issue_3595\", \"test_lambda\", \"test_lambda_raises\", \"test_sympify_raises\", \"test__sympify\", \"test_sympifyit\", \"test_int_float\", \"test_evaluate_false\", \"test_issue_4133\", \"test_issue_3982\", \"test_S_sympify\", \"test_issue_4788\", \"test_issue_4798_None\", \"test_issue_3218\", \"test_issue_4988_builtins\", \"test_geometry\", \"test_kernS\", \"test_issue_6540_6552\", \"test_issue_8821_highprec_from_str\", \"test_Range\", \"test_sympify_set\", \"test_issue_5939\", \"test_issue_16759\", \"test_issue_17811\", \"test_sympy_parser\", \"test_rationalize\", \"test_factorial_fail\", \"test_repeated_fail\", \"test_repeated_dot_only\", \"test_local_dict\", \"test_local_dict_split_implmult\", \"test_global_dict\", \"test_issue_2515\", \"test_issue_7663\", \"test_recursive_evaluate_false_10560\", \"test_issue_10773\", \"test_split_symbols\", \"test_split_symbols_function\", \"test_functional_exponent\", \"test_match_parentheses_implicit_multiplication\", \"test_convert_equals_signs\", \"test_parse_function_issue_3539\", \"test_split_symbols_numeric\", \"test_unicode_names\", \"test_python3_features\"]",
  "environment_setup_commit": "f9a6f50ec0c74d935c50a6e9c9b2cb0469570d91",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.144576",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}