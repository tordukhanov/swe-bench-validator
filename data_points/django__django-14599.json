{
  "repo": "django/django",
  "instance_id": "django__django-14599",
  "base_commit": "019424e44efe495bc5981eb9848c0bb398a6f068",
  "patch": "diff --git a/django/middleware/csrf.py b/django/middleware/csrf.py\n--- a/django/middleware/csrf.py\n+++ b/django/middleware/csrf.py\n@@ -437,15 +437,25 @@ def process_view(self, request, callback, callback_args, callback_kwargs):\n         return self._accept(request)\n \n     def process_response(self, request, response):\n-        if not getattr(request, 'csrf_cookie_needs_reset', False):\n-            if getattr(response, 'csrf_cookie_set', False):\n-                return response\n-\n-        if not request.META.get(\"CSRF_COOKIE_USED\", False):\n-            return response\n+        # Send the CSRF cookie whenever the cookie is being used (even if the\n+        # client already has it) in order to renew the expiry timer, but only\n+        # if it hasn't already been sent during this request-response cycle.\n+        # Also, send the cookie no matter what if a reset was requested.\n+        if (\n+            getattr(request, 'csrf_cookie_needs_reset', False) or (\n+                request.META.get('CSRF_COOKIE_USED') and\n+                not getattr(response, 'csrf_cookie_set', False)\n+            )\n+        ):\n+            self._set_token(request, response)\n+            # Update state to prevent _set_token() from being unnecessarily\n+            # called again in process_response() by other instances of\n+            # CsrfViewMiddleware. This can happen e.g. when both a decorator\n+            # and middleware are used. However, the csrf_cookie_needs_reset\n+            # attribute is still respected in subsequent calls e.g. in case\n+            # rotate_token() is called in process_response() later by custom\n+            # middleware but before those subsequent calls.\n+            response.csrf_cookie_set = True\n+            request.csrf_cookie_needs_reset = False\n \n-        # Set the CSRF cookie even if it's already set, so we renew\n-        # the expiry timer.\n-        self._set_token(request, response)\n-        response.csrf_cookie_set = True\n         return response\n",
  "test_patch": "diff --git a/tests/csrf_tests/tests.py b/tests/csrf_tests/tests.py\n--- a/tests/csrf_tests/tests.py\n+++ b/tests/csrf_tests/tests.py\n@@ -14,8 +14,9 @@\n from django.views.decorators.csrf import csrf_exempt, requires_csrf_token\n \n from .views import (\n-    ensure_csrf_cookie_view, non_token_view_using_request_processor,\n-    post_form_view, token_view,\n+    ensure_csrf_cookie_view, ensured_and_protected_view,\n+    non_token_view_using_request_processor, post_form_view, protected_view,\n+    sandwiched_rotate_token_view, token_view,\n )\n \n # This is a test (unmasked) CSRF cookie / secret.\n@@ -69,14 +70,30 @@ def test_mask_cipher_secret(self):\n                 self.assertMaskedSecretCorrect(masked, secret)\n \n \n+class TestingSessionStore(SessionStore):\n+    \"\"\"\n+    A version of SessionStore that stores what cookie values are passed to\n+    set_cookie() when CSRF_USE_SESSIONS=True.\n+    \"\"\"\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        # This is a list of the cookie values passed to set_cookie() over\n+        # the course of the request-response.\n+        self._cookies_set = []\n+\n+    def __setitem__(self, key, value):\n+        super().__setitem__(key, value)\n+        self._cookies_set.append(value)\n+\n+\n class TestingHttpRequest(HttpRequest):\n     \"\"\"\n-    A version of HttpRequest that allows us to change some things\n-    more easily\n+    A version of HttpRequest that lets one track and change some things more\n+    easily.\n     \"\"\"\n     def __init__(self):\n         super().__init__()\n-        self.session = SessionStore()\n+        self.session = TestingSessionStore()\n \n     def is_secure(self):\n         return getattr(self, '_is_secure_override', False)\n@@ -99,6 +116,21 @@ def _read_csrf_cookie(self, req, resp):\n         \"\"\"\n         raise NotImplementedError('This method must be implemented by a subclass.')\n \n+    def _get_cookies_set(self, req, resp):\n+        \"\"\"\n+        Return a list of the cookie values passed to set_cookie() over the\n+        course of the request-response.\n+        \"\"\"\n+        raise NotImplementedError('This method must be implemented by a subclass.')\n+\n+    def assertCookiesSet(self, req, resp, expected_secrets):\n+        \"\"\"\n+        Assert that set_cookie() was called with the given sequence of secrets.\n+        \"\"\"\n+        cookies_set = self._get_cookies_set(req, resp)\n+        secrets_set = [_unmask_cipher_token(cookie) for cookie in cookies_set]\n+        self.assertEqual(secrets_set, expected_secrets)\n+\n     def _get_request(self, method=None, cookie=None):\n         if method is None:\n             method = 'GET'\n@@ -332,6 +364,21 @@ def test_put_and_delete_allowed(self):\n         resp = mw.process_view(req, post_form_view, (), {})\n         self.assertIsNone(resp)\n \n+    def test_rotate_token_triggers_second_reset(self):\n+        \"\"\"\n+        If rotate_token() is called after the token is reset in\n+        CsrfViewMiddleware's process_response() and before another call to\n+        the same process_response(), the cookie is reset a second time.\n+        \"\"\"\n+        req = self._get_POST_request_with_token()\n+        resp = sandwiched_rotate_token_view(req)\n+        self.assertContains(resp, 'OK')\n+        csrf_cookie = self._read_csrf_cookie(req, resp)\n+        actual_secret = _unmask_cipher_token(csrf_cookie)\n+        # set_cookie() was called a second time with a different secret.\n+        self.assertCookiesSet(req, resp, [TEST_SECRET, actual_secret])\n+        self.assertNotEqual(actual_secret, TEST_SECRET)\n+\n     # Tests for the template tag method\n     def test_token_node_no_csrf_cookie(self):\n         \"\"\"\n@@ -875,6 +922,9 @@ def _read_csrf_cookie(self, req, resp):\n         csrf_cookie = resp.cookies[settings.CSRF_COOKIE_NAME]\n         return csrf_cookie.value\n \n+    def _get_cookies_set(self, req, resp):\n+        return resp._cookies_set\n+\n     def test_ensures_csrf_cookie_no_middleware(self):\n         \"\"\"\n         The ensure_csrf_cookie() decorator works without middleware.\n@@ -1016,6 +1066,32 @@ def test_masked_unmasked_combinations(self):\n                 resp = mw.process_view(req, token_view, (), {})\n                 self.assertIsNone(resp)\n \n+    def test_cookie_reset_only_once(self):\n+        \"\"\"\n+        A CSRF cookie that needs to be reset is reset only once when the view\n+        is decorated with both ensure_csrf_cookie and csrf_protect.\n+        \"\"\"\n+        # Pass an unmasked cookie to trigger a cookie reset.\n+        req = self._get_POST_request_with_token(cookie=TEST_SECRET)\n+        resp = ensured_and_protected_view(req)\n+        self.assertContains(resp, 'OK')\n+        csrf_cookie = self._read_csrf_cookie(req, resp)\n+        actual_secret = _unmask_cipher_token(csrf_cookie)\n+        self.assertEqual(actual_secret, TEST_SECRET)\n+        # set_cookie() was called only once and with the expected secret.\n+        self.assertCookiesSet(req, resp, [TEST_SECRET])\n+\n+    def test_invalid_cookie_replaced_on_GET(self):\n+        \"\"\"\n+        A CSRF cookie with the wrong format is replaced during a GET request.\n+        \"\"\"\n+        req = self._get_request(cookie='badvalue')\n+        resp = protected_view(req)\n+        self.assertContains(resp, 'OK')\n+        csrf_cookie = self._read_csrf_cookie(req, resp)\n+        self.assertTrue(csrf_cookie, msg='No CSRF cookie was sent.')\n+        self.assertEqual(len(csrf_cookie), CSRF_TOKEN_LENGTH)\n+\n     def test_bare_secret_accepted_and_replaced(self):\n         \"\"\"\n         The csrf token is reset from a bare secret.\n@@ -1089,6 +1165,9 @@ def _read_csrf_cookie(self, req, resp=None):\n             return False\n         return req.session[CSRF_SESSION_KEY]\n \n+    def _get_cookies_set(self, req, resp):\n+        return req.session._cookies_set\n+\n     def test_no_session_on_request(self):\n         msg = (\n             'CSRF_USE_SESSIONS is enabled, but request.session is not set. '\ndiff --git a/tests/csrf_tests/views.py b/tests/csrf_tests/views.py\n--- a/tests/csrf_tests/views.py\n+++ b/tests/csrf_tests/views.py\n@@ -1,8 +1,63 @@\n from django.http import HttpResponse\n-from django.middleware.csrf import get_token\n+from django.middleware.csrf import get_token, rotate_token\n from django.template import Context, RequestContext, Template\n from django.template.context_processors import csrf\n-from django.views.decorators.csrf import ensure_csrf_cookie\n+from django.utils.decorators import decorator_from_middleware\n+from django.utils.deprecation import MiddlewareMixin\n+from django.views.decorators.csrf import csrf_protect, ensure_csrf_cookie\n+\n+\n+class TestingHttpResponse(HttpResponse):\n+    \"\"\"\n+    A version of HttpResponse that stores what cookie values are passed to\n+    set_cookie() when CSRF_USE_SESSIONS=False.\n+    \"\"\"\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        # This is a list of the cookie values passed to set_cookie() over\n+        # the course of the request-response.\n+        self._cookies_set = []\n+\n+    def set_cookie(self, key, value, **kwargs):\n+        super().set_cookie(key, value, **kwargs)\n+        self._cookies_set.append(value)\n+\n+\n+class _CsrfCookieRotator(MiddlewareMixin):\n+\n+    def process_response(self, request, response):\n+        rotate_token(request)\n+        return response\n+\n+\n+csrf_rotating_token = decorator_from_middleware(_CsrfCookieRotator)\n+\n+\n+@csrf_protect\n+def protected_view(request):\n+    return HttpResponse('OK')\n+\n+\n+@ensure_csrf_cookie\n+def ensure_csrf_cookie_view(request):\n+    return HttpResponse('OK')\n+\n+\n+@csrf_protect\n+@ensure_csrf_cookie\n+def ensured_and_protected_view(request):\n+    return TestingHttpResponse('OK')\n+\n+\n+@csrf_protect\n+@csrf_rotating_token\n+@ensure_csrf_cookie\n+def sandwiched_rotate_token_view(request):\n+    \"\"\"\n+    This is a view that calls rotate_token() in process_response() between two\n+    calls to CsrfViewMiddleware.process_response().\n+    \"\"\"\n+    return TestingHttpResponse('OK')\n \n \n def post_form_view(request):\n@@ -12,12 +67,6 @@ def post_form_view(request):\n \"\"\")\n \n \n-@ensure_csrf_cookie\n-def ensure_csrf_cookie_view(request):\n-    # Doesn't insert a token or anything.\n-    return HttpResponse()\n-\n-\n def token_view(request):\n     context = RequestContext(request, processors=[csrf])\n     template = Template('{% csrf_token %}')\n",
  "problem_statement": "CsrfViewMiddleware.process_response()'s csrf_cookie_needs_reset and csrf_cookie_set logic isn't right\nDescription\n\t\nI noticed that the csrf_cookie_needs_reset and csrf_cookie_set logic inside CsrfViewMiddleware.process_response() isn't right: ​https://github.com/django/django/blob/fa35c8bdbc6aca65d94d6280fa463d5bc7baa5c0/django/middleware/csrf.py#L439-L451\nConsequently--\nself._set_token(request, response) can get called twice in some circumstances, even if response.csrf_cookie_set is true at the beginning, and\nthe cookie can fail to be reset in some circumstances, even if csrf_cookie_needs_reset is true at the beginning.\n(I previously let security@djangoproject.com know about this issue, and they said it was okay to resolve this publicly.)\n",
  "hints_text": "",
  "created_at": "2021-07-06T01:37:59Z",
  "version": "4.0",
  "FAIL_TO_PASS": "[\"A CSRF cookie that needs to be reset is reset only once when the view\", \"A CSRF cookie with the wrong format is replaced during a GET request.\"]",
  "PASS_TO_PASS": "[\"test_mask_cipher_secret (csrf_tests.tests.CsrfFunctionTests)\", \"test_unmask_cipher_token (csrf_tests.tests.CsrfFunctionTests)\", \"A request with a bad origin is rejected.\", \"A request with an origin with wrong protocol is rejected.\", \"A POST request with an origin that can't be parsed by urlparse() is\", \"A request with an origin with the wrong protocol compared to\", \"A request with a null origin is rejected.\", \"The csrf token used in posts is changed on every request (although\", \"If a CSRF cookie is present but the token is missing or invalid, the\", \"If a CSRF cookie is present and an invalid token is passed via a\", \"The token may be passed in a header instead of in the form.\", \"settings.CSRF_HEADER_NAME can be used to customize the CSRF header name\", \"ensure_csrf_cookie() doesn't log warnings (#19436).\", \"The ensure_csrf_cookie() decorator works with the CsrfViewMiddleware\", \"get_token still works for a view decorated with 'csrf_exempt'.\", \"get_token() works for a view decorated solely with requires_csrf_token.\", \"A POST request with an origin added to the CSRF_TRUSTED_ORIGINS\", \"A POST HTTP request with a good origin is accepted.\", \"A POST HTTPS request with a good origin is accepted.\", \"A POST request with an origin that matches a CSRF_TRUSTED_ORIGINS\", \"A POST HTTPS request with a bad referer is rejected\", \"A POST HTTPS request with a referer added to the CSRF_TRUSTED_ORIGINS\", \"A POST HTTPS request with a referer that matches a CSRF_TRUSTED_ORIGINS\", \"A POST HTTPS request with a good referer is accepted.\", \"A POST HTTPS request with a good referer is accepted where the referer\", \"A POST HTTPS request is accepted when USE_X_FORWARDED_PORT=True.\", \"A POST HTTPS request is accepted if it receives a good referer with\", \"A POST HTTPS request with a good referer should be accepted from a\", \"CsrfViewMiddleware generates a 403 response if it receives an HTTPS\", \"A POST HTTPS request with a bad referer is rejected.\", \"A POST HTTPS request with a missing referer is rejected.\", \"A POST HTTPS request from an insecure referer should be rejected.\", \"Masked and unmasked tokens are allowed both as POST and as the\", \"If no CSRF cookies is present, the middleware rejects the incoming\", \"test_no_session_on_request (csrf_tests.tests.CsrfViewMiddlewareUseSessionsTests)\", \"test_origin_malformed_host (csrf_tests.tests.CsrfViewMiddlewareUseSessionsTests)\", \"OSErrors during POST data reading are caught and treated as if the\", \"If both a cookie and a token is present, the middleware lets it through.\", \"If a CSRF cookie is present and no token, but the csrf_exempt decorator\", \"If get_token() is not called, the view middleware does not\", \"The ensure_csrf_cookie() decorator works without middleware.\", \"HTTP PUT and DELETE can get through with X-CSRFToken and a cookie.\", \"HTTP PUT and DELETE methods have protection\", \"If rotate_token() is called after the token is reset in\", \"The session isn't saved if the CSRF cookie is unchanged.\", \"A new token is sent if the csrf_cookie is the empty string.\", \"CsrfTokenNode works when no CSRF cookie is set.\", \"CsrfTokenNode works when a CSRF cookie is set.\", \"CsrfTokenNode works when a CSRF cookie is created by\", \"If the CSRF cookie has invalid characters in a POST request, the\", \"If the CSRF cookie has an incorrect length in a POST request, the\", \"The csrf token is reset from a bare secret.\", \"CSRF cookie age can be set using settings.CSRF_COOKIE_AGE.\", \"CSRF cookie age does not have max age set and therefore uses\", \"test_csrf_cookie_samesite (csrf_tests.tests.CsrfViewMiddlewareTests)\", \"All combinations are allowed of (1) masked and unmasked cookies,\", \"test_origin_malformed_host (csrf_tests.tests.CsrfViewMiddlewareTests)\", \"If the token contains non-alphanumeric characters, it is ignored and a\", \"If the token is longer than expected, it is ignored and a new token is\", \"test_csrf_token_on_404_stays_constant (csrf_tests.tests.CsrfInErrorHandlingViewsTests)\"]",
  "environment_setup_commit": "475cffd1d64c690cdad16ede4d5e81985738ceb4",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.697517",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}