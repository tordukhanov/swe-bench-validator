{
  "repo": "django/django",
  "instance_id": "django__django-13145",
  "base_commit": "bde33bdd51b58a63d3e50fab687815968383b86d",
  "patch": "diff --git a/django/utils/timesince.py b/django/utils/timesince.py\n--- a/django/utils/timesince.py\n+++ b/django/utils/timesince.py\n@@ -24,26 +24,30 @@\n )\n \n \n-def timesince(d, now=None, reversed=False, time_strings=None):\n+def timesince(d, now=None, reversed=False, time_strings=None, depth=2):\n     \"\"\"\n     Take two datetime objects and return the time between d and now as a nicely\n     formatted string, e.g. \"10 minutes\". If d occurs after now, return\n     \"0 minutes\".\n \n     Units used are years, months, weeks, days, hours, and minutes.\n-    Seconds and microseconds are ignored.  Up to two adjacent units will be\n+    Seconds and microseconds are ignored. Up to `depth` adjacent units will be\n     displayed.  For example, \"2 weeks, 3 days\" and \"1 year, 3 months\" are\n     possible outputs, but \"2 weeks, 3 hours\" and \"1 year, 5 days\" are not.\n \n     `time_strings` is an optional dict of strings to replace the default\n     TIME_STRINGS dict.\n \n+    `depth` is an optional integer to control the number of adjacent time\n+    units returned.\n+\n     Adapted from\n     https://web.archive.org/web/20060617175230/http://blog.natbat.co.uk/archive/2003/Jun/14/time_since\n     \"\"\"\n     if time_strings is None:\n         time_strings = TIME_STRINGS\n-\n+    if depth <= 0:\n+        raise ValueError('depth must be greater than 0.')\n     # Convert datetime.date to datetime.datetime for comparison.\n     if not isinstance(d, datetime.datetime):\n         d = datetime.datetime(d.year, d.month, d.day)\n@@ -74,18 +78,24 @@ def timesince(d, now=None, reversed=False, time_strings=None):\n         count = since // seconds\n         if count != 0:\n             break\n-    result = avoid_wrapping(time_strings[name] % count)\n-    if i + 1 < len(TIMESINCE_CHUNKS):\n-        # Now get the second item\n-        seconds2, name2 = TIMESINCE_CHUNKS[i + 1]\n-        count2 = (since - (seconds * count)) // seconds2\n-        if count2 != 0:\n-            result += gettext(', ') + avoid_wrapping(time_strings[name2] % count2)\n-    return result\n+    else:\n+        return avoid_wrapping(time_strings['minute'] % 0)\n+    result = []\n+    current_depth = 0\n+    while i < len(TIMESINCE_CHUNKS) and current_depth < depth:\n+        seconds, name = TIMESINCE_CHUNKS[i]\n+        count = since // seconds\n+        if count == 0:\n+            break\n+        result.append(avoid_wrapping(time_strings[name] % count))\n+        since -= seconds * count\n+        current_depth += 1\n+        i += 1\n+    return gettext(', ').join(result)\n \n \n-def timeuntil(d, now=None, time_strings=None):\n+def timeuntil(d, now=None, time_strings=None, depth=2):\n     \"\"\"\n     Like timesince, but return a string measuring the time until the given time.\n     \"\"\"\n-    return timesince(d, now, reversed=True, time_strings=time_strings)\n+    return timesince(d, now, reversed=True, time_strings=time_strings, depth=depth)\n",
  "test_patch": "diff --git a/tests/utils_tests/test_timesince.py b/tests/utils_tests/test_timesince.py\n--- a/tests/utils_tests/test_timesince.py\n+++ b/tests/utils_tests/test_timesince.py\n@@ -1,13 +1,13 @@\n import datetime\n-import unittest\n \n+from django.test import TestCase\n from django.test.utils import requires_tz_support\n from django.utils import timezone, translation\n from django.utils.timesince import timesince, timeuntil\n from django.utils.translation import npgettext_lazy\n \n \n-class TimesinceTests(unittest.TestCase):\n+class TimesinceTests(TestCase):\n \n     def setUp(self):\n         self.t = datetime.datetime(2007, 8, 14, 13, 46, 0)\n@@ -140,3 +140,31 @@ def test_thousand_years_ago(self):\n         t = datetime.datetime(1007, 8, 14, 13, 46, 0)\n         self.assertEqual(timesince(t, self.t), '1000\\xa0years')\n         self.assertEqual(timeuntil(self.t, t), '1000\\xa0years')\n+\n+    def test_depth(self):\n+        t = self.t + self.oneyear + self.onemonth + self.oneweek + self.oneday + self.onehour\n+        tests = [\n+            (t, 1, '1\\xa0year'),\n+            (t, 2, '1\\xa0year, 1\\xa0month'),\n+            (t, 3, '1\\xa0year, 1\\xa0month, 1\\xa0week'),\n+            (t, 4, '1\\xa0year, 1\\xa0month, 1\\xa0week, 1\\xa0day'),\n+            (t, 5, '1\\xa0year, 1\\xa0month, 1\\xa0week, 1\\xa0day, 1\\xa0hour'),\n+            (t, 6, '1\\xa0year, 1\\xa0month, 1\\xa0week, 1\\xa0day, 1\\xa0hour'),\n+            (self.t + self.onehour, 5, '1\\xa0hour'),\n+            (self.t + (4 * self.oneminute), 3, '4\\xa0minutes'),\n+            (self.t + self.onehour + self.oneminute, 1, '1\\xa0hour'),\n+            (self.t + self.oneday + self.onehour, 1, '1\\xa0day'),\n+            (self.t + self.oneweek + self.oneday, 1, '1\\xa0week'),\n+            (self.t + self.onemonth + self.oneweek, 1, '1\\xa0month'),\n+            (self.t + self.oneyear + self.onemonth, 1, '1\\xa0year'),\n+            (self.t + self.oneyear + self.oneweek + self.oneday, 3, '1\\xa0year'),\n+        ]\n+        for value, depth, expected in tests:\n+            with self.subTest():\n+                self.assertEqual(timesince(self.t, value, depth=depth), expected)\n+                self.assertEqual(timeuntil(value, self.t, depth=depth), expected)\n+\n+    def test_depth_invalid(self):\n+        msg = 'depth must be greater than 0.'\n+        with self.assertRaisesMessage(ValueError, msg):\n+            timesince(self.t, self.t, depth=0)\n",
  "problem_statement": "timesince 'depth' parameter\nDescription\n\t \n\t\t(last modified by Toby Such)\n\t \nDiscussed â€‹here. The timesince function is a bit limiting as it is right now. A depth parameter should be added to configure how many values are shown. The depth parameter should be defaulted to 2 as this is how the current implementation behaves. The existing rule of values having to be adjacent to one another should still remain.\nThe logic for calculating the time since, before formatting should also be pulled out of the function and placed in its own so that custom implementations can be created.\nFor example: \nWith a depth of one it should always display as \"1 week\" or \"3 years\" etc. \nWith a depth of two: \"1 week, 3 days\" or \"3 years, 7 months\"\nWith a depth of three: \"1 week, 3 days, 5 hours\" or \"3 years, 7 months, 2 weeks\"\n",
  "hints_text": "As discussed on the ML, the most important thing is to make it easily customizable.",
  "created_at": "2020-07-03T23:30:47Z",
  "version": "3.2",
  "FAIL_TO_PASS": "[\"test_depth (utils_tests.test_timesince.TimesinceTests)\", \"test_depth_invalid (utils_tests.test_timesince.TimesinceTests)\"]",
  "PASS_TO_PASS": "[\"Timesince should work with both date objects (#9672)\", \"Both timesince and timeuntil should work on date objects (#17937).\", \"When using two different timezones.\", \"test_display_first_unit (utils_tests.test_timesince.TimesinceTests)\", \"test_display_second_before_first (utils_tests.test_timesince.TimesinceTests)\", \"equal datetimes.\", \"Microseconds and seconds are ignored.\", \"test_leap_year (utils_tests.test_timesince.TimesinceTests)\", \"test_leap_year_new_years_eve (utils_tests.test_timesince.TimesinceTests)\", \"Test multiple units.\", \"test_naive_datetime_with_tzinfo_attribute (utils_tests.test_timesince.TimesinceTests)\", \"Test other units.\", \"test_second_before_equal_first_humanize_time_strings (utils_tests.test_timesince.TimesinceTests)\", \"test_thousand_years_ago (utils_tests.test_timesince.TimesinceTests)\"]",
  "environment_setup_commit": "65dfb06a1ab56c238cc80f5e1c31f61210c4577d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.645021",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}