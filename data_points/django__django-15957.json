{
  "repo": "django/django",
  "instance_id": "django__django-15957",
  "base_commit": "f387d024fc75569d2a4a338bfda76cc2f328f627",
  "patch": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -64,8 +64,10 @@ class Child(Model):\n \"\"\"\n \n from django.core.exceptions import FieldError\n-from django.db import connections, router, transaction\n-from django.db.models import Q, signals\n+from django.db import DEFAULT_DB_ALIAS, connections, router, transaction\n+from django.db.models import Q, Window, signals\n+from django.db.models.functions import RowNumber\n+from django.db.models.lookups import GreaterThan, LessThanOrEqual\n from django.db.models.query import QuerySet\n from django.db.models.query_utils import DeferredAttribute\n from django.db.models.utils import resolve_callables\n@@ -81,6 +83,24 @@ def __set__(self, instance, value):\n         instance.__dict__[self.field.attname] = value\n \n \n+def _filter_prefetch_queryset(queryset, field_name, instances):\n+    predicate = Q(**{f\"{field_name}__in\": instances})\n+    if queryset.query.is_sliced:\n+        low_mark, high_mark = queryset.query.low_mark, queryset.query.high_mark\n+        order_by = [\n+            expr\n+            for expr, _ in queryset.query.get_compiler(\n+                using=queryset._db or DEFAULT_DB_ALIAS\n+            ).get_order_by()\n+        ]\n+        window = Window(RowNumber(), partition_by=field_name, order_by=order_by)\n+        predicate &= GreaterThan(window, low_mark)\n+        if high_mark is not None:\n+            predicate &= LessThanOrEqual(window, high_mark)\n+        queryset.query.clear_limits()\n+    return queryset.filter(predicate)\n+\n+\n class ForwardManyToOneDescriptor:\n     \"\"\"\n     Accessor to the related object on the forward side of a many-to-one or\n@@ -718,8 +738,7 @@ def get_prefetch_queryset(self, instances, queryset=None):\n             rel_obj_attr = self.field.get_local_related_value\n             instance_attr = self.field.get_foreign_related_value\n             instances_dict = {instance_attr(inst): inst for inst in instances}\n-            query = {\"%s__in\" % self.field.name: instances}\n-            queryset = queryset.filter(**query)\n+            queryset = _filter_prefetch_queryset(queryset, self.field.name, instances)\n \n             # Since we just bypassed this class' get_queryset(), we must manage\n             # the reverse relation manually.\n@@ -1050,9 +1069,9 @@ def get_prefetch_queryset(self, instances, queryset=None):\n \n             queryset._add_hints(instance=instances[0])\n             queryset = queryset.using(queryset._db or self._db)\n-\n-            query = {\"%s__in\" % self.query_field_name: instances}\n-            queryset = queryset._next_is_sticky().filter(**query)\n+            queryset = _filter_prefetch_queryset(\n+                queryset._next_is_sticky(), self.query_field_name, instances\n+            )\n \n             # M2M: need to annotate the query in order to get the primary model\n             # that the secondary model was actually related to. We know that\n",
  "test_patch": "diff --git a/tests/prefetch_related/tests.py b/tests/prefetch_related/tests.py\n--- a/tests/prefetch_related/tests.py\n+++ b/tests/prefetch_related/tests.py\n@@ -1908,3 +1908,67 @@ def test_nested_prefetch_is_not_overwritten_by_related_object(self):\n         self.assertIs(Room.house.is_cached(self.room), True)\n         with self.assertNumQueries(0):\n             house.rooms.first().house.address\n+\n+\n+class PrefetchLimitTests(TestDataMixin, TestCase):\n+    def test_m2m_forward(self):\n+        authors = Author.objects.all()  # Meta.ordering\n+        with self.assertNumQueries(3):\n+            books = list(\n+                Book.objects.prefetch_related(\n+                    Prefetch(\"authors\", authors),\n+                    Prefetch(\"authors\", authors[1:], to_attr=\"authors_sliced\"),\n+                )\n+            )\n+        for book in books:\n+            with self.subTest(book=book):\n+                self.assertEqual(book.authors_sliced, list(book.authors.all())[1:])\n+\n+    def test_m2m_reverse(self):\n+        books = Book.objects.order_by(\"title\")\n+        with self.assertNumQueries(3):\n+            authors = list(\n+                Author.objects.prefetch_related(\n+                    Prefetch(\"books\", books),\n+                    Prefetch(\"books\", books[1:2], to_attr=\"books_sliced\"),\n+                )\n+            )\n+        for author in authors:\n+            with self.subTest(author=author):\n+                self.assertEqual(author.books_sliced, list(author.books.all())[1:2])\n+\n+    def test_foreignkey_reverse(self):\n+        authors = Author.objects.order_by(\"-name\")\n+        with self.assertNumQueries(3):\n+            books = list(\n+                Book.objects.prefetch_related(\n+                    Prefetch(\n+                        \"first_time_authors\",\n+                        authors,\n+                    ),\n+                    Prefetch(\n+                        \"first_time_authors\",\n+                        authors[1:],\n+                        to_attr=\"first_time_authors_sliced\",\n+                    ),\n+                )\n+            )\n+        for book in books:\n+            with self.subTest(book=book):\n+                self.assertEqual(\n+                    book.first_time_authors_sliced,\n+                    list(book.first_time_authors.all())[1:],\n+                )\n+\n+    def test_reverse_ordering(self):\n+        authors = Author.objects.reverse()  # Reverse Meta.ordering\n+        with self.assertNumQueries(3):\n+            books = list(\n+                Book.objects.prefetch_related(\n+                    Prefetch(\"authors\", authors),\n+                    Prefetch(\"authors\", authors[1:], to_attr=\"authors_sliced\"),\n+                )\n+            )\n+        for book in books:\n+            with self.subTest(book=book):\n+                self.assertEqual(book.authors_sliced, list(book.authors.all())[1:])\n",
  "problem_statement": "Prefetch objects don't work with slices\nDescription\n\t\n​Prefetch() objects does not work with sliced querysets. For example the following code results in AssertionError: Cannot filter a query once a slice has been taken.:\nCategory.objects.prefetch_related(Prefetch(\n\t'post_set',\n\tqueryset=Post.objects.all()[:3],\n\tto_attr='example_posts',\n))\nThis behavior is also mentioned in ​this StackOverflow answer. On the other hand it does not seem to be documented in Django Docs.\nWhy is it needed?\nMy use case seems to be a common one: I want to display a list of categories while displaying couple of example objects from each category next to it. If I'm not mistaken there isn't currently an efficient way of doing this. Prefetching without slicing would prefetch all objects (and there may be thousands of them) instead of the three examples that are needed.\n",
  "hints_text": "It seems to me that #26565 (\"Allow Prefetch query to use .values()\") is related.\nHi ludwik, #26565 is about a different issue. The only way we could support slices would be to extract it from the provided queryset to make it filterable again and apply it when in-memory joining. The prefect queryset would still have to fetch all results so I'm not sure it's worth the trouble as accessing category.example_posts[:3] would have the same effect.\nCharettes, Thank you for the reply. accessing category.example_posts[:3] would have the same effect I'm pretty sure that is not correct. The end effect would obviously be the same, but the way it is achieved behind the scenes and the performance characteristics that follows would be widely different. What you propose (prefetching without limit, adding slicing in a loop after the fact) would make Django perform a database query selecting all objects from the database table and loading them into memory. This would happen when the main queryset is evaluated (that's what prefetching is all about). Then the slicing would be performed by Python in memory, on a queryset that was already evaluated. That's what I understood from ​the documentation and also how Django actually behaved in an experiment I performed couple of minutes ago. What I want to avoid is exactly this behavior - loading thousands of objects from the database to display first three of them. I would be happy with a sane workaround, but to my knowledge there isn't any.\nTentatively accepting but as you've noticed it would require a large refactor of the way prefetching is actually done. I could see Category.objects.prefetch_related(Prefetch('articles', Article.object.order_by('-published_data')[0:3], to_attr='latest_articles')) being useful but the underlying prefetch query would need to rely on subqueries, a feature the ORM is not good at for now. Maybe the addition of the ​Subquery expression could help here.\nThe only way to limit this Query (and to not load all the records into memory) would be to do a top-n-per-group query which I don't think the ORM is capable of. What I can suggest is: Instead of limiting the QuerySet, find a way to filter it. For example, get only the Posts in the last day, week or a month (based on the post-frequency). Category.objects.prefetch_related(Prefetch( 'post_set', queryset=Post.objects.filter( date_published__gte=datetime.date.today()-timedelta(days=7)), to_attr='example_posts', )) This way you won't load all the Posts into Memory.\nIf window queries are implemented (https://code.djangoproject.com/ticket/26608) then this use case could be possible in something similar to: Prefetch( 'post_set', queryset= Post.objects .annotate(_rank=Window(Rank(), partition_by='cateogry') .filter(_rank__lte=3) )\nI tried the filter by rank suggestion using Django 2.0 but I get this error: django.db.utils.NotSupportedError: Window is disallowed in the filter clause.\nI think there is a workaround now to in django new version as we have OuterRef and Subquery. from django.db.models import OuterRef, Subquery User.objects.all().prefetch_related('comments',queryset=Comment.objects.filter(id__in=Subquery(Comment.objects.filter(user_id=OuterRef('user_id')).values_list('id', flat=True)[:5])))\nNote that the solution above might not be portable to some MySql databases, with error 1235, \"This version of MySQL doesn't yet support 'LIMIT & IN/ALL/ANY/SOME subquery'\"\nAs pointed out by others support for filter against window functions would allow prefetch_related_objects to use Rank(partition_by) to support this feature. If someone wants to give a shot at solving this particular issue before #28333 is resolved it should be doable by using a combination of Queryset.raw and Query.compile combinations.",
  "created_at": "2022-08-13T06:18:25Z",
  "version": "4.2",
  "FAIL_TO_PASS": "[\"test_foreignkey_reverse (prefetch_related.tests.PrefetchLimitTests)\", \"test_m2m_forward (prefetch_related.tests.PrefetchLimitTests)\", \"test_m2m_reverse (prefetch_related.tests.PrefetchLimitTests)\", \"test_reverse_ordering (prefetch_related.tests.PrefetchLimitTests)\"]",
  "PASS_TO_PASS": "[\"The prefetched relationship is used rather than populating the reverse\", \"test_bug (prefetch_related.tests.Ticket19607Tests)\", \"When intermediary results are prefetched without a destination\", \"In-bulk does correctly prefetch objects by not using .iterator()\", \"test_prefetch_nullable (prefetch_related.tests.NullableTest)\", \"test_traverse_nullable (prefetch_related.tests.NullableTest)\", \"test_bug (prefetch_related.tests.Ticket21410Tests)\", \"test_bug (prefetch_related.tests.Ticket21760Tests)\", \"test_m2m_then_m2m (prefetch_related.tests.DefaultManagerTests)\", \"test_order (prefetch_related.tests.LookupOrderingTest)\", \"test_foreignkey (prefetch_related.tests.ForeignKeyToFieldTest)\", \"test_m2m (prefetch_related.tests.ForeignKeyToFieldTest)\", \"test_m2m_manager_reused (prefetch_related.tests.ForeignKeyToFieldTest)\", \"test_basic (prefetch_related.tests.RawQuerySetTests)\", \"test_clear (prefetch_related.tests.RawQuerySetTests)\", \"test_prefetch_before_raw (prefetch_related.tests.RawQuerySetTests)\", \"test_using_is_honored_custom_qs (prefetch_related.tests.MultiDbTests)\", \"test_using_is_honored_fkey (prefetch_related.tests.MultiDbTests)\", \"test_using_is_honored_inheritance (prefetch_related.tests.MultiDbTests)\", \"test_using_is_honored_m2m (prefetch_related.tests.MultiDbTests)\", \"test_child_link_prefetch (prefetch_related.tests.MultiTableInheritanceTest)\", \"test_foreignkey (prefetch_related.tests.MultiTableInheritanceTest)\", \"test_foreignkey_to_inherited (prefetch_related.tests.MultiTableInheritanceTest)\", \"test_m2m_to_inheriting_model (prefetch_related.tests.MultiTableInheritanceTest)\", \"test_parent_link_prefetch (prefetch_related.tests.MultiTableInheritanceTest)\", \"test_add_clears_prefetched_objects (prefetch_related.tests.DirectPrefetchedObjectCacheReuseTests)\", \"Nested prefetch_related() shouldn't trigger duplicate queries for the same\", \"test_detect_is_fetched_with_to_attr (prefetch_related.tests.DirectPrefetchedObjectCacheReuseTests)\", \"test_prefetch_reverse_foreign_key (prefetch_related.tests.DirectPrefetchedObjectCacheReuseTests)\", \"test_remove_clears_prefetched_objects (prefetch_related.tests.DirectPrefetchedObjectCacheReuseTests)\", \"test_charfield_GFK (prefetch_related.tests.GenericRelationTests)\", \"test_custom_queryset (prefetch_related.tests.GenericRelationTests)\", \"test_deleted_GFK (prefetch_related.tests.GenericRelationTests)\", \"test_generic_relation (prefetch_related.tests.GenericRelationTests)\", \"test_nullable_GFK (prefetch_related.tests.GenericRelationTests)\", \"test_prefetch_GFK (prefetch_related.tests.GenericRelationTests)\", \"test_prefetch_GFK_fk_pk (prefetch_related.tests.GenericRelationTests)\", \"test_prefetch_GFK_nonint_pk (prefetch_related.tests.GenericRelationTests)\", \"test_prefetch_GFK_uuid_pk (prefetch_related.tests.GenericRelationTests)\", \"A 'content_object' can be traversed with prefetch_related() and\", \"test_attribute_error (prefetch_related.tests.PrefetchRelatedTests)\", \"test_bool (prefetch_related.tests.PrefetchRelatedTests)\", \"test_clear (prefetch_related.tests.PrefetchRelatedTests)\", \"test_count (prefetch_related.tests.PrefetchRelatedTests)\", \"test_exists (prefetch_related.tests.PrefetchRelatedTests)\", \"Related filtering of prefetched querysets is deferred on m2m and\", \"A m2m relation can be followed after a relation like ForeignKey that\", \"test_foreignkey_forward (prefetch_related.tests.PrefetchRelatedTests)\", \"test_foreignkey_reverse (prefetch_related.tests.PrefetchRelatedTests)\", \"test_forward_m2m_to_attr_conflict (prefetch_related.tests.PrefetchRelatedTests)\", \"Objects retrieved with .get() get the prefetch behavior.\", \"Regression test for #20242 - QuerySet \\\"in\\\" didn't work the first time\", \"test_invalid_final_lookup (prefetch_related.tests.PrefetchRelatedTests)\", \"test_len (prefetch_related.tests.PrefetchRelatedTests)\", \"test_m2m_forward (prefetch_related.tests.PrefetchRelatedTests)\", \"test_m2m_prefetching_iterator_with_chunks (prefetch_related.tests.PrefetchRelatedTests)\", \"test_m2m_prefetching_iterator_without_chunks (prefetch_related.tests.PrefetchRelatedTests)\", \"test_m2m_prefetching_iterator_without_chunks_warning (prefetch_related.tests.PrefetchRelatedTests)\", \"test_m2m_reverse (prefetch_related.tests.PrefetchRelatedTests)\", \"A m2m can be followed through another m2m.\", \"test_m2m_then_m2m_object_ids (prefetch_related.tests.PrefetchRelatedTests)\", \"test_m2m_then_reverse_fk_object_ids (prefetch_related.tests.PrefetchRelatedTests)\", \"test_m2m_then_reverse_one_to_one_object_ids (prefetch_related.tests.PrefetchRelatedTests)\", \"test_named_values_list (prefetch_related.tests.PrefetchRelatedTests)\", \"test_onetoone_reverse_no_match (prefetch_related.tests.PrefetchRelatedTests)\", \"A model (Bio) with a OneToOneField primary key (author) that references\", \"test_overriding_prefetch (prefetch_related.tests.PrefetchRelatedTests)\", \"test_prefetch_eq (prefetch_related.tests.PrefetchRelatedTests)\", \"test_reverse_m2m_to_attr_conflict (prefetch_related.tests.PrefetchRelatedTests)\", \"A m2m relation can be followed after going through the select_related\", \"test_survives_clone (prefetch_related.tests.PrefetchRelatedTests)\", \"test_ambiguous (prefetch_related.tests.CustomPrefetchTests)\", \"test_custom_qs (prefetch_related.tests.CustomPrefetchTests)\", \"Related filtering of prefetched querysets is deferred until necessary.\", \"test_generic_rel (prefetch_related.tests.CustomPrefetchTests)\", \"test_m2m (prefetch_related.tests.CustomPrefetchTests)\", \"test_m2m_through_fk (prefetch_related.tests.CustomPrefetchTests)\", \"test_m2m_through_gfk (prefetch_related.tests.CustomPrefetchTests)\", \"test_nested_prefetch_related_are_not_overwritten (prefetch_related.tests.CustomPrefetchTests)\", \"Nested prefetches whose name clashes with descriptor names\", \"test_o2m_through_m2m (prefetch_related.tests.CustomPrefetchTests)\", \"test_raw_queryset (prefetch_related.tests.CustomPrefetchTests)\", \"test_reverse_m2m (prefetch_related.tests.CustomPrefetchTests)\", \"test_to_attr_cached_property (prefetch_related.tests.CustomPrefetchTests)\", \"test_to_attr_doesnt_cache_through_attr_as_list (prefetch_related.tests.CustomPrefetchTests)\", \"test_traverse_multiple_items_property (prefetch_related.tests.CustomPrefetchTests)\", \"test_traverse_qs (prefetch_related.tests.CustomPrefetchTests)\", \"test_traverse_single_item_property (prefetch_related.tests.CustomPrefetchTests)\", \"test_values_queryset (prefetch_related.tests.CustomPrefetchTests)\"]",
  "environment_setup_commit": "0fbdb9784da915fce5dcc1fe82bac9b4785749e5",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.743335",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}