{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-16493",
  "base_commit": "24c62c84a000d1e220eea0633efc188c60859f55",
  "patch": "diff --git a/sympy/tensor/tensor.py b/sympy/tensor/tensor.py\n--- a/sympy/tensor/tensor.py\n+++ b/sympy/tensor/tensor.py\n@@ -2110,7 +2110,7 @@ def contract_and_permute(metric, array, pos):\n \n         return free_ind2, array\n \n-    def replace_with_arrays(self, replacement_dict, indices):\n+    def replace_with_arrays(self, replacement_dict, indices=None):\n         \"\"\"\n         Replace the tensorial expressions with arrays. The final array will\n         correspond to the N-dimensional array with indices arranged according\n@@ -2122,7 +2122,8 @@ def replace_with_arrays(self, replacement_dict, indices):\n         replacement_dict\n             dictionary containing the replacement rules for tensors.\n         indices\n-            the index order with respect to which the array is read.\n+            the index order with respect to which the array is read. The\n+            original index order will be used if no value is passed.\n \n         Examples\n         ========\n@@ -2136,15 +2137,22 @@ def replace_with_arrays(self, replacement_dict, indices):\n         >>> A = tensorhead(\"A\", [L], [[1]])\n         >>> A(i).replace_with_arrays({A(i): [1, 2]}, [i])\n         [1, 2]\n+\n+        Since 'indices' is optional, we can also call replace_with_arrays by\n+        this way if no specific index order is needed:\n+\n+        >>> A(i).replace_with_arrays({A(i): [1, 2]})\n+        [1, 2]\n+\n         >>> expr = A(i)*A(j)\n-        >>> expr.replace_with_arrays({A(i): [1, 2]}, [i, j])\n+        >>> expr.replace_with_arrays({A(i): [1, 2]})\n         [[1, 2], [2, 4]]\n \n         For contractions, specify the metric of the ``TensorIndexType``, which\n         in this case is ``L``, in its covariant form:\n \n         >>> expr = A(i)*A(-i)\n-        >>> expr.replace_with_arrays({A(i): [1, 2], L: diag(1, -1)}, [])\n+        >>> expr.replace_with_arrays({A(i): [1, 2], L: diag(1, -1)})\n         -3\n \n         Symmetrization of an array:\n@@ -2152,14 +2160,14 @@ def replace_with_arrays(self, replacement_dict, indices):\n         >>> H = tensorhead(\"H\", [L, L], [[1], [1]])\n         >>> a, b, c, d = symbols(\"a b c d\")\n         >>> expr = H(i, j)/2 + H(j, i)/2\n-        >>> expr.replace_with_arrays({H(i, j): [[a, b], [c, d]]}, [i, j])\n+        >>> expr.replace_with_arrays({H(i, j): [[a, b], [c, d]]})\n         [[a, b/2 + c/2], [b/2 + c/2, d]]\n \n         Anti-symmetrization of an array:\n \n         >>> expr = H(i, j)/2 - H(j, i)/2\n         >>> repl = {H(i, j): [[a, b], [c, d]]}\n-        >>> expr.replace_with_arrays(repl, [i, j])\n+        >>> expr.replace_with_arrays(repl)\n         [[0, b/2 - c/2], [-b/2 + c/2, 0]]\n \n         The same expression can be read as the transpose by inverting ``i`` and\n@@ -2170,6 +2178,7 @@ def replace_with_arrays(self, replacement_dict, indices):\n         \"\"\"\n         from .array import Array\n \n+        indices = indices or []\n         replacement_dict = {tensor: Array(array) for tensor, array in replacement_dict.items()}\n \n         # Check dimensions of replaced arrays:\n",
  "test_patch": "diff --git a/sympy/tensor/tests/test_tensor.py b/sympy/tensor/tests/test_tensor.py\n--- a/sympy/tensor/tests/test_tensor.py\n+++ b/sympy/tensor/tests/test_tensor.py\n@@ -1897,6 +1897,7 @@ def test_tensor_replacement():\n     repl = {H(i,-j): [[1,2],[3,4]], L: diag(1, -1)}\n     assert expr._extract_data(repl) == ([i, j], Array([[1, -2], [3, -4]]))\n \n+    assert expr.replace_with_arrays(repl) == Array([[1, -2], [3, -4]])\n     assert expr.replace_with_arrays(repl, [i, j]) == Array([[1, -2], [3, -4]])\n     assert expr.replace_with_arrays(repl, [i, -j]) == Array([[1, 2], [3, 4]])\n     assert expr.replace_with_arrays(repl, [-i, j]) == Array([[1, -2], [-3, 4]])\n@@ -1905,11 +1906,14 @@ def test_tensor_replacement():\n     assert expr.replace_with_arrays(repl, [j, -i]) == Array([[1, -3], [-2, 4]])\n     assert expr.replace_with_arrays(repl, [-j, i]) == Array([[1, 3], [2, 4]])\n     assert expr.replace_with_arrays(repl, [-j, -i]) == Array([[1, -3], [2, -4]])\n+    # Test stability of optional parameter 'indices'\n+    assert expr.replace_with_arrays(repl) == Array([[1, -2], [3, -4]])\n \n     expr = H(i,j)\n     repl = {H(i,j): [[1,2],[3,4]], L: diag(1, -1)}\n     assert expr._extract_data(repl) == ([i, j], Array([[1, 2], [3, 4]]))\n \n+    assert expr.replace_with_arrays(repl) == Array([[1, 2], [3, 4]])\n     assert expr.replace_with_arrays(repl, [i, j]) == Array([[1, 2], [3, 4]])\n     assert expr.replace_with_arrays(repl, [i, -j]) == Array([[1, -2], [3, -4]])\n     assert expr.replace_with_arrays(repl, [-i, j]) == Array([[1, 2], [-3, -4]])\n",
  "problem_statement": "Make `indices` parameter optional in .replace_with_arrays\nParameter `.indices` of method `.replace_with_arrays` introduced in https://github.com/sympy/sympy/pull/15271\n",
  "hints_text": "Hello,\r\n\r\nI would like to work on this issue. Could you please guide me?\r\nI have tested with indices=[] and in most of the cases it works fine except that we want to explicitly change the output. So I suppose that a default value [] can be set to 'indices' so that it can become optional. Would that be a possible solution?\r\nBut while trying to verify this idea and looking into the code, I am a little bit lost.  Especially for the _match_indices_with_other_tensor who has two indices parameters. \r\n\r\n`    def _match_indices_with_other_tensor(array, free_ind1, free_ind2, replacement_dict):`\r\n\r\nIs free_ind means the indices for no-replaced expression?\r\n\r\nIf the [] parameter is not robust enough, I am also thinking about automatically adding default indices in the function. That is to get indices from the expression itself. But this approach has a difficulty is that tensorhead doesn't have the get_indices function. \r\n\r\nWhat do you think about it? Could you please give me some advices? Thank you!\r\n",
  "created_at": "2019-03-30T01:25:10Z",
  "version": "1.5",
  "FAIL_TO_PASS": "[\"test_tensor_replacement\"]",
  "PASS_TO_PASS": "[\"test_canonicalize_no_slot_sym\", \"test_canonicalize_no_dummies\", \"test_tensorhead_construction_without_symmetry\", \"test_no_metric_symmetry\", \"test_canonicalize1\", \"test_bug_correction_tensor_indices\", \"test_riemann_invariants\", \"test_riemann_products\", \"test_canonicalize2\", \"test_canonicalize3\", \"test_TensorIndexType\", \"test_indices\", \"test_tensorsymmetry\", \"test_TensorType\", \"test_TensExpr\", \"test_TensorHead\", \"test_add1\", \"test_special_eq_ne\", \"test_add2\", \"test_add3\", \"test_mul\", \"test_substitute_indices\", \"test_riemann_cyclic_replace\", \"test_riemann_cyclic\", \"test_contract_metric1\", \"test_contract_metric2\", \"test_metric_contract3\", \"test_epsilon\", \"test_contract_delta1\", \"test_fun\", \"test_TensorManager\", \"test_hash\", \"test_valued_tensor_iter\", \"test_valued_tensor_covariant_contravariant_elements\", \"test_valued_tensor_get_matrix\", \"test_valued_tensor_contraction\", \"test_valued_tensor_self_contraction\", \"test_valued_tensor_pow\", \"test_valued_tensor_expressions\", \"test_valued_tensor_add_scalar\", \"test_noncommuting_components\", \"test_valued_non_diagonal_metric\", \"test_valued_assign_numpy_ndarray\", \"test_valued_metric_inverse\", \"test_valued_canon_bp_swapaxes\", \"test_pprint\", \"test_valued_components_with_wrong_symmetry\", \"test_issue_10972_TensMul_data\", \"test_TensMul_data\", \"test_issue_11020_TensAdd_data\", \"test_index_iteration\", \"test_tensor_expand\", \"test_tensor_alternative_construction\"]",
  "environment_setup_commit": "70381f282f2d9d039da860e391fe51649df2779d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.108181",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}