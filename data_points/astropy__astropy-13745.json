{
  "repo": "astropy/astropy",
  "instance_id": "astropy__astropy-13745",
  "base_commit": "0446f168dc6e34996482394f00770b52756b8f9c",
  "patch": "diff --git a/astropy/coordinates/angles.py b/astropy/coordinates/angles.py\n--- a/astropy/coordinates/angles.py\n+++ b/astropy/coordinates/angles.py\n@@ -587,7 +587,7 @@ def _validate_angles(self, angles=None):\n         if angles.unit is u.deg:\n             limit = 90\n         elif angles.unit is u.rad:\n-            limit = 0.5 * np.pi\n+            limit = self.dtype.type(0.5 * np.pi)\n         else:\n             limit = u.degree.to(angles.unit, 90.0)\n \n",
  "test_patch": "diff --git a/astropy/coordinates/tests/test_angles.py b/astropy/coordinates/tests/test_angles.py\n--- a/astropy/coordinates/tests/test_angles.py\n+++ b/astropy/coordinates/tests/test_angles.py\n@@ -1092,3 +1092,54 @@ def test_str_repr_angles_nan(cls, input, expstr, exprepr):\n     # Deleting whitespaces since repr appears to be adding them for some values\n     # making the test fail.\n     assert repr(q).replace(\" \", \"\") == f'<{cls.__name__}{exprepr}>'.replace(\" \",\"\")\n+\n+\n+@pytest.mark.parametrize(\"sign\", (-1, 1))\n+@pytest.mark.parametrize(\n+    \"value,expected_value,dtype,expected_dtype\",\n+    [\n+        (np.pi / 2, np.pi / 2, None, np.float64),\n+        (np.pi / 2, np.pi / 2, np.float64, np.float64),\n+        (np.float32(np.pi / 2), np.float32(np.pi / 2), None, np.float32),\n+        (np.float32(np.pi / 2), np.float32(np.pi / 2), np.float32, np.float32),\n+        # these cases would require coercing the float32 value to the float64 value\n+        # making validate have side effects, so it's not implemented for now\n+        # (np.float32(np.pi / 2), np.pi / 2, np.float64, np.float64),\n+        # (np.float32(-np.pi / 2), -np.pi / 2, np.float64, np.float64),\n+    ]\n+)\n+def test_latitude_limits(value, expected_value, dtype, expected_dtype, sign):\n+    \"\"\"\n+    Test that the validation of the Latitude value range in radians works\n+    in both float32 and float64.\n+\n+    As discussed in issue #13708, before, the float32 represenation of pi/2\n+    was rejected as invalid because the comparison always used the float64\n+    representation.\n+    \"\"\"\n+    # this prevents upcasting to float64 as sign * value would do\n+    if sign < 0:\n+        value = -value\n+        expected_value = -expected_value\n+\n+    result = Latitude(value, u.rad, dtype=dtype)\n+    assert result.value == expected_value\n+    assert result.dtype == expected_dtype\n+    assert result.unit == u.rad\n+\n+\n+@pytest.mark.parametrize(\n+    \"value,dtype\",\n+    [\n+        (0.50001 * np.pi, np.float32),\n+        (np.float32(0.50001 * np.pi), np.float32),\n+        (0.50001 * np.pi, np.float64),\n+    ]\n+)\n+def test_latitude_out_of_limits(value, dtype):\n+    \"\"\"\n+    Test that values slightly larger than pi/2 are rejected for different dtypes.\n+    Test cases for issue #13708\n+    \"\"\"\n+    with pytest.raises(ValueError, match=r\"Latitude angle\\(s\\) must be within.*\"):\n+        Latitude(value, u.rad, dtype=dtype)\n",
  "problem_statement": "float32 representation of pi/2 is rejected by `Latitude`\n<!-- This comments are hidden when you submit the issue,\r\nso you do not need to remove them! -->\r\n\r\n<!-- Please be sure to check out our contributing guidelines,\r\nhttps://github.com/astropy/astropy/blob/main/CONTRIBUTING.md .\r\nPlease be sure to check out our code of conduct,\r\nhttps://github.com/astropy/astropy/blob/main/CODE_OF_CONDUCT.md . -->\r\n\r\n<!-- Please have a search on our GitHub repository to see if a similar\r\nissue has already been posted.\r\nIf a similar issue is closed, have a quick look to see if you are satisfied\r\nby the resolution.\r\nIf not please go ahead and open an issue! -->\r\n\r\n<!-- Please check that the development version still produces the same bug.\r\nYou can install development version with\r\npip install git+https://github.com/astropy/astropy\r\ncommand. -->\r\n\r\n### Description\r\n\r\nThe closest float32 value to pi/2 is by accident slightly larger than pi/2:\r\n\r\n```\r\nIn [5]: np.pi/2\r\nOut[5]: 1.5707963267948966\r\n\r\nIn [6]: np.float32(np.pi/2)\r\nOut[6]: 1.5707964\r\n```\r\n\r\nAstropy checks using float64 precision, rejecting \"valid\" alt values (e.g. float32 values read from files):\r\n\r\n```\r\n\r\nIn [1]: from astropy.coordinates import Latitude\r\n\r\nIn [2]: import numpy as np\r\n\r\nIn [3]: lat = np.float32(np.pi/2)\r\n\r\nIn [4]: Latitude(lat, 'rad')\r\n---------------------------------------------------------------------------\r\nValueError                                Traceback (most recent call last)\r\nCell In [4], line 1\r\n----> 1 Latitude(lat, 'rad')\r\n\r\nFile ~/.local/lib/python3.10/site-packages/astropy/coordinates/angles.py:564, in Latitude.__new__(cls, angle, unit, **kwargs)\r\n    562     raise TypeError(\"A Latitude angle cannot be created from a Longitude angle\")\r\n    563 self = super().__new__(cls, angle, unit=unit, **kwargs)\r\n--> 564 self._validate_angles()\r\n    565 return self\r\n\r\nFile ~/.local/lib/python3.10/site-packages/astropy/coordinates/angles.py:585, in Latitude._validate_angles(self, angles)\r\n    582     invalid_angles = (np.any(angles.value < lower) or\r\n    583                       np.any(angles.value > upper))\r\n    584 if invalid_angles:\r\n--> 585     raise ValueError('Latitude angle(s) must be within -90 deg <= angle <= 90 deg, '\r\n    586                      'got {}'.format(angles.to(u.degree)))\r\n\r\nValueError: Latitude angle(s) must be within -90 deg <= angle <= 90 deg, got 90.00000250447816 deg\r\n```\r\n\r\n### Expected behavior\r\n\r\nBe lenient? E.g. only make the comparison up to float 32 precision?\r\n\r\n### Actual behavior\r\nSee error above\r\n\r\n### Steps to Reproduce\r\n\r\nSee snippet above.\r\n\r\n### System Details\r\n<!-- Even if you do not think this is necessary, it is useful information for the maintainers.\r\nPlease run the following snippet and paste the output below:\r\nimport platform; print(platform.platform())\r\nimport sys; print(\"Python\", sys.version)\r\nimport numpy; print(\"Numpy\", numpy.__version__)\r\nimport erfa; print(\"pyerfa\", erfa.__version__)\r\nimport astropy; print(\"astropy\", astropy.__version__)\r\nimport scipy; print(\"Scipy\", scipy.__version__)\r\nimport matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\n-->\r\n```\r\nLinux-5.15.65-1-MANJARO-x86_64-with-glibc2.36\r\nPython 3.10.7 (main, Sep  6 2022, 21:22:27) [GCC 12.2.0]\r\nNumpy 1.23.3\r\npyerfa 2.0.0.1\r\nastropy 5.0.1\r\nScipy 1.9.1\r\nMatplotlib 3.5.2\r\n```\n",
  "hints_text": "> Be lenient? E.g. only make the comparison up to float 32 precision?\r\n\r\nInstead, we could make the comparison based on the precision of the ``dtype``, using something like https://numpy.org/doc/stable/reference/generated/numpy.finfo.html?highlight=finfo#numpy.finfo\nThat's a funny one! I think @nstarman's suggestion would work: would just need to change the dtype of `limit` to `self.dtype` in `_validate_angles`.\nThat wouldn't solve the case where the value is read from a float32 into a float64, which can happen pretty fast due to the places where casting can happen. Better than nothing, but...\nDo we want to simply let it pass with that value, or rather \"round\" the input value down to the float64 representation of `pi/2`? Just wondering what may happen with larger values in any calculations down the line; probably nothing really terrible (like ending up with inverse Longitude), but...\nThis is what I did to fix it on our end:\r\nhttps://github.com/cta-observatory/ctapipe/pull/2077/files#diff-d2022785b8c35b2f43d3b9d43c3721efaa9339d98dbff39c864172f1ba2f4f6f\r\n```python\r\n_half_pi = 0.5 * np.pi\r\n_half_pi_maxval = (1 + 1e-6) * _half_pi\r\n\r\n\r\n\r\n\r\ndef _clip_altitude_if_close(altitude):\r\n    \"\"\"\r\n    Round absolute values slightly larger than pi/2 in float64 to pi/2\r\n\r\n    These can come from simtel_array because float32(pi/2) > float64(pi/2)\r\n    and simtel using float32.\r\n\r\n    Astropy complains about these values, so we fix them here.\r\n    \"\"\"\r\n    if altitude > _half_pi and altitude < _half_pi_maxval:\r\n        return _half_pi\r\n\r\n\r\n    if altitude < -_half_pi and altitude > -_half_pi_maxval:\r\n        return -_half_pi\r\n\r\n\r\n    return altitude\r\n```\r\n\r\nWould that be an acceptable solution also here?\nDoes this keep the numpy dtype of the input?\nNo, the point is that this casts to float64.\nSo ``Latitude(pi/2, unit=u.deg, dtype=float32)``  can become a float64?\n> Does this keep the numpy dtype of the input?\r\n\r\nIf `limit` is cast to `self.dtype` (is that identical to `self.angle.dtype`?) as per your suggestion above, it should.\r\nBut that modification should already catch the cases of `angle` still passed as float32, since both are compared at the same resolution. I'd vote to do this and only implement the more lenient comparison (for float32 that had already been upcast to float64)  as a fallback, i.e. if still `invalid_angles`, set something like\r\n`_half_pi_maxval = (0.5 + np.finfo(np.float32).eps)) * np.pi` and do a second comparison to that, if that passes, set to  `limit * np.sign(self.angle)`. Have to remember that `self.angle` is an array in general...\n> So `Latitude(pi/2, unit=u.deg, dtype=float32)` can become a float64?\r\n\r\n`Latitude(pi/2, unit=u.rad, dtype=float32)` would in that approach, as it currently raises the `ValueError`.\nI'll open a PR with unit test cases and then we can decide about the wanted behaviour for each of them",
  "created_at": "2022-09-23T11:54:47Z",
  "version": "5.0",
  "FAIL_TO_PASS": "[\"astropy/coordinates/tests/test_angles.py::test_latitude_limits[value2-expected_value2-None-float32--1]\", \"astropy/coordinates/tests/test_angles.py::test_latitude_limits[value2-expected_value2-None-float32-1]\", \"astropy/coordinates/tests/test_angles.py::test_latitude_limits[value3-expected_value3-float32-float32--1]\", \"astropy/coordinates/tests/test_angles.py::test_latitude_limits[value3-expected_value3-float32-float32-1]\"]",
  "PASS_TO_PASS": "[\"astropy/coordinates/tests/test_angles.py::test_create_angles\", \"astropy/coordinates/tests/test_angles.py::test_angle_from_view\", \"astropy/coordinates/tests/test_angles.py::test_angle_ops\", \"astropy/coordinates/tests/test_angles.py::test_angle_methods\", \"astropy/coordinates/tests/test_angles.py::test_angle_convert\", \"astropy/coordinates/tests/test_angles.py::test_angle_formatting\", \"astropy/coordinates/tests/test_angles.py::test_to_string_vector\", \"astropy/coordinates/tests/test_angles.py::test_angle_format_roundtripping\", \"astropy/coordinates/tests/test_angles.py::test_radec\", \"astropy/coordinates/tests/test_angles.py::test_negative_zero_dms\", \"astropy/coordinates/tests/test_angles.py::test_negative_zero_dm\", \"astropy/coordinates/tests/test_angles.py::test_negative_zero_hms\", \"astropy/coordinates/tests/test_angles.py::test_negative_zero_hm\", \"astropy/coordinates/tests/test_angles.py::test_negative_sixty_hm\", \"astropy/coordinates/tests/test_angles.py::test_plus_sixty_hm\", \"astropy/coordinates/tests/test_angles.py::test_negative_fifty_nine_sixty_dms\", \"astropy/coordinates/tests/test_angles.py::test_plus_fifty_nine_sixty_dms\", \"astropy/coordinates/tests/test_angles.py::test_negative_sixty_dms\", \"astropy/coordinates/tests/test_angles.py::test_plus_sixty_dms\", \"astropy/coordinates/tests/test_angles.py::test_angle_to_is_angle\", \"astropy/coordinates/tests/test_angles.py::test_angle_to_quantity\", \"astropy/coordinates/tests/test_angles.py::test_quantity_to_angle\", \"astropy/coordinates/tests/test_angles.py::test_angle_string\", \"astropy/coordinates/tests/test_angles.py::test_angle_repr\", \"astropy/coordinates/tests/test_angles.py::test_large_angle_representation\", \"astropy/coordinates/tests/test_angles.py::test_wrap_at_inplace\", \"astropy/coordinates/tests/test_angles.py::test_latitude\", \"astropy/coordinates/tests/test_angles.py::test_longitude\", \"astropy/coordinates/tests/test_angles.py::test_wrap_at\", \"astropy/coordinates/tests/test_angles.py::test_is_within_bounds\", \"astropy/coordinates/tests/test_angles.py::test_angle_mismatched_unit\", \"astropy/coordinates/tests/test_angles.py::test_regression_formatting_negative\", \"astropy/coordinates/tests/test_angles.py::test_regression_formatting_default_precision\", \"astropy/coordinates/tests/test_angles.py::test_empty_sep\", \"astropy/coordinates/tests/test_angles.py::test_create_tuple\", \"astropy/coordinates/tests/test_angles.py::test_list_of_quantities\", \"astropy/coordinates/tests/test_angles.py::test_multiply_divide\", \"astropy/coordinates/tests/test_angles.py::test_mixed_string_and_quantity\", \"astropy/coordinates/tests/test_angles.py::test_array_angle_tostring\", \"astropy/coordinates/tests/test_angles.py::test_wrap_at_without_new\", \"astropy/coordinates/tests/test_angles.py::test__str__\", \"astropy/coordinates/tests/test_angles.py::test_repr_latex\", \"astropy/coordinates/tests/test_angles.py::test_angle_with_cds_units_enabled\", \"astropy/coordinates/tests/test_angles.py::test_longitude_nan\", \"astropy/coordinates/tests/test_angles.py::test_latitude_nan\", \"astropy/coordinates/tests/test_angles.py::test_angle_wrap_at_nan\", \"astropy/coordinates/tests/test_angles.py::test_angle_multithreading\", \"astropy/coordinates/tests/test_angles.py::test_str_repr_angles_nan[input0-nan-nan\", \"astropy/coordinates/tests/test_angles.py::test_str_repr_angles_nan[input1-[nan\", \"astropy/coordinates/tests/test_angles.py::test_str_repr_angles_nan[input2-[6d00m00s\", \"astropy/coordinates/tests/test_angles.py::test_str_repr_angles_nan[input3-[nan\", \"astropy/coordinates/tests/test_angles.py::test_str_repr_angles_nan[input4-nan-nan\", \"astropy/coordinates/tests/test_angles.py::test_str_repr_angles_nan[input5-[nan\", \"astropy/coordinates/tests/test_angles.py::test_str_repr_angles_nan[input6-[6h00m00s\", \"astropy/coordinates/tests/test_angles.py::test_str_repr_angles_nan[input7-[nan\", \"astropy/coordinates/tests/test_angles.py::test_str_repr_angles_nan[input8-nan-nan\", \"astropy/coordinates/tests/test_angles.py::test_str_repr_angles_nan[input9-[nan\", \"astropy/coordinates/tests/test_angles.py::test_str_repr_angles_nan[input10-[1.5rad\", \"astropy/coordinates/tests/test_angles.py::test_str_repr_angles_nan[input11-[nan\", \"astropy/coordinates/tests/test_angles.py::test_latitude_limits[1.5707963267948966-1.5707963267948966-None-float64--1]\", \"astropy/coordinates/tests/test_angles.py::test_latitude_limits[1.5707963267948966-1.5707963267948966-None-float64-1]\", \"astropy/coordinates/tests/test_angles.py::test_latitude_limits[1.5707963267948966-1.5707963267948966-float64-float64--1]\", \"astropy/coordinates/tests/test_angles.py::test_latitude_limits[1.5707963267948966-1.5707963267948966-float64-float64-1]\", \"astropy/coordinates/tests/test_angles.py::test_latitude_out_of_limits[1.5708277427214323-float32]\", \"astropy/coordinates/tests/test_angles.py::test_latitude_out_of_limits[value1-float32]\", \"astropy/coordinates/tests/test_angles.py::test_latitude_out_of_limits[1.5708277427214323-float64]\"]",
  "environment_setup_commit": "cdf311e0714e611d48b0a31eb1f0e2cbffab7f23",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.534333",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}