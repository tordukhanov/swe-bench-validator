{
  "repo": "sphinx-doc/sphinx",
  "instance_id": "sphinx-doc__sphinx-7814",
  "base_commit": "55fc097833ee1e0efc689ddc85bd2af2e77f4af7",
  "patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -623,7 +623,8 @@ def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]\n \n         typ = self.options.get('type')\n         if typ:\n-            signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), type_to_xref(typ))\n+            annotations = _parse_annotation(typ)\n+            signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), *annotations)\n \n         value = self.options.get('value')\n         if value:\n@@ -868,7 +869,8 @@ def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]\n \n         typ = self.options.get('type')\n         if typ:\n-            signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), type_to_xref(typ))\n+            annotations = _parse_annotation(typ)\n+            signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), *annotations)\n \n         value = self.options.get('value')\n         if value:\n",
  "test_patch": "diff --git a/tests/test_domain_py.py b/tests/test_domain_py.py\n--- a/tests/test_domain_py.py\n+++ b/tests/test_domain_py.py\n@@ -679,7 +679,7 @@ def test_pyattribute(app):\n     text = (\".. py:class:: Class\\n\"\n             \"\\n\"\n             \"   .. py:attribute:: attr\\n\"\n-            \"      :type: str\\n\"\n+            \"      :type: Optional[str]\\n\"\n             \"      :value: ''\\n\")\n     domain = app.env.get_domain('py')\n     doctree = restructuredtext.parse(app, text)\n@@ -692,7 +692,10 @@ def test_pyattribute(app):\n                 entries=[('single', 'attr (Class attribute)', 'Class.attr', '', None)])\n     assert_node(doctree[1][1][1], ([desc_signature, ([desc_name, \"attr\"],\n                                                      [desc_annotation, (\": \",\n-                                                                        [pending_xref, \"str\"])],\n+                                                                        [pending_xref, \"Optional\"],\n+                                                                        [desc_sig_punctuation, \"[\"],\n+                                                                        [pending_xref, \"str\"],\n+                                                                        [desc_sig_punctuation, \"]\"])],\n                                                      [desc_annotation, \" = ''\"])],\n                                    [desc_content, ()]))\n     assert 'Class.attr' in domain.objects\n",
  "problem_statement": "Warnings raised on variable and attribute type annotations\n**Describe the bug**\r\n\r\nautodoc signature for non-builtin types raises warning and thus fails nitpicking:\r\n\r\n```\r\n/path/to/foo.py:docstring of foo.Foo.a:: WARNING: py:class reference target not found: Optional[str]\r\n```\r\n\r\n**To Reproduce**\r\n\r\nSteps to reproduce the behavior:\r\n\r\nCreate a file `foo.py` with the following content:\r\n```python\r\nfrom typing import Optional\r\n\r\n\r\nclass Foo:\r\n    a: Optional[str] = None\r\n```\r\n\r\nUse sphinx-apidoc to generate an rst file, while enabling autodoc and intersphinx: `sphinx-apidoc --ext-autodoc --ext-intersphinx`\r\n\r\nMake sure the `intersphinx_mapping` in the Sphinx `conf.py` contains `\"python\": (\"https://docs.python.org/3.8/\", None),`\r\n\r\nRun `make html` with loud warnings and nitpicking: `SPHINXOPTS=\"-n -v -W --keep-going\" make html`.\r\n\r\nYou will get an error message\r\n```\r\n/path/to/foo.py:docstring of foo.Foo.a:: WARNING: py:class reference target not found: Optional[str]\r\n```\r\n\r\n**Expected behavior**\r\n\r\nI'd expect Sphinx to resolve the type annotation `Optional[str]` and possibly link both classes.\r\n\r\n**Environment info**\r\n- OS: Linux\r\n- Python version: 3.8.3\r\n- Sphinx version: 3.1.0\r\n- Sphinx extensions:  sphinx.ext.autodoc, sphinx.ext.intersphinx\r\n\r\n**Additional context**\r\n\r\nI think the issue stems from the change in 88e8ebbe199c151a14d7df814807172f7565a073 which appears to try to lookup the entire type annotation as a single class.\r\n\r\nUsing `_parse_annotation()` instead of `type_to_xref()` solves this particular issue:\r\n```diff\r\ndiff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\r\nindex fc1136ae2..6101de56a 100644\r\n--- a/sphinx/domains/python.py\r\n+++ b/sphinx/domains/python.py\r\n@@ -623,7 +623,7 @@ class PyVariable(PyObject):\r\n \r\n         typ = self.options.get('type')\r\n         if typ:\r\n-            signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), type_to_xref(typ))\r\n+            signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), *_parse_annotation(typ))\r\n \r\n         value = self.options.get('value')\r\n         if value:\r\n@@ -868,7 +868,7 @@ class PyAttribute(PyObject):\r\n \r\n         typ = self.options.get('type')\r\n         if typ:\r\n-            signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), type_to_xref(typ))\r\n+            signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), *_parse_annotation(typ))\r\n \r\n         value = self.options.get('value')\r\n         if value:\r\n```\r\n\r\nHowever, it doesn't seem to work with custom classes. Take this snippet for example:\r\n```python\r\nclass Bar:\r\n    i: int\r\n\r\n\r\nclass Foo:\r\n    a: Bar\r\n```\r\nThis causes the following warning:\r\n```\r\nfoo.py:docstring of foo.Foo.a:: WARNING: py:class reference target not found: Bar\r\n```\n",
  "hints_text": "We have a similar problem in the Trio project where we use annotations like \"str or list\", ThisType or None\" or even \"bytes-like\" in a number of place. Here's an example: https://github.com/python-trio/trio/blob/dependabot/pip/sphinx-3.1.0/trio/_subprocess.py#L75-L96\nTo clarify a bit on the Trio issue: we don't expect sphinx to magically do anything with `bytes-like`, but currently you can use something like this in a Google-style docstring:\r\n\r\n```\r\n    Attributes:\r\n      args (str or list): The ``command`` passed at construction time,\r\n          specifying the process to execute and its arguments.\r\n```\r\n\r\nAnd with previous versions of Sphinx, it renders like this:\r\n\r\n![image](https://user-images.githubusercontent.com/609896/84207125-73d55100-aa65-11ea-98e6-4b3b8f619be9.png)\r\n\r\nhttps://trio.readthedocs.io/en/v0.15.1/reference-io.html#trio.Process.args\r\n\r\nNotice that `str` and `list` are both hyperlinked appropriately.\r\n\r\nSo Sphinx used to be able to cope with this kind of \"or\" syntax, and if it can't anymore it's a regression.\nThis also occurs with built-in container classes and 'or'-types (in nitpick mode):\r\n```\r\nWARNING: py:class reference target not found: tuple[str]\r\nWARNING: py:class reference target not found: str or None\r\n```\r\n\r\nUnfortunately this breaks my CI pipeline at the moment. Does anyone know a work-around other than disabling nitpick mode?\r\n",
  "created_at": "2020-06-10T14:00:51Z",
  "version": "3.1",
  "FAIL_TO_PASS": "[\"tests/test_domain_py.py::test_pyattribute\"]",
  "PASS_TO_PASS": "[\"tests/test_domain_py.py::test_function_signatures\", \"tests/test_domain_py.py::test_domain_py_xrefs\", \"tests/test_domain_py.py::test_domain_py_objects\", \"tests/test_domain_py.py::test_resolve_xref_for_properties\", \"tests/test_domain_py.py::test_domain_py_find_obj\", \"tests/test_domain_py.py::test_get_full_qualified_name\", \"tests/test_domain_py.py::test_parse_annotation\", \"tests/test_domain_py.py::test_pyfunction_signature\", \"tests/test_domain_py.py::test_pyfunction_signature_full\", \"tests/test_domain_py.py::test_pyfunction_signature_full_py38\", \"tests/test_domain_py.py::test_optional_pyfunction_signature\", \"tests/test_domain_py.py::test_pyexception_signature\", \"tests/test_domain_py.py::test_exceptions_module_is_ignored\", \"tests/test_domain_py.py::test_pydata_signature\", \"tests/test_domain_py.py::test_pydata_signature_old\", \"tests/test_domain_py.py::test_pyobject_prefix\", \"tests/test_domain_py.py::test_pydata\", \"tests/test_domain_py.py::test_pyfunction\", \"tests/test_domain_py.py::test_pyclass_options\", \"tests/test_domain_py.py::test_pymethod_options\", \"tests/test_domain_py.py::test_pyclassmethod\", \"tests/test_domain_py.py::test_pystaticmethod\", \"tests/test_domain_py.py::test_pydecorator_signature\", \"tests/test_domain_py.py::test_pydecoratormethod_signature\", \"tests/test_domain_py.py::test_module_index\", \"tests/test_domain_py.py::test_module_index_submodule\", \"tests/test_domain_py.py::test_module_index_not_collapsed\", \"tests/test_domain_py.py::test_modindex_common_prefix\"]",
  "environment_setup_commit": "5afc77ee27fc01c57165ab260d3a76751f9ddb35",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.046877",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}