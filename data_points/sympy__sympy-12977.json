{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-12977",
  "base_commit": "34d83416b3e0223b4e8abaa582416812719b81da",
  "patch": "diff --git a/sympy/core/function.py b/sympy/core/function.py\n--- a/sympy/core/function.py\n+++ b/sympy/core/function.py\n@@ -425,13 +425,12 @@ def __new__(cls, *args, **options):\n \n         evaluate = options.get('evaluate', global_evaluate[0])\n         result = super(Function, cls).__new__(cls, *args, **options)\n-        if not evaluate or not isinstance(result, cls):\n-            return result\n+        if evaluate and isinstance(result, cls) and result.args:\n+            pr2 = min(cls._should_evalf(a) for a in result.args)\n+            if pr2 > 0:\n+                pr = max(cls._should_evalf(a) for a in result.args)\n+                result = result.evalf(mlib.libmpf.prec_to_dps(pr))\n \n-        pr = max(cls._should_evalf(a) for a in result.args)\n-        pr2 = min(cls._should_evalf(a) for a in result.args)\n-        if pr2 > 0:\n-            return result.evalf(mlib.libmpf.prec_to_dps(pr))\n         return result\n \n     @classmethod\n",
  "test_patch": "diff --git a/sympy/core/tests/test_function.py b/sympy/core/tests/test_function.py\n--- a/sympy/core/tests/test_function.py\n+++ b/sympy/core/tests/test_function.py\n@@ -47,6 +47,17 @@ def test_general_function():\n     assert edxdx == diff(diff(nu(x), x), x)\n     assert edxdy == 0\n \n+def test_general_function_nullary():\n+    nu = Function('nu')\n+\n+    e = nu()\n+    edx = e.diff(x)\n+    edxdx = e.diff(x).diff(x)\n+    assert e == nu()\n+    assert edx != nu()\n+    assert edx == 0\n+    assert edxdx == 0\n+\n \n def test_derivative_subs_bug():\n     e = diff(g(x), x)\n@@ -96,6 +107,15 @@ def test_diff_symbols():\n \n \n def test_Function():\n+    class myfunc(Function):\n+        @classmethod\n+        def eval(cls):  # zero args\n+            return\n+\n+    assert myfunc.nargs == FiniteSet(0)\n+    assert myfunc().nargs == FiniteSet(0)\n+    raises(TypeError, lambda: myfunc(x).nargs)\n+\n     class myfunc(Function):\n         @classmethod\n         def eval(cls, x):  # one arg\n@@ -136,6 +156,12 @@ def test_Lambda():\n     assert e(x) == x**2\n     assert e(y) == y**2\n \n+    assert Lambda((), 42)() == 42\n+    assert Lambda((), 42) == Lambda((), 42)\n+    assert Lambda((), 42) != Lambda((), 43)\n+    assert Lambda((), f(x))() == f(x)\n+    assert Lambda((), 42).nargs == FiniteSet(0)\n+\n     assert Lambda(x, x**2) == Lambda(x, x**2)\n     assert Lambda(x, x**2) == Lambda(y, y**2)\n     assert Lambda(x, x**2) != Lambda(y, y**2 + 1)\n@@ -161,6 +187,7 @@ def test_Lambda():\n     assert Lambda(x, 1)(1) is S.One\n \n \n+\n def test_IdentityFunction():\n     assert Lambda(x, x) is Lambda(y, y) is S.IdentityFunction\n     assert Lambda(x, 2*x) is not S.IdentityFunction\n@@ -170,11 +197,14 @@ def test_IdentityFunction():\n def test_Lambda_symbols():\n     assert Lambda(x, 2*x).free_symbols == set()\n     assert Lambda(x, x*y).free_symbols == {y}\n+    assert Lambda((), 42).free_symbols == set()\n+    assert Lambda((), x*y).free_symbols == {x,y}\n \n \n def test_Lambda_arguments():\n     raises(TypeError, lambda: Lambda(x, 2*x)(x, y))\n     raises(TypeError, lambda: Lambda((x, y), x + y)(x))\n+    raises(TypeError, lambda: Lambda((), 42)(x))\n \n \n def test_Lambda_equality():\n",
  "problem_statement": "nullary functions should be allowed\n```\nIn [34]: f()\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n<ipython-input-34-0ec059b9bfe1> in <module>()\n----> 1 f()\n\n/Users/aaronmeurer/Documents/Python/sympy/sympy/sympy/core/function.pyc in __new__(cls, *args, **options)\n    622     def __new__(cls, *args, **options):\n    623         args = map(sympify, args)\n--> 624         result = super(AppliedUndef, cls).__new__(cls, *args, **options)\n    625         result.nargs = len(args)\n    626         return result\n\n/Users/aaronmeurer/Documents/Python/sympy/sympy/sympy/core/cache.pyc in wrapper(*args, **kw_args)\n     90         except KeyError:\n     91             pass\n---> 92         func_cache_it_cache[k] = r = func(*args, **kw_args)\n     93         return r\n     94     return wrapper\n\n/Users/aaronmeurer/Documents/Python/sympy/sympy/sympy/core/function.pyc in __new__(cls, *args, **options)\n    282             return result\n    283\n--> 284         pr = max(cls._should_evalf(a) for a in result.args)\n    285         pr2 = min(cls._should_evalf(a) for a in result.args)\n    286         if pr2 > 0:\n\nValueError: max() arg is an empty sequence\n\nIt should also work with explicit subclasses of Function.\n```\n\nOriginal issue for #6984: http://code.google.com/p/sympy/issues/detail?id=3885\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n",
  "hints_text": "```\nHow this could be useful, any example?  Keep in mind that f is a pure mathematical function (doesn't have side-effects, etc), not anything \"callable\" from python's point of view.\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=3885#c1\nOriginal author: https://code.google.com/u/113518207426301808764/\n\n```\nTo provide a uniform interface to something that wants to represent functions called with n args, where n could be 0. \n\nSee https://github.com/sympy/sympy/pull/2640#discussion_r8360098 for an example.\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=3885#c2\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n",
  "created_at": "2017-07-16T08:38:53Z",
  "version": "1.1",
  "FAIL_TO_PASS": "[\"test_general_function_nullary\", \"test_Function\", \"test_function_evalf\"]",
  "PASS_TO_PASS": "[\"test_f_expand_complex\", \"test_bug1\", \"test_general_function\", \"test_derivative_subs_bug\", \"test_derivative_subs_self_bug\", \"test_derivative_linearity\", \"test_derivative_evaluate\", \"test_diff_symbols\", \"test_nargs\", \"test_Lambda\", \"test_IdentityFunction\", \"test_Lambda_symbols\", \"test_Lambda_arguments\", \"test_Lambda_equality\", \"test_expand_function\", \"test_function_comparable\", \"test_deriv1\", \"test_deriv2\", \"test_func_deriv\", \"test_suppressed_evaluation\", \"test_extensibility_eval\", \"test_function_non_commutative\", \"test_function_complex\", \"test_doit\", \"test_evalf_default\", \"test_issue_5399\", \"test_derivative_numerically\", \"test_fdiff_argument_index_error\", \"test_deriv_wrt_function\", \"test_diff_wrt_value\", \"test_diff_wrt\", \"test_diff_wrt_func_subs\", \"test_diff_wrt_not_allowed\", \"test_klein_gordon_lagrangian\", \"test_sho_lagrangian\", \"test_straight_line\", \"test_sort_variable\", \"test_unhandled\", \"test_issue_4711\", \"test_issue_7068\", \"test_issue_7687\", \"test_issue_7688\", \"test_mexpand\", \"test_issue_8469\", \"test_Derivative_as_finite_difference\", \"test_issue_11159\"]",
  "environment_setup_commit": "ec9e3c0436fbff934fa84e22bf07f1b3ef5bfac3",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.078907",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}