{
  "repo": "django/django",
  "instance_id": "django__django-11916",
  "base_commit": "09578f6dfb757c55f107e30a85434cedeb47465a",
  "patch": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -883,6 +883,7 @@ def _apply_rel_filters(self, queryset):\n             queryset._add_hints(instance=self.instance)\n             if self._db:\n                 queryset = queryset.using(self._db)\n+            queryset._defer_next_filter = True\n             return queryset._next_is_sticky().filter(**self.core_filters)\n \n         def _remove_prefetched_objects(self):\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -189,7 +189,7 @@ def __init__(self, model=None, query=None, using=None, hints=None):\n         self.model = model\n         self._db = using\n         self._hints = hints or {}\n-        self.query = query or sql.Query(self.model)\n+        self._query = query or sql.Query(self.model)\n         self._result_cache = None\n         self._sticky_filter = False\n         self._for_write = False\n@@ -198,6 +198,20 @@ def __init__(self, model=None, query=None, using=None, hints=None):\n         self._known_related_objects = {}  # {rel_field: {pk: rel_obj}}\n         self._iterable_class = ModelIterable\n         self._fields = None\n+        self._defer_next_filter = False\n+        self._deferred_filter = None\n+\n+    @property\n+    def query(self):\n+        if self._deferred_filter:\n+            negate, args, kwargs = self._deferred_filter\n+            self._filter_or_exclude_inplace(negate, *args, **kwargs)\n+            self._deferred_filter = None\n+        return self._query\n+\n+    @query.setter\n+    def query(self, value):\n+        self._query = value\n \n     def as_manager(cls):\n         # Address the circular dependency between `Queryset` and `Manager`.\n@@ -914,12 +928,19 @@ def _filter_or_exclude(self, negate, *args, **kwargs):\n                 \"Cannot filter a query once a slice has been taken.\"\n \n         clone = self._chain()\n-        if negate:\n-            clone.query.add_q(~Q(*args, **kwargs))\n+        if self._defer_next_filter:\n+            self._defer_next_filter = False\n+            clone._deferred_filter = negate, args, kwargs\n         else:\n-            clone.query.add_q(Q(*args, **kwargs))\n+            clone._filter_or_exclude_inplace(negate, *args, **kwargs)\n         return clone\n \n+    def _filter_or_exclude_inplace(self, negate, *args, **kwargs):\n+        if negate:\n+            self._query.add_q(~Q(*args, **kwargs))\n+        else:\n+            self._query.add_q(Q(*args, **kwargs))\n+\n     def complex_filter(self, filter_obj):\n         \"\"\"\n         Return a new QuerySet instance with filter_obj added to the filters.\n@@ -935,7 +956,7 @@ def complex_filter(self, filter_obj):\n             clone.query.add_q(filter_obj)\n             return clone\n         else:\n-            return self._filter_or_exclude(None, **filter_obj)\n+            return self._filter_or_exclude(False, **filter_obj)\n \n     def _combinator_query(self, combinator, *other_qs, all=False):\n         # Clone the query to inherit the select list and everything\n",
  "test_patch": "diff --git a/tests/prefetch_related/tests.py b/tests/prefetch_related/tests.py\n--- a/tests/prefetch_related/tests.py\n+++ b/tests/prefetch_related/tests.py\n@@ -5,6 +5,7 @@\n from django.db import connection\n from django.db.models import Prefetch, QuerySet\n from django.db.models.query import get_prefetcher, prefetch_related_objects\n+from django.db.models.sql import Query\n from django.test import TestCase, override_settings\n from django.test.utils import CaptureQueriesContext\n \n@@ -291,6 +292,20 @@ def test_m2m_then_reverse_one_to_one_object_ids(self):\n         sql = queries[-1]['sql']\n         self.assertWhereContains(sql, self.author1.id)\n \n+    def test_filter_deferred(self):\n+        \"\"\"\n+        Related filtering of prefetched querysets is deferred until necessary.\n+        \"\"\"\n+        add_q = Query.add_q\n+        with mock.patch.object(\n+            Query,\n+            'add_q',\n+            autospec=True,\n+            side_effect=lambda self, q: add_q(self, q),\n+        ) as add_q_mock:\n+            list(Book.objects.prefetch_related('authors'))\n+            self.assertEqual(add_q_mock.call_count, 1)\n+\n \n class RawQuerySetTests(TestDataMixin, TestCase):\n     def test_basic(self):\n@@ -823,6 +838,22 @@ def test_to_attr_cached_property(self):\n             with self.assertNumQueries(0):\n                 self.assertEqual(person.cached_all_houses, all_houses)\n \n+    def test_filter_deferred(self):\n+        \"\"\"\n+        Related filtering of prefetched querysets is deferred until necessary.\n+        \"\"\"\n+        add_q = Query.add_q\n+        with mock.patch.object(\n+            Query,\n+            'add_q',\n+            autospec=True,\n+            side_effect=lambda self, q: add_q(self, q),\n+        ) as add_q_mock:\n+            list(House.objects.prefetch_related(\n+                Prefetch('occupants', queryset=Person.objects.all())\n+            ))\n+            self.assertEqual(add_q_mock.call_count, 1)\n+\n \n class DefaultManagerTests(TestCase):\n \ndiff --git a/tests/queryset_pickle/tests.py b/tests/queryset_pickle/tests.py\n--- a/tests/queryset_pickle/tests.py\n+++ b/tests/queryset_pickle/tests.py\n@@ -212,6 +212,12 @@ def test_annotation_with_callable_default(self):\n         qs = Happening.objects.annotate(latest_time=models.Max('when'))\n         self.assert_pickles(qs)\n \n+    def test_filter_deferred(self):\n+        qs = Happening.objects.all()\n+        qs._defer_next_filter = True\n+        qs = qs.filter(id=0)\n+        self.assert_pickles(qs)\n+\n     def test_missing_django_version_unpickling(self):\n         \"\"\"\n         #21430 -- Verifies a warning is raised for querysets that are\n",
  "problem_statement": "Make prefetch_related faster by lazily creating related querysets\nDescription\n\t\nIn one project of mine I will need to prefetch the following things for each \"machine\": computerdata__operatingsystem, identifiers. computerdata is one-to-one to machine, operatingsystem is manytomany, and identifiers are many-to-one. The data is distributed in a way that any one machine have on average one operating system, and a couple of identifiers.\nFetching data results in this profile:\n\t\t1\t0.000\t0.000\t6.835\t6.835 manage.py:2(<module>)\n\t\t1\t0.000\t0.000\t6.795\t6.795 __init__.py:394(execute_from_command_line)\n\t\t1\t0.000\t0.000\t6.795\t6.795 __init__.py:350(execute)\n\t\t1\t0.000\t0.000\t6.207\t6.207 base.py:228(run_from_argv)\n\t\t1\t0.000\t0.000\t6.199\t6.199 base.py:250(execute)\n\t\t1\t0.000\t0.000\t6.072\t6.072 ad_guess.py:9(handle)\n\t 10/2\t0.016\t0.002\t6.069\t3.034 query.py:853(_fetch_all)\n\t 6/1\t0.000\t0.000\t6.043\t6.043 query.py:80(__iter__)\n\t\t1\t0.000\t0.000\t5.837\t5.837 query.py:517(_prefetch_related_objects)\n\t\t1\t0.009\t0.009\t5.837\t5.837 query.py:1512(prefetch_related_objects)\n\t\t3\t0.080\t0.027\t5.819\t1.940 query.py:1671(prefetch_one_level)\n\t 4640\t0.018\t0.000\t3.917\t0.001 manager.py:132(all)\n\t 4646\t0.014\t0.000\t3.206\t0.001 query.py:587(filter)\n\t 4648\t0.037\t0.000\t3.193\t0.001 query.py:601(_filter_or_exclude)\n\t 4648\t0.031\t0.000\t2.661\t0.001 query.py:1188(add_q)\n\t 4648\t0.053\t0.000\t2.401\t0.001 query.py:1208(_add_q)\n\t 4648\t0.144\t0.000\t2.284\t0.000 query.py:1010(build_filter)\n\t 2320\t0.040\t0.000\t2.076\t0.001 related.py:529(get_queryset)\n\t 2320\t0.063\t0.000\t1.823\t0.001 related.py:404(get_queryset)\n\t14380\t0.068\t0.000\t1.052\t0.000 query.py:160(iterator)\n\t\t1\t0.023\t0.023\t0.993\t0.993 related.py:418(get_prefetch_queryset)\n\t 9299\t0.067\t0.000\t0.841\t0.000 query.py:838(_clone)\n\t 4649\t0.086\t0.000\t0.752\t0.000 query.py:1323(setup_joins)\n\t 9299\t0.226\t0.000\t0.738\t0.000 query.py:214(clone)\n\t 4644\t0.177\t0.000\t0.668\t0.000 related.py:1041(get_lookup_constraint)\n\t\t1\t0.000\t0.000\t0.577\t0.577 __init__.py:256(fetch_command)\n\t14375\t0.330\t0.000\t0.548\t0.000 base.py:325(__init__)\n 127/79\t0.007\t0.000\t0.447\t0.006 {__import__}\n\t 4645\t0.012\t0.000\t0.443\t0.000 query.py:788(using)\n\t14380\t0.017\t0.000\t0.433\t0.000 compiler.py:694(results_iter)\n<SNIP>\n\t\t5\t0.197\t0.039\t0.197\t0.039 {method 'execute' of 'psycopg2._psycopg.cursor' objects}\nIf I am reading this correctly, the actual data fetching costs 0.2 seconds of the total runtime of 6.8 seconds. (In reality the ratio is 0.2 vs 2 seconds due to overhead of profiling not affecting the execute time but having a big effect on other parts).\nThe big \"failure\" in above profile is the creation of related querysets:\n4640\t0.018\t0.000\t3.917\t0.001 manager.py:132(all)\nthis takes more than half (approx 57%) of the total runtime. Every cycle here is wasted - we don't ever need the related queryset when using the prefetched results.\nI see two options here:\nAllow assigning the results to somewhere else than manager.all() (that is, a plain list you can name). This would naturally get rid of the overhead, but then you will need to alter code to explicitly use the named list when that is available.\nSomehow lazily instantiate the .all() queryset. If prefetch is in effect calling relmanager.all() will not create a queryset, it just creates a proxy which when iterated gives the related objects, but works otherwise like the related queryset (*not* like manager).\nI prefer option 2 as this doesn't require any new APIs or changes to user code to take advantage of this feature. However creating a proxy object that works like the related queryset except for iteration, and which doesn't involve actually creating that queryset will likely be an interesting technical challenge (for example it would be nice to ensure isinstance(obj.operating_systems.all(), QuerySet) == True. Solving this challenge will likely speed up some prefetch_related queries by 50% or so.\n",
  "hints_text": "I implemented a branch where it is possible to chain operations. The operations are executed on next queryset access. See ​https://github.com/akaariai/django/tree/chain_ops. The branch isn't meant to be committable, and it fails a couple of tests (one reason might be that cloning does a bit more than just clone(), so when chaining ops without clone things will break). The basic idea is to add a new QuerySet method chain_ops(). The usage is simple: qs.chain_ops(lambda qs: qs.filter(foo=bar).using(baz).order_by(xyzzy)). The chain_ops() method will *not* clone the queryset. The operations in the lambda function are executed when needed, that is on queryset evaluation, accessing qs.query, or cloning the queryset. When the operations in the lambda function are executed, the queryset isn't cloned in between. The result of this is 2.3x speedup in ​query_prefetch_related djangobench benchmark.\nNice work! I'm wondering if there is some overlap with _sticky_filter (or if that could be implemented using chain_ops).\nThe _sticky_filter is related, but I don't see any immediate way to implement that with chain_ops. The _sticky_filter tells self.query to not reset reusable aliases when cloning so that two .filter() calls in row target the same multijoin alias (or, this is how I recall). There are a couple of other cases where clone() resets some state to start next operation. The chain_ops() will need a way to tell self.query to reset state after each operation without doing a clone, while _sticky_filter needs a way to not reset state while doing a clone. The Query.clone() is responsible for even changing the class of the Query sometimes. It might be better to separate the responsibilities a bit, so that .clone() does a full clone. Then there is a .start_op() or something like that that does the state cleanup & class copying for starting a new operation. I am not sure how this interacts with all the Query subclasses, or if this will have noticeable performance impact. I am not sure if chain_ops() is needed API after all. For user API the wanted behaviour is to first do a clone, then run all the operations without cloning between and finally return the result. chain_ops() doesn't clone at all, and delays the operations until next queryset operation. As is, chain_ops() is very useful for prefetch_related but completely wrong as user API. So, maybe there needs to be some internal setup for prefetch_related delayed execution. The same setup can then be used for chain_ops() too if need be.\n#19264 was a duplicate. In addition #20880 (splitted clone()) tracks splitting clone() to pre_next_op() and clone() parts. That seems to be a pre-requisite for the chain_ops() approach.\nThe approach in #17001 (prefetch custom querysets) will provide the speedup promised in this ticket. Unfortunately the speedup is only available to custom prefetches, not ordinary .prefetch_related('some_related_set'). I am going to do a wait-and-see on this ticket, changes required for fast prefetches directly into querysets require some hacks. The hacks needed: create QuerySet.query lazily, and have a \"on_query_creation_ops\" QuerySet attribute, that is things that are ran when the inner query is created. I am going to leave this in accepted status - if a suitably clean patch is written I think speeding up prefetch_related is a good idea.\nfyi, i can still observe this behavior. the profile looks pretty similar. using the Prefetch object didn't change anything.\nEchoing karyon here -- We're seeing pretty significant performance hits for our django rest api on endpoints that return objects that need to have access to their child objects.",
  "created_at": "2019-10-14T23:01:15Z",
  "version": "3.1",
  "FAIL_TO_PASS": "[\"test_filter_deferred (prefetch_related.tests.PrefetchRelatedTests)\", \"test_filter_deferred (prefetch_related.tests.CustomPrefetchTests)\"]",
  "PASS_TO_PASS": "[\"test_bug (prefetch_related.tests.Ticket21760Tests)\", \"test_bug (prefetch_related.tests.Ticket21410Tests)\", \"test_m2m_then_m2m (prefetch_related.tests.DefaultManagerTests)\", \"test_foreignkey (prefetch_related.tests.ForeignKeyToFieldTest)\", \"test_m2m (prefetch_related.tests.ForeignKeyToFieldTest)\", \"test_in_lookup_query_evaluation (queryset_pickle.tests.InLookupTests)\", \"test_in_lookup_queryset_evaluation (queryset_pickle.tests.InLookupTests)\", \"test_retrieves_results_from_prefetched_objects_cache (prefetch_related.tests.ReadPrefetchedObjectsCacheTests)\", \"test_bug (prefetch_related.tests.Ticket19607Tests)\", \"test_basic (prefetch_related.tests.RawQuerySetTests)\", \"test_clear (prefetch_related.tests.RawQuerySetTests)\", \"test_prefetch_before_raw (prefetch_related.tests.RawQuerySetTests)\", \"test_order (prefetch_related.tests.LookupOrderingTest)\", \"test_add_clears_prefetched_objects (prefetch_related.tests.DirectPrefetchedObjectCacheReuseTests)\", \"test_detect_is_fetched (prefetch_related.tests.DirectPrefetchedObjectCacheReuseTests)\", \"test_detect_is_fetched_with_to_attr (prefetch_related.tests.DirectPrefetchedObjectCacheReuseTests)\", \"test_prefetch_reverse_foreign_key (prefetch_related.tests.DirectPrefetchedObjectCacheReuseTests)\", \"test_remove_clears_prefetched_objects (prefetch_related.tests.DirectPrefetchedObjectCacheReuseTests)\", \"test_in_bulk (prefetch_related.tests.NullableTest)\", \"test_prefetch_nullable (prefetch_related.tests.NullableTest)\", \"test_traverse_nullable (prefetch_related.tests.NullableTest)\", \"test_using_is_honored_custom_qs (prefetch_related.tests.MultiDbTests)\", \"test_using_is_honored_fkey (prefetch_related.tests.MultiDbTests)\", \"test_using_is_honored_inheritance (prefetch_related.tests.MultiDbTests)\", \"test_using_is_honored_m2m (prefetch_related.tests.MultiDbTests)\", \"test_child_link_prefetch (prefetch_related.tests.MultiTableInheritanceTest)\", \"test_foreignkey (prefetch_related.tests.MultiTableInheritanceTest)\", \"test_foreignkey_to_inherited (prefetch_related.tests.MultiTableInheritanceTest)\", \"test_m2m_to_inheriting_model (prefetch_related.tests.MultiTableInheritanceTest)\", \"test_parent_link_prefetch (prefetch_related.tests.MultiTableInheritanceTest)\", \"test_charfield_GFK (prefetch_related.tests.GenericRelationTests)\", \"test_custom_queryset (prefetch_related.tests.GenericRelationTests)\", \"test_generic_relation (prefetch_related.tests.GenericRelationTests)\", \"test_nullable_GFK (prefetch_related.tests.GenericRelationTests)\", \"test_prefetch_GFK (prefetch_related.tests.GenericRelationTests)\", \"test_prefetch_GFK_fk_pk (prefetch_related.tests.GenericRelationTests)\", \"test_prefetch_GFK_nonint_pk (prefetch_related.tests.GenericRelationTests)\", \"test_prefetch_GFK_uuid_pk (prefetch_related.tests.GenericRelationTests)\", \"test_traverse_GFK (prefetch_related.tests.GenericRelationTests)\", \"test_annotation_with_callable_default (queryset_pickle.tests.PickleabilityTestCase)\", \"test_datetime_callable_default_all (queryset_pickle.tests.PickleabilityTestCase)\", \"test_datetime_callable_default_filter (queryset_pickle.tests.PickleabilityTestCase)\", \"test_doesnotexist_class (queryset_pickle.tests.PickleabilityTestCase)\", \"test_doesnotexist_exception (queryset_pickle.tests.PickleabilityTestCase)\", \"test_filter_deferred (queryset_pickle.tests.PickleabilityTestCase)\", \"test_filter_reverse_fk (queryset_pickle.tests.PickleabilityTestCase)\", \"test_forward_relatedobjectdoesnotexist_class (queryset_pickle.tests.PickleabilityTestCase)\", \"test_manager_pickle (queryset_pickle.tests.PickleabilityTestCase)\", \"test_missing_django_version_unpickling (queryset_pickle.tests.PickleabilityTestCase)\", \"test_model_pickle (queryset_pickle.tests.PickleabilityTestCase)\", \"test_model_pickle_dynamic (queryset_pickle.tests.PickleabilityTestCase)\", \"test_model_pickle_m2m (queryset_pickle.tests.PickleabilityTestCase)\", \"test_multipleobjectsreturned_class (queryset_pickle.tests.PickleabilityTestCase)\", \"test_pickle_exists_queryset_not_evaluated (queryset_pickle.tests.PickleabilityTestCase)\", \"test_pickle_exists_queryset_still_usable (queryset_pickle.tests.PickleabilityTestCase)\", \"test_pickle_prefetch_queryset_not_evaluated (queryset_pickle.tests.PickleabilityTestCase)\", \"test_pickle_prefetch_queryset_still_usable (queryset_pickle.tests.PickleabilityTestCase)\", \"test_pickle_prefetch_queryset_usable_outside_of_prefetch (queryset_pickle.tests.PickleabilityTestCase)\", \"test_pickle_prefetch_related_idempotence (queryset_pickle.tests.PickleabilityTestCase)\", \"test_pickle_prefetch_related_with_m2m_and_objects_deletion (queryset_pickle.tests.PickleabilityTestCase)\", \"test_pickle_subquery_queryset_not_evaluated (queryset_pickle.tests.PickleabilityTestCase)\", \"test_related_field (queryset_pickle.tests.PickleabilityTestCase)\", \"test_reverse_one_to_one_relatedobjectdoesnotexist_class (queryset_pickle.tests.PickleabilityTestCase)\", \"test_specialized_queryset (queryset_pickle.tests.PickleabilityTestCase)\", \"test_standalone_method_as_default (queryset_pickle.tests.PickleabilityTestCase)\", \"test_staticmethod_as_default (queryset_pickle.tests.PickleabilityTestCase)\", \"test_string_as_default (queryset_pickle.tests.PickleabilityTestCase)\", \"test_unsupported_unpickle (queryset_pickle.tests.PickleabilityTestCase)\", \"test_attribute_error (prefetch_related.tests.PrefetchRelatedTests)\", \"test_bool (prefetch_related.tests.PrefetchRelatedTests)\", \"test_clear (prefetch_related.tests.PrefetchRelatedTests)\", \"test_count (prefetch_related.tests.PrefetchRelatedTests)\", \"test_exists (prefetch_related.tests.PrefetchRelatedTests)\", \"test_foreign_key_then_m2m (prefetch_related.tests.PrefetchRelatedTests)\", \"test_foreignkey_forward (prefetch_related.tests.PrefetchRelatedTests)\", \"test_foreignkey_reverse (prefetch_related.tests.PrefetchRelatedTests)\", \"test_forward_m2m_to_attr_conflict (prefetch_related.tests.PrefetchRelatedTests)\", \"test_get (prefetch_related.tests.PrefetchRelatedTests)\", \"test_in_and_prefetch_related (prefetch_related.tests.PrefetchRelatedTests)\", \"test_invalid_final_lookup (prefetch_related.tests.PrefetchRelatedTests)\", \"test_len (prefetch_related.tests.PrefetchRelatedTests)\", \"test_m2m_forward (prefetch_related.tests.PrefetchRelatedTests)\", \"test_m2m_reverse (prefetch_related.tests.PrefetchRelatedTests)\", \"A m2m can be followed through another m2m.\", \"test_m2m_then_m2m_object_ids (prefetch_related.tests.PrefetchRelatedTests)\", \"test_m2m_then_reverse_fk_object_ids (prefetch_related.tests.PrefetchRelatedTests)\", \"test_m2m_then_reverse_one_to_one_object_ids (prefetch_related.tests.PrefetchRelatedTests)\", \"test_onetoone_reverse_no_match (prefetch_related.tests.PrefetchRelatedTests)\", \"test_onetoone_reverse_with_to_field_pk (prefetch_related.tests.PrefetchRelatedTests)\", \"test_overriding_prefetch (prefetch_related.tests.PrefetchRelatedTests)\", \"test_prefetch_eq (prefetch_related.tests.PrefetchRelatedTests)\", \"test_reverse_m2m_to_attr_conflict (prefetch_related.tests.PrefetchRelatedTests)\", \"test_reverse_one_to_one_then_m2m (prefetch_related.tests.PrefetchRelatedTests)\", \"test_survives_clone (prefetch_related.tests.PrefetchRelatedTests)\", \"test_ambiguous (prefetch_related.tests.CustomPrefetchTests)\", \"test_custom_qs (prefetch_related.tests.CustomPrefetchTests)\", \"test_generic_rel (prefetch_related.tests.CustomPrefetchTests)\", \"test_m2m (prefetch_related.tests.CustomPrefetchTests)\", \"test_m2m_through_fk (prefetch_related.tests.CustomPrefetchTests)\", \"test_m2m_through_gfk (prefetch_related.tests.CustomPrefetchTests)\", \"test_nested_prefetch_related_are_not_overwritten (prefetch_related.tests.CustomPrefetchTests)\", \"test_nested_prefetch_related_with_duplicate_prefetcher (prefetch_related.tests.CustomPrefetchTests)\", \"test_o2m_through_m2m (prefetch_related.tests.CustomPrefetchTests)\", \"test_reverse_m2m (prefetch_related.tests.CustomPrefetchTests)\", \"test_to_attr_cached_property (prefetch_related.tests.CustomPrefetchTests)\", \"test_to_attr_doesnt_cache_through_attr_as_list (prefetch_related.tests.CustomPrefetchTests)\", \"test_traverse_multiple_items_property (prefetch_related.tests.CustomPrefetchTests)\", \"test_traverse_qs (prefetch_related.tests.CustomPrefetchTests)\", \"test_traverse_single_item_property (prefetch_related.tests.CustomPrefetchTests)\", \"test_values_queryset (prefetch_related.tests.CustomPrefetchTests)\"]",
  "environment_setup_commit": "0668164b4ac93a5be79f5b87fae83c657124d9ab",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.589276",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}