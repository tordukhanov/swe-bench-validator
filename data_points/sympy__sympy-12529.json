{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-12529",
  "base_commit": "0266dd4f262137858050dc5ebfc4df783f245947",
  "patch": "diff --git a/sympy/ntheory/factor_.py b/sympy/ntheory/factor_.py\n--- a/sympy/ntheory/factor_.py\n+++ b/sympy/ntheory/factor_.py\n@@ -17,6 +17,7 @@\n from sympy.core.compatibility import as_int, SYMPY_INTS, range\n from sympy.core.singleton import S\n from sympy.core.function import Function\n+from sympy.core.expr import Expr\n \n small_trailing = [i and max(int(not i % 2**j) and j for j in range(1, 8))\n     for i in range(256)]\n@@ -1591,6 +1592,8 @@ def eval(cls, n):\n             for p, k in factors.items():\n                 t *= (p - 1) * p**(k - 1)\n             return t\n+        elif not isinstance(n, Expr) or (n.is_integer is False) or (n.is_positive is False):\n+            raise ValueError(\"n must be a positive integer\")\n \n     def _eval_is_integer(self):\n         return fuzzy_and([self.args[0].is_integer, self.args[0].is_positive])\n",
  "test_patch": "diff --git a/sympy/ntheory/tests/test_factor_.py b/sympy/ntheory/tests/test_factor_.py\n--- a/sympy/ntheory/tests/test_factor_.py\n+++ b/sympy/ntheory/tests/test_factor_.py\n@@ -301,6 +301,9 @@ def test_totient():\n     assert totient(5009) == 5008\n     assert totient(2**100) == 2**99\n \n+    raises(ValueError, lambda: totient(30.1))\n+    raises(ValueError, lambda: totient(20.001))\n+\n     m = Symbol(\"m\", integer=True)\n     assert totient(m)\n     assert totient(m).subs(m, 3**10) == 3**10 - 3**9\n@@ -309,6 +312,16 @@ def test_totient():\n     n = Symbol(\"n\", integer=True, positive=True)\n     assert totient(n).is_integer\n \n+    x=Symbol(\"x\", integer=False)\n+    raises(ValueError, lambda: totient(x))\n+\n+    y=Symbol(\"y\", positive=False)\n+    raises(ValueError, lambda: totient(y))\n+\n+    z=Symbol(\"z\", positive=True, integer=True)\n+    raises(ValueError, lambda: totient(2**(-z)))\n+\n+\n def test_reduced_totient():\n     assert [reduced_totient(k) for k in range(1, 16)] == \\\n         [1, 1, 2, 2, 4, 2, 6, 2, 6, 4, 10, 2, 12, 6, 4]\n",
  "problem_statement": "Totient of any non-integer number\nAccording to the Totient function definition on [wikipedia](http://en.wikipedia.org/wiki/Euler%27s_totient_function), the totient of non-integer numbers is not there. But in sympy:\n\n```\n>>> totient(2.3)\ntotient(2.3)\n```\n\nthe value is returned, instead of an error.\n\n",
  "hints_text": "From the wikipedia article you cited:\n\nIn number theory http://en.wikipedia.org/wiki/Number_theory, _Euler's\ntotient_ or _phi function_, φ(_n_), is an arithmetic function\nhttp://en.wikipedia.org/wiki/Arithmetic_function that counts the totatives\nhttp://en.wikipedia.org/wiki/Totative of _n_, that is, the positive\nintegers less than or equal to _n_ that are relatively prime\nhttp://en.wikipedia.org/wiki/Relatively_prime to _n_. Thus, if _n_\nis a positive\ninteger http://en.wikipedia.org/wiki/Positive_integer, then φ(_n_) is the\nnumber of integers _k_ in the range 1 ≤ _k_ ≤ _n_ for which the greatest\ncommon divisor gcd http://en.wikipedia.org/wiki/Greatest_common_divisor(\n_n_, _k_) = 1.[1]\nhttp://en.wikipedia.org/wiki/Euler%27s_totient_function#cite_note-1[2]\nhttp://en.wikipedia.org/wiki/Euler%27s_totient_function#cite_note-2 The\ntotient function is a multiplicative function\nhttp://en.wikipedia.org/wiki/Multiplicative_function, meaning that if two\nnumbers _m_ and _n_ are relatively prime (with respect to each other), then\nφ(_mn_) = φ(_m_)φ(_n_).[3]\nhttp://en.wikipedia.org/wiki/Euler%27s_totient_function#cite_note-3[4]\nhttp://en.wikipedia.org/wiki/Euler%27s_totient_function#cite_note-4\n\nIt looks like the issue is the \"relatively prime\" requirement, since it is\nonly defined for integers ( http://en.wikipedia.org/wiki/Coprime_integers\n). Certainly, getting a list of integers less than or equal to n doesn't\nrequire n to be a real number.\nThe requirement to get the number of integers k in the range 1 ≤ k ≤ n\ndoesn't require n to be an integer. I don't know if calculating the\ngreatest common divisor is defined for non-integers.  I'm unclear about the\nefficacy or applicability of the totient function being a multiplicative\nfunction.\n\nDavid\n\nOn Fri, Jan 23, 2015 at 12:40 PM, Gaurav Dhingra notifications@github.com\nwrote:\n\n> According to the Totient function definition on wikipedia\n> http://en.wikipedia.org/wiki/Euler%27s_totient_function, the totient of\n> non-integer numbers is not there. But in sympy:\n> \n>  totient(2.3)\n> totient(2.3)\n> \n>  the value is returned, instead of an error.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/sympy/sympy/issues/8875.\n\nI don't get you completely, but The wolframalpha also raise an error, http://www.wolframalpha.com/input/?i=totient%282.3%29\n\nIn number theory, Euler's totient or phi function, φ(n), is an arithmetic function that counts the totatives of n,\nand In number theory, a totative of a given positive integer n is an integer k\n\nAnd in sympy/ntheory/factor_.py toitent class is also defined this way\nclass totient(Function):\n    \"\"\"\n    Calculate the Euler totient function phi(n)\n\n```\n>>> from sympy.ntheory import totient\n>>> totient(1)\n1\n>>> totient(25)\n20\n\nSee Also\n========\n\ndivisor_count\n\"\"\"\n@classmethod\ndef eval(cls, n):\n    n = sympify(n)\n    if n.is_Integer:\n        if n < 1:\n            raise ValueError(\"n must be a positive integer\")\n        factors = factorint(n)\n        t = 1\n        for p, k in factors.items():\n            t *= (p - 1) * p**(k - 1)\n        return t\n```\n\nit checks if n is a integer\n\nSo i think that gxyd is right and this should fix it:-\n        else:\n            raise ValueError(\"n must be a positive integer\")\n\n@smichr  plz. take a look at this issue, i think earlier you were discussing about the totient function's output but i think the input to the function should only be a positive integer.\n\n@darkcoderrises i think adding the code you are suggesting i.e.(else: raise ValueError(\"n must be positive\") would not work, since this totient function should still be returned unevaluated for an instance of Symbol. Ex.\n\n> > > x = Symbol('x')\n> > > totient(x)\n> > > totient(x)              # should be returned as it is\n> > > totient(oo)    # should raise an error\n\n@gxyd Ya sorry for that we can do something like elif n is number(real and complex)\n\n@smichr  please have a look at the reference i have given for this issue( #8875 ) .\n\nI have added test cases for this as well.\nPlease review it.\nhttps://github.com/sympy/sympy/pull/8923\n",
  "created_at": "2017-04-11T13:17:25Z",
  "version": "1.1",
  "FAIL_TO_PASS": "[\"test_totient\"]",
  "PASS_TO_PASS": "[\"test_trailing_bitcount\", \"test_multiplicity\", \"test_perfect_power\", \"test_factorint\", \"test_divisors_and_divisor_count\", \"test_udivisors_and_udivisor_count\", \"test_issue_6981\", \"test_reduced_totient\", \"test_divisor_sigma\", \"test_udivisor_sigma\", \"test_issue_4356\", \"test_divisors\", \"test_divisor_count\", \"test_antidivisors\", \"test_antidivisor_count\", \"test_smoothness_and_smoothness_p\", \"test_visual_factorint\", \"test_factorrat\", \"test_visual_io\", \"test_core\", \"test_digits\", \"test_primenu\"]",
  "environment_setup_commit": "ec9e3c0436fbff934fa84e22bf07f1b3ef5bfac3",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.077974",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}