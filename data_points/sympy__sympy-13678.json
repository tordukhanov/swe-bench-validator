{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-13678",
  "base_commit": "53fc684467088cdf0acccb6ad770cbde97e32268",
  "patch": "diff --git a/sympy/functions/elementary/hyperbolic.py b/sympy/functions/elementary/hyperbolic.py\n--- a/sympy/functions/elementary/hyperbolic.py\n+++ b/sympy/functions/elementary/hyperbolic.py\n@@ -228,7 +228,16 @@ def _eval_as_leading_term(self, x):\n             return self.func(arg)\n \n     def _eval_is_real(self):\n-        return self.args[0].is_real\n+        if self.args[0].is_real:\n+            return True\n+\n+    def _eval_is_positive(self):\n+        if self.args[0].is_real:\n+            return self.args[0].is_positive\n+\n+    def _eval_is_negative(self):\n+        if self.args[0].is_real:\n+            return self.args[0].is_negative\n \n     def _eval_is_finite(self):\n         arg = self.args[0]\n@@ -379,8 +388,9 @@ def _eval_as_leading_term(self, x):\n         else:\n             return self.func(arg)\n \n-    def _eval_is_real(self):\n-        return self.args[0].is_real\n+    def _eval_is_positive(self):\n+        if self.args[0].is_real:\n+            return True\n \n     def _eval_is_finite(self):\n         arg = self.args[0]\n@@ -526,7 +536,16 @@ def _eval_as_leading_term(self, x):\n             return self.func(arg)\n \n     def _eval_is_real(self):\n-        return self.args[0].is_real\n+        if self.args[0].is_real:\n+            return True\n+\n+    def _eval_is_positive(self):\n+        if self.args[0].is_real:\n+            return self.args[0].is_positive\n+\n+    def _eval_is_negative(self):\n+        if self.args[0].is_real:\n+            return self.args[0].is_negative\n \n     def _eval_is_finite(self):\n         arg = self.args[0]\n@@ -657,6 +676,14 @@ def _eval_rewrite_as_cosh(self, arg):\n     def _eval_rewrite_as_tanh(self, arg):\n         return 1/tanh(arg)\n \n+    def _eval_is_positive(self):\n+        if self.args[0].is_real:\n+            return self.args[0].is_positive\n+\n+    def _eval_is_negative(self):\n+        if self.args[0].is_real:\n+            return self.args[0].is_negative\n+\n     def _eval_as_leading_term(self, x):\n         from sympy import Order\n         arg = self.args[0].as_leading_term(x)\n@@ -784,6 +811,14 @@ def taylor_term(n, x, *previous_terms):\n     def _eval_rewrite_as_cosh(self, arg):\n         return S.ImaginaryUnit / cosh(arg + S.ImaginaryUnit * S.Pi / 2)\n \n+    def _eval_is_positive(self):\n+        if self.args[0].is_real:\n+            return self.args[0].is_positive\n+\n+    def _eval_is_negative(self):\n+        if self.args[0].is_real:\n+            return self.args[0].is_negative\n+\n     def _sage_(self):\n         import sage.all as sage\n         return sage.csch(self.args[0]._sage_())\n@@ -823,6 +858,10 @@ def taylor_term(n, x, *previous_terms):\n     def _eval_rewrite_as_sinh(self, arg):\n         return S.ImaginaryUnit / sinh(arg + S.ImaginaryUnit * S.Pi /2)\n \n+    def _eval_is_positive(self):\n+        if self.args[0].is_real:\n+            return True\n+\n     def _sage_(self):\n         import sage.all as sage\n         return sage.sech(self.args[0]._sage_())\ndiff --git a/sympy/functions/elementary/trigonometric.py b/sympy/functions/elementary/trigonometric.py\n--- a/sympy/functions/elementary/trigonometric.py\n+++ b/sympy/functions/elementary/trigonometric.py\n@@ -6,7 +6,7 @@\n from sympy.core.numbers import igcdex, Rational, pi\n from sympy.core.singleton import S\n from sympy.core.symbol import Symbol, Wild\n-from sympy.core.logic import fuzzy_not\n+from sympy.core.logic import fuzzy_not, fuzzy_or\n from sympy.functions.combinatorial.factorials import factorial, RisingFactorial\n from sympy.functions.elementary.miscellaneous import sqrt, Min, Max\n from sympy.functions.elementary.exponential import log, exp\n@@ -460,7 +460,8 @@ def _eval_as_leading_term(self, x):\n             return self.func(arg)\n \n     def _eval_is_real(self):\n-        return self.args[0].is_real\n+        if self.args[0].is_real:\n+            return True\n \n     def _eval_is_finite(self):\n         arg = self.args[0]\n@@ -879,7 +880,8 @@ def _eval_as_leading_term(self, x):\n             return self.func(arg)\n \n     def _eval_is_real(self):\n-        return self.args[0].is_real\n+        if self.args[0].is_real:\n+            return True\n \n     def _eval_is_finite(self):\n         arg = self.args[0]\n@@ -1887,10 +1889,10 @@ def _eval_is_rational(self):\n             return s.is_rational\n \n     def _eval_is_positive(self):\n-        if self.args[0].is_positive:\n-            return (self.args[0] - 1).is_negative\n-        if self.args[0].is_negative:\n-            return not (self.args[0] + 1).is_positive\n+        return self._eval_is_real() and self.args[0].is_positive\n+\n+    def _eval_is_negative(self):\n+        return self._eval_is_real() and self.args[0].is_negative\n \n     @classmethod\n     def eval(cls, arg):\n@@ -2048,10 +2050,6 @@ def _eval_is_rational(self):\n         else:\n             return s.is_rational\n \n-    def _eval_is_positive(self):\n-        x = self.args[0]\n-        return (1 - abs(x)).is_nonnegative\n-\n     @classmethod\n     def eval(cls, arg):\n         if arg.is_Number:\n@@ -2117,6 +2115,9 @@ def _eval_is_real(self):\n         x = self.args[0]\n         return x.is_real and (1 - abs(x)).is_nonnegative\n \n+    def _eval_is_nonnegative(self):\n+        return self._eval_is_real()\n+\n     def _eval_nseries(self, x, n, logx):\n         return self._eval_rewrite_as_log(self.args[0])._eval_nseries(x, n, logx)\n \n@@ -2344,6 +2345,12 @@ def _eval_is_rational(self):\n             return s.is_rational\n \n     def _eval_is_positive(self):\n+        return self.args[0].is_nonnegative\n+\n+    def _eval_is_negative(self):\n+        return self.args[0].is_negative\n+\n+    def _eval_is_real(self):\n         return self.args[0].is_real\n \n     @classmethod\n@@ -2542,7 +2549,7 @@ def _eval_is_real(self):\n         x = self.args[0]\n         if x.is_real is False:\n             return False\n-        return (x - 1).is_nonnegative or (-x - 1).is_nonnegative\n+        return fuzzy_or(((x - 1).is_nonnegative, (-x - 1).is_nonnegative))\n \n     def _eval_rewrite_as_log(self, arg):\n         return S.Pi/2 + S.ImaginaryUnit*log(S.ImaginaryUnit/arg + sqrt(1 - 1/arg**2))\n",
  "test_patch": "diff --git a/sympy/functions/elementary/tests/test_hyperbolic.py b/sympy/functions/elementary/tests/test_hyperbolic.py\n--- a/sympy/functions/elementary/tests/test_hyperbolic.py\n+++ b/sympy/functions/elementary/tests/test_hyperbolic.py\n@@ -937,3 +937,28 @@ def test_cosh_expansion():\n     assert cosh(2*x).expand(trig=True) == cosh(x)**2 + sinh(x)**2\n     assert cosh(3*x).expand(trig=True).expand() == \\\n         3*sinh(x)**2*cosh(x) + cosh(x)**3\n+\n+def test_real_assumptions():\n+    z = Symbol('z', real=False)\n+    assert sinh(z).is_real is None\n+    assert cosh(z).is_real is None\n+    assert tanh(z).is_real is None\n+    assert sech(z).is_real is None\n+    assert csch(z).is_real is None\n+    assert coth(z).is_real is None\n+\n+def test_sign_assumptions():\n+    p = Symbol('p', positive=True)\n+    n = Symbol('n', negative=True)\n+    assert sinh(n).is_negative is True\n+    assert sinh(p).is_positive is True\n+    assert cosh(n).is_positive is True\n+    assert cosh(p).is_positive is True\n+    assert tanh(n).is_negative is True\n+    assert tanh(p).is_positive is True\n+    assert csch(n).is_negative is True\n+    assert csch(p).is_positive is True\n+    assert sech(n).is_positive is True\n+    assert sech(p).is_positive is True\n+    assert coth(n).is_negative is True\n+    assert coth(p).is_positive is True\ndiff --git a/sympy/functions/elementary/tests/test_trigonometric.py b/sympy/functions/elementary/tests/test_trigonometric.py\n--- a/sympy/functions/elementary/tests/test_trigonometric.py\n+++ b/sympy/functions/elementary/tests/test_trigonometric.py\n@@ -940,7 +940,7 @@ def test_acot():\n     assert acot(I*pi) == -I*acoth(pi)\n     assert acot(-2*I) == I*acoth(2)\n     assert acot(x).is_positive is None\n-    assert acot(r).is_positive is True\n+    assert acot(n).is_positive is False\n     assert acot(p).is_positive is True\n     assert acot(I).is_positive is False\n \n@@ -1541,3 +1541,24 @@ def test_issue_11864():\n     F = Piecewise((1, Eq(2*pi*k, 0)), (sin(pi*k)/(pi*k), True))\n     soln = Piecewise((1, Eq(2*pi*k, 0)), (sinc(pi*k), True))\n     assert F.rewrite(sinc) == soln\n+\n+def test_real_assumptions():\n+    z = Symbol('z', real=False)\n+    assert sin(z).is_real is None\n+    assert cos(z).is_real is None\n+    assert tan(z).is_real is False\n+    assert sec(z).is_real is None\n+    assert csc(z).is_real is None\n+    assert cot(z).is_real is False\n+    assert asin(p).is_real is None\n+    assert asin(n).is_real is None\n+    assert asec(p).is_real is None\n+    assert asec(n).is_real is None\n+    assert acos(p).is_real is None\n+    assert acos(n).is_real is None\n+    assert acsc(p).is_real is None\n+    assert acsc(n).is_real is None\n+    assert atan(p).is_positive is True\n+    assert atan(n).is_negative is True\n+    assert acot(p).is_positive is True\n+    assert acot(n).is_negative is True\n",
  "problem_statement": "is_real returns False instead of None for many trigonometric and hyperbolic functions\nAll the following assertions fail at the moment. I'm going to submit a pull request.\r\n```py\r\nassert sinh(Symbol('z', real=False)).is_real is None\r\nassert cosh(Symbol('z', real=False)).is_real is None\r\nassert tanh(Symbol('z', real=False)).is_real is None\r\nassert sech(Symbol('z', real=False)).is_real is None\r\nassert csch(Symbol('z', real=False)).is_real is None\r\n\r\nassert sin(Symbol('z', real=False)).is_real is None\r\nassert cos(Symbol('z', real=False)).is_real is None\r\nassert sec(Symbol('z', real=False)).is_real is None\r\nassert csc(Symbol('z', real=False)).is_real is None\r\n\r\nassert asin(Symbol('x', positive=True)).is_real is None\r\nassert asin(Symbol('x', negative=True)).is_real is None\r\nassert asec(Symbol('x', positive=True)).is_real is None\r\nassert asec(Symbol('x', negative=True)).is_real is None\r\nassert acot(Symbol('x', negative=True)).is_negative is True\r\n```\n",
  "hints_text": "",
  "created_at": "2017-12-05T23:21:31Z",
  "version": "1.1",
  "FAIL_TO_PASS": "[\"test_real_assumptions\"]",
  "PASS_TO_PASS": "[\"test_sinh\", \"test_cosh\", \"test_tanh\", \"test_coth\", \"test_csch\", \"test_sech\", \"test_asinh\", \"test_asinh_rewrite\", \"test_acosh\", \"test_acosh_rewrite\", \"test_asech\", \"test_asech_series\", \"test_asech_rewrite\", \"test_acsch\", \"test_acsch_infinities\", \"test_acsch_rewrite\", \"test_atanh\", \"test_atanh_rewrite\", \"test_acoth\", \"test_acoth_rewrite\", \"test_inverses\", \"test_complex_2899\", \"test_simplifications\", \"test_issue_4136\", \"test_sinh_rewrite\", \"test_cosh_rewrite\", \"test_tanh_rewrite\", \"test_coth_rewrite\", \"test_csch_rewrite\", \"test_sech_rewrite\", \"test_sinh_expansion\", \"test_cosh_expansion\", \"test_sin\", \"test_sin_cos\", \"test_sin_rewrite\", \"test_sin_expansion\", \"test_sin_AccumBounds\", \"test_trig_symmetry\", \"test_cos\", \"test_issue_6190\", \"test_cos_rewrite\", \"test_cos_expansion\", \"test_cos_AccumBounds\", \"test_tan\", \"test_tan_rewrite\", \"test_tan_subs\", \"test_tan_expansion\", \"test_tan_AccumBounds\", \"test_cot\", \"test_cot_rewrite\", \"test_cot_subs\", \"test_cot_expansion\", \"test_cot_AccumBounds\", \"test_asin_rewrite\", \"test_acos_rewrite\", \"test_atan_rewrite\", \"test_acot_rewrite\", \"test_attributes\", \"test_sincos_rewrite\", \"test_evenodd_rewrite\", \"test_issue_4547\", \"test_leading_terms\", \"test_issue_4420\", \"test_real_imag\", \"test_sec_rewrite\", \"test_csc_rewrite\", \"test_issue_8653\", \"test_trig_period\", \"test_issue_7171\", \"test_issue_11864\"]",
  "environment_setup_commit": "ec9e3c0436fbff934fa84e22bf07f1b3ef5bfac3",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.085932",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}