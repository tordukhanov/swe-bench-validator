{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-14207",
  "base_commit": "9ebcce18bd0ea331b55b8538d2c45e56a3821715",
  "patch": "diff --git a/sympy/printing/codeprinter.py b/sympy/printing/codeprinter.py\n--- a/sympy/printing/codeprinter.py\n+++ b/sympy/printing/codeprinter.py\n@@ -420,6 +420,8 @@ def _print_Mul(self, expr):\n         a = []  # items in the numerator\n         b = []  # items that are in the denominator (if any)\n \n+        pow_paren = []  # Will collect all pow with more than one base element and exp = -1\n+\n         if self.order not in ('old', 'none'):\n             args = expr.as_ordered_factors()\n         else:\n@@ -432,6 +434,8 @@ def _print_Mul(self, expr):\n                 if item.exp != -1:\n                     b.append(Pow(item.base, -item.exp, evaluate=False))\n                 else:\n+                    if len(item.args[0].args) != 1 and isinstance(item.base, Mul):   # To avoid situations like #14160\n+                        pow_paren.append(item)\n                     b.append(Pow(item.base, -item.exp))\n             else:\n                 a.append(item)\n@@ -441,6 +445,11 @@ def _print_Mul(self, expr):\n         a_str = [self.parenthesize(x, prec) for x in a]\n         b_str = [self.parenthesize(x, prec) for x in b]\n \n+        # To parenthesize Pow with exp = -1 and having more than one Symbol\n+        for item in pow_paren:\n+            if item.base in b:\n+                b_str[b.index(item.base)] = \"(%s)\" % b_str[b.index(item.base)]\n+\n         if len(b) == 0:\n             return sign + '*'.join(a_str)\n         elif len(b) == 1:\ndiff --git a/sympy/printing/julia.py b/sympy/printing/julia.py\n--- a/sympy/printing/julia.py\n+++ b/sympy/printing/julia.py\n@@ -134,6 +134,8 @@ def _print_Mul(self, expr):\n         a = []  # items in the numerator\n         b = []  # items that are in the denominator (if any)\n \n+        pow_paren = []  # Will collect all pow with more than one base element and exp = -1\n+\n         if self.order not in ('old', 'none'):\n             args = expr.as_ordered_factors()\n         else:\n@@ -147,6 +149,8 @@ def _print_Mul(self, expr):\n                 if item.exp != -1:\n                     b.append(Pow(item.base, -item.exp, evaluate=False))\n                 else:\n+                    if len(item.args[0].args) != 1 and isinstance(item.base, Mul):   # To avoid situations like #14160\n+                        pow_paren.append(item)\n                     b.append(Pow(item.base, -item.exp))\n             elif item.is_Rational and item is not S.Infinity:\n                 if item.p != 1:\n@@ -161,6 +165,11 @@ def _print_Mul(self, expr):\n         a_str = [self.parenthesize(x, prec) for x in a]\n         b_str = [self.parenthesize(x, prec) for x in b]\n \n+        # To parenthesize Pow with exp = -1 and having more than one Symbol\n+        for item in pow_paren:\n+            if item.base in b:\n+                b_str[b.index(item.base)] = \"(%s)\" % b_str[b.index(item.base)]\n+\n         # from here it differs from str.py to deal with \"*\" and \".*\"\n         def multjoin(a, a_str):\n             # here we probably are assuming the constants will come first\ndiff --git a/sympy/printing/octave.py b/sympy/printing/octave.py\n--- a/sympy/printing/octave.py\n+++ b/sympy/printing/octave.py\n@@ -146,6 +146,8 @@ def _print_Mul(self, expr):\n         a = []  # items in the numerator\n         b = []  # items that are in the denominator (if any)\n \n+        pow_paren = []  # Will collect all pow with more than one base element and exp = -1\n+\n         if self.order not in ('old', 'none'):\n             args = expr.as_ordered_factors()\n         else:\n@@ -159,6 +161,8 @@ def _print_Mul(self, expr):\n                 if item.exp != -1:\n                     b.append(Pow(item.base, -item.exp, evaluate=False))\n                 else:\n+                    if len(item.args[0].args) != 1 and isinstance(item.base, Mul):   # To avoid situations like #14160\n+                        pow_paren.append(item)\n                     b.append(Pow(item.base, -item.exp))\n             elif item.is_Rational and item is not S.Infinity:\n                 if item.p != 1:\n@@ -173,6 +177,11 @@ def _print_Mul(self, expr):\n         a_str = [self.parenthesize(x, prec) for x in a]\n         b_str = [self.parenthesize(x, prec) for x in b]\n \n+        # To parenthesize Pow with exp = -1 and having more than one Symbol\n+        for item in pow_paren:\n+            if item.base in b:\n+                b_str[b.index(item.base)] = \"(%s)\" % b_str[b.index(item.base)]\n+\n         # from here it differs from str.py to deal with \"*\" and \".*\"\n         def multjoin(a, a_str):\n             # here we probably are assuming the constants will come first\ndiff --git a/sympy/printing/str.py b/sympy/printing/str.py\n--- a/sympy/printing/str.py\n+++ b/sympy/printing/str.py\n@@ -270,6 +270,8 @@ def _print_Mul(self, expr):\n         a = []  # items in the numerator\n         b = []  # items that are in the denominator (if any)\n \n+        pow_paren = []  # Will collect all pow with more than one base element and exp = -1\n+\n         if self.order not in ('old', 'none'):\n             args = expr.as_ordered_factors()\n         else:\n@@ -282,6 +284,8 @@ def _print_Mul(self, expr):\n                 if item.exp != -1:\n                     b.append(Pow(item.base, -item.exp, evaluate=False))\n                 else:\n+                    if len(item.args[0].args) != 1 and isinstance(item.base, Mul):   # To avoid situations like #14160\n+                        pow_paren.append(item)\n                     b.append(Pow(item.base, -item.exp))\n             elif item.is_Rational and item is not S.Infinity:\n                 if item.p != 1:\n@@ -296,6 +300,11 @@ def _print_Mul(self, expr):\n         a_str = [self.parenthesize(x, prec, strict=False) for x in a]\n         b_str = [self.parenthesize(x, prec, strict=False) for x in b]\n \n+        # To parenthesize Pow with exp = -1 and having more than one Symbol\n+        for item in pow_paren:\n+            if item.base in b:\n+                b_str[b.index(item.base)] = \"(%s)\" % b_str[b.index(item.base)]\n+\n         if len(b) == 0:\n             return sign + '*'.join(a_str)\n         elif len(b) == 1:\n",
  "test_patch": "diff --git a/sympy/printing/tests/test_ccode.py b/sympy/printing/tests/test_ccode.py\n--- a/sympy/printing/tests/test_ccode.py\n+++ b/sympy/printing/tests/test_ccode.py\n@@ -1,6 +1,6 @@\n import warnings\n-from sympy.core import (S, pi, oo, symbols, Rational, Integer, Float, Mod,\n-                        GoldenRatio, EulerGamma, Catalan, Lambda, Dummy, Eq, nan)\n+from sympy.core import (S, pi, oo, symbols, Rational, Integer, Float, Mod, GoldenRatio,\n+                        EulerGamma, Catalan, Lambda, Dummy, Eq, nan, Mul, Pow)\n from sympy.functions import (Abs, acos, acosh, asin, asinh, atan, atanh, atan2,\n                              ceiling, cos, cosh, erf, erfc, exp, floor, gamma, log,\n                              loggamma, Max, Min, Piecewise,\n@@ -58,6 +58,9 @@ def test_ccode_Pow():\n     # Related to gh-11353\n     assert ccode(2**x, user_functions={'Pow': _cond_cfunc2}) == 'exp2(x)'\n     assert ccode(x**2, user_functions={'Pow': _cond_cfunc2}) == 'pow(x, 2)'\n+    # For issue 14160\n+    assert ccode(Mul(-2, x, Pow(Mul(y,y,evaluate=False), -1, evaluate=False),\n+                                                evaluate=False)) == '-2*x/(y*y)'\n \n \n def test_ccode_Max():\ndiff --git a/sympy/printing/tests/test_julia.py b/sympy/printing/tests/test_julia.py\n--- a/sympy/printing/tests/test_julia.py\n+++ b/sympy/printing/tests/test_julia.py\n@@ -1,6 +1,6 @@\n from sympy.core import (S, pi, oo, symbols, Function, Rational, Integer,\n                         Tuple, Symbol)\n-from sympy.core import EulerGamma, GoldenRatio, Catalan, Lambda\n+from sympy.core import EulerGamma, GoldenRatio, Catalan, Lambda, Mul, Pow\n from sympy.functions import Piecewise, sqrt, ceiling, exp, sin, cos\n from sympy.utilities.pytest import raises\n from sympy.utilities.lambdify import implemented_function\n@@ -44,6 +44,9 @@ def test_Pow():\n     g = implemented_function('g', Lambda(x, 2*x))\n     assert julia_code(1/(g(x)*3.5)**(x - y**x)/(x**2 + y)) == \\\n         \"(3.5*2*x).^(-x + y.^x)./(x.^2 + y)\"\n+    # For issue 14160\n+    assert julia_code(Mul(-2, x, Pow(Mul(y,y,evaluate=False), -1, evaluate=False),\n+                                                evaluate=False)) == '-2*x./(y.*y)'\n \n \n def test_basic_ops():\ndiff --git a/sympy/printing/tests/test_octave.py b/sympy/printing/tests/test_octave.py\n--- a/sympy/printing/tests/test_octave.py\n+++ b/sympy/printing/tests/test_octave.py\n@@ -1,6 +1,6 @@\n from sympy.core import (S, pi, oo, symbols, Function, Rational, Integer,\n                         Tuple, Symbol)\n-from sympy.core import EulerGamma, GoldenRatio, Catalan, Lambda\n+from sympy.core import EulerGamma, GoldenRatio, Catalan, Lambda, Mul, Pow\n from sympy.functions import (Piecewise, sqrt, ceiling, exp, sin, cos, LambertW,\n                              sinc, Max, Min, arg, im, re)\n from sympy.utilities.pytest import raises\n@@ -53,6 +53,9 @@ def test_Pow():\n     g = implemented_function('g', Lambda(x, 2*x))\n     assert mcode(1/(g(x)*3.5)**(x - y**x)/(x**2 + y)) == \\\n         \"(3.5*2*x).^(-x + y.^x)./(x.^2 + y)\"\n+    # For issue 14160\n+    assert mcode(Mul(-2, x, Pow(Mul(y,y,evaluate=False), -1, evaluate=False),\n+                                                evaluate=False)) == '-2*x./(y.*y)'\n \n \n def test_basic_ops():\ndiff --git a/sympy/printing/tests/test_str.py b/sympy/printing/tests/test_str.py\n--- a/sympy/printing/tests/test_str.py\n+++ b/sympy/printing/tests/test_str.py\n@@ -7,7 +7,7 @@\n     WildFunction, zeta, zoo, Dummy, Dict, Tuple, FiniteSet, factor,\n     subfactorial, true, false, Equivalent, Xor, Complement, SymmetricDifference,\n     AccumBounds, UnevaluatedExpr, Eq, Ne, Quaternion)\n-from sympy.core import Expr\n+from sympy.core import Expr, Mul\n from sympy.physics.units import second, joule\n from sympy.polys import Poly, rootof, RootSum, groebner, ring, field, ZZ, QQ, lex, grlex\n from sympy.geometry import Point, Circle\n@@ -214,6 +214,10 @@ def test_Mul():\n     assert str(-2*x/3) == '-2*x/3'\n     assert str(-1.0*x) == '-1.0*x'\n     assert str(1.0*x) == '1.0*x'\n+    # For issue 14160\n+    assert str(Mul(-2, x, Pow(Mul(y,y,evaluate=False), -1, evaluate=False),\n+                                                evaluate=False)) == '-2*x/(y*y)'\n+\n \n     class CustomClass1(Expr):\n         is_commutative = True\n",
  "problem_statement": "Necessary parenthesis in printing of some multiplications\nReproducer:\r\n\r\n```\r\nfrom sympy import *\r\n\r\na = Symbol('a')\r\nu = Symbol('u')\r\n\r\na2inv = Pow(Mul(a,a,evaluate=False), -1, evaluate=False)\r\nd = Mul(-2, u, a2inv, evaluate=False)\r\n\r\nprint(\"This should be -2*u/(a*a)\")\r\nprint(d)\r\n```\r\n\r\nOutput:\r\n\r\n```\r\nThis should be -2*u/(a*a)\r\n-2*u/a*a\r\n```\r\n\r\nThe evaluate=False's are necessary because this is being used in a code-generation context, and the desired code is ``float lhs = -2*u/(a*a)`` not ``float lhs = -2*u*pow(a,-2)`` (which promotes the operations to double precision).\r\n\r\nPython 3.6\r\nSympy Version: latest master (sympy-1.1.1-2784-g98d5dd9) but present before that.\r\nAlso occurs (importantly, in this case) in the C and Python code generation printers (which duplicate a lot of the logic in print_Mul, so may possibly need duplicated fixes).\r\n\r\n\n",
  "hints_text": "",
  "created_at": "2018-02-14T17:34:16Z",
  "version": "1.1",
  "FAIL_TO_PASS": "[\"test_ccode_Pow\", \"test_Mul\"]",
  "PASS_TO_PASS": "[\"test_printmethod\", \"test_ccode_sqrt\", \"test_ccode_Max\", \"test_ccode_constants_mathh\", \"test_ccode_constants_other\", \"test_ccode_Rational\", \"test_ccode_Integer\", \"test_ccode_functions\", \"test_ccode_inline_function\", \"test_ccode_exceptions\", \"test_ccode_user_functions\", \"test_ccode_boolean\", \"test_ccode_Relational\", \"test_ccode_Piecewise\", \"test_ccode_sinc\", \"test_ccode_Piecewise_deep\", \"test_ccode_ITE\", \"test_ccode_settings\", \"test_ccode_Indexed\", \"test_ccode_Indexed_without_looking_for_contraction\", \"test_ccode_loops_matrix_vector\", \"test_dummy_loops\", \"test_ccode_loops_add\", \"test_ccode_loops_multiple_contractions\", \"test_ccode_loops_addfactor\", \"test_ccode_loops_multiple_terms\", \"test_dereference_printing\", \"test_Matrix_printing\", \"test_ccode_reserved_words\", \"test_ccode_sign\", \"test_ccode_Assignment\", \"test_ccode_For\", \"test_ccode_Max_Min\", \"test_ccode_standard\", \"test_CCodePrinter\", \"test_C89CodePrinter\", \"test_C99CodePrinter\", \"test_C99CodePrinter__precision\", \"test_get_math_macros\", \"test_ccode_Declaration\", \"test_C99CodePrinter_custom_type\", \"test_MatrixElement_printing\", \"test_subclass_CCodePrinter\", \"test_Integer\", \"test_Rational\", \"test_Function\", \"test_Pow\", \"test_basic_ops\", \"test_1_over_x_and_sqrt\", \"test_mix_number_mult_symbols\", \"test_mix_number_pow_symbols\", \"test_imag\", \"test_constants\", \"test_constants_other\", \"test_boolean\", \"test_Matrices\", \"test_vector_entries_hadamard\", \"test_MatrixSymbol\", \"test_special_matrices\", \"test_containers\", \"test_julia_noninline\", \"test_julia_piecewise\", \"test_julia_piecewise_times_const\", \"test_julia_matrix_assign_to\", \"test_julia_matrix_assign_to_more\", \"test_julia_matrix_1x1\", \"test_julia_matrix_elements\", \"test_julia_boolean\", \"test_julia_not_supported\", \"test_trick_indent_with_end_else_words\", \"test_haramard\", \"test_sparse\", \"test_specfun\", \"test_octave_noninline\", \"test_octave_piecewise\", \"test_octave_piecewise_times_const\", \"test_octave_matrix_assign_to\", \"test_octave_matrix_assign_to_more\", \"test_octave_matrix_1x1\", \"test_octave_matrix_elements\", \"test_octave_boolean\", \"test_octave_not_supported\", \"test_sinc\", \"test_Abs\", \"test_Add\", \"test_Catalan\", \"test_ComplexInfinity\", \"test_Derivative\", \"test_dict\", \"test_Dict\", \"test_Dummy\", \"test_EulerGamma\", \"test_Exp\", \"test_factorial\", \"test_Geometry\", \"test_GoldenRatio\", \"test_ImaginaryUnit\", \"test_Infinity\", \"test_Integral\", \"test_Interval\", \"test_AccumBounds\", \"test_Lambda\", \"test_Limit\", \"test_list\", \"test_Matrix_str\", \"test_NaN\", \"test_NegativeInfinity\", \"test_Order\", \"test_Permutation_Cycle\", \"test_Pi\", \"test_Poly\", \"test_PolyRing\", \"test_FracField\", \"test_PolyElement\", \"test_FracElement\", \"test_sqrt\", \"test_Float\", \"test_Relational\", \"test_CRootOf\", \"test_RootSum\", \"test_GroebnerBasis\", \"test_set\", \"test_SparseMatrix\", \"test_Sum\", \"test_Symbol\", \"test_tuple\", \"test_Quaternion_str_printer\", \"test_Quantity_str\", \"test_wild_str\", \"test_zeta\", \"test_issue_3101\", \"test_issue_3103\", \"test_issue_4021\", \"test_sstrrepr\", \"test_infinity\", \"test_full_prec\", \"test_noncommutative\", \"test_empty_printer\", \"test_settings\", \"test_RandomDomain\", \"test_FiniteSet\", \"test_PrettyPoly\", \"test_categories\", \"test_Tr\", \"test_issue_6387\", \"test_MatMul_MatAdd\", \"test_MatrixSlice\", \"test_true_false\", \"test_Equivalent\", \"test_Xor\", \"test_Complement\", \"test_SymmetricDifference\", \"test_UnevaluatedExpr\"]",
  "environment_setup_commit": "ec9e3c0436fbff934fa84e22bf07f1b3ef5bfac3",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.092755",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}