{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-18200",
  "base_commit": "c559a8421ac4865ebfe66024be6cd43a6103a62b",
  "patch": "diff --git a/sympy/sets/handlers/intersection.py b/sympy/sets/handlers/intersection.py\n--- a/sympy/sets/handlers/intersection.py\n+++ b/sympy/sets/handlers/intersection.py\n@@ -235,26 +235,46 @@ def intersection_sets(self, other): # noqa:F811\n     # diophantine equations f(n)=g(m).\n     # If the solutions for n are {h(t) : t in Integers} then we return\n     # {f(h(t)) : t in integers}.\n+    # If the solutions for n are {n_1, n_2, ..., n_k} then we return\n+    # {f(n_i) : 1 <= i <= k}.\n     if base_set is S.Integers:\n         gm = None\n         if isinstance(other, ImageSet) and other.base_sets == (S.Integers,):\n             gm = other.lamda.expr\n-            m = other.lamda.variables[0]\n+            var = other.lamda.variables[0]\n+            # Symbol of second ImageSet lambda must be distinct from first\n+            m = Dummy('m')\n+            gm = gm.subs(var, m)\n         elif other is S.Integers:\n-            m = gm = Dummy('x')\n+            m = gm = Dummy('m')\n         if gm is not None:\n             fn = self.lamda.expr\n             n = self.lamda.variables[0]\n-            solns = list(diophantine(fn - gm, syms=(n, m)))\n+            try:\n+                solns = list(diophantine(fn - gm, syms=(n, m), permute=True))\n+            except (TypeError, NotImplementedError):\n+                # TypeError if equation not polynomial with rational coeff.\n+                # NotImplementedError if correct format but no solver.\n+                return\n+            # 3 cases are possible for solns:\n+            # - empty set,\n+            # - one or more parametric (infinite) solutions,\n+            # - a finite number of (non-parametric) solution couples.\n+            # Among those, there is one type of solution set that is\n+            # not helpful here: multiple parametric solutions.\n             if len(solns) == 0:\n                 return EmptySet\n-            elif len(solns) != 1:\n-                return\n+            elif any(not isinstance(s, int) and s.free_symbols\n+                     for tupl in solns for s in tupl):\n+                if len(solns) == 1:\n+                    soln, solm = solns[0]\n+                    (t,) = soln.free_symbols\n+                    expr = fn.subs(n, soln.subs(t, n)).expand()\n+                    return imageset(Lambda(n, expr), S.Integers)\n+                else:\n+                    return\n             else:\n-                soln, solm = solns[0]\n-                (t,) = soln.free_symbols\n-                expr = fn.subs(n, soln.subs(t, n))\n-                return imageset(Lambda(n, expr), S.Integers)\n+                return FiniteSet(*(fn.subs(n, s[0]) for s in solns))\n \n     if other == S.Reals:\n         from sympy.solvers.solveset import solveset_real\ndiff --git a/sympy/solvers/diophantine.py b/sympy/solvers/diophantine.py\n--- a/sympy/solvers/diophantine.py\n+++ b/sympy/solvers/diophantine.py\n@@ -294,7 +294,10 @@ def diophantine(eq, param=symbols(\"t\", integer=True), syms=None,\n         else:\n             raise TypeError\n     except (TypeError, NotImplementedError):\n-        terms = factor_list(eq)[1]\n+        fl = factor_list(eq)\n+        if fl[0].is_Rational and fl[0] != 1:\n+            return diophantine(eq/fl[0], param=param, syms=syms, permute=permute)\n+        terms = fl[1]\n \n     sols = set([])\n \n",
  "test_patch": "diff --git a/sympy/sets/tests/test_fancysets.py b/sympy/sets/tests/test_fancysets.py\n--- a/sympy/sets/tests/test_fancysets.py\n+++ b/sympy/sets/tests/test_fancysets.py\n@@ -618,6 +618,49 @@ def test_imageset_intersect_interval():\n     assert f9.intersect(Interval(1, 2)) == Intersection(f9, Interval(1, 2))\n \n \n+def test_imageset_intersect_diophantine():\n+    from sympy.abc import m, n\n+    # Check that same lambda variable for both ImageSets is handled correctly\n+    img1 = ImageSet(Lambda(n, 2*n + 1), S.Integers)\n+    img2 = ImageSet(Lambda(n, 4*n + 1), S.Integers)\n+    assert img1.intersect(img2) == img2\n+    # Empty solution set returned by diophantine:\n+    assert ImageSet(Lambda(n, 2*n), S.Integers).intersect(\n+            ImageSet(Lambda(n, 2*n + 1), S.Integers)) == S.EmptySet\n+    # Check intersection with S.Integers:\n+    assert ImageSet(Lambda(n, 9/n + 20*n/3), S.Integers).intersect(\n+            S.Integers) == FiniteSet(-61, -23, 23, 61)\n+    # Single solution (2, 3) for diophantine solution:\n+    assert ImageSet(Lambda(n, (n - 2)**2), S.Integers).intersect(\n+            ImageSet(Lambda(n, -(n - 3)**2), S.Integers)) == FiniteSet(0)\n+    # Single parametric solution for diophantine solution:\n+    assert ImageSet(Lambda(n, n**2 + 5), S.Integers).intersect(\n+            ImageSet(Lambda(m, 2*m), S.Integers)) == ImageSet(\n+            Lambda(n, 4*n**2 + 4*n + 6), S.Integers)\n+    # 4 non-parametric solution couples for dioph. equation:\n+    assert ImageSet(Lambda(n, n**2 - 9), S.Integers).intersect(\n+            ImageSet(Lambda(m, -m**2), S.Integers)) == FiniteSet(-9, 0)\n+    # Double parametric solution for diophantine solution:\n+    assert ImageSet(Lambda(m, m**2 + 40), S.Integers).intersect(\n+            ImageSet(Lambda(n, 41*n), S.Integers)) == Intersection(\n+            ImageSet(Lambda(m, m**2 + 40), S.Integers),\n+            ImageSet(Lambda(n, 41*n), S.Integers))\n+    # Check that diophantine returns *all* (8) solutions (permute=True)\n+    assert ImageSet(Lambda(n, n**4 - 2**4), S.Integers).intersect(\n+            ImageSet(Lambda(m, -m**4 + 3**4), S.Integers)) == FiniteSet(0, 65)\n+    assert ImageSet(Lambda(n, pi/12 + n*5*pi/12), S.Integers).intersect(\n+            ImageSet(Lambda(n, 7*pi/12 + n*11*pi/12), S.Integers)) == ImageSet(\n+            Lambda(n, 55*pi*n/12 + 17*pi/4), S.Integers)\n+    # TypeError raised by diophantine (#18081)\n+    assert ImageSet(Lambda(n, n*log(2)), S.Integers).intersection(S.Integers) \\\n+            == Intersection(ImageSet(Lambda(n, n*log(2)), S.Integers), S.Integers)\n+    # NotImplementedError raised by diophantine (no solver for cubic_thue)\n+    assert ImageSet(Lambda(n, n**3 + 1), S.Integers).intersect(\n+            ImageSet(Lambda(n, n**3), S.Integers)) == Intersection(\n+            ImageSet(Lambda(n, n**3 + 1), S.Integers),\n+            ImageSet(Lambda(n, n**3), S.Integers))\n+\n+\n def test_infinitely_indexed_set_3():\n     from sympy.abc import n, m, t\n     assert imageset(Lambda(m, 2*pi*m), S.Integers).intersect(\n@@ -656,7 +699,6 @@ def test_ImageSet_contains():\n \n \n def test_ComplexRegion_contains():\n-\n     # contains in ComplexRegion\n     a = Interval(2, 3)\n     b = Interval(4, 6)\n@@ -687,7 +729,6 @@ def test_ComplexRegion_contains():\n \n \n def test_ComplexRegion_intersect():\n-\n     # Polar form\n     X_axis = ComplexRegion(Interval(0, oo)*FiniteSet(0, S.Pi), polar=True)\n \n@@ -735,7 +776,6 @@ def test_ComplexRegion_intersect():\n \n \n def test_ComplexRegion_union():\n-\n     # Polar form\n     c1 = ComplexRegion(Interval(0, 1)*Interval(0, 2*S.Pi), polar=True)\n     c2 = ComplexRegion(Interval(0, 1)*Interval(0, S.Pi), polar=True)\n@@ -782,7 +822,6 @@ def test_ComplexRegion_measure():\n \n \n def test_normalize_theta_set():\n-\n     # Interval\n     assert normalize_theta_set(Interval(pi, 2*pi)) == \\\n         Union(FiniteSet(0), Interval.Ropen(pi, 2*pi))\ndiff --git a/sympy/solvers/tests/test_diophantine.py b/sympy/solvers/tests/test_diophantine.py\n--- a/sympy/solvers/tests/test_diophantine.py\n+++ b/sympy/solvers/tests/test_diophantine.py\n@@ -487,12 +487,15 @@ def test_diophantine():\n     assert check_solutions((x**2 - 3*y**2 - 1)*(y - 7*z))\n     assert check_solutions((x**2 + y**2 - z**2)*(x - 7*y - 3*z + 4*w))\n     # Following test case caused problems in parametric representation\n-    # But this can be solved by factroing out y.\n+    # But this can be solved by factoring out y.\n     # No need to use methods for ternary quadratic equations.\n     assert check_solutions(y**2 - 7*x*y + 4*y*z)\n     assert check_solutions(x**2 - 2*x + 1)\n \n     assert diophantine(x - y) == diophantine(Eq(x, y))\n+    # 18196\n+    eq = x**4 + y**4 - 97\n+    assert diophantine(eq, permute=True) == diophantine(-eq, permute=True)\n     assert diophantine(3*x*pi - 2*y*pi) == set([(2*t_0, 3*t_0)])\n     eq = x**2 + y**2 + z**2 - 14\n     base_sol = set([(1, 2, 3)])\n",
  "problem_statement": "ImageSet(Lambda(n, n**2), S.Integers).intersect(S.Integers) raises AttributeError\n```\r\nIn [3]: ImageSet(Lambda(n, n**2), S.Integers).intersect(S.Integers)\r\n---------------------------------------------------------------------------\r\nAttributeError                            Traceback (most recent call last)\r\n<ipython-input-3-90c3407ef4ee> in <module>()\r\n----> 1 ImageSet(Lambda(n, n**2), S.Integers).intersect(S.Integers)\r\n  \r\n/root/sympy/sympy/sets/sets.py in intersect(self, other)\r\n    125\r\n    126         \"\"\"\r\n--> 127         return Intersection(self, other)\r\n    128\r\n    129     def intersection(self, other):\r\n\r\n/root/sympy/sympy/sets/sets.py in __new__(cls, *args, **kwargs)\r\n   1339         if evaluate:\r\n   1340             args = list(cls._new_args_filter(args))\r\n-> 1341             return simplify_intersection(args)\r\n   1342\r\n   1343         args = list(ordered(args, Set._infimum_key))\r\n\r\n/root/sympy/sympy/sets/sets.py in simplify_intersection(args)\r\n   2260             new_args = False\r\n   2261             for t in args - set((s,)):\r\n-> 2262                 new_set = intersection_sets(s, t)\r\n   2263                 # This returns None if s does not know how to intersect\r\n   2264                 # with t. Returns the newly intersected set otherwise\r\n\r\n/root/sympy/sympy/multipledispatch/dispatcher.py in __call__(self, *args, **kwargs)\r\n    196             self._cache[types] = func\r\n    197         try:\r\n--> 198             return func(*args, **kwargs)\r\n    199\r\n    200         except MDNotImplementedError:\r\n\r\n/root/sympy/sympy/sets/handlers/intersection.py in intersection_sets(self, other)\r\n    256             else:\r\n    257                 soln, solm = solns[0]\r\n--> 258                 (t,) = soln.free_symbols\r\n    259                 expr = fn.subs(n, soln.subs(t, n))\r\n    260                 return imageset(Lambda(n, expr), S.Integers)\r\n\r\nAttributeError: 'int' object has no attribute 'free_symbols'\r\n```\r\n\r\nThis is in the `diophantine` related intersection code. See also: #17568, #18081\r\nand https://github.com/sympy/sympy/issues/9616#issuecomment-568465831\n",
  "hints_text": "The call to `diophantine` is `diophantine(n**2 - _x, syms=(n, _x))` which returns `[(0, 0)]` where the `0`s are plain `int`s.\r\n\r\nSo:\r\n1. The code in lines 258-260 seems to assume that a single solution tuple will only ever arise in parametrized solutions. This isn't the case here.\r\n2. `(0, 0)` isn't the only integer solution to the equation, so either I don't understand what `diophantine` is supposed to return (partial results?) or it's broken for quadratic equations. (See also #18114.)\r\n\r\nHmm, for point 2 above I just noticed that `diophantine` depends on the ~~assumptions on the variables. So for a plain `isympy` session with `m` and `n` integers and `x` and `y` generic symbols we have~~ alphabetic order of the variables.\r\n```\r\nIn [1]: diophantine(m**2 - n)\r\nOut[1]:\r\n⎧⎛    2⎞⎫\r\n⎨⎝t, t ⎠⎬\r\n⎩       ⎭\r\n\r\nIn [2]: diophantine(x**2 - n)\r\nOut[2]: {(0, 0)}\r\n\r\nIn [3]: diophantine(m**2 - y)\r\nOut[3]:\r\n⎧⎛    2⎞⎫\r\n⎨⎝t, t ⎠⎬\r\n⎩       ⎭\r\n\r\nIn [4]: diophantine(x**2 - y)\r\nOut[4]:\r\n⎧⎛    2⎞⎫\r\n⎨⎝t, t ⎠⎬\r\n⎩       ⎭\r\n```\nI filed #18122 for the `diophantine` issue. This one's then only about the uncaught exception in the sets code.",
  "created_at": "2020-01-01T22:13:06Z",
  "version": "1.6",
  "FAIL_TO_PASS": "[\"test_imageset_intersect_diophantine\", \"test_diophantine\"]",
  "PASS_TO_PASS": "[\"test_naturals\", \"test_naturals0\", \"test_integers\", \"test_ImageSet\", \"test_image_is_ImageSet\", \"test_halfcircle\", \"test_ImageSet_iterator_not_injective\", \"test_inf_Range_len\", \"test_Range_set\", \"test_Range_symbolic\", \"test_range_range_intersection\", \"test_range_interval_intersection\", \"test_Integers_eval_imageset\", \"test_Range_eval_imageset\", \"test_fun\", \"test_Reals\", \"test_Complex\", \"test_intersections\", \"test_infinitely_indexed_set_1\", \"test_infinitely_indexed_set_2\", \"test_imageset_intersect_real\", \"test_imageset_intersect_interval\", \"test_infinitely_indexed_set_3\", \"test_ImageSet_simplification\", \"test_ImageSet_contains\", \"test_ComplexRegion_contains\", \"test_ComplexRegion_intersect\", \"test_ComplexRegion_union\", \"test_ComplexRegion_from_real\", \"test_ComplexRegion_measure\", \"test_normalize_theta_set\", \"test_ComplexRegion_FiniteSet\", \"test_union_RealSubSet\", \"test_issue_9980\", \"test_issue_11732\", \"test_issue_11730\", \"test_issue_11938\", \"test_issue_11914\", \"test_issue_9543\", \"test_issue_16871\", \"test_issue_18050\", \"test_Rationals\", \"test_NZQRC_unions\", \"test_imageset_intersection\", \"test_issue_17858\", \"test_input_format\", \"test_univariate\", \"test_classify_diop\", \"test_linear\", \"test_quadratic_simple_hyperbolic_case\", \"test_quadratic_elliptical_case\", \"test_quadratic_parabolic_case\", \"test_quadratic_perfect_square\", \"test_quadratic_non_perfect_square\", \"test_issue_9106\", \"test_issue_18138\", \"test_DN\", \"test_bf_pell\", \"test_length\", \"test_transformation_to_pell\", \"test_find_DN\", \"test_ldescent\", \"test_diop_ternary_quadratic_normal\", \"test_transformation_to_normal\", \"test_diop_ternary_quadratic\", \"test_square_factor\", \"test_parametrize_ternary_quadratic\", \"test_no_square_ternary_quadratic\", \"test_descent\", \"test_general_pythagorean\", \"test_diop_general_sum_of_squares_quick\", \"test_diop_partition\", \"test_prime_as_sum_of_two_squares\", \"test_sum_of_three_squares\", \"test_sum_of_four_squares\", \"test_power_representation\", \"test_assumptions\", \"test_diopcoverage\", \"test_holzer\", \"test_issue_9539\", \"test_issue_8943\", \"test_diop_sum_of_even_powers\", \"test_sum_of_squares_powers\", \"test__can_do_sum_of_squares\", \"test_diophantine_permute_sign\", \"test_issue_9538\"]",
  "environment_setup_commit": "28b41c73c12b70d6ad9f6e45109a80649c4456da",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.122089",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}