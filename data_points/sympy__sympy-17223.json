{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-17223",
  "base_commit": "30a0130b463a8b73bed10f707c86fb80cd5eba73",
  "patch": "diff --git a/sympy/core/mul.py b/sympy/core/mul.py\n--- a/sympy/core/mul.py\n+++ b/sympy/core/mul.py\n@@ -950,81 +950,161 @@ def matches(self, expr, repl_dict={}, old=False):\n             return AssocOp._matches_commutative(self, expr, repl_dict, old)\n         elif self.is_commutative is not expr.is_commutative:\n             return None\n+\n+        # Proceed only if both both expressions are non-commutative\n         c1, nc1 = self.args_cnc()\n         c2, nc2 = expr.args_cnc()\n-        repl_dict = repl_dict.copy()\n-        if c1:\n-            if not c2:\n-                c2 = [1]\n-            a = self.func(*c1)\n-            if isinstance(a, AssocOp):\n-                repl_dict = a._matches_commutative(self.func(*c2), repl_dict, old)\n-            else:\n-                repl_dict = a.matches(self.func(*c2), repl_dict)\n-        if repl_dict:\n-            a = self.func(*nc1)\n-            if isinstance(a, self.func):\n-                repl_dict = a._matches(self.func(*nc2), repl_dict)\n-            else:\n-                repl_dict = a.matches(self.func(*nc2), repl_dict)\n+        c1, c2 = [c or [1] for c in [c1, c2]]\n+\n+        # TODO: Should these be self.func?\n+        comm_mul_self = Mul(*c1)\n+        comm_mul_expr = Mul(*c2)\n+\n+        repl_dict = comm_mul_self.matches(comm_mul_expr, repl_dict, old)\n+\n+        # If the commutative arguments didn't match and aren't equal, then\n+        # then the expression as a whole doesn't match\n+        if repl_dict is None and c1 != c2:\n+            return None\n+\n+        # Now match the non-commutative arguments, expanding powers to\n+        # multiplications\n+        nc1 = Mul._matches_expand_pows(nc1)\n+        nc2 = Mul._matches_expand_pows(nc2)\n+\n+        repl_dict = Mul._matches_noncomm(nc1, nc2, repl_dict)\n+\n         return repl_dict or None\n \n-    def _matches(self, expr, repl_dict={}):\n-        # weed out negative one prefixes#\n-        from sympy import Wild\n-        sign = 1\n-        a, b = self.as_two_terms()\n-        if a is S.NegativeOne:\n-            if b.is_Mul:\n-                sign = -sign\n+    @staticmethod\n+    def _matches_expand_pows(arg_list):\n+        new_args = []\n+        for arg in arg_list:\n+            if arg.is_Pow and arg.exp > 0:\n+                new_args.extend([arg.base] * arg.exp)\n             else:\n-                # the remainder, b, is not a Mul anymore\n-                return b.matches(-expr, repl_dict)\n-        expr = sympify(expr)\n-        if expr.is_Mul and expr.args[0] is S.NegativeOne:\n-            expr = -expr\n-            sign = -sign\n-\n-        if not expr.is_Mul:\n-            # expr can only match if it matches b and a matches +/- 1\n-            if len(self.args) == 2:\n-                # quickly test for equality\n-                if b == expr:\n-                    return a.matches(Rational(sign), repl_dict)\n-                # do more expensive match\n-                dd = b.matches(expr, repl_dict)\n-                if dd is None:\n-                    return None\n-                dd = a.matches(Rational(sign), dd)\n-                return dd\n-            return None\n+                new_args.append(arg)\n+        return new_args\n \n-        d = repl_dict.copy()\n+    @staticmethod\n+    def _matches_noncomm(nodes, targets, repl_dict={}):\n+        \"\"\"Non-commutative multiplication matcher.\n \n-        # weed out identical terms\n-        pp = list(self.args)\n-        ee = list(expr.args)\n-        for p in self.args:\n-            if p in expr.args:\n-                ee.remove(p)\n-                pp.remove(p)\n+        `nodes` is a list of symbols within the matcher multiplication\n+        expression, while `targets` is a list of arguments in the\n+        multiplication expression being matched against.\n+        \"\"\"\n+        # List of possible future states to be considered\n+        agenda = []\n+        # The current matching state, storing index in nodes and targets\n+        state = (0, 0)\n+        node_ind, target_ind = state\n+        # Mapping between wildcard indices and the index ranges they match\n+        wildcard_dict = {}\n+        repl_dict = repl_dict.copy()\n \n-        # only one symbol left in pattern -> match the remaining expression\n-        if len(pp) == 1 and isinstance(pp[0], Wild):\n-            if len(ee) == 1:\n-                d[pp[0]] = sign * ee[0]\n+        while target_ind < len(targets) and node_ind < len(nodes):\n+            node = nodes[node_ind]\n+\n+            if node.is_Wild:\n+                Mul._matches_add_wildcard(wildcard_dict, state)\n+\n+            states_matches = Mul._matches_new_states(wildcard_dict, state,\n+                                                     nodes, targets)\n+            if states_matches:\n+                new_states, new_matches = states_matches\n+                agenda.extend(new_states)\n+                if new_matches:\n+                    for match in new_matches:\n+                        repl_dict[match] = new_matches[match]\n+            if not agenda:\n+                return None\n             else:\n-                d[pp[0]] = sign * expr.func(*ee)\n-            return d\n+                state = agenda.pop()\n+                node_ind, target_ind = state\n+\n+        return repl_dict\n \n-        if len(ee) != len(pp):\n+    @staticmethod\n+    def _matches_add_wildcard(dictionary, state):\n+        node_ind, target_ind = state\n+        if node_ind in dictionary:\n+            begin, end = dictionary[node_ind]\n+            dictionary[node_ind] = (begin, target_ind)\n+        else:\n+            dictionary[node_ind] = (target_ind, target_ind)\n+\n+    @staticmethod\n+    def _matches_new_states(dictionary, state, nodes, targets):\n+        node_ind, target_ind = state\n+        node = nodes[node_ind]\n+        target = targets[target_ind]\n+\n+        # Don't advance at all if we've exhausted the targets but not the nodes\n+        if target_ind >= len(targets) - 1 and node_ind < len(nodes) - 1:\n             return None\n \n-        for p, e in zip(pp, ee):\n-            d = p.xreplace(d).matches(e, d)\n-            if d is None:\n+        if node.is_Wild:\n+            match_attempt = Mul._matches_match_wilds(dictionary, node_ind,\n+                                                     nodes, targets)\n+            if match_attempt:\n+                # If the same node has been matched before, don't return\n+                # anything if the current match is diverging from the previous\n+                # match\n+                other_node_inds = Mul._matches_get_other_nodes(dictionary,\n+                                                               nodes, node_ind)\n+                for ind in other_node_inds:\n+                    other_begin, other_end = dictionary[ind]\n+                    curr_begin, curr_end = dictionary[node_ind]\n+\n+                    other_targets = targets[other_begin:other_end + 1]\n+                    current_targets = targets[curr_begin:curr_end + 1]\n+\n+                    for curr, other in zip(current_targets, other_targets):\n+                        if curr != other:\n+                            return None\n+\n+                # A wildcard node can match more than one target, so only the\n+                # target index is advanced\n+                new_state = [(node_ind, target_ind + 1)]\n+                # Only move on to the next node if there is one\n+                if node_ind < len(nodes) - 1:\n+                    new_state.append((node_ind + 1, target_ind + 1))\n+                return new_state, match_attempt\n+        else:\n+            # If we're not at a wildcard, then make sure we haven't exhausted\n+            # nodes but not targets, since in this case one node can only match\n+            # one target\n+            if node_ind >= len(nodes) - 1 and target_ind < len(targets) - 1:\n+                return None\n+\n+            match_attempt = node.matches(target)\n+\n+            if match_attempt:\n+                return [(node_ind + 1, target_ind + 1)], match_attempt\n+            elif node == target:\n+                return [(node_ind + 1, target_ind + 1)], None\n+            else:\n                 return None\n-        return d\n+\n+    @staticmethod\n+    def _matches_match_wilds(dictionary, wildcard_ind, nodes, targets):\n+        \"\"\"Determine matches of a wildcard with sub-expression in `target`.\"\"\"\n+        wildcard = nodes[wildcard_ind]\n+        begin, end = dictionary[wildcard_ind]\n+        terms = targets[begin:end + 1]\n+        # TODO: Should this be self.func?\n+        mul = Mul(*terms) if len(terms) > 1 else terms[0]\n+        return wildcard.matches(mul)\n+\n+    @staticmethod\n+    def _matches_get_other_nodes(dictionary, nodes, node_ind):\n+        \"\"\"Find other wildcards that may have already been matched.\"\"\"\n+        other_node_inds = []\n+        for ind in dictionary:\n+            if nodes[ind] == nodes[node_ind]:\n+                other_node_inds.append(ind)\n+        return other_node_inds\n \n     @staticmethod\n     def _combine_inverse(lhs, rhs):\n",
  "test_patch": "diff --git a/sympy/core/tests/test_match.py b/sympy/core/tests/test_match.py\n--- a/sympy/core/tests/test_match.py\n+++ b/sympy/core/tests/test_match.py\n@@ -139,9 +139,9 @@ def test_mul():\n \n def test_mul_noncommutative():\n     x, y = symbols('x y')\n-    A, B = symbols('A B', commutative=False)\n+    A, B, C = symbols('A B C', commutative=False)\n     u, v = symbols('u v', cls=Wild)\n-    w = Wild('w', commutative=False)\n+    w, z = symbols('w z', cls=Wild, commutative=False)\n \n     assert (u*v).matches(x) in ({v: x, u: 1}, {u: x, v: 1})\n     assert (u*v).matches(x*y) in ({v: y, u: x}, {u: y, v: x})\n@@ -170,6 +170,72 @@ def test_mul_noncommutative():\n     assert (v*w).matches(-x*A*B) == {w: A*B, v: -x}\n     assert (v*w).matches(-x*y*A*B) == {w: A*B, v: -x*y}\n \n+    assert (w*z).matches(x) is None\n+    assert (w*z).matches(x*y) is None\n+    assert (w*z).matches(A) is None\n+    assert (w*z).matches(A*B) == {w: A, z: B}\n+    assert (w*z).matches(B*A) == {w: B, z: A}\n+    assert (w*z).matches(A*B*C) in [{w: A, z: B*C}, {w: A*B, z: C}]\n+    assert (w*z).matches(x*A) is None\n+    assert (w*z).matches(x*y*A) is None\n+    assert (w*z).matches(x*A*B) is None\n+    assert (w*z).matches(x*y*A*B) is None\n+\n+    assert (w*A).matches(A) is None\n+    assert (A*w*B).matches(A*B) is None\n+\n+    assert (u*w*z).matches(x) is None\n+    assert (u*w*z).matches(x*y) is None\n+    assert (u*w*z).matches(A) is None\n+    assert (u*w*z).matches(A*B) == {u: 1, w: A, z: B}\n+    assert (u*w*z).matches(B*A) == {u: 1, w: B, z: A}\n+    assert (u*w*z).matches(x*A) is None\n+    assert (u*w*z).matches(x*y*A) is None\n+    assert (u*w*z).matches(x*A*B) == {u: x, w: A, z: B}\n+    assert (u*w*z).matches(x*B*A) == {u: x, w: B, z: A}\n+    assert (u*w*z).matches(x*y*A*B) == {u: x*y, w: A, z: B}\n+    assert (u*w*z).matches(x*y*B*A) == {u: x*y, w: B, z: A}\n+\n+    assert (u*A).matches(x*A) == {u: x}\n+    assert (u*A).matches(x*A*B) is None\n+    assert (u*B).matches(x*A) is None\n+    assert (u*A*B).matches(x*A*B) == {u: x}\n+    assert (u*A*B).matches(x*B*A) is None\n+    assert (u*A*B).matches(x*A) is None\n+\n+    assert (u*w*A).matches(x*A*B) is None\n+    assert (u*w*B).matches(x*A*B) == {u: x, w: A}\n+\n+    assert (u*v*A*B).matches(x*A*B) in [{u: x, v: 1}, {v: x, u: 1}]\n+    assert (u*v*A*B).matches(x*B*A) is None\n+    assert (u*v*A*B).matches(u*v*A*C) is None\n+\n+\n+def test_mul_noncommutative_mismatch():\n+    A, B, C = symbols('A B C', commutative=False)\n+    w = symbols('w', cls=Wild, commutative=False)\n+\n+    assert (w*B*w).matches(A*B*A) == {w: A}\n+    assert (w*B*w).matches(A*C*B*A*C) == {w: A*C}\n+    assert (w*B*w).matches(A*C*B*A*B) is None\n+    assert (w*B*w).matches(A*B*C) is None\n+    assert (w*w*C).matches(A*B*C) is None\n+\n+\n+def test_mul_noncommutative_pow():\n+    A, B, C = symbols('A B C', commutative=False)\n+    w = symbols('w', cls=Wild, commutative=False)\n+\n+    assert (A*B*w).matches(A*B**2) == {w: B}\n+    assert (A*(B**2)*w*(B**3)).matches(A*B**8) == {w: B**3}\n+    assert (A*B*w*C).matches(A*(B**4)*C) == {w: B**3}\n+\n+    assert (A*B*(w**(-1))).matches(A*B*(C**(-1))) == {w: C}\n+    assert (A*(B*w)**(-1)*C).matches(A*(B*C)**(-1)*C) == {w: C}\n+\n+    assert ((w**2)*B*C).matches((A**2)*B*C) == {w: A}\n+    assert ((w**2)*B*(w**3)).matches((A**2)*B*(A**3)) == {w: A}\n+    assert ((w**2)*B*(w**4)).matches((A**2)*B*(A**2)) is None\n \n def test_complex():\n     a, b, c = map(Symbol, 'abc')\n",
  "problem_statement": "Match doesn't respect matrix non-commutativity\n`match` doesn't obey the commutativity of matrix expressions when matching scalars between two expressions. As a demonstration:\r\n\r\n```python\r\n>>> from sympy.abc import N\r\n>>> A, B, C, D = map(lambda x: MatrixSymbol(x, N, N), ['A', 'B', 'C', 'D'])\r\n>>> w = Wild('w')\r\n>>> a, b = symbols('a b')\r\n>>> e1 = a * b * (A * B * C * D)\r\n>>> e2 = w * (D * C * B * A)\r\n>>> e1.match(e2)\r\n{w_: a*b}\r\n```\r\n\r\n`e1.match(e1)` should be `None`, since the associated matrix multiplications are in a different order (and so not indentical).\n",
  "hints_text": "",
  "created_at": "2019-07-18T20:06:19Z",
  "version": "1.5",
  "FAIL_TO_PASS": "[\"test_mul_noncommutative\", \"test_mul_noncommutative_mismatch\", \"test_mul_noncommutative_pow\"]",
  "PASS_TO_PASS": "[\"test_symbol\", \"test_add\", \"test_power\", \"test_match_exclude\", \"test_mul\", \"test_complex\", \"test_functions\", \"test_interface\", \"test_derivative1\", \"test_derivative_bug1\", \"test_derivative2\", \"test_match_deriv_bug1\", \"test_match_bug2\", \"test_match_bug3\", \"test_match_bug4\", \"test_match_bug5\", \"test_match_bug6\", \"test_match_polynomial\", \"test_exclude\", \"test_floats\", \"test_Derivative_bug1\", \"test_match_wild_wild\", \"test__combine_inverse\", \"test_issue_3773\", \"test_issue_3883\", \"test_issue_4418\", \"test_issue_4700\", \"test_issue_5168\", \"test_issue_4559\", \"test_issue_4319\", \"test_issue_3778\", \"test_issue_6103\", \"test_issue_3539\"]",
  "environment_setup_commit": "70381f282f2d9d039da860e391fe51649df2779d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.114582",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}