{
  "repo": "django/django",
  "instance_id": "django__django-12464",
  "base_commit": "f37d548ede290690589e86b892c4f106e2a8e1bc",
  "patch": "diff --git a/django/db/backends/sqlite3/operations.py b/django/db/backends/sqlite3/operations.py\n--- a/django/db/backends/sqlite3/operations.py\n+++ b/django/db/backends/sqlite3/operations.py\n@@ -56,7 +56,11 @@ def check_expression_support(self, expression):\n                             'aggregations on date/time fields in sqlite3 '\n                             'since date/time is saved as text.'\n                         )\n-        if isinstance(expression, models.Aggregate) and len(expression.source_expressions) > 1:\n+        if (\n+            isinstance(expression, models.Aggregate) and\n+            expression.distinct and\n+            len(expression.source_expressions) > 1\n+        ):\n             raise NotSupportedError(\n                 \"SQLite doesn't support DISTINCT on aggregate functions \"\n                 \"accepting multiple arguments.\"\n",
  "test_patch": "diff --git a/tests/backends/sqlite/tests.py b/tests/backends/sqlite/tests.py\n--- a/tests/backends/sqlite/tests.py\n+++ b/tests/backends/sqlite/tests.py\n@@ -63,6 +63,15 @@ class DistinctAggregate(Aggregate):\n         with self.assertRaisesMessage(NotSupportedError, msg):\n             connection.ops.check_expression_support(aggregate)\n \n+    def test_distinct_aggregation_multiple_args_no_distinct(self):\n+        # Aggregate functions accept multiple arguments when DISTINCT isn't\n+        # used, e.g. GROUP_CONCAT().\n+        class DistinctAggregate(Aggregate):\n+            allow_distinct = True\n+\n+        aggregate = DistinctAggregate('first', 'second', distinct=False)\n+        connection.ops.check_expression_support(aggregate)\n+\n     def test_memory_db_test_name(self):\n         \"\"\"A named in-memory db should be allowed where supported.\"\"\"\n         from django.db.backends.sqlite3.base import DatabaseWrapper\n",
  "problem_statement": "DISTINCT with GROUP_CONCAT() and multiple expressions raises NotSupportedError on SQLite.\nDescription\n\t\nContrary to what is suggested in ​lines 60-64 of django.db.backends.sqlite3.operations.py, SQLite does support DISTINCT on aggregate functions.\nOne such example is GROUP_CONCAT, which is quite similar to PostgreSQL's STRING_AGG.\nI can't find any canonical links which provide a useful explanation of GROUP_CONCAT, but this should be good enough: ​https://www.w3resource.com/sqlite/aggregate-functions-and-grouping-group_concat.php\nI came across this issue when trying to create my own GroupConcat function subclassing Aggregate (similar to the ​StringAgg implementation from postgres) and noticed that skipping the check in django.db.backends.sqlite3.operations.py would allow my queries to run as advertised.\nMy code for GroupConcat is:\nfrom django.db.models import Value\nfrom django.db.models.aggregates import Aggregate\nclass GroupConcat(Aggregate):\n\tfunction = 'GROUP_CONCAT'\n\ttemplate = '%(function)s(%(distinct)s %(expressions)s)'\n\tallow_distinct = True\n\tdef __init__(self, expression, delimiter=None, **extra):\n\t\tif delimiter is not None:\n\t\t\tself.allow_distinct = False\n\t\t\tdelimiter_expr = Value(str(delimiter))\n\t\t\tsuper().__init__(expression, delimiter_expr, **extra)\t\t\n\t\telse:\n\t\t\tsuper().__init__(expression, **extra)\t\t\n\tdef as_sqlite(self, compiler, connection, **extra_context):\n\t\treturn super().as_sql(\n\t\t\tcompiler, connection,\n\t\t\tfunction=self.function,\n\t\t\ttemplate=self.template,\n\t\t\t**extra_context\n\t\t)\nFor the record, as the code above suggests, a separate issue is that GROUP_CONCAT only allows DISTINCT when a delimiter isn't specified.\nAfter some discussion on #django, an argument was raised in favor of changing the message to say \"Django doesn't support...\", but I would imagine that skipping the check entirely would simply result in an OperationalError for malformed queries while still allowing users to extend the ORM as needed.\n",
  "hints_text": "Thanks for this ticket. I agree that it shouldn't raise an error in some cases, but removing this check is not an option, IMO. Regression in bc05547cd8c1dd511c6b6a6c873a1bc63417b111.\nThere seems to be problem for concatenation style aggregation in general, here is what i experimented on postgresql: In [18]: Blog.objects.annotate(StringAgg('title', delimiter='x')) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) ~/django/django/db/models/query.py in annotate(self, *args, **kwargs) 1071 try: -> 1072 if arg.default_alias in kwargs: 1073 raise ValueError(\"The named annotation '%s' conflicts with the \" ~/django/django/db/models/aggregates.py in default_alias(self) 64 return '%s__%s' % (expressions[0].name, self.name.lower()) ---> 65 raise TypeError(\"Complex expressions require an alias\") 66 TypeError: Complex expressions require an alias During handling of the above exception, another exception occurred: TypeError Traceback (most recent call last) <ipython-input-18-b924dae7712a> in <module> ----> 1 Blog.objects.annotate(StringAgg('title', delimiter='x')) ~/django/django/db/models/manager.py in manager_method(self, *args, **kwargs) 80 def create_method(name, method): 81 def manager_method(self, *args, **kwargs): ---> 82 return getattr(self.get_queryset(), name)(*args, **kwargs) 83 manager_method.__name__ = method.__name__ 84 manager_method.__doc__ = method.__doc__ ~/django/django/db/models/query.py in annotate(self, *args, **kwargs) 1075 % arg.default_alias) 1076 except TypeError: -> 1077 raise TypeError(\"Complex annotations require an alias\") 1078 annotations[arg.default_alias] = arg 1079 annotations.update(kwargs) TypeError: Complex annotations require an alias In [19]:\nAn error is quite descriptive IMO, \"TypeError: Complex expressions require an alias\".\nReplying to felixxm: An error is quite descriptive IMO, \"TypeError: Complex expressions require an alias\". Not quite sure about what kind of 'expressions' deserve being called complex. But I assume StringAgg('title', delimiter='x') shouldn't be one of them. The problem here is that the delimiter part of StringAgg is included in the expressions, which probably makes it complex. From the syntax defined by Postgresql, the expression is explicitly separated from the delimiter: string_agg(expression, delimiter) ​string_agg\nYes, because delimiter is treated as an expression in StringAgg. Please don't add unrelated comments/questions to tickets.",
  "created_at": "2020-02-18T07:34:42Z",
  "version": "3.1",
  "FAIL_TO_PASS": "[\"test_distinct_aggregation_multiple_args_no_distinct (backends.sqlite.tests.Tests)\"]",
  "PASS_TO_PASS": "[\"test_parameter_escaping (backends.sqlite.tests.EscapingChecksDebug)\", \"test_parameter_escaping (backends.sqlite.tests.EscapingChecks)\", \"test_large_number_of_parameters (backends.sqlite.tests.LastExecutedQueryTest)\", \"test_no_interpolation (backends.sqlite.tests.LastExecutedQueryTest)\", \"test_parameter_quoting (backends.sqlite.tests.LastExecutedQueryTest)\", \"test_aggregation (backends.sqlite.tests.Tests)\", \"test_check_sqlite_version (backends.sqlite.tests.Tests)\", \"test_distinct_aggregation (backends.sqlite.tests.Tests)\", \"A named in-memory db should be allowed where supported.\", \"test_pathlib_name (backends.sqlite.tests.Tests)\", \"test_regexp_function (backends.sqlite.tests.Tests)\", \"test_database_sharing_in_threads (backends.sqlite.tests.ThreadSharing)\", \"test_autoincrement (backends.sqlite.tests.SchemaTests)\", \"test_constraint_checks_disabled_atomic_allowed (backends.sqlite.tests.SchemaTests)\", \"test_disable_constraint_checking_failure_disallowed (backends.sqlite.tests.SchemaTests)\"]",
  "environment_setup_commit": "0668164b4ac93a5be79f5b87fae83c657124d9ab",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.625794",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}