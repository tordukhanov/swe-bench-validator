{
  "repo": "django/django",
  "instance_id": "django__django-14641",
  "base_commit": "304f6ff46a9d78aab0213b599356d3c7875b0bb9",
  "patch": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -1,4 +1,3 @@\n-import datetime\n import re\n \n from django.core.exceptions import ValidationError\n@@ -228,13 +227,7 @@ def id_for_label(self):\n \n     @cached_property\n     def initial(self):\n-        data = self.form.get_initial_for_field(self.field, self.name)\n-        # If this is an auto-generated default date, nix the microseconds for\n-        # standardized handling. See #22502.\n-        if (isinstance(data, (datetime.datetime, datetime.time)) and\n-                not self.field.widget.supports_microseconds):\n-            data = data.replace(microsecond=0)\n-        return data\n+        return self.form.get_initial_for_field(self.field, self.name)\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -3,6 +3,7 @@\n \"\"\"\n \n import copy\n+import datetime\n \n from django.core.exceptions import NON_FIELD_ERRORS, ValidationError\n from django.forms.fields import Field, FileField\n@@ -475,6 +476,11 @@ def get_initial_for_field(self, field, field_name):\n         value = self.initial.get(field_name, field.initial)\n         if callable(value):\n             value = value()\n+        # If this is an auto-generated default date, nix the microseconds\n+        # for standardized handling. See #22502.\n+        if (isinstance(value, (datetime.datetime, datetime.time)) and\n+                not field.widget.supports_microseconds):\n+            value = value.replace(microsecond=0)\n         return value\n \n \n",
  "test_patch": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -1983,19 +1983,33 @@ class UserRegistration(Form):\n         )\n \n     def test_get_initial_for_field(self):\n+        now = datetime.datetime(2006, 10, 25, 14, 30, 45, 123456)\n+\n         class PersonForm(Form):\n             first_name = CharField(initial='John')\n             last_name = CharField(initial='Doe')\n             age = IntegerField()\n             occupation = CharField(initial=lambda: 'Unknown')\n+            dt_fixed = DateTimeField(initial=now)\n+            dt_callable = DateTimeField(initial=lambda: now)\n \n         form = PersonForm(initial={'first_name': 'Jane'})\n-        self.assertIsNone(form.get_initial_for_field(form.fields['age'], 'age'))\n-        self.assertEqual(form.get_initial_for_field(form.fields['last_name'], 'last_name'), 'Doe')\n-        # Form.initial overrides Field.initial.\n-        self.assertEqual(form.get_initial_for_field(form.fields['first_name'], 'first_name'), 'Jane')\n-        # Callables are evaluated.\n-        self.assertEqual(form.get_initial_for_field(form.fields['occupation'], 'occupation'), 'Unknown')\n+        cases = [\n+            ('age', None),\n+            ('last_name', 'Doe'),\n+            # Form.initial overrides Field.initial.\n+            ('first_name', 'Jane'),\n+            # Callables are evaluated.\n+            ('occupation', 'Unknown'),\n+            # Microseconds are removed from datetimes.\n+            ('dt_fixed', datetime.datetime(2006, 10, 25, 14, 30, 45)),\n+            ('dt_callable', datetime.datetime(2006, 10, 25, 14, 30, 45)),\n+        ]\n+        for field_name, expected in cases:\n+            with self.subTest(field_name=field_name):\n+                field = form.fields[field_name]\n+                actual = form.get_initial_for_field(field, field_name)\n+                self.assertEqual(actual, expected)\n \n     def test_changed_data(self):\n         class Person(Form):\n@@ -2097,6 +2111,8 @@ class TextInputWithoutMicrosec(TextInput):\n             supports_microseconds = False\n \n         class DateTimeForm(Form):\n+            # Test a non-callable.\n+            fixed = DateTimeField(initial=now)\n             auto_timestamp = DateTimeField(initial=delayed_now)\n             auto_time_only = TimeField(initial=delayed_now_time)\n             supports_microseconds = DateTimeField(initial=delayed_now, widget=TextInput)\n@@ -2105,12 +2121,23 @@ class DateTimeForm(Form):\n             ti_without_microsec = DateTimeField(initial=delayed_now, widget=TextInputWithoutMicrosec)\n \n         unbound = DateTimeForm()\n-        self.assertEqual(unbound['auto_timestamp'].value(), now_no_ms)\n-        self.assertEqual(unbound['auto_time_only'].value(), now_no_ms.time())\n-        self.assertEqual(unbound['supports_microseconds'].value(), now)\n-        self.assertEqual(unbound['hi_default_microsec'].value(), now)\n-        self.assertEqual(unbound['hi_without_microsec'].value(), now_no_ms)\n-        self.assertEqual(unbound['ti_without_microsec'].value(), now_no_ms)\n+        cases = [\n+            ('fixed', now_no_ms),\n+            ('auto_timestamp', now_no_ms),\n+            ('auto_time_only', now_no_ms.time()),\n+            ('supports_microseconds', now),\n+            ('hi_default_microsec', now),\n+            ('hi_without_microsec', now_no_ms),\n+            ('ti_without_microsec', now_no_ms),\n+        ]\n+        for field_name, expected in cases:\n+            with self.subTest(field_name=field_name):\n+                actual = unbound[field_name].value()\n+                self.assertEqual(actual, expected)\n+                # Also check get_initial_for_field().\n+                field = unbound.fields[field_name]\n+                actual = unbound.get_initial_for_field(field, field_name)\n+                self.assertEqual(actual, expected)\n \n     def get_datetime_form_with_callable_initial(self, disabled, microseconds=0):\n         class FakeTime:\n",
  "problem_statement": "Move special-case logic in BoundField.initial() to BaseForm.get_initial_for_field()\nDescription\n\t\nThis is another follow-up to ticket #32920.\nCurrently, BoundField.initial() has logic to special-case time and datetime objects:\n​https://github.com/django/django/blob/f5669fd7b568cf8a3eda1e65c1c6fb583c7b177d/django/forms/boundfield.py#L217-L219\nI noticed that this logic can be moved to BaseForm.get_initial_for_field(), and in particular under the if callable(value) block:\n​https://github.com/django/django/blob/f5669fd7b568cf8a3eda1e65c1c6fb583c7b177d/django/forms/forms.py#L496-L497\nEventually, I think it could make sense to go further and move some of this logic to a new method of the Field class, which could permit the special-casing to be handled by overriding in sub-classes that use times and datetimes.\n",
  "hints_text": "",
  "created_at": "2021-07-15T15:14:48Z",
  "version": "4.0",
  "FAIL_TO_PASS": "[\"test_get_initial_for_field (forms_tests.tests.test_forms.FormsTestCase)\", \"test_has_error (forms_tests.tests.test_forms.FormsTestCase)\", \"test_initial_datetime_values (forms_tests.tests.test_forms.FormsTestCase)\", \"test_iterable_boundfield_select (forms_tests.tests.test_forms.FormsTestCase)\"]",
  "PASS_TO_PASS": "[\"test_attribute_class (forms_tests.tests.test_forms.RendererTests)\", \"test_attribute_instance (forms_tests.tests.test_forms.RendererTests)\", \"test_attribute_override (forms_tests.tests.test_forms.RendererTests)\", \"test_default (forms_tests.tests.test_forms.RendererTests)\", \"test_kwarg_class (forms_tests.tests.test_forms.RendererTests)\", \"test_kwarg_instance (forms_tests.tests.test_forms.RendererTests)\", \"test_accessing_clean (forms_tests.tests.test_forms.FormsTestCase)\", \"test_auto_id (forms_tests.tests.test_forms.FormsTestCase)\", \"test_auto_id_false (forms_tests.tests.test_forms.FormsTestCase)\", \"test_auto_id_on_form_and_field (forms_tests.tests.test_forms.FormsTestCase)\", \"test_auto_id_true (forms_tests.tests.test_forms.FormsTestCase)\", \"BaseForm.__repr__() should contain some basic information about the\", \"BaseForm.__repr__() shouldn't trigger the form validation.\", \"test_basic_processing_in_view (forms_tests.tests.test_forms.FormsTestCase)\", \"BoundField without any choices (subwidgets) evaluates to True.\", \"test_boundfield_css_classes (forms_tests.tests.test_forms.FormsTestCase)\", \"test_boundfield_empty_label (forms_tests.tests.test_forms.FormsTestCase)\", \"test_boundfield_id_for_label (forms_tests.tests.test_forms.FormsTestCase)\", \"If an id is provided in `Widget.attrs`, it overrides the generated ID,\", \"Multiple calls to BoundField().value() in an unbound form should return\", \"test_boundfield_invalid_index (forms_tests.tests.test_forms.FormsTestCase)\", \"test_boundfield_label_tag (forms_tests.tests.test_forms.FormsTestCase)\", \"test_boundfield_label_tag_custom_widget_id_for_label (forms_tests.tests.test_forms.FormsTestCase)\", \"If a widget has no id, label_tag just returns the text with no\", \"test_boundfield_slice (forms_tests.tests.test_forms.FormsTestCase)\", \"test_boundfield_value_disabled_callable_initial (forms_tests.tests.test_forms.FormsTestCase)\", \"test_boundfield_values (forms_tests.tests.test_forms.FormsTestCase)\", \"test_boundfield_widget_type (forms_tests.tests.test_forms.FormsTestCase)\", \"test_callable_initial_data (forms_tests.tests.test_forms.FormsTestCase)\", \"test_changed_data (forms_tests.tests.test_forms.FormsTestCase)\", \"test_changing_cleaned_data_in_clean (forms_tests.tests.test_forms.FormsTestCase)\", \"test_changing_cleaned_data_nothing_returned (forms_tests.tests.test_forms.FormsTestCase)\", \"test_checkbox_auto_id (forms_tests.tests.test_forms.FormsTestCase)\", \"test_class_prefix (forms_tests.tests.test_forms.FormsTestCase)\", \"test_cleaned_data_only_fields (forms_tests.tests.test_forms.FormsTestCase)\", \"test_custom_boundfield (forms_tests.tests.test_forms.FormsTestCase)\", \"Form fields can customize what is considered as an empty value\", \"test_datetime_changed_data_callable_with_microseconds (forms_tests.tests.test_forms.FormsTestCase)\", \"The cleaned value for a form with a disabled DateTimeField and callable\", \"Cleaning a form with a disabled DateTimeField and callable initial\", \"test_dynamic_construction (forms_tests.tests.test_forms.FormsTestCase)\", \"test_dynamic_initial_data (forms_tests.tests.test_forms.FormsTestCase)\", \"test_empty_data_files_multi_value_dict (forms_tests.tests.test_forms.FormsTestCase)\", \"test_empty_dict (forms_tests.tests.test_forms.FormsTestCase)\", \"test_empty_permitted (forms_tests.tests.test_forms.FormsTestCase)\", \"test_empty_permitted_and_use_required_attribute (forms_tests.tests.test_forms.FormsTestCase)\", \"test_empty_querydict_args (forms_tests.tests.test_forms.FormsTestCase)\", \"test_error_dict (forms_tests.tests.test_forms.FormsTestCase)\", \"#21962 - adding html escape flag to ErrorDict\", \"test_error_escaping (forms_tests.tests.test_forms.FormsTestCase)\", \"test_error_html_required_html_classes (forms_tests.tests.test_forms.FormsTestCase)\", \"test_error_list (forms_tests.tests.test_forms.FormsTestCase)\", \"test_error_list_class_has_one_class_specified (forms_tests.tests.test_forms.FormsTestCase)\", \"test_error_list_class_not_specified (forms_tests.tests.test_forms.FormsTestCase)\", \"test_error_list_with_hidden_field_errors_has_correct_class (forms_tests.tests.test_forms.FormsTestCase)\", \"test_error_list_with_non_field_errors_has_correct_class (forms_tests.tests.test_forms.FormsTestCase)\", \"test_errorlist_override (forms_tests.tests.test_forms.FormsTestCase)\", \"test_escaping (forms_tests.tests.test_forms.FormsTestCase)\", \"test_explicit_field_order (forms_tests.tests.test_forms.FormsTestCase)\", \"test_extracting_hidden_and_visible (forms_tests.tests.test_forms.FormsTestCase)\", \"test_field_deep_copy_error_messages (forms_tests.tests.test_forms.FormsTestCase)\", \"#5749 - `field_name` may be used as a key in _html_output().\", \"BaseForm._html_output() should merge all the hidden input fields and\", \"test_field_named_data (forms_tests.tests.test_forms.FormsTestCase)\", \"test_field_order (forms_tests.tests.test_forms.FormsTestCase)\", \"`css_classes` may be used as a key in _html_output() (class comes\", \"`css_classes` may be used as a key in _html_output() (empty classes).\", \"test_filefield_initial_callable (forms_tests.tests.test_forms.FormsTestCase)\", \"test_filefield_with_fileinput_required (forms_tests.tests.test_forms.FormsTestCase)\", \"test_form (forms_tests.tests.test_forms.FormsTestCase)\", \"test_form_html_attributes (forms_tests.tests.test_forms.FormsTestCase)\", \"test_form_with_disabled_fields (forms_tests.tests.test_forms.FormsTestCase)\", \"test_form_with_iterable_boundfield (forms_tests.tests.test_forms.FormsTestCase)\", \"test_form_with_iterable_boundfield_id (forms_tests.tests.test_forms.FormsTestCase)\", \"test_form_with_noniterable_boundfield (forms_tests.tests.test_forms.FormsTestCase)\", \"test_forms_with_choices (forms_tests.tests.test_forms.FormsTestCase)\", \"test_forms_with_file_fields (forms_tests.tests.test_forms.FormsTestCase)\", \"test_forms_with_multiple_choice (forms_tests.tests.test_forms.FormsTestCase)\", \"test_forms_with_null_boolean (forms_tests.tests.test_forms.FormsTestCase)\", \"test_forms_with_prefixes (forms_tests.tests.test_forms.FormsTestCase)\", \"test_forms_with_radio (forms_tests.tests.test_forms.FormsTestCase)\", \"test_help_text (forms_tests.tests.test_forms.FormsTestCase)\", \"test_hidden_data (forms_tests.tests.test_forms.FormsTestCase)\", \"test_hidden_initial_gets_id (forms_tests.tests.test_forms.FormsTestCase)\", \"test_hidden_widget (forms_tests.tests.test_forms.FormsTestCase)\", \"test_html_output_with_hidden_input_field_errors (forms_tests.tests.test_forms.FormsTestCase)\", \"test_html_safe (forms_tests.tests.test_forms.FormsTestCase)\", \"test_id_on_field (forms_tests.tests.test_forms.FormsTestCase)\", \"test_initial_data (forms_tests.tests.test_forms.FormsTestCase)\", \"#17922 - required_css_class is added to the label_tag() of required fields.\", \"test_label_split_datetime_not_displayed (forms_tests.tests.test_forms.FormsTestCase)\", \"test_label_suffix (forms_tests.tests.test_forms.FormsTestCase)\", \"BoundField label_suffix (if provided) overrides Form label_suffix\", \"test_multipart_encoded_form (forms_tests.tests.test_forms.FormsTestCase)\", \"test_multiple_choice_checkbox (forms_tests.tests.test_forms.FormsTestCase)\", \"test_multiple_choice_list_data (forms_tests.tests.test_forms.FormsTestCase)\", \"test_multiple_hidden (forms_tests.tests.test_forms.FormsTestCase)\", \"#19298 -- MultiValueField needs to override the default as it needs\", \"test_multivalue_field_validation (forms_tests.tests.test_forms.FormsTestCase)\", \"#23674 -- invalid initial data should not break form.changed_data()\", \"test_multivalue_optional_subfields (forms_tests.tests.test_forms.FormsTestCase)\", \"test_only_hidden_fields (forms_tests.tests.test_forms.FormsTestCase)\", \"test_optional_data (forms_tests.tests.test_forms.FormsTestCase)\", \"test_specifying_labels (forms_tests.tests.test_forms.FormsTestCase)\", \"test_subclassing_forms (forms_tests.tests.test_forms.FormsTestCase)\", \"test_templates_with_forms (forms_tests.tests.test_forms.FormsTestCase)\", \"test_unbound_form (forms_tests.tests.test_forms.FormsTestCase)\", \"test_unicode_values (forms_tests.tests.test_forms.FormsTestCase)\", \"test_update_error_dict (forms_tests.tests.test_forms.FormsTestCase)\", \"test_use_required_attribute_false (forms_tests.tests.test_forms.FormsTestCase)\", \"test_use_required_attribute_true (forms_tests.tests.test_forms.FormsTestCase)\", \"test_validating_multiple_fields (forms_tests.tests.test_forms.FormsTestCase)\", \"The list of form field validators can be modified without polluting\", \"test_various_boolean_values (forms_tests.tests.test_forms.FormsTestCase)\", \"test_widget_output (forms_tests.tests.test_forms.FormsTestCase)\"]",
  "environment_setup_commit": "475cffd1d64c690cdad16ede4d5e81985738ceb4",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.698692",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}