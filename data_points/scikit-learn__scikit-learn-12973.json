{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-12973",
  "base_commit": "a7b8b9e9e16d4e15fabda5ae615086c2e1c47d8a",
  "patch": "diff --git a/sklearn/linear_model/least_angle.py b/sklearn/linear_model/least_angle.py\n--- a/sklearn/linear_model/least_angle.py\n+++ b/sklearn/linear_model/least_angle.py\n@@ -1479,7 +1479,7 @@ def __init__(self, criterion='aic', fit_intercept=True, verbose=False,\n         self.eps = eps\n         self.fit_path = True\n \n-    def fit(self, X, y, copy_X=True):\n+    def fit(self, X, y, copy_X=None):\n         \"\"\"Fit the model using X, y as training data.\n \n         Parameters\n@@ -1490,7 +1490,9 @@ def fit(self, X, y, copy_X=True):\n         y : array-like, shape (n_samples,)\n             target values. Will be cast to X's dtype if necessary\n \n-        copy_X : boolean, optional, default True\n+        copy_X : boolean, optional, default None\n+            If provided, this parameter will override the choice\n+            of copy_X made at instance creation.\n             If ``True``, X will be copied; else, it may be overwritten.\n \n         Returns\n@@ -1498,10 +1500,12 @@ def fit(self, X, y, copy_X=True):\n         self : object\n             returns an instance of self.\n         \"\"\"\n+        if copy_X is None:\n+            copy_X = self.copy_X\n         X, y = check_X_y(X, y, y_numeric=True)\n \n         X, y, Xmean, ymean, Xstd = LinearModel._preprocess_data(\n-            X, y, self.fit_intercept, self.normalize, self.copy_X)\n+            X, y, self.fit_intercept, self.normalize, copy_X)\n         max_iter = self.max_iter\n \n         Gram = self.precompute\n",
  "test_patch": "diff --git a/sklearn/linear_model/tests/test_least_angle.py b/sklearn/linear_model/tests/test_least_angle.py\n--- a/sklearn/linear_model/tests/test_least_angle.py\n+++ b/sklearn/linear_model/tests/test_least_angle.py\n@@ -18,7 +18,7 @@\n from sklearn.utils.testing import TempMemmap\n from sklearn.exceptions import ConvergenceWarning\n from sklearn import linear_model, datasets\n-from sklearn.linear_model.least_angle import _lars_path_residues\n+from sklearn.linear_model.least_angle import _lars_path_residues, LassoLarsIC\n \n diabetes = datasets.load_diabetes()\n X, y = diabetes.data, diabetes.target\n@@ -686,3 +686,34 @@ def test_lasso_lars_vs_R_implementation():\n \n     assert_array_almost_equal(r2, skl_betas2, decimal=12)\n     ###########################################################################\n+\n+\n+@pytest.mark.parametrize('copy_X', [True, False])\n+def test_lasso_lars_copyX_behaviour(copy_X):\n+    \"\"\"\n+    Test that user input regarding copy_X is not being overridden (it was until\n+    at least version 0.21)\n+\n+    \"\"\"\n+    lasso_lars = LassoLarsIC(copy_X=copy_X, precompute=False)\n+    rng = np.random.RandomState(0)\n+    X = rng.normal(0, 1, (100, 5))\n+    X_copy = X.copy()\n+    y = X[:, 2]\n+    lasso_lars.fit(X, y)\n+    assert copy_X == np.array_equal(X, X_copy)\n+\n+\n+@pytest.mark.parametrize('copy_X', [True, False])\n+def test_lasso_lars_fit_copyX_behaviour(copy_X):\n+    \"\"\"\n+    Test that user input to .fit for copy_X overrides default __init__ value\n+\n+    \"\"\"\n+    lasso_lars = LassoLarsIC(precompute=False)\n+    rng = np.random.RandomState(0)\n+    X = rng.normal(0, 1, (100, 5))\n+    X_copy = X.copy()\n+    y = X[:, 2]\n+    lasso_lars.fit(X, y, copy_X=copy_X)\n+    assert copy_X == np.array_equal(X, X_copy)\n",
  "problem_statement": "LassoLarsIC: unintuitive copy_X behaviour\nHi, I would like to report what seems to be a bug in the treatment of the `copy_X` parameter of the `LassoLarsIC` class. Because it's a simple bug, it's much easier to see in the code directly than in the execution, so I am not posting steps to reproduce it.\r\n\r\nAs you can see here, LassoLarsIC accepts a copy_X parameter.\r\nhttps://github.com/scikit-learn/scikit-learn/blob/7389dbac82d362f296dc2746f10e43ffa1615660/sklearn/linear_model/least_angle.py#L1487\r\n\r\nHowever, it also takes a copy_X parameter a few lines below, in the definition of ```fit```.\r\n    ```def fit(self, X, y, copy_X=True):```\r\n\r\nNow there are two values (potentially contradicting each other) for copy_X and each one is used once. Therefore ```fit``` can have a mixed behaviour. Even worse, this can be completely invisible to the user, since copy_X has a default value of True. Let's assume that I'd like it to be False, and have set it to False in the initialization, `my_lasso = LassoLarsIC(copy_X=False)`. I then call ```my_lasso.fit(X, y)``` and my choice will be silently overwritten. \r\n\r\nIdeally I think that copy_X should be removed as an argument in ```fit```. No other estimator seems to have a duplication in class parameters and fit arguments (I've checked more than ten in the linear models module). However, this would break existing code. Therefore I propose that ```fit``` takes a default value of `None` and only overwrites the existing value if the user has explicitly passed it as an argument to ```fit```. I will submit a PR to that effect.\n",
  "hints_text": "",
  "created_at": "2019-01-13T16:19:52Z",
  "version": "0.21",
  "FAIL_TO_PASS": "[\"sklearn/linear_model/tests/test_least_angle.py::test_lasso_lars_fit_copyX_behaviour[False]\"]",
  "PASS_TO_PASS": "[\"sklearn/linear_model/tests/test_least_angle.py::test_simple\", \"sklearn/linear_model/tests/test_least_angle.py::test_simple_precomputed\", \"sklearn/linear_model/tests/test_least_angle.py::test_all_precomputed\", \"sklearn/linear_model/tests/test_least_angle.py::test_lars_lstsq\", \"sklearn/linear_model/tests/test_least_angle.py::test_lasso_gives_lstsq_solution\", \"sklearn/linear_model/tests/test_least_angle.py::test_collinearity\", \"sklearn/linear_model/tests/test_least_angle.py::test_no_path\", \"sklearn/linear_model/tests/test_least_angle.py::test_no_path_precomputed\", \"sklearn/linear_model/tests/test_least_angle.py::test_no_path_all_precomputed\", \"sklearn/linear_model/tests/test_least_angle.py::test_lars_precompute[Lars]\", \"sklearn/linear_model/tests/test_least_angle.py::test_lars_precompute[LarsCV]\", \"sklearn/linear_model/tests/test_least_angle.py::test_lars_precompute[LassoLarsIC]\", \"sklearn/linear_model/tests/test_least_angle.py::test_singular_matrix\", \"sklearn/linear_model/tests/test_least_angle.py::test_lasso_lars_vs_lasso_cd\", \"sklearn/linear_model/tests/test_least_angle.py::test_lasso_lars_vs_lasso_cd_early_stopping\", \"sklearn/linear_model/tests/test_least_angle.py::test_lasso_lars_path_length\", \"sklearn/linear_model/tests/test_least_angle.py::test_lasso_lars_vs_lasso_cd_ill_conditioned\", \"sklearn/linear_model/tests/test_least_angle.py::test_lasso_lars_vs_lasso_cd_ill_conditioned2\", \"sklearn/linear_model/tests/test_least_angle.py::test_lars_add_features\", \"sklearn/linear_model/tests/test_least_angle.py::test_lars_n_nonzero_coefs\", \"sklearn/linear_model/tests/test_least_angle.py::test_multitarget\", \"sklearn/linear_model/tests/test_least_angle.py::test_lars_cv\", \"sklearn/linear_model/tests/test_least_angle.py::test_lars_cv_max_iter\", \"sklearn/linear_model/tests/test_least_angle.py::test_lasso_lars_ic\", \"sklearn/linear_model/tests/test_least_angle.py::test_lars_path_readonly_data\", \"sklearn/linear_model/tests/test_least_angle.py::test_lars_path_positive_constraint\", \"sklearn/linear_model/tests/test_least_angle.py::test_estimatorclasses_positive_constraint\", \"sklearn/linear_model/tests/test_least_angle.py::test_lasso_lars_vs_lasso_cd_positive\", \"sklearn/linear_model/tests/test_least_angle.py::test_lasso_lars_vs_R_implementation\", \"sklearn/linear_model/tests/test_least_angle.py::test_lasso_lars_copyX_behaviour[True]\", \"sklearn/linear_model/tests/test_least_angle.py::test_lasso_lars_copyX_behaviour[False]\", \"sklearn/linear_model/tests/test_least_angle.py::test_lasso_lars_fit_copyX_behaviour[True]\"]",
  "environment_setup_commit": "7813f7efb5b2012412888b69e73d76f2df2b50b6",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.976995",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}