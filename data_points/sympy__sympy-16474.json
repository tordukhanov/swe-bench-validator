{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-16474",
  "base_commit": "d13eb25999fb8af72c87fded526f995f5c79cb3d",
  "patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -556,20 +556,22 @@ def _print_Pow(self, expr):\n                 return self._print(expr.base, exp=self._print(expr.exp))\n             else:\n                 tex = r\"%s^{%s}\"\n-                exp = self._print(expr.exp)\n-                # issue #12886: add parentheses around superscripts raised\n-                # to powers\n-                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n-                if '^' in base and expr.base.is_Symbol:\n-                    base = r\"\\left(%s\\right)\" % base\n-                elif (isinstance(expr.base, Derivative)\n-                        and base.startswith(r'\\left(')\n-                        and re.match(r'\\\\left\\(\\\\d?d?dot', base)\n-                        and base.endswith(r'\\right)')):\n-                    # don't use parentheses around dotted derivative\n-                    base = base[6: -7]  # remove outermost added parens\n-\n-                return tex % (base, exp)\n+                return self._helper_print_standard_power(expr, tex)\n+\n+    def _helper_print_standard_power(self, expr, template):\n+        exp = self._print(expr.exp)\n+        # issue #12886: add parentheses around superscripts raised\n+        # to powers\n+        base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+        if '^' in base and expr.base.is_Symbol:\n+            base = r\"\\left(%s\\right)\" % base\n+        elif (isinstance(expr.base, Derivative)\n+            and base.startswith(r'\\left(')\n+            and re.match(r'\\\\left\\(\\\\d?d?dot', base)\n+            and base.endswith(r'\\right)')):\n+            # don't use parentheses around dotted derivative\n+            base = base[6: -7]  # remove outermost added parens\n+        return template % (base, exp)\n \n     def _print_UnevaluatedExpr(self, expr):\n         return self._print(expr.args[0])\n@@ -1512,7 +1514,7 @@ def _print_Transpose(self, expr):\n         if not isinstance(mat, MatrixSymbol):\n             return r\"\\left(%s\\right)^{T}\" % self._print(mat)\n         else:\n-            return \"%s^{T}\" % self._print(mat)\n+            return \"%s^{T}\" % self.parenthesize(mat, precedence_traditional(expr), True)\n \n     def _print_Trace(self, expr):\n         mat = expr.arg\n@@ -1558,28 +1560,30 @@ def _print_Mod(self, expr, exp=None):\n                                  self._print(expr.args[1]))\n \n     def _print_HadamardProduct(self, expr):\n-        from sympy import Add, MatAdd, MatMul\n+        args = expr.args\n+        prec = PRECEDENCE['Pow']\n+        parens = self.parenthesize\n+\n+        return r' \\circ '.join(\n+            map(lambda arg: parens(arg, prec, strict=True), args))\n \n-        def parens(x):\n-            if isinstance(x, (Add, MatAdd, MatMul)):\n-                return r\"\\left(%s\\right)\" % self._print(x)\n-            return self._print(x)\n-        return r' \\circ '.join(map(parens, expr.args))\n+    def _print_HadamardPower(self, expr):\n+        template = r\"%s^{\\circ {%s}}\"\n+        return self._helper_print_standard_power(expr, template)\n \n     def _print_KroneckerProduct(self, expr):\n-        from sympy import Add, MatAdd, MatMul\n+        args = expr.args\n+        prec = PRECEDENCE['Pow']\n+        parens = self.parenthesize\n \n-        def parens(x):\n-            if isinstance(x, (Add, MatAdd, MatMul)):\n-                return r\"\\left(%s\\right)\" % self._print(x)\n-            return self._print(x)\n-        return r' \\otimes '.join(map(parens, expr.args))\n+        return r' \\otimes '.join(\n+            map(lambda arg: parens(arg, prec, strict=True), args))\n \n     def _print_MatPow(self, expr):\n         base, exp = expr.base, expr.exp\n         from sympy.matrices import MatrixSymbol\n         if not isinstance(base, MatrixSymbol):\n-            return r\"\\left(%s\\right)^{%s}\" % (self._print(base),\n+            return \"\\\\left(%s\\\\right)^{%s}\" % (self._print(base),\n                                               self._print(exp))\n         else:\n             return \"%s^{%s}\" % (self._print(base), self._print(exp))\ndiff --git a/sympy/printing/precedence.py b/sympy/printing/precedence.py\n--- a/sympy/printing/precedence.py\n+++ b/sympy/printing/precedence.py\n@@ -24,6 +24,7 @@\n # A dictionary assigning precedence values to certain classes. These values are\n # treated like they were inherited, so not every single class has to be named\n # here.\n+# Do not use this with printers other than StrPrinter\n PRECEDENCE_VALUES = {\n     \"Equivalent\": PRECEDENCE[\"Xor\"],\n     \"Xor\": PRECEDENCE[\"Xor\"],\n@@ -115,8 +116,9 @@ def precedence_UnevaluatedExpr(item):\n \n \n def precedence(item):\n-    \"\"\"\n-    Returns the precedence of a given object.\n+    \"\"\"Returns the precedence of a given object.\n+\n+    This is the precedence for StrPrinter.\n     \"\"\"\n     if hasattr(item, \"precedence\"):\n         return item.precedence\n@@ -134,19 +136,22 @@ def precedence(item):\n \n \n def precedence_traditional(item):\n-    \"\"\"\n-    Returns the precedence of a given object according to the traditional rules\n-    of mathematics. This is the precedence for the LaTeX and pretty printer.\n+    \"\"\"Returns the precedence of a given object according to the\n+    traditional rules of mathematics.\n+\n+    This is the precedence for the LaTeX and pretty printer.\n     \"\"\"\n     # Integral, Sum, Product, Limit have the precedence of Mul in LaTeX,\n     # the precedence of Atom for other printers:\n-    from sympy import Integral, Sum, Product, Limit, Derivative\n+    from sympy import Integral, Sum, Product, Limit, Derivative, Transpose, Adjoint\n     from sympy.core.expr import UnevaluatedExpr\n     from sympy.tensor.functions import TensorProduct\n \n     if isinstance(item, (Integral, Sum, Product, Limit, Derivative, TensorProduct)):\n         return PRECEDENCE[\"Mul\"]\n-    if (item.__class__.__name__ in (\"Dot\", \"Cross\", \"Gradient\", \"Divergence\",\n+    elif isinstance(item, (Transpose, Adjoint)):\n+        return PRECEDENCE[\"Pow\"]\n+    elif (item.__class__.__name__ in (\"Dot\", \"Cross\", \"Gradient\", \"Divergence\",\n                                     \"Curl\", \"Laplacian\")):\n         return PRECEDENCE[\"Mul\"]-1\n     elif isinstance(item, UnevaluatedExpr):\n",
  "test_patch": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1579,17 +1579,45 @@ def test_Adjoint():\n     assert latex(Adjoint(Transpose(X))) == r'\\left(X^{T}\\right)^{\\dagger}'\n     assert latex(Transpose(Adjoint(X))) == r'\\left(X^{\\dagger}\\right)^{T}'\n     assert latex(Transpose(Adjoint(X) + Y)) == r'\\left(X^{\\dagger} + Y\\right)^{T}'\n+\n+\n+def test_Transpose():\n+    from sympy.matrices import Transpose, MatPow, HadamardPower\n+    X = MatrixSymbol('X', 2, 2)\n+    Y = MatrixSymbol('Y', 2, 2)\n     assert latex(Transpose(X)) == r'X^{T}'\n     assert latex(Transpose(X + Y)) == r'\\left(X + Y\\right)^{T}'\n \n+    assert latex(Transpose(HadamardPower(X, 2))) == \\\n+        r'\\left(X^{\\circ {2}}\\right)^{T}'\n+    assert latex(HadamardPower(Transpose(X), 2)) == \\\n+        r'\\left(X^{T}\\right)^{\\circ {2}}'\n+    assert latex(Transpose(MatPow(X, 2))) == \\\n+        r'\\left(X^{2}\\right)^{T}'\n+    assert latex(MatPow(Transpose(X), 2)) == \\\n+        r'\\left(X^{T}\\right)^{2}'\n+\n \n def test_Hadamard():\n-    from sympy.matrices import MatrixSymbol, HadamardProduct\n+    from sympy.matrices import MatrixSymbol, HadamardProduct, HadamardPower\n+    from sympy.matrices.expressions import MatAdd, MatMul, MatPow\n     X = MatrixSymbol('X', 2, 2)\n     Y = MatrixSymbol('Y', 2, 2)\n     assert latex(HadamardProduct(X, Y*Y)) == r'X \\circ Y^{2}'\n     assert latex(HadamardProduct(X, Y)*Y) == r'\\left(X \\circ Y\\right) Y'\n \n+    assert latex(HadamardPower(X, 2)) == r'X^{\\circ {2}}'\n+    assert latex(HadamardPower(X, -1)) == r'X^{\\circ {-1}}'\n+    assert latex(HadamardPower(MatAdd(X, Y), 2)) == \\\n+        r'\\left(X + Y\\right)^{\\circ {2}}'\n+    assert latex(HadamardPower(MatMul(X, Y), 2)) == \\\n+        r'\\left(X Y\\right)^{\\circ {2}}'\n+\n+    assert latex(HadamardPower(MatPow(X, -1), -1)) == \\\n+        r'\\left(X^{-1}\\right)^{\\circ {-1}}'\n+    assert latex(MatPow(HadamardPower(X, -1), -1)) == \\\n+        r'\\left(X^{\\circ {-1}}\\right)^{-1}'\n+\n \n def test_ZeroMatrix():\n     from sympy import ZeroMatrix\n",
  "problem_statement": "Add LaTeX and pretty printers for HadamardPower\nFurthermore, HadamardProduct may be extended to support the division symbol.\r\n\r\n- [ ] Add latex printer\r\n- [ ] Add mathml printer\r\n- [ ] Add pretty printer\n",
  "hints_text": "See: https://github.com/sympy/sympy/pull/16443#issuecomment-476504237 and subsequent discussion.",
  "created_at": "2019-03-28T13:14:14Z",
  "version": "1.5",
  "FAIL_TO_PASS": "[\"test_Transpose\", \"test_Hadamard\"]",
  "PASS_TO_PASS": "[\"test_printmethod\", \"test_latex_basic\", \"test_latex_builtins\", \"test_latex_SingularityFunction\", \"test_latex_cycle\", \"test_latex_permutation\", \"test_latex_Float\", \"test_latex_vector_expressions\", \"test_latex_symbols\", \"test_latex_functions\", \"test_function_subclass_different_name\", \"test_hyper_printing\", \"test_latex_bessel\", \"test_latex_fresnel\", \"test_latex_brackets\", \"test_latex_indexed\", \"test_latex_derivatives\", \"test_latex_subs\", \"test_latex_integrals\", \"test_latex_sets\", \"test_latex_SetExpr\", \"test_latex_Range\", \"test_latex_sequences\", \"test_latex_FourierSeries\", \"test_latex_FormalPowerSeries\", \"test_latex_intervals\", \"test_latex_AccumuBounds\", \"test_latex_emptyset\", \"test_latex_commutator\", \"test_latex_union\", \"test_latex_intersection\", \"test_latex_symmetric_difference\", \"test_latex_Complement\", \"test_latex_Complexes\", \"test_latex_productset\", \"test_latex_Naturals\", \"test_latex_Naturals0\", \"test_latex_Integers\", \"test_latex_ImageSet\", \"test_latex_ConditionSet\", \"test_latex_ComplexRegion\", \"test_latex_Contains\", \"test_latex_sum\", \"test_latex_product\", \"test_latex_limits\", \"test_latex_log\", \"test_issue_3568\", \"test_latex\", \"test_latex_dict\", \"test_latex_list\", \"test_latex_rational\", \"test_latex_inverse\", \"test_latex_DiracDelta\", \"test_latex_Heaviside\", \"test_latex_KroneckerDelta\", \"test_latex_LeviCivita\", \"test_mode\", \"test_latex_Piecewise\", \"test_latex_Matrix\", \"test_latex_matrix_with_functions\", \"test_latex_NDimArray\", \"test_latex_mul_symbol\", \"test_latex_issue_4381\", \"test_latex_issue_4576\", \"test_latex_pow_fraction\", \"test_noncommutative\", \"test_latex_order\", \"test_latex_Lambda\", \"test_latex_PolyElement\", \"test_latex_FracElement\", \"test_latex_Poly\", \"test_latex_Poly_order\", \"test_latex_ComplexRootOf\", \"test_latex_RootSum\", \"test_settings\", \"test_latex_numbers\", \"test_latex_euler\", \"test_lamda\", \"test_custom_symbol_names\", \"test_matAdd\", \"test_matMul\", \"test_latex_MatrixSlice\", \"test_latex_RandomDomain\", \"test_PrettyPoly\", \"test_integral_transforms\", \"test_PolynomialRingBase\", \"test_categories\", \"test_Modules\", \"test_QuotientRing\", \"test_Tr\", \"test_Adjoint\", \"test_ZeroMatrix\", \"test_Identity\", \"test_boolean_args_order\", \"test_imaginary\", \"test_builtins_without_args\", \"test_latex_greek_functions\", \"test_translate\", \"test_other_symbols\", \"test_modifiers\", \"test_greek_symbols\", \"test_builtin_no_args\", \"test_issue_6853\", \"test_Mul\", \"test_Pow\", \"test_issue_7180\", \"test_issue_8409\", \"test_issue_7117\", \"test_issue_15439\", \"test_issue_2934\", \"test_issue_10489\", \"test_issue_12886\", \"test_issue_13651\", \"test_latex_UnevaluatedExpr\", \"test_MatrixElement_printing\", \"test_MatrixSymbol_printing\", \"test_KroneckerProduct_printing\", \"test_Quaternion_latex_printing\", \"test_TensorProduct_printing\", \"test_WedgeProduct_printing\", \"test_issue_14041\", \"test_issue_9216\", \"test_latex_printer_tensor\", \"test_issue_15353\", \"test_trace\", \"test_print_basic\", \"test_MatrixSymbol_bold\", \"test_imaginary_unit\", \"test_text_re_im\"]",
  "environment_setup_commit": "70381f282f2d9d039da860e391fe51649df2779d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.108016",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}