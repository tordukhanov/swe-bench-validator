{
  "repo": "matplotlib/matplotlib",
  "instance_id": "matplotlib__matplotlib-22945",
  "base_commit": "89b21b517df0b2a9c378913bae8e1f184988b554",
  "patch": "diff --git a/lib/matplotlib/collections.py b/lib/matplotlib/collections.py\n--- a/lib/matplotlib/collections.py\n+++ b/lib/matplotlib/collections.py\n@@ -195,8 +195,9 @@ def __init__(self,\n \n         # default to zeros\n         self._offsets = np.zeros((1, 2))\n+        self._has_offsets = offsets is not None\n \n-        if offsets is not None:\n+        if self._has_offsets:\n             offsets = np.asanyarray(offsets, float)\n             # Broadcast (2,) -> (1, 2) but nothing else.\n             if offsets.shape == (2,):\n@@ -278,7 +279,7 @@ def get_datalim(self, transData):\n             offsets = offsets.filled(np.nan)\n             # get_path_collection_extents handles nan but not masked arrays\n \n-        if len(paths) and len(offsets):\n+        if len(paths):\n             if any(transform.contains_branch_seperately(transData)):\n                 # collections that are just in data units (like quiver)\n                 # can properly have the axes limits set by their shape +\n@@ -290,18 +291,19 @@ def get_datalim(self, transData):\n                     offset_trf.transform_non_affine(offsets),\n                     offset_trf.get_affine().frozen())\n \n-            # this is for collections that have their paths (shapes)\n-            # in physical, axes-relative, or figure-relative units\n-            # (i.e. like scatter). We can't uniquely set limits based on\n-            # those shapes, so we just set the limits based on their\n-            # location.\n-            offsets = (offset_trf - transData).transform(offsets)\n-            # note A-B means A B^{-1}\n-            offsets = np.ma.masked_invalid(offsets)\n-            if not offsets.mask.all():\n-                bbox = transforms.Bbox.null()\n-                bbox.update_from_data_xy(offsets)\n-                return bbox\n+            if self._has_offsets:\n+                # this is for collections that have their paths (shapes)\n+                # in physical, axes-relative, or figure-relative units\n+                # (i.e. like scatter). We can't uniquely set limits based on\n+                # those shapes, so we just set the limits based on their\n+                # location.\n+                offsets = (offset_trf - transData).transform(offsets)\n+                # note A-B means A B^{-1}\n+                offsets = np.ma.masked_invalid(offsets)\n+                if not offsets.mask.all():\n+                    bbox = transforms.Bbox.null()\n+                    bbox.update_from_data_xy(offsets)\n+                    return bbox\n         return transforms.Bbox.null()\n \n     def get_window_extent(self, renderer):\n",
  "test_patch": "diff --git a/lib/matplotlib/tests/test_collections.py b/lib/matplotlib/tests/test_collections.py\n--- a/lib/matplotlib/tests/test_collections.py\n+++ b/lib/matplotlib/tests/test_collections.py\n@@ -9,6 +9,7 @@\n import matplotlib.pyplot as plt\n import matplotlib.collections as mcollections\n import matplotlib.colors as mcolors\n+import matplotlib.path as mpath\n import matplotlib.transforms as mtransforms\n from matplotlib.collections import (Collection, LineCollection,\n                                     EventCollection, PolyCollection)\n@@ -291,6 +292,17 @@ def test_null_collection_datalim():\n                        mtransforms.Bbox.null().get_points())\n \n \n+def test_no_offsets_datalim():\n+    # A collection with no offsets and a non transData\n+    # transform should return a null bbox\n+    ax = plt.axes()\n+    coll = mcollections.PathCollection([mpath.Path([(0, 0), (1, 0)])])\n+    ax.add_collection(coll)\n+    coll_data_lim = coll.get_datalim(mtransforms.IdentityTransform())\n+    assert_array_equal(coll_data_lim.get_points(),\n+                       mtransforms.Bbox.null().get_points())\n+\n+\n def test_add_collection():\n     # Test if data limits are unchanged by adding an empty collection.\n     # GitHub issue #1490, pull #1497.\n",
  "problem_statement": "[Bug]: Regression in animation from #22175\n### Bug summary\r\n\r\nOn a9dd8b999a74d7cefc92f3c599bee6c11958d05a things are fine, on the next commit 396a010a6147e232d7ab101db9e4b5c6a48d0b36 from #22175 we get an error with previously working animation code.\r\n\r\n### Code for reproduction\r\n\r\n```python\r\nimport numpy as np\r\nimport matplotlib\r\nfrom matplotlib import pyplot as plt, animation, patches\r\nmatplotlib.use('agg', force=True)\r\nfig, ax = plt.subplots()\r\n\r\n\r\ndef _init_anim():\r\n    patch_ = patches.Ellipse((0, 0), 1, 1)\r\n    Xi, Yi = np.meshgrid(np.arange(4), np.arange(3))\r\n    cont = ax.contour(Xi, Yi, Yi, levels=1)\r\n    cont.collections[0].set_clip_path(patch_)\r\n    fig.tight_layout()\r\n    return tuple(cont.collections)\r\n\r\n\r\nanimate_func = lambda: None\r\nanim = animation.FuncAnimation(fig, animate_func, init_func=_init_anim,\r\n                                frames=1, blit=True)\r\n```\r\n~~This is nowhere near self-contained, but it will probably take me some time to make a self-contained example. In the meantime I wanted to post this issue in case it was clear from the traceback and `git bisect` what the problem is.~~\r\n\r\n\r\n### Actual outcome\r\n\r\n```\r\n  File \"/home/larsoner/Desktop/rep.py\", line 18, in <module>\r\n    anim = animation.FuncAnimation(fig, animate_func, init_func=_init_anim,\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/animation.py\", line 1648, in __init__\r\n    super().__init__(fig, **kwargs)\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/animation.py\", line 1398, in __init__\r\n    super().__init__(fig, event_source=event_source, *args, **kwargs)\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/animation.py\", line 879, in __init__\r\n    self._setup_blit()\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/animation.py\", line 1191, in _setup_blit\r\n    self._post_draw(None, self._blit)\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/animation.py\", line 1146, in _post_draw\r\n    self._fig.canvas.draw_idle()\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/backend_bases.py\", line 1982, in draw_idle\r\n    self.draw(*args, **kwargs)\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/backends/backend_agg.py\", line 409, in draw\r\n    self.figure.draw(self.renderer)\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/artist.py\", line 73, in draw_wrapper\r\n    result = draw(artist, renderer, *args, **kwargs)\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/artist.py\", line 50, in draw_wrapper\r\n    return draw(artist, renderer)\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/figure.py\", line 2901, in draw\r\n    self.canvas.draw_event(renderer)\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/backend_bases.py\", line 1700, in draw_event\r\n    self.callbacks.process(s, event)\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/cbook/__init__.py\", line 301, in process\r\n    self.exception_handler(exc)\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/cbook/__init__.py\", line 84, in _exception_printer\r\n    raise exc\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/cbook/__init__.py\", line 296, in process\r\n    func(*args, **kwargs)\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/animation.py\", line 903, in _start\r\n    self._init_draw()\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/animation.py\", line 1712, in _init_draw\r\n    self._drawn_artists = self._init_func()\r\n  File \"/home/larsoner/Desktop/rep.py\", line 13, in _init_anim\r\n    fig.tight_layout()\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/figure.py\", line 3270, in tight_layout\r\n    engine.execute(self)\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/layout_engine.py\", line 159, in execute\r\n    kwargs = get_tight_layout_figure(\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/_tight_layout.py\", line 316, in get_tight_layout_figure\r\n    kwargs = _auto_adjust_subplotpars(fig, renderer,\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/_tight_layout.py\", line 81, in _auto_adjust_subplotpars\r\n    bb += [martist._get_tightbbox_for_layout_only(ax, renderer)]\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/artist.py\", line 1363, in _get_tightbbox_for_layout_only\r\n    return obj.get_tightbbox(*args, **{**kwargs, \"for_layout_only\": True})\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/axes/_base.py\", line 4516, in get_tightbbox\r\n    bbox = a.get_tightbbox(renderer)\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/artist.py\", line 344, in get_tightbbox\r\n    bbox = Bbox.intersection(bbox, clip_path.get_extents())\r\n  File \"/home/larsoner/python/matplotlib/lib/matplotlib/transforms.py\", line 663, in intersection\r\n    x0 = np.maximum(bbox1.xmin, bbox2.xmin)\r\nAttributeError: 'NoneType' object has no attribute 'xmin'\r\n```\r\n\r\n### Expected outcome\r\n\r\nNo error\r\n\r\n### Additional information\r\n\r\n_No response_\r\n\r\n### Operating system\r\n\r\nUbuntu 22.04\r\n\r\n### Matplotlib Version\r\n\r\n396a010a6147e232d7ab101db9e4b5c6a48d0b36\r\n\r\n### Matplotlib Backend\r\n\r\nQtAgg (PyQt6)\r\n\r\n### Python version\r\n\r\n3.10.4\r\n\r\n### Jupyter version\r\n\r\n_No response_\r\n\r\n### Installation\r\n\r\ngit checkout\n",
  "hints_text": "Okay the minimal example wasn't so bad, updated top comment.\nArgh actually on main `git revert f93a0fc251f7aa0a8da71f92e97e54faa25b8cd7` (f93a0fc251f7aa0a8da71f92e97e54faa25b8cd7) seems to fix it, not `git revert 396a010`. Apparently I am bad at `git bisect`. So maybe it's actually #22476?\nI can confirm it started failing in f93a0fc251f7aa0a8da71f92e97e54faa25b8cd7.\nI think this ultimately stems from removing `offsetsNone` back in https://github.com/matplotlib/matplotlib/pull/20717\r\nWe need some way of tracking that the (0, 0) case was actually passed in and desired, or if that is just the default (0, 0) from initialization. Seems like adding that flag (maybe renaming it too) is the quick fix?\r\n\r\n```diff --git a/lib/matplotlib/collections.py b/lib/matplotlib/collections.py\r\nindex 49485bd900..0a62cd49e4 100644\r\n--- a/lib/matplotlib/collections.py\r\n+++ b/lib/matplotlib/collections.py\r\n@@ -195,8 +195,9 @@ class Collection(artist.Artist, cm.ScalarMappable):\r\n \r\n         # default to zeros\r\n         self._offsets = np.zeros((1, 2))\r\n+        self._has_offsets = offsets is not None\r\n \r\n-        if offsets is not None:\r\n+        if self._has_offsets:\r\n             offsets = np.asanyarray(offsets, float)\r\n             # Broadcast (2,) -> (1, 2) but nothing else.\r\n             if offsets.shape == (2,):\r\n@@ -290,18 +291,19 @@ class Collection(artist.Artist, cm.ScalarMappable):\r\n                     offset_trf.transform_non_affine(offsets),\r\n                     offset_trf.get_affine().frozen())\r\n \r\n-            # this is for collections that have their paths (shapes)\r\n-            # in physical, axes-relative, or figure-relative units\r\n-            # (i.e. like scatter). We can't uniquely set limits based on\r\n-            # those shapes, so we just set the limits based on their\r\n-            # location.\r\n-            offsets = (offset_trf - transData).transform(offsets)\r\n-            # note A-B means A B^{-1}\r\n-            offsets = np.ma.masked_invalid(offsets)\r\n-            if not offsets.mask.all():\r\n-                bbox = transforms.Bbox.null()\r\n-                bbox.update_from_data_xy(offsets)\r\n-                return bbox\r\n+            if self._has_offsets:\r\n+                # this is for collections that have their paths (shapes)\r\n+                # in physical, axes-relative, or figure-relative units\r\n+                # (i.e. like scatter). We can't uniquely set limits based on\r\n+                # those shapes, so we just set the limits based on their\r\n+                # location.\r\n+                offsets = (offset_trf - transData).transform(offsets)\r\n+                # note A-B means A B^{-1}\r\n+                offsets = np.ma.masked_invalid(offsets)\r\n+                if not offsets.mask.all():\r\n+                    bbox = transforms.Bbox.null()\r\n+                    bbox.update_from_data_xy(offsets)\r\n+                    return bbox\r\n         return transforms.Bbox.null()\r\n \r\n     def get_window_extent(self, renderer):\r\n```",
  "created_at": "2022-04-30T03:59:59Z",
  "version": "3.5",
  "FAIL_TO_PASS": "[\"lib/matplotlib/tests/test_collections.py::test_no_offsets_datalim\"]",
  "PASS_TO_PASS": "[\"lib/matplotlib/tests/test_collections.py::test__EventCollection__get_props[png]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__get_props[pdf]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__set_positions[png]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__set_positions[pdf]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__add_positions[png]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__add_positions[pdf]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__append_positions[png]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__append_positions[pdf]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__extend_positions[png]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__extend_positions[pdf]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__switch_orientation[png]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__switch_orientation[pdf]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__switch_orientation_2x[png]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__switch_orientation_2x[pdf]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__set_orientation[png]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__set_orientation[pdf]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__set_linelength[png]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__set_linelength[pdf]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__set_lineoffset[png]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__set_lineoffset[pdf]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__set_prop[png]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__set_prop[pdf]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__set_color[png]\", \"lib/matplotlib/tests/test_collections.py::test__EventCollection__set_color[pdf]\", \"lib/matplotlib/tests/test_collections.py::test_null_collection_datalim\", \"lib/matplotlib/tests/test_collections.py::test_add_collection\", \"lib/matplotlib/tests/test_collections.py::test_collection_log_datalim[png]\", \"lib/matplotlib/tests/test_collections.py::test_quiver_limits\", \"lib/matplotlib/tests/test_collections.py::test_barb_limits\", \"lib/matplotlib/tests/test_collections.py::test_EllipseCollection[png]\", \"lib/matplotlib/tests/test_collections.py::test_polycollection_close[png]\", \"lib/matplotlib/tests/test_collections.py::test_regularpolycollection_rotate[png]\", \"lib/matplotlib/tests/test_collections.py::test_regularpolycollection_scale[png]\", \"lib/matplotlib/tests/test_collections.py::test_picking\", \"lib/matplotlib/tests/test_collections.py::test_linestyle_single_dashes\", \"lib/matplotlib/tests/test_collections.py::test_size_in_xy[png]\", \"lib/matplotlib/tests/test_collections.py::test_pandas_indexing\", \"lib/matplotlib/tests/test_collections.py::test_lslw_bcast\", \"lib/matplotlib/tests/test_collections.py::test_capstyle\", \"lib/matplotlib/tests/test_collections.py::test_joinstyle\", \"lib/matplotlib/tests/test_collections.py::test_cap_and_joinstyle_image[png]\", \"lib/matplotlib/tests/test_collections.py::test_scatter_post_alpha[png]\", \"lib/matplotlib/tests/test_collections.py::test_scatter_alpha_array\", \"lib/matplotlib/tests/test_collections.py::test_pathcollection_legend_elements\", \"lib/matplotlib/tests/test_collections.py::test_EventCollection_nosort\", \"lib/matplotlib/tests/test_collections.py::test_collection_set_verts_array\", \"lib/matplotlib/tests/test_collections.py::test_collection_set_array\", \"lib/matplotlib/tests/test_collections.py::test_blended_collection_autolim\", \"lib/matplotlib/tests/test_collections.py::test_singleton_autolim\", \"lib/matplotlib/tests/test_collections.py::test_autolim_with_zeros[transData-expected0]\", \"lib/matplotlib/tests/test_collections.py::test_autolim_with_zeros[transAxes-expected1]\", \"lib/matplotlib/tests/test_collections.py::test_quadmesh_deprecated_signature[png-True-kwargs0]\", \"lib/matplotlib/tests/test_collections.py::test_quadmesh_deprecated_signature[png-False-kwargs1]\", \"lib/matplotlib/tests/test_collections.py::test_quadmesh_deprecated_signature[png-True-kwargs2]\", \"lib/matplotlib/tests/test_collections.py::test_quadmesh_deprecated_signature[png-False-kwargs3]\", \"lib/matplotlib/tests/test_collections.py::test_quadmesh_deprecated_positional[png]\", \"lib/matplotlib/tests/test_collections.py::test_quadmesh_set_array_validation\", \"lib/matplotlib/tests/test_collections.py::test_quadmesh_get_coordinates\", \"lib/matplotlib/tests/test_collections.py::test_quadmesh_set_array\", \"lib/matplotlib/tests/test_collections.py::test_quadmesh_vmin_vmax\", \"lib/matplotlib/tests/test_collections.py::test_quadmesh_alpha_array\", \"lib/matplotlib/tests/test_collections.py::test_alpha_validation\", \"lib/matplotlib/tests/test_collections.py::test_legend_inverse_size_label_relationship\", \"lib/matplotlib/tests/test_collections.py::test_color_logic[pcolor]\", \"lib/matplotlib/tests/test_collections.py::test_color_logic[pcolormesh]\", \"lib/matplotlib/tests/test_collections.py::test_LineCollection_args\", \"lib/matplotlib/tests/test_collections.py::test_array_wrong_dimensions\", \"lib/matplotlib/tests/test_collections.py::test_get_segments\", \"lib/matplotlib/tests/test_collections.py::test_set_offsets_late\", \"lib/matplotlib/tests/test_collections.py::test_set_offset_transform\", \"lib/matplotlib/tests/test_collections.py::test_set_offset_units\"]",
  "environment_setup_commit": "de98877e3dc45de8dd441d008f23d88738dc015d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.797446",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}