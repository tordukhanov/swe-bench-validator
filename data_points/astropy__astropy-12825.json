{
  "repo": "astropy/astropy",
  "instance_id": "astropy__astropy-12825",
  "base_commit": "43ee5806e9c6f7d58c12c1cb9287b3c61abe489d",
  "patch": "diff --git a/astropy/table/column.py b/astropy/table/column.py\n--- a/astropy/table/column.py\n+++ b/astropy/table/column.py\n@@ -340,7 +340,9 @@ class ColumnInfo(BaseColumnInfo):\n     This is required when the object is used as a mixin column within a table,\n     but can be used as a general way to store meta information.\n     \"\"\"\n-    attrs_from_parent = BaseColumnInfo.attr_names\n+    attr_names = BaseColumnInfo.attr_names | {'groups'}\n+    _attrs_no_copy = BaseColumnInfo._attrs_no_copy | {'groups'}\n+    attrs_from_parent = attr_names\n     _supports_indexing = True\n \n     def new_like(self, cols, length, metadata_conflicts='warn', name=None):\ndiff --git a/astropy/table/groups.py b/astropy/table/groups.py\n--- a/astropy/table/groups.py\n+++ b/astropy/table/groups.py\n@@ -214,7 +214,7 @@ def __len__(self):\n class ColumnGroups(BaseGroups):\n     def __init__(self, parent_column, indices=None, keys=None):\n         self.parent_column = parent_column  # parent Column\n-        self.parent_table = parent_column.parent_table\n+        self.parent_table = parent_column.info.parent_table\n         self._indices = indices\n         self._keys = keys\n \n@@ -238,7 +238,8 @@ def keys(self):\n             return self._keys\n \n     def aggregate(self, func):\n-        from .column import MaskedColumn\n+        from .column import MaskedColumn, Column\n+        from astropy.utils.compat import NUMPY_LT_1_20\n \n         i0s, i1s = self.indices[:-1], self.indices[1:]\n         par_col = self.parent_column\n@@ -248,6 +249,15 @@ def aggregate(self, func):\n         mean_case = func is np.mean\n         try:\n             if not masked and (reduceat or sum_case or mean_case):\n+                # For numpy < 1.20 there is a bug where reduceat will fail to\n+                # raise an exception for mixin columns that do not support the\n+                # operation. For details see:\n+                # https://github.com/astropy/astropy/pull/12825#issuecomment-1082412447\n+                # Instead we try the function directly with a 2-element version\n+                # of the column\n+                if NUMPY_LT_1_20 and not isinstance(par_col, Column) and len(par_col) > 0:\n+                    func(par_col[[0, 0]])\n+\n                 if mean_case:\n                     vals = np.add.reduceat(par_col, i0s) / np.diff(self.indices)\n                 else:\n@@ -256,17 +266,18 @@ def aggregate(self, func):\n                     vals = func.reduceat(par_col, i0s)\n             else:\n                 vals = np.array([func(par_col[i0: i1]) for i0, i1 in zip(i0s, i1s)])\n+            out = par_col.__class__(vals)\n         except Exception as err:\n-            raise TypeError(\"Cannot aggregate column '{}' with type '{}'\"\n-                            .format(par_col.info.name,\n-                                    par_col.info.dtype)) from err\n-\n-        out = par_col.__class__(data=vals,\n-                                name=par_col.info.name,\n-                                description=par_col.info.description,\n-                                unit=par_col.info.unit,\n-                                format=par_col.info.format,\n-                                meta=par_col.info.meta)\n+            raise TypeError(\"Cannot aggregate column '{}' with type '{}': {}\"\n+                            .format(par_col.info.name, par_col.info.dtype, err)) from err\n+\n+        out_info = out.info\n+        for attr in ('name', 'unit', 'format', 'description', 'meta'):\n+            try:\n+                setattr(out_info, attr, getattr(par_col.info, attr))\n+            except AttributeError:\n+                pass\n+\n         return out\n \n     def filter(self, func):\n@@ -354,7 +365,7 @@ def aggregate(self, func):\n                 new_col = col.take(i0s)\n             else:\n                 try:\n-                    new_col = col.groups.aggregate(func)\n+                    new_col = col.info.groups.aggregate(func)\n                 except TypeError as err:\n                     warnings.warn(str(err), AstropyUserWarning)\n                     continue\ndiff --git a/astropy/utils/data_info.py b/astropy/utils/data_info.py\n--- a/astropy/utils/data_info.py\n+++ b/astropy/utils/data_info.py\n@@ -511,7 +511,7 @@ class BaseColumnInfo(DataInfo):\n     Note that this class is defined here so that mixins can use it\n     without importing the table package.\n     \"\"\"\n-    attr_names = DataInfo.attr_names.union(['parent_table', 'indices'])\n+    attr_names = DataInfo.attr_names | {'parent_table', 'indices'}\n     _attrs_no_copy = set(['parent_table', 'indices'])\n \n     # Context for serialization.  This can be set temporarily via\n@@ -752,6 +752,15 @@ def name(self, name):\n \n         self._attrs['name'] = name\n \n+    @property\n+    def groups(self):\n+        # This implementation for mixin columns essentially matches the Column\n+        # property definition.  `groups` is a read-only property here and\n+        # depends on the parent table of the column having `groups`. This will\n+        # allow aggregating mixins as long as they support those operations.\n+        from astropy.table import groups\n+        return self._attrs.setdefault('groups', groups.ColumnGroups(self._parent))\n+\n \n class ParentDtypeInfo(MixinInfo):\n     \"\"\"Mixin that gets info.dtype from parent\"\"\"\n",
  "test_patch": "diff --git a/astropy/table/tests/conftest.py b/astropy/table/tests/conftest.py\n--- a/astropy/table/tests/conftest.py\n+++ b/astropy/table/tests/conftest.py\n@@ -178,16 +178,17 @@ def mixin_cols(request):\n \n @pytest.fixture(params=[False, True])\n def T1(request):\n-    T = Table.read([' a b c d',\n-                    ' 2 c 7.0 0',\n-                    ' 2 b 5.0 1',\n-                    ' 2 b 6.0 2',\n-                    ' 2 a 4.0 3',\n-                    ' 0 a 0.0 4',\n-                    ' 1 b 3.0 5',\n-                    ' 1 a 2.0 6',\n-                    ' 1 a 1.0 7',\n-                    ], format='ascii')\n+    T = QTable.read([' a b c d',\n+                     ' 2 c 7.0 0',\n+                     ' 2 b 5.0 1',\n+                     ' 2 b 6.0 2',\n+                     ' 2 a 4.0 3',\n+                     ' 0 a 0.0 4',\n+                     ' 1 b 3.0 5',\n+                     ' 1 a 2.0 6',\n+                     ' 1 a 1.0 7',\n+                     ], format='ascii')\n+    T['q'] = np.arange(len(T)) * u.m\n     T.meta.update({'ta': 1})\n     T['c'].meta.update({'a': 1})\n     T['c'].description = 'column c'\ndiff --git a/astropy/table/tests/test_groups.py b/astropy/table/tests/test_groups.py\n--- a/astropy/table/tests/test_groups.py\n+++ b/astropy/table/tests/test_groups.py\n@@ -17,7 +17,7 @@ def sort_eq(list1, list2):\n \n def test_column_group_by(T1):\n     for masked in (False, True):\n-        t1 = Table(T1, masked=masked)\n+        t1 = QTable(T1, masked=masked)\n         t1a = t1['a'].copy()\n \n         # Group by a Column (i.e. numpy array)\n@@ -39,7 +39,7 @@ def test_table_group_by(T1):\n     masked/unmasked tables.\n     \"\"\"\n     for masked in (False, True):\n-        t1 = Table(T1, masked=masked)\n+        t1 = QTable(T1, masked=masked)\n         # Group by a single column key specified by name\n         tg = t1.group_by('a')\n         assert np.all(tg.groups.indices == np.array([0, 1, 4, 8]))\n@@ -47,16 +47,17 @@ def test_table_group_by(T1):\n         assert str(tg['a'].groups) == \"<ColumnGroups indices=[0 1 4 8]>\"\n \n         # Sorted by 'a' and in original order for rest\n-        assert tg.pformat() == [' a   b   c   d ',\n-                                '--- --- --- ---',\n-                                '  0   a 0.0   4',\n-                                '  1   b 3.0   5',\n-                                '  1   a 2.0   6',\n-                                '  1   a 1.0   7',\n-                                '  2   c 7.0   0',\n-                                '  2   b 5.0   1',\n-                                '  2   b 6.0   2',\n-                                '  2   a 4.0   3']\n+        assert tg.pformat() == [' a   b   c   d   q ',\n+                                '                 m ',\n+                                '--- --- --- --- ---',\n+                                '  0   a 0.0   4 4.0',\n+                                '  1   b 3.0   5 5.0',\n+                                '  1   a 2.0   6 6.0',\n+                                '  1   a 1.0   7 7.0',\n+                                '  2   c 7.0   0 0.0',\n+                                '  2   b 5.0   1 1.0',\n+                                '  2   b 6.0   2 2.0',\n+                                '  2   a 4.0   3 3.0']\n         assert tg.meta['ta'] == 1\n         assert tg['c'].meta['a'] == 1\n         assert tg['c'].description == 'column c'\n@@ -70,16 +71,17 @@ def test_table_group_by(T1):\n             tg = t1.group_by(keys)\n             assert np.all(tg.groups.indices == np.array([0, 1, 3, 4, 5, 7, 8]))\n             # Sorted by 'a', 'b' and in original order for rest\n-            assert tg.pformat() == [' a   b   c   d ',\n-                                    '--- --- --- ---',\n-                                    '  0   a 0.0   4',\n-                                    '  1   a 2.0   6',\n-                                    '  1   a 1.0   7',\n-                                    '  1   b 3.0   5',\n-                                    '  2   a 4.0   3',\n-                                    '  2   b 5.0   1',\n-                                    '  2   b 6.0   2',\n-                                    '  2   c 7.0   0']\n+            assert tg.pformat() == [' a   b   c   d   q ',\n+                                    '                 m ',\n+                                    '--- --- --- --- ---',\n+                                    '  0   a 0.0   4 4.0',\n+                                    '  1   a 2.0   6 6.0',\n+                                    '  1   a 1.0   7 7.0',\n+                                    '  1   b 3.0   5 5.0',\n+                                    '  2   a 4.0   3 3.0',\n+                                    '  2   b 5.0   1 1.0',\n+                                    '  2   b 6.0   2 2.0',\n+                                    '  2   c 7.0   0 0.0']\n \n         # Group by a Table\n         tg2 = t1.group_by(t1['a', 'b'])\n@@ -92,16 +94,17 @@ def test_table_group_by(T1):\n         # Group by a simple ndarray\n         tg = t1.group_by(np.array([0, 1, 0, 1, 2, 1, 0, 0]))\n         assert np.all(tg.groups.indices == np.array([0, 4, 7, 8]))\n-        assert tg.pformat() == [' a   b   c   d ',\n-                                '--- --- --- ---',\n-                                '  2   c 7.0   0',\n-                                '  2   b 6.0   2',\n-                                '  1   a 2.0   6',\n-                                '  1   a 1.0   7',\n-                                '  2   b 5.0   1',\n-                                '  2   a 4.0   3',\n-                                '  1   b 3.0   5',\n-                                '  0   a 0.0   4']\n+        assert tg.pformat() == [' a   b   c   d   q ',\n+                                '                 m ',\n+                                '--- --- --- --- ---',\n+                                '  2   c 7.0   0 0.0',\n+                                '  2   b 6.0   2 2.0',\n+                                '  1   a 2.0   6 6.0',\n+                                '  1   a 1.0   7 7.0',\n+                                '  2   b 5.0   1 1.0',\n+                                '  2   a 4.0   3 3.0',\n+                                '  1   b 3.0   5 5.0',\n+                                '  0   a 0.0   4 4.0']\n \n \n def test_groups_keys(T1):\n@@ -134,7 +137,7 @@ def test_grouped_copy(T1):\n     Test that copying a table or column copies the groups properly\n     \"\"\"\n     for masked in (False, True):\n-        t1 = Table(T1, masked=masked)\n+        t1 = QTable(T1, masked=masked)\n         tg = t1.group_by('a')\n         tgc = tg.copy()\n         assert np.all(tgc.groups.indices == tg.groups.indices)\n@@ -155,7 +158,7 @@ def test_grouped_slicing(T1):\n     \"\"\"\n \n     for masked in (False, True):\n-        t1 = Table(T1, masked=masked)\n+        t1 = QTable(T1, masked=masked)\n \n         # Regular slice of a table\n         tg = t1.group_by('a')\n@@ -266,11 +269,11 @@ def test_mutable_operations(T1):\n     but adding or removing or renaming a column should retain grouping.\n     \"\"\"\n     for masked in (False, True):\n-        t1 = Table(T1, masked=masked)\n+        t1 = QTable(T1, masked=masked)\n \n         # add row\n         tg = t1.group_by('a')\n-        tg.add_row((0, 'a', 3.0, 4))\n+        tg.add_row((0, 'a', 3.0, 4, 4 * u.m))\n         assert np.all(tg.groups.indices == np.array([0, len(tg)]))\n         assert tg.groups.keys is None\n \n@@ -312,19 +315,20 @@ def test_mutable_operations(T1):\n \n \n def test_group_by_masked(T1):\n-    t1m = Table(T1, masked=True)\n+    t1m = QTable(T1, masked=True)\n     t1m['c'].mask[4] = True\n     t1m['d'].mask[5] = True\n-    assert t1m.group_by('a').pformat() == [' a   b   c   d ',\n-                                           '--- --- --- ---',\n-                                           '  0   a  --   4',\n-                                           '  1   b 3.0  --',\n-                                           '  1   a 2.0   6',\n-                                           '  1   a 1.0   7',\n-                                           '  2   c 7.0   0',\n-                                           '  2   b 5.0   1',\n-                                           '  2   b 6.0   2',\n-                                           '  2   a 4.0   3']\n+    assert t1m.group_by('a').pformat() == [' a   b   c   d   q ',\n+                                           '                 m ',\n+                                           '--- --- --- --- ---',\n+                                           '  0   a  --   4 4.0',\n+                                           '  1   b 3.0  -- 5.0',\n+                                           '  1   a 2.0   6 6.0',\n+                                           '  1   a 1.0   7 7.0',\n+                                           '  2   c 7.0   0 0.0',\n+                                           '  2   b 5.0   1 1.0',\n+                                           '  2   b 6.0   2 2.0',\n+                                           '  2   a 4.0   3 3.0']\n \n \n def test_group_by_errors(T1):\n@@ -348,7 +352,7 @@ def test_group_by_errors(T1):\n         T1.group_by(None)\n \n     # Masked key column\n-    t1 = Table(T1, masked=True)\n+    t1 = QTable(T1, masked=True)\n     t1['a'].mask[4] = True\n     with pytest.raises(ValueError):\n         t1.group_by('a')\n@@ -408,23 +412,24 @@ def test_table_aggregate(T1):\n     # Aggregate with np.sum with masked elements.  This results\n     # in one group with no elements, hence a nan result and conversion\n     # to float for the 'd' column.\n-    t1m = Table(t1, masked=True)\n+    t1m = QTable(T1, masked=True)\n     t1m['c'].mask[4:6] = True\n     t1m['d'].mask[4:6] = True\n     tg = t1m.group_by('a')\n     with pytest.warns(UserWarning, match=\"converting a masked element to nan\"):\n         tga = tg.groups.aggregate(np.sum)\n \n-    assert tga.pformat() == [' a   c    d  ',\n-                             '--- ---- ----',\n-                             '  0  nan  nan',\n-                             '  1  3.0 13.0',\n-                             '  2 22.0  6.0']\n+    assert tga.pformat() == [' a   c    d    q  ',\n+                             '               m  ',\n+                             '--- ---- ---- ----',\n+                             '  0  nan  nan  4.0',\n+                             '  1  3.0 13.0 18.0',\n+                             '  2 22.0  6.0  6.0']\n \n     # Aggregrate with np.sum with masked elements, but where every\n     # group has at least one remaining (unmasked) element.  Then\n     # the int column stays as an int.\n-    t1m = Table(t1, masked=True)\n+    t1m = QTable(t1, masked=True)\n     t1m['c'].mask[5] = True\n     t1m['d'].mask[5] = True\n     tg = t1m.group_by('a')\n@@ -440,11 +445,12 @@ def test_table_aggregate(T1):\n     tg = T1.group_by('a')\n     with pytest.warns(AstropyUserWarning, match=\"Cannot aggregate column\"):\n         tga = tg.groups.aggregate(np.sum)\n-    assert tga.pformat() == [' a   c    d ',\n-                             '--- ---- ---',\n-                             '  0  0.0   4',\n-                             '  1  6.0  18',\n-                             '  2 22.0   6']\n+    assert tga.pformat() == [' a   c    d   q  ',\n+                             '              m  ',\n+                             '--- ---- --- ----',\n+                             '  0  0.0   4  4.0',\n+                             '  1  6.0  18 18.0',\n+                             '  2 22.0   6  6.0']\n \n \n def test_table_aggregate_reduceat(T1):\n@@ -504,7 +510,7 @@ def test_column_aggregate(T1):\n     Aggregate a single table column\n     \"\"\"\n     for masked in (False, True):\n-        tg = Table(T1, masked=masked).group_by('a')\n+        tg = QTable(T1, masked=masked).group_by('a')\n         tga = tg['c'].groups.aggregate(np.sum)\n         assert tga.pformat() == [' c  ',\n                                  '----',\n@@ -635,3 +641,16 @@ def test_group_mixins():\n     # Column group_by() with mixins\n     idxg = qt['idx'].group_by(qt[mixin_keys])\n     assert np.all(idxg == [1, 3, 2, 0])\n+\n+\n+@pytest.mark.parametrize(\n+    'col', [time.TimeDelta([1, 2], format='sec'),\n+            time.Time([1, 2], format='cxcsec'),\n+            coordinates.SkyCoord([1, 2], [3, 4], unit='deg,deg')])\n+def test_group_mixins_unsupported(col):\n+    \"\"\"Test that aggregating unsupported mixins produces a warning only\"\"\"\n+\n+    t = Table([[1, 1], [3, 4], col], names=['a', 'b', 'mix'])\n+    tg = t.group_by('a')\n+    with pytest.warns(AstropyUserWarning, match=\"Cannot aggregate column 'mix'\"):\n+        tg.groups.aggregate(np.sum)\n",
  "problem_statement": "SkyCoord in Table breaks aggregate on group_by\n### Description, actual behaviour, reproduction\r\nWhen putting a column of `SkyCoord`s in a `Table`, `aggregate` does not work on `group_by().groups`:\r\n\r\n```python\r\nfrom astropy.table import Table\r\nimport astropy.units as u\r\nfrom astropy.coordinates import SkyCoord\r\nimport numpy as np\r\n\r\nras = [10, 20] * u.deg\r\ndecs = [32, -2] * u.deg\r\n\r\nstr_col = ['foo', 'bar']\r\ncoords = SkyCoord(ra=ras, dec=decs)\r\n\r\ntable = Table([str_col, coords], names=['col1', 'col2'])\r\ntable.group_by('col1').groups.aggregate(np.mean)\r\n```\r\n\r\n fails with \r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"repro.py\", line 13, in <module>\r\n    table.group_by('col1').groups.aggregate(np.mean)\r\n  File \"astropy/table/groups.py\", line 357, in aggregate\r\n    new_col = col.groups.aggregate(func)\r\n  File \"astropy/coordinates/sky_coordinate.py\", line 835, in __getattr__\r\n    raise AttributeError(\"'{}' object has no attribute '{}'\"\r\nAttributeError: 'SkyCoord' object has no attribute 'groups'\r\n```\r\nThis happens irregardless of the aggregation function.\r\n\r\n### Expected behavior\r\nAggregation works, only fails to aggregate columns where operation does not make sense.\r\n\r\n\r\n### System Details\r\n```\r\nLinux-5.14.11-arch1-1-x86_64-with-glibc2.33\r\nPython 3.9.7 (default, Aug 31 2021, 13:28:12) \r\n[GCC 11.1.0]\r\nNumpy 1.21.2\r\nastropy 5.0.dev945+g7dfa1edb2\r\n(no scipy or matplotlib)\r\n```\r\nand\r\n```\r\nLinux-5.14.11-arch1-1-x86_64-with-glibc2.33\r\nPython 3.9.7 (default, Aug 31 2021, 13:28:12) \r\n[GCC 11.1.0]\r\nNumpy 1.21.2\r\nastropy 4.3.1\r\nScipy 1.7.1\r\nMatplotlib 3.4.3\r\n```\r\n\r\n\n",
  "hints_text": "Hmm. Maybe the logic here needs fixing:\r\n\r\nhttps://github.com/astropy/astropy/blob/bcde23429a076859af856d941282f3df917b8dd4/astropy/table/groups.py#L351-L360\nMostly finished with a fix for this which makes it possible to aggregate tables that have mixin columns. In cases where the aggregation makes sense (e.g. with Quantity) it will just work. In other cases a warning only.",
  "created_at": "2022-02-05T12:13:44Z",
  "version": "4.3",
  "FAIL_TO_PASS": "[\"astropy/table/tests/test_groups.py::test_table_aggregate[False]\", \"astropy/table/tests/test_groups.py::test_table_aggregate[True]\", \"astropy/table/tests/test_groups.py::test_group_mixins_unsupported[col0]\", \"astropy/table/tests/test_groups.py::test_group_mixins_unsupported[col1]\", \"astropy/table/tests/test_groups.py::test_group_mixins_unsupported[col2]\"]",
  "PASS_TO_PASS": "[\"astropy/table/tests/test_groups.py::test_column_group_by[False]\", \"astropy/table/tests/test_groups.py::test_column_group_by[True]\", \"astropy/table/tests/test_groups.py::test_table_group_by[False]\", \"astropy/table/tests/test_groups.py::test_groups_keys[False]\", \"astropy/table/tests/test_groups.py::test_groups_keys[True]\", \"astropy/table/tests/test_groups.py::test_groups_iterator[False]\", \"astropy/table/tests/test_groups.py::test_groups_iterator[True]\", \"astropy/table/tests/test_groups.py::test_grouped_copy[False]\", \"astropy/table/tests/test_groups.py::test_grouped_copy[True]\", \"astropy/table/tests/test_groups.py::test_grouped_slicing[False]\", \"astropy/table/tests/test_groups.py::test_grouped_slicing[True]\", \"astropy/table/tests/test_groups.py::test_group_column_from_table[False]\", \"astropy/table/tests/test_groups.py::test_group_column_from_table[True]\", \"astropy/table/tests/test_groups.py::test_table_groups_mask_index[False]\", \"astropy/table/tests/test_groups.py::test_table_groups_mask_index[True]\", \"astropy/table/tests/test_groups.py::test_table_groups_array_index[False]\", \"astropy/table/tests/test_groups.py::test_table_groups_array_index[True]\", \"astropy/table/tests/test_groups.py::test_table_groups_slicing[False]\", \"astropy/table/tests/test_groups.py::test_table_groups_slicing[True]\", \"astropy/table/tests/test_groups.py::test_grouped_item_access[False]\", \"astropy/table/tests/test_groups.py::test_grouped_item_access[True]\", \"astropy/table/tests/test_groups.py::test_mutable_operations[False]\", \"astropy/table/tests/test_groups.py::test_mutable_operations[True]\", \"astropy/table/tests/test_groups.py::test_group_by_masked[False]\", \"astropy/table/tests/test_groups.py::test_group_by_errors[False]\", \"astropy/table/tests/test_groups.py::test_group_by_errors[True]\", \"astropy/table/tests/test_groups.py::test_groups_keys_meta[False]\", \"astropy/table/tests/test_groups.py::test_groups_keys_meta[True]\", \"astropy/table/tests/test_groups.py::test_table_aggregate_reduceat[False]\", \"astropy/table/tests/test_groups.py::test_table_aggregate_reduceat[True]\", \"astropy/table/tests/test_groups.py::test_column_aggregate[False]\", \"astropy/table/tests/test_groups.py::test_column_aggregate[True]\", \"astropy/table/tests/test_groups.py::test_column_aggregate_f8\", \"astropy/table/tests/test_groups.py::test_table_filter\", \"astropy/table/tests/test_groups.py::test_column_filter\", \"astropy/table/tests/test_groups.py::test_group_mixins\"]",
  "environment_setup_commit": "298ccb478e6bf092953bca67a3d29dc6c35f6752",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.522342",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}