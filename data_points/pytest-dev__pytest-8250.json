{
  "repo": "pytest-dev/pytest",
  "instance_id": "pytest-dev__pytest-8250",
  "base_commit": "7f782c72ba157aaa26f74553ab328c898dab949c",
  "patch": "diff --git a/src/_pytest/faulthandler.py b/src/_pytest/faulthandler.py\n--- a/src/_pytest/faulthandler.py\n+++ b/src/_pytest/faulthandler.py\n@@ -69,7 +69,12 @@ def pytest_unconfigure(self, config: Config) -> None:\n     @staticmethod\n     def _get_stderr_fileno():\n         try:\n-            return sys.stderr.fileno()\n+            fileno = sys.stderr.fileno()\n+            # The Twisted Logger will return an invalid file descriptor since it is not backed\n+            # by an FD. So, let's also forward this to the same code path as with pytest-xdist.\n+            if fileno == -1:\n+                raise AttributeError()\n+            return fileno\n         except (AttributeError, io.UnsupportedOperation):\n             # pytest-xdist monkeypatches sys.stderr with an object that is not an actual file.\n             # https://docs.python.org/3/library/faulthandler.html#issue-with-file-descriptors\n",
  "test_patch": "diff --git a/testing/test_faulthandler.py b/testing/test_faulthandler.py\n--- a/testing/test_faulthandler.py\n+++ b/testing/test_faulthandler.py\n@@ -1,3 +1,4 @@\n+import io\n import sys\n \n import pytest\n@@ -135,3 +136,27 @@ def test():\n         result.stdout.no_fnmatch_line(warning_line)\n     result.stdout.fnmatch_lines(\"*1 passed*\")\n     assert result.ret == 0\n+\n+\n+def test_get_stderr_fileno_invalid_fd() -> None:\n+    \"\"\"Test for faulthandler being able to handle invalid file descriptors for stderr (#8249).\"\"\"\n+    from _pytest.faulthandler import FaultHandlerHooks\n+\n+    class StdErrWrapper(io.StringIO):\n+        \"\"\"\n+        Mimic ``twisted.logger.LoggingFile`` to simulate returning an invalid file descriptor.\n+\n+        https://github.com/twisted/twisted/blob/twisted-20.3.0/src/twisted/logger/_io.py#L132-L139\n+        \"\"\"\n+\n+        def fileno(self):\n+            return -1\n+\n+    wrapper = StdErrWrapper()\n+\n+    with pytest.MonkeyPatch.context() as mp:\n+        mp.setattr(\"sys.stderr\", wrapper)\n+\n+        # Even when the stderr wrapper signals an invalid file descriptor,\n+        # ``_get_stderr_fileno()`` should return the real one.\n+        assert FaultHandlerHooks._get_stderr_fileno() == 2\n",
  "problem_statement": "Problem with faulthandler when used with Twisted Logger and \"pytest --capture=no\"\nDear `pytest` developers,\r\n\r\nthanks a stack for conceiving and maintaining this excellent package. I never expected to file an issue or submit a patch here, but here we go.\r\n\r\n### Introduction\r\nOn behalf of https://github.com/daq-tools/kotori/pull/38, we are currently in the progress of finally upgrading [Kotori](https://getkotori.org/) to Python 3. Kotori is based on Twisted and uses `pytest` for testing. Within [`kotori.util.logger`](https://github.com/daq-tools/kotori/blob/master/kotori/util/logger.py), we tried hard to apply some magic to make everything work together on all occasions with respect to appropriately configuring `twisted.logger` to our needs.\r\n\r\n### Environment\r\nWe are on macOS 10.13.6.\r\n```\r\n$ pip list\r\npytest                        6.2.1\r\npytest-twisted                1.13.2\r\nTwisted                       20.3.0\r\n```\r\n\r\n### Details\r\nThe background on this is that the Twisted Logger intercepts the logging by providing a file-like wrapper around the `STDERR` stream, which is obviously not an actual stream. In this case, when running with `pytest capture=no`, `pytest`'s `faulthandler` fails when trying to restore the `stderr` stream through `sys.stderr.fileno()` at [1] as this will actually return `-1`, in turn signaling an invalid file descriptor [2].\r\n\r\nIt will a) raise the exception outlined below and b) won't stop the process on teardown.\r\n\r\n[1] https://github.com/pytest-dev/pytest/blob/6.2.1/src/_pytest/faulthandler.py#L69-L77\r\n[2] https://github.com/twisted/twisted/blob/twisted-20.3.0/src/twisted/logger/_io.py#L132-L139\r\n\r\n#### Traceback\r\n```\r\nTraceback (most recent call last):\r\n  File \"/path/to/.venv/bin/pytest\", line 8, in <module>\r\n    sys.exit(console_main())\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/_pytest/config/__init__.py\", line 185, in console_main\r\n    code = main()\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/_pytest/config/__init__.py\", line 162, in main\r\n    ret: Union[ExitCode, int] = config.hook.pytest_cmdline_main(\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/pluggy/hooks.py\", line 286, in __call__\r\n    return self._hookexec(self, self.get_hookimpls(), kwargs)\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/pluggy/manager.py\", line 93, in _hookexec\r\n    return self._inner_hookexec(hook, methods, kwargs)\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/pluggy/manager.py\", line 84, in <lambda>\r\n    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/pluggy/callers.py\", line 208, in _multicall\r\n    return outcome.get_result()\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/pluggy/callers.py\", line 80, in get_result\r\n    raise ex[1].with_traceback(ex[2])\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/pluggy/callers.py\", line 187, in _multicall\r\n    res = hook_impl.function(*args)\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/_pytest/main.py\", line 316, in pytest_cmdline_main\r\n    return wrap_session(config, _main)\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/_pytest/main.py\", line 311, in wrap_session\r\n    config._ensure_unconfigure()\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/_pytest/config/__init__.py\", line 987, in _ensure_unconfigure\r\n    self.hook.pytest_unconfigure(config=self)\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/pluggy/hooks.py\", line 286, in __call__\r\n    return self._hookexec(self, self.get_hookimpls(), kwargs)\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/pluggy/manager.py\", line 93, in _hookexec\r\n    return self._inner_hookexec(hook, methods, kwargs)\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/pluggy/manager.py\", line 84, in <lambda>\r\n    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/pluggy/callers.py\", line 208, in _multicall\r\n    return outcome.get_result()\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/pluggy/callers.py\", line 80, in get_result\r\n    raise ex[1].with_traceback(ex[2])\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/pluggy/callers.py\", line 187, in _multicall\r\n    res = hook_impl.function(*args)\r\n  File \"/path/to/.venv/lib/python3.8/site-packages/_pytest/faulthandler.py\", line 69, in pytest_unconfigure\r\n    faulthandler.enable(file=self._get_stderr_fileno())\r\nValueError: file is not a valid file descripter\r\n```\r\n\r\n### Patch\r\nThis problem is mitigated by #8250.\r\n\r\nWith kind regards,\r\nAndreas.\r\n\n",
  "hints_text": "",
  "created_at": "2021-01-17T19:08:35Z",
  "version": "6.3",
  "FAIL_TO_PASS": "[\"testing/test_faulthandler.py::test_get_stderr_fileno_invalid_fd\"]",
  "PASS_TO_PASS": "[\"testing/test_faulthandler.py::test_cancel_timeout_on_hook[pytest_enter_pdb]\", \"testing/test_faulthandler.py::test_cancel_timeout_on_hook[pytest_exception_interact]\", \"testing/test_faulthandler.py::test_already_initialized[0]\", \"testing/test_faulthandler.py::test_already_initialized[2]\", \"testing/test_faulthandler.py::test_enabled\", \"testing/test_faulthandler.py::test_crash_near_exit\", \"testing/test_faulthandler.py::test_disabled\", \"testing/test_faulthandler.py::test_timeout[False]\"]",
  "environment_setup_commit": "634312b14a45db8d60d72016e01294284e3a18d4",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.941754",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}