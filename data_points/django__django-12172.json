{
  "repo": "django/django",
  "instance_id": "django__django-12172",
  "base_commit": "b92d101bd868aa460d16d1196a798df7e5c1ea33",
  "patch": "diff --git a/django/utils/asyncio.py b/django/utils/asyncio.py\n--- a/django/utils/asyncio.py\n+++ b/django/utils/asyncio.py\n@@ -1,5 +1,6 @@\n import asyncio\n import functools\n+import os\n \n from django.core.exceptions import SynchronousOnlyOperation\n \n@@ -12,14 +13,15 @@ def async_unsafe(message):\n     def decorator(func):\n         @functools.wraps(func)\n         def inner(*args, **kwargs):\n-            # Detect a running event loop in this thread.\n-            try:\n-                event_loop = asyncio.get_event_loop()\n-            except RuntimeError:\n-                pass\n-            else:\n-                if event_loop.is_running():\n-                    raise SynchronousOnlyOperation(message)\n+            if not os.environ.get('DJANGO_ALLOW_ASYNC_UNSAFE'):\n+                # Detect a running event loop in this thread.\n+                try:\n+                    event_loop = asyncio.get_event_loop()\n+                except RuntimeError:\n+                    pass\n+                else:\n+                    if event_loop.is_running():\n+                        raise SynchronousOnlyOperation(message)\n             # Pass onwards.\n             return func(*args, **kwargs)\n         return inner\n",
  "test_patch": "diff --git a/tests/async/tests.py b/tests/async/tests.py\n--- a/tests/async/tests.py\n+++ b/tests/async/tests.py\n@@ -1,5 +1,6 @@\n+import os\n import sys\n-from unittest import skipIf\n+from unittest import mock, skipIf\n \n from asgiref.sync import async_to_sync\n \n@@ -39,3 +40,13 @@ async def test_async_unsafe(self):\n         )\n         with self.assertRaisesMessage(SynchronousOnlyOperation, msg):\n             self.dangerous_method()\n+\n+    @mock.patch.dict(os.environ, {'DJANGO_ALLOW_ASYNC_UNSAFE': 'true'})\n+    @async_to_sync\n+    async def test_async_unsafe_suppressed(self):\n+        # Decorator doesn't trigger check when the environment variable to\n+        # suppress it is set.\n+        try:\n+            self.dangerous_method()\n+        except SynchronousOnlyOperation:\n+            self.fail('SynchronousOnlyOperation should not be raised.')\n",
  "problem_statement": "Add ability to override \"async unsafe\" checks.\nDescription\n\t\nIt's been reported that Jupyter, at least, executes apparently-synchronous code in an async environment (​https://forum.djangoproject.com/t/is-there-a-way-to-disable-the-synchronousonlyoperation-check-when-using-the-orm-in-a-jupyter-notebook/548/3) and we're going to have people running headlong into this soon.\nThe \"right\" way of wrapping code in sync_to_async works, but is an undue burden on notebook authors as it would have to be in every cell, so it's suggested that we add a flag that disables the async-unsafe check. Either a setting or an environment variable could work; I slightly prefer an environment variable (as it's hard to forget about) provided this works well with Jupyter.\n",
  "hints_text": "Pull request: ​https://github.com/django/django/pull/12172",
  "created_at": "2019-12-02T20:04:10Z",
  "version": "3.1",
  "FAIL_TO_PASS": "[\"test_async_unsafe_suppressed (async.tests.AsyncUnsafeTest)\"]",
  "PASS_TO_PASS": "[\"test_async_unsafe (async.tests.AsyncUnsafeTest)\", \"test_get_async_connection (async.tests.DatabaseConnectionTest)\"]",
  "environment_setup_commit": "0668164b4ac93a5be79f5b87fae83c657124d9ab",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.616924",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}