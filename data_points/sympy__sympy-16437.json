{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-16437",
  "base_commit": "f499cbbc188d777be2998b01e48a3d8b64f1ea10",
  "patch": "diff --git a/sympy/core/numbers.py b/sympy/core/numbers.py\n--- a/sympy/core/numbers.py\n+++ b/sympy/core/numbers.py\n@@ -806,10 +806,10 @@ class Float(Number):\n     100.0\n \n     Float can automatically count significant figures if a null string\n-    is sent for the precision; space are also allowed in the string. (Auto-\n+    is sent for the precision; spaces or underscores are also allowed. (Auto-\n     counting is only allowed for strings, ints and longs).\n \n-    >>> Float('123 456 789 . 123 456', '')\n+    >>> Float('123 456 789.123_456', '')\n     123456789.123456\n     >>> Float('12e-3', '')\n     0.012\n@@ -943,7 +943,16 @@ def __new__(cls, num, dps=None, prec=None, precision=None):\n                              'Supply only one. ')\n \n         if isinstance(num, string_types):\n+            # Float already accepts spaces as digit separators; in Py 3.6\n+            # underscores are allowed. In anticipation of that, we ignore\n+            # legally placed underscores\n             num = num.replace(' ', '')\n+            if '_' in num:\n+                if num.startswith('_') or num.endswith('_') or any(\n+                        i in num for i in ('__', '_.', '._')):\n+                    # copy Py 3.6 error\n+                    raise ValueError(\"could not convert string to float: '%s'\" % num)\n+                num = num.replace('_', '')\n             if num.startswith('.') and len(num) > 1:\n                 num = '0' + num\n             elif num.startswith('-.') and len(num) > 2:\n",
  "test_patch": "diff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py\n--- a/sympy/core/tests/test_numbers.py\n+++ b/sympy/core/tests/test_numbers.py\n@@ -487,6 +487,16 @@ def teq(a):\n     Rational('123 456.123 456') == Rational('123456.123456')\n     assert Float(' .3e2') == Float('0.3e2')\n \n+    # allow underscore\n+    assert Float('1_23.4_56') == Float('123.456')\n+    assert Float('1_23.4_5_6', 12) == Float('123.456', 12)\n+    # ...but not in all cases (per Py 3.6)\n+    raises(ValueError, lambda: Float('_1'))\n+    raises(ValueError, lambda: Float('1_'))\n+    raises(ValueError, lambda: Float('1_.'))\n+    raises(ValueError, lambda: Float('1._'))\n+    raises(ValueError, lambda: Float('1__2'))\n+\n     # allow auto precision detection\n     assert Float('.1', '') == Float(.1, 1)\n     assert Float('.125', '') == Float(.125, 3)\n",
  "problem_statement": "Float from string with underscores misplaces decimal point\nThis is correct:\r\n````\r\nIn [52]: Float('1_234.345678', 24)\r\nOut[52]: 1234.34567800000000000000\r\n````\r\n\r\nNone of these are:\r\n````\r\nIn [53]: Float('1_234.345_678', 24)\r\nOut[53]: 123.434567800000000000000\r\n\r\nIn [54]: Float('1_234.34_5_678', 24)\r\nOut[54]: 12.3434567800000000000000\r\n\r\nIn [55]: Float('1_234.34_5_6_78', 24)\r\nOut[55]: 1.23434567800000000000000\r\n\r\nIn [56]: Float('1_234.34_5_6_7_8', 24)\r\nOut[56]: 0.123434567800000000000000\r\n````\r\n\r\nI think this is an upstream bug in mpmath: https://github.com/fredrik-johansson/mpmath/issues/377\r\n\n",
  "hints_text": "I am taking this up.",
  "created_at": "2019-03-25T17:16:45Z",
  "version": "1.5",
  "FAIL_TO_PASS": "[\"test_Float\"]",
  "PASS_TO_PASS": "[\"test_seterr\", \"test_mod\", \"test_divmod\", \"test_igcd\", \"test_igcd_lehmer\", \"test_igcd2\", \"test_ilcm\", \"test_igcdex\", \"test_Integer_new\", \"test_Rational_new\", \"test_Number_new\", \"test_Number_cmp\", \"test_Rational_cmp\", \"test_float_mpf\", \"test_Float_RealElement\", \"test_Float_default_to_highprec_from_str\", \"test_Float_eval\", \"test_Float_issue_2107\", \"test_issue_14289\", \"test_Float_from_tuple\", \"test_Infinity\", \"test_Infinity_2\", \"test_Mul_Infinity_Zero\", \"test_Div_By_Zero\", \"test_Infinity_inequations\", \"test_NaN\", \"test_special_numbers\", \"test_powers\", \"test_integer_nthroot_overflow\", \"test_integer_log\", \"test_isqrt\", \"test_powers_Integer\", \"test_powers_Rational\", \"test_powers_Float\", \"test_abs1\", \"test_accept_int\", \"test_dont_accept_str\", \"test_int\", \"test_long\", \"test_real_bug\", \"test_bug_sqrt\", \"test_pi_Pi\", \"test_no_len\", \"test_issue_3321\", \"test_issue_3692\", \"test_issue_3423\", \"test_issue_3449\", \"test_issue_13890\", \"test_Integer_factors\", \"test_Rational_factors\", \"test_issue_4107\", \"test_IntegerInteger\", \"test_Rational_gcd_lcm_cofactors\", \"test_Float_gcd_lcm_cofactors\", \"test_issue_4611\", \"test_conversion_to_mpmath\", \"test_relational\", \"test_Integer_as_index\", \"test_Rational_int\", \"test_zoo\", \"test_issue_4122\", \"test_GoldenRatio_expand\", \"test_TribonacciConstant_expand\", \"test_as_content_primitive\", \"test_hashing_sympy_integers\", \"test_issue_4172\", \"test_Catalan_EulerGamma_prec\", \"test_Float_eq\", \"test_int_NumberSymbols\", \"test_issue_6640\", \"test_issue_6349\", \"test_mpf_norm\", \"test_latex\", \"test_issue_7742\", \"test_simplify_AlgebraicNumber\", \"test_Float_idempotence\", \"test_comp\", \"test_issue_9491\", \"test_issue_10063\", \"test_issue_10020\", \"test_invert_numbers\", \"test_mod_inverse\", \"test_golden_ratio_rewrite_as_sqrt\", \"test_tribonacci_constant_rewrite_as_sqrt\", \"test_comparisons_with_unknown_type\", \"test_NumberSymbol_comparison\", \"test_Integer_precision\", \"test_Integer_ceiling_floor\", \"test_ComplexInfinity\", \"test_Infinity_floor_ceiling_power\", \"test_One_power\", \"test_NegativeInfinity\"]",
  "environment_setup_commit": "70381f282f2d9d039da860e391fe51649df2779d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.107427",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}