{
  "repo": "django/django",
  "instance_id": "django__django-13218",
  "base_commit": "3f2821af6bc48fa8e7970c1ce27bc54c3172545e",
  "patch": "diff --git a/django/db/migrations/loader.py b/django/db/migrations/loader.py\n--- a/django/db/migrations/loader.py\n+++ b/django/db/migrations/loader.py\n@@ -88,6 +88,11 @@ def load_disk(self):\n                     continue\n                 raise\n             else:\n+                # Empty directories are namespaces.\n+                # getattr() needed on PY36 and older (replace w/attribute access).\n+                if getattr(module, '__file__', None) is None:\n+                    self.unmigrated_apps.add(app_config.label)\n+                    continue\n                 # Module is not a package (e.g. migrations.py).\n                 if not hasattr(module, '__path__'):\n                     self.unmigrated_apps.add(app_config.label)\n@@ -95,14 +100,11 @@ def load_disk(self):\n                 # Force a reload if it's already loaded (tests need this)\n                 if was_loaded:\n                     reload(module)\n+            self.migrated_apps.add(app_config.label)\n             migration_names = {\n                 name for _, name, is_pkg in pkgutil.iter_modules(module.__path__)\n                 if not is_pkg and name[0] not in '_~'\n             }\n-            if migration_names or self.ignore_no_migrations:\n-                self.migrated_apps.add(app_config.label)\n-            else:\n-                self.unmigrated_apps.add(app_config.label)\n             # Load migrations\n             for migration_name in migration_names:\n                 migration_path = '%s.%s' % (module_name, migration_name)\n",
  "test_patch": "diff --git a/tests/migrations/test_loader.py b/tests/migrations/test_loader.py\n--- a/tests/migrations/test_loader.py\n+++ b/tests/migrations/test_loader.py\n@@ -506,12 +506,11 @@ def test_ignore_files(self):\n         MIGRATION_MODULES={'migrations': 'migrations.test_migrations_namespace_package'},\n     )\n     def test_loading_namespace_package(self):\n-        \"\"\"Migration directories without an __init__.py file are loaded.\"\"\"\n-        migration_loader = MigrationLoader(connection)\n-        self.assertEqual(\n-            migration_loader.graph.forwards_plan(('migrations', '0001_initial')),\n-            [('migrations', '0001_initial')],\n-        )\n+        \"\"\"Migration directories without an __init__.py file are ignored.\"\"\"\n+        loader = MigrationLoader(connection)\n+        loader.load_disk()\n+        migrations = [name for app, name in loader.disk_migrations if app == 'migrations']\n+        self.assertEqual(migrations, [])\n \n \n class PycLoaderTests(MigrationTestBase):\n",
  "problem_statement": "Allow migrations directories without __init__.py files\nDescription\n\t \n\t\t(last modified by Tim Graham)\n\t \nBackground: In python 3 a package with no __init__.py is implicitly a namespace package, so it has no __file__ attribute. \nThe migrate command currently checks for existence of a __file__ attribute on the migrations package. This check was introduced in #21015, because the __file__ attribute was used in migration file discovery. \nHowever, in #23406 migration file discovery was changed to use pkgutil.iter_modules (), instead of direct filesystem access. pkgutil. iter_modules() uses the package's __path__ list, which exists on implicit namespace packages.\nAs a result, the __file__ check is no longer needed, and in fact prevents migrate from working on namespace packages (implicit or otherwise). \nRelated work: #29091\n",
  "hints_text": "Proposed fix in ​https://github.com/django/django/pull/11141 (branch ​https://github.com/benjyw/django/tree/ticket_30300)/\nHi Benjy. Thanks for the report — and the test case in the PR! Unless something comes up in review, this seems reasonable to me. I'm going to call it a new feature, since this behaviour will never have worked I think. ... (implicit or otherwise) I don't quite follow the or otherwise there?\nWhat's the use case? When makemigrations generates the first migration, it adds an __init__.py file. There was some concern about encouraging namespace packages in ticket:23919#comment:102.\nThe \"or otherwise\" refers to namespace packages being either implicit (lacking an __init__.py) or explicit (an __init__.py containing an old-style namespace package incantation).\nRe the use case: It seems unnecessary to insist on an empty __init__.py just to preserve a (stale) check for __file__, when they are otherwise not required in Python 3. And #29091 implies that this should be allowed. Context is: We've just finished migrating our codebase to all-python 3, and nuked all our __init__py files. We are now upgrading to Django 2.1, and noticing the various places where they're still de-facto required by Django. This particular case seemed unnecessary and easy to fix.\nWe had a similar issue with test discovery. One of our developers read an article that __init__.py files are not required on Python3 and started removing them. Everything seemingly worked but some tests were not discovered and did not run in CI (which made it difficult to spot). I think Django should not required them if technically possible or at least it should be made clear in the documentation (sorry if I overlooked it).\nFriendly nudge?\n​PR\nIn 3cd3bebe: Fixed #30300 -- Allowed migrations to be loaded from directories without init.py file.\nI raised this issue ​on the mailing list as there was a thread that concluded that Django shouldn't promote use of implicit namespace packages.",
  "created_at": "2020-07-21T16:40:51Z",
  "version": "3.2",
  "FAIL_TO_PASS": "[\"Migration directories without an __init__.py file are ignored.\"]",
  "PASS_TO_PASS": "[\"test_apply (migrations.test_loader.RecorderTests)\", \"test_invalid (migrations.test_loader.PycLoaderTests)\", \"test_valid (migrations.test_loader.PycLoaderTests)\", \"test_check_consistent_history (migrations.test_loader.LoaderTests)\", \"test_check_consistent_history_squashed (migrations.test_loader.LoaderTests)\", \"test_explicit_missing_module (migrations.test_loader.LoaderTests)\", \"test_first (migrations.test_loader.LoaderTests)\", \"Files prefixed with underscore, tilde, or dot aren't loaded.\", \"test_load (migrations.test_loader.LoaderTests)\", \"test_load_empty_dir (migrations.test_loader.LoaderTests)\", \"test_load_import_error (migrations.test_loader.LoaderTests)\", \"test_load_module_file (migrations.test_loader.LoaderTests)\", \"test_load_unmigrated_dependency (migrations.test_loader.LoaderTests)\", \"Tests loading a squashed migration\", \"Tests loading a complex set of squashed migrations\", \"test_loading_squashed_complex_multi_apps (migrations.test_loader.LoaderTests)\", \"test_loading_squashed_complex_multi_apps_partially_applied (migrations.test_loader.LoaderTests)\", \"Tests loading a complex but erroneous set of squashed migrations\", \"Tests loading a squashed migration with a new migration referencing it\", \"test_marked_as_migrated (migrations.test_loader.LoaderTests)\", \"test_marked_as_unmigrated (migrations.test_loader.LoaderTests)\", \"Tests prefix name matching\", \"test_plan_handles_repeated_migrations (migrations.test_loader.LoaderTests)\", \"test_run_before (migrations.test_loader.LoaderTests)\"]",
  "environment_setup_commit": "65dfb06a1ab56c238cc80f5e1c31f61210c4577d",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.647458",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}