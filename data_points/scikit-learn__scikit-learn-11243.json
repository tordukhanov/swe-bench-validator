{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-11243",
  "base_commit": "c4146095e8bb2e49fcdfb36a655be645b73a72a6",
  "patch": "diff --git a/sklearn/preprocessing/data.py b/sklearn/preprocessing/data.py\n--- a/sklearn/preprocessing/data.py\n+++ b/sklearn/preprocessing/data.py\n@@ -455,7 +455,7 @@ def minmax_scale(X, feature_range=(0, 1), axis=0, copy=True):\n     # Unlike the scaler object, this function allows 1d input.\n     # If copy is required, it will be done inside the scaler object.\n     X = check_array(X, copy=False, ensure_2d=False, warn_on_dtype=True,\n-                    dtype=FLOAT_DTYPES)\n+                    dtype=FLOAT_DTYPES, force_all_finite='allow-nan')\n     original_ndim = X.ndim\n \n     if original_ndim == 1:\n",
  "test_patch": "diff --git a/sklearn/preprocessing/tests/test_common.py b/sklearn/preprocessing/tests/test_common.py\n--- a/sklearn/preprocessing/tests/test_common.py\n+++ b/sklearn/preprocessing/tests/test_common.py\n@@ -8,8 +8,11 @@\n \n from sklearn.base import clone\n \n-from sklearn.preprocessing import QuantileTransformer\n+from sklearn.preprocessing import minmax_scale\n+from sklearn.preprocessing import quantile_transform\n+\n from sklearn.preprocessing import MinMaxScaler\n+from sklearn.preprocessing import QuantileTransformer\n \n from sklearn.utils.testing import assert_array_equal\n from sklearn.utils.testing import assert_allclose\n@@ -23,11 +26,11 @@ def _get_valid_samples_by_column(X, col):\n \n \n @pytest.mark.parametrize(\n-    \"est, support_sparse\",\n-    [(MinMaxScaler(), False),\n-     (QuantileTransformer(n_quantiles=10, random_state=42), True)]\n+    \"est, func, support_sparse\",\n+    [(MinMaxScaler(), minmax_scale, False),\n+     (QuantileTransformer(n_quantiles=10), quantile_transform, True)]\n )\n-def test_missing_value_handling(est, support_sparse):\n+def test_missing_value_handling(est, func, support_sparse):\n     # check that the preprocessing method let pass nan\n     rng = np.random.RandomState(42)\n     X = iris.data.copy()\n@@ -45,6 +48,12 @@ def test_missing_value_handling(est, support_sparse):\n     # missing values should still be missing, and only them\n     assert_array_equal(np.isnan(Xt), np.isnan(X_test))\n \n+    # check that the function leads to the same results as the class\n+    Xt_class = est.transform(X_train)\n+    Xt_func = func(X_train, **est.get_params())\n+    assert_array_equal(np.isnan(Xt_func), np.isnan(Xt_class))\n+    assert_allclose(Xt_func[~np.isnan(Xt_func)], Xt_class[~np.isnan(Xt_class)])\n+\n     # check that the inverse transform keep NaN\n     Xt_inv = est.inverse_transform(Xt)\n     assert_array_equal(np.isnan(Xt_inv), np.isnan(X_test))\n",
  "problem_statement": "minmax_scale does not ignore NaNs\nThe class `MinMaxScaler` ignore NaNs. Its counterpart function does not.\r\n\r\nThe `check_array` needs to add the option `force_all_finite='allow-nan'`.\r\n#11206 implement the tests and this fix. However, it should be done in another proper PR.\n",
  "hints_text": "Isn't that just a matter of cherry-picking\n76691a925eea2528ef4f72ebcac7baeafb9cd6c2\ninto a new PR?​\n\nKinda, some changes are not necessary.\n76691a925eea2528ef4f72ebcac7baeafb9cd6c2 looks pretty good as a stand-alone\nchange...?\n​\n",
  "created_at": "2018-06-12T11:58:47Z",
  "version": "0.20",
  "FAIL_TO_PASS": "[\"sklearn/preprocessing/tests/test_common.py::test_missing_value_handling[est0-minmax_scale-False]\"]",
  "PASS_TO_PASS": "[\"sklearn/preprocessing/tests/test_common.py::test_missing_value_handling[est1-quantile_transform-True]\"]",
  "environment_setup_commit": "55bf5d93e5674f13a1134d93a11fd0cd11aabcd1",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.959904",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}