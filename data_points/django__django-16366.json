{
  "repo": "django/django",
  "instance_id": "django__django-16366",
  "base_commit": "0036bcdcb65874f63fff8139fe86574fa155eb26",
  "patch": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -239,103 +239,53 @@ def check_constraints(self, table_names=None):\n         determine if rows with invalid references were entered while constraint\n         checks were off.\n         \"\"\"\n-        if self.features.supports_pragma_foreign_key_check:\n-            with self.cursor() as cursor:\n-                if table_names is None:\n-                    violations = cursor.execute(\"PRAGMA foreign_key_check\").fetchall()\n-                else:\n-                    violations = chain.from_iterable(\n-                        cursor.execute(\n-                            \"PRAGMA foreign_key_check(%s)\"\n-                            % self.ops.quote_name(table_name)\n-                        ).fetchall()\n-                        for table_name in table_names\n-                    )\n-                # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check\n-                for (\n-                    table_name,\n-                    rowid,\n-                    referenced_table_name,\n-                    foreign_key_index,\n-                ) in violations:\n-                    foreign_key = cursor.execute(\n-                        \"PRAGMA foreign_key_list(%s)\" % self.ops.quote_name(table_name)\n-                    ).fetchall()[foreign_key_index]\n-                    column_name, referenced_column_name = foreign_key[3:5]\n-                    primary_key_column_name = self.introspection.get_primary_key_column(\n-                        cursor, table_name\n-                    )\n-                    primary_key_value, bad_value = cursor.execute(\n-                        \"SELECT %s, %s FROM %s WHERE rowid = %%s\"\n-                        % (\n-                            self.ops.quote_name(primary_key_column_name),\n-                            self.ops.quote_name(column_name),\n-                            self.ops.quote_name(table_name),\n-                        ),\n-                        (rowid,),\n-                    ).fetchone()\n-                    raise IntegrityError(\n-                        \"The row in table '%s' with primary key '%s' has an \"\n-                        \"invalid foreign key: %s.%s contains a value '%s' that \"\n-                        \"does not have a corresponding value in %s.%s.\"\n-                        % (\n-                            table_name,\n-                            primary_key_value,\n-                            table_name,\n-                            column_name,\n-                            bad_value,\n-                            referenced_table_name,\n-                            referenced_column_name,\n-                        )\n-                    )\n-        else:\n-            with self.cursor() as cursor:\n-                if table_names is None:\n-                    table_names = self.introspection.table_names(cursor)\n-                for table_name in table_names:\n-                    primary_key_column_name = self.introspection.get_primary_key_column(\n-                        cursor, table_name\n-                    )\n-                    if not primary_key_column_name:\n-                        continue\n-                    relations = self.introspection.get_relations(cursor, table_name)\n-                    for column_name, (\n-                        referenced_column_name,\n+        with self.cursor() as cursor:\n+            if table_names is None:\n+                violations = cursor.execute(\"PRAGMA foreign_key_check\").fetchall()\n+            else:\n+                violations = chain.from_iterable(\n+                    cursor.execute(\n+                        \"PRAGMA foreign_key_check(%s)\" % self.ops.quote_name(table_name)\n+                    ).fetchall()\n+                    for table_name in table_names\n+                )\n+            # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check\n+            for (\n+                table_name,\n+                rowid,\n+                referenced_table_name,\n+                foreign_key_index,\n+            ) in violations:\n+                foreign_key = cursor.execute(\n+                    \"PRAGMA foreign_key_list(%s)\" % self.ops.quote_name(table_name)\n+                ).fetchall()[foreign_key_index]\n+                column_name, referenced_column_name = foreign_key[3:5]\n+                primary_key_column_name = self.introspection.get_primary_key_column(\n+                    cursor, table_name\n+                )\n+                primary_key_value, bad_value = cursor.execute(\n+                    \"SELECT %s, %s FROM %s WHERE rowid = %%s\"\n+                    % (\n+                        self.ops.quote_name(primary_key_column_name),\n+                        self.ops.quote_name(column_name),\n+                        self.ops.quote_name(table_name),\n+                    ),\n+                    (rowid,),\n+                ).fetchone()\n+                raise IntegrityError(\n+                    \"The row in table '%s' with primary key '%s' has an \"\n+                    \"invalid foreign key: %s.%s contains a value '%s' that \"\n+                    \"does not have a corresponding value in %s.%s.\"\n+                    % (\n+                        table_name,\n+                        primary_key_value,\n+                        table_name,\n+                        column_name,\n+                        bad_value,\n                         referenced_table_name,\n-                    ) in relations.items():\n-                        cursor.execute(\n-                            \"\"\"\n-                            SELECT REFERRING.`%s`, REFERRING.`%s` FROM `%s` as REFERRING\n-                            LEFT JOIN `%s` as REFERRED\n-                            ON (REFERRING.`%s` = REFERRED.`%s`)\n-                            WHERE REFERRING.`%s` IS NOT NULL AND REFERRED.`%s` IS NULL\n-                            \"\"\"\n-                            % (\n-                                primary_key_column_name,\n-                                column_name,\n-                                table_name,\n-                                referenced_table_name,\n-                                column_name,\n-                                referenced_column_name,\n-                                column_name,\n-                                referenced_column_name,\n-                            )\n-                        )\n-                        for bad_row in cursor.fetchall():\n-                            raise IntegrityError(\n-                                \"The row in table '%s' with primary key '%s' has an \"\n-                                \"invalid foreign key: %s.%s contains a value '%s' that \"\n-                                \"does not have a corresponding value in %s.%s.\"\n-                                % (\n-                                    table_name,\n-                                    bad_row[0],\n-                                    table_name,\n-                                    column_name,\n-                                    bad_row[1],\n-                                    referenced_table_name,\n-                                    referenced_column_name,\n-                                )\n-                            )\n+                        referenced_column_name,\n+                    )\n+                )\n \n     def is_usable(self):\n         return True\ndiff --git a/django/db/backends/sqlite3/features.py b/django/db/backends/sqlite3/features.py\n--- a/django/db/backends/sqlite3/features.py\n+++ b/django/db/backends/sqlite3/features.py\n@@ -9,7 +9,7 @@\n \n \n class DatabaseFeatures(BaseDatabaseFeatures):\n-    minimum_database_version = (3, 9)\n+    minimum_database_version = (3, 21)\n     test_db_allows_multiple_connections = False\n     supports_unspecified_pk = True\n     supports_timezones = False\n@@ -31,11 +31,7 @@ class DatabaseFeatures(BaseDatabaseFeatures):\n     # Is \"ALTER TABLE ... DROP COLUMN\" supported?\n     can_alter_table_drop_column = Database.sqlite_version_info >= (3, 35, 5)\n     supports_parentheses_in_compound = False\n-    # Deferred constraint checks can be emulated on SQLite < 3.20 but not in a\n-    # reasonably performant way.\n-    supports_pragma_foreign_key_check = Database.sqlite_version_info >= (3, 20, 0)\n-    can_defer_constraint_checks = supports_pragma_foreign_key_check\n-    supports_functions_in_partial_indexes = Database.sqlite_version_info >= (3, 15, 0)\n+    can_defer_constraint_checks = True\n     supports_over_clause = Database.sqlite_version_info >= (3, 25, 0)\n     supports_frame_range_fixed_distance = Database.sqlite_version_info >= (3, 28, 0)\n     supports_aggregate_filter_clause = Database.sqlite_version_info >= (3, 30, 1)\n",
  "test_patch": "diff --git a/tests/backends/sqlite/tests.py b/tests/backends/sqlite/tests.py\n--- a/tests/backends/sqlite/tests.py\n+++ b/tests/backends/sqlite/tests.py\n@@ -106,9 +106,9 @@ def test_pathlib_name(self):\n             connections[\"default\"].close()\n             self.assertTrue(os.path.isfile(os.path.join(tmp, \"test.db\")))\n \n-    @mock.patch.object(connection, \"get_database_version\", return_value=(3, 8))\n+    @mock.patch.object(connection, \"get_database_version\", return_value=(3, 20))\n     def test_check_database_version_supported(self, mocked_get_database_version):\n-        msg = \"SQLite 3.9 or later is required (found 3.8).\"\n+        msg = \"SQLite 3.21 or later is required (found 3.20).\"\n         with self.assertRaisesMessage(NotSupportedError, msg):\n             connection.check_database_version_supported()\n         self.assertTrue(mocked_get_database_version.called)\n",
  "problem_statement": "Drop support for SQLite < 3.21.0\nDescription\n\t\nSQLite 3.15+ supports functions in partial indexes.\nSQLite 3.20+ can defer constraint checks and supports PRAGMA foreign key checks.\nUbuntu Xenial ships with SQLite 3.22.0 (which will still by supported by Django) and will EOL in April 2023. Debian Buster ships with 3.27.2 and will EOL in June 2024. Python 3.7 ships with 3.21.0. \n​SQLite 3.21.0 was released in October 2017. SQLite version support seems like a similar situation as GEOS libraries which we generally support about 5 years after released.\n",
  "hints_text": "+1",
  "created_at": "2022-12-07T11:09:50Z",
  "version": "4.2",
  "FAIL_TO_PASS": "[\"test_check_database_version_supported (backends.sqlite.tests.Tests)\"]",
  "PASS_TO_PASS": "[\"test_parameter_escaping (backends.sqlite.tests.EscapingChecks)\", \"test_parameter_escaping (backends.sqlite.tests.EscapingChecksDebug)\", \"test_large_number_of_parameters (backends.sqlite.tests.LastExecutedQueryTest)\", \"test_no_interpolation (backends.sqlite.tests.LastExecutedQueryTest)\", \"test_parameter_quoting (backends.sqlite.tests.LastExecutedQueryTest)\", \"Raise NotSupportedError when aggregating on date/time fields.\", \"test_distinct_aggregation (backends.sqlite.tests.Tests)\", \"test_distinct_aggregation_multiple_args_no_distinct (backends.sqlite.tests.Tests)\", \"A named in-memory db should be allowed where supported.\", \"test_pathlib_name (backends.sqlite.tests.Tests)\", \"test_regexp_function (backends.sqlite.tests.Tests)\", \"test_database_sharing_in_threads (backends.sqlite.tests.ThreadSharing)\", \"auto_increment fields are created with the AUTOINCREMENT keyword\", \"SQLite schema editor is usable within an outer transaction as long as\", \"SQLite schema editor is not usable within an outer transaction if\"]",
  "environment_setup_commit": "0fbdb9784da915fce5dcc1fe82bac9b4785749e5",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.754384",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}