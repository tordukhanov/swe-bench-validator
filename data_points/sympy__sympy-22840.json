{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-22840",
  "base_commit": "d822fcba181155b85ff2b29fe525adbafb22b448",
  "patch": "diff --git a/sympy/simplify/cse_main.py b/sympy/simplify/cse_main.py\n--- a/sympy/simplify/cse_main.py\n+++ b/sympy/simplify/cse_main.py\n@@ -567,6 +567,7 @@ def tree_cse(exprs, symbols, opt_subs=None, order='canonical', ignore=()):\n         Substitutions containing any Symbol from ``ignore`` will be ignored.\n     \"\"\"\n     from sympy.matrices.expressions import MatrixExpr, MatrixSymbol, MatMul, MatAdd\n+    from sympy.matrices.expressions.matexpr import MatrixElement\n     from sympy.polys.rootoftools import RootOf\n \n     if opt_subs is None:\n@@ -586,7 +587,10 @@ def _find_repeated(expr):\n         if isinstance(expr, RootOf):\n             return\n \n-        if isinstance(expr, Basic) and (expr.is_Atom or expr.is_Order):\n+        if isinstance(expr, Basic) and (\n+                expr.is_Atom or\n+                expr.is_Order or\n+                isinstance(expr, (MatrixSymbol, MatrixElement))):\n             if expr.is_Symbol:\n                 excluded_symbols.add(expr)\n             return\n",
  "test_patch": "diff --git a/sympy/simplify/tests/test_cse.py b/sympy/simplify/tests/test_cse.py\n--- a/sympy/simplify/tests/test_cse.py\n+++ b/sympy/simplify/tests/test_cse.py\n@@ -347,6 +347,10 @@ def test_cse_MatrixSymbol():\n     B = MatrixSymbol(\"B\", n, n)\n     assert cse(B) == ([], [B])\n \n+    assert cse(A[0] * A[0]) == ([], [A[0]*A[0]])\n+\n+    assert cse(A[0,0]*A[0,1] + A[0,0]*A[0,1]*A[0,2]) == ([(x0, A[0, 0]*A[0, 1])], [x0*A[0, 2] + x0])\n+\n def test_cse_MatrixExpr():\n     A = MatrixSymbol('A', 3, 3)\n     y = MatrixSymbol('y', 3, 1)\ndiff --git a/sympy/utilities/tests/test_codegen.py b/sympy/utilities/tests/test_codegen.py\n--- a/sympy/utilities/tests/test_codegen.py\n+++ b/sympy/utilities/tests/test_codegen.py\n@@ -531,26 +531,9 @@ def test_multidim_c_argument_cse():\n         '#include \"test.h\"\\n'\n         \"#include <math.h>\\n\"\n         \"void c(double *A, double *b, double *out) {\\n\"\n-        \"   double x0[9];\\n\"\n-        \"   x0[0] = A[0];\\n\"\n-        \"   x0[1] = A[1];\\n\"\n-        \"   x0[2] = A[2];\\n\"\n-        \"   x0[3] = A[3];\\n\"\n-        \"   x0[4] = A[4];\\n\"\n-        \"   x0[5] = A[5];\\n\"\n-        \"   x0[6] = A[6];\\n\"\n-        \"   x0[7] = A[7];\\n\"\n-        \"   x0[8] = A[8];\\n\"\n-        \"   double x1[3];\\n\"\n-        \"   x1[0] = b[0];\\n\"\n-        \"   x1[1] = b[1];\\n\"\n-        \"   x1[2] = b[2];\\n\"\n-        \"   const double x2 = x1[0];\\n\"\n-        \"   const double x3 = x1[1];\\n\"\n-        \"   const double x4 = x1[2];\\n\"\n-        \"   out[0] = x2*x0[0] + x3*x0[1] + x4*x0[2];\\n\"\n-        \"   out[1] = x2*x0[3] + x3*x0[4] + x4*x0[5];\\n\"\n-        \"   out[2] = x2*x0[6] + x3*x0[7] + x4*x0[8];\\n\"\n+        \"   out[0] = A[0]*b[0] + A[1]*b[1] + A[2]*b[2];\\n\"\n+        \"   out[1] = A[3]*b[0] + A[4]*b[1] + A[5]*b[2];\\n\"\n+        \"   out[2] = A[6]*b[0] + A[7]*b[1] + A[8]*b[2];\\n\"\n         \"}\\n\"\n     )\n     assert code == expected\n",
  "problem_statement": "cse() has strange behaviour for MatrixSymbol indexing\nExample: \r\n```python\r\nimport sympy as sp\r\nfrom pprint import pprint\r\n\r\n\r\ndef sub_in_matrixsymbols(exp, matrices):\r\n    for matrix in matrices:\r\n        for i in range(matrix.shape[0]):\r\n            for j in range(matrix.shape[1]):\r\n                name = \"%s_%d_%d\" % (matrix.name, i, j)\r\n                sym = sp.symbols(name)\r\n                exp = exp.subs(sym, matrix[i, j])\r\n    return exp\r\n\r\n\r\ndef t44(name):\r\n    return sp.Matrix(4, 4, lambda i, j: sp.symbols('%s_%d_%d' % (name, i, j)))\r\n\r\n\r\n# Construct matrices of symbols that work with our\r\n# expressions. (MatrixSymbols does not.)\r\na = t44(\"a\")\r\nb = t44(\"b\")\r\n\r\n# Set up expression. This is a just a simple example.\r\ne = a * b\r\n\r\n# Put in matrixsymbols. (Gives array-input in codegen.)\r\ne2 = sub_in_matrixsymbols(e, [sp.MatrixSymbol(\"a\", 4, 4), sp.MatrixSymbol(\"b\", 4, 4)])\r\ncse_subs, cse_reduced = sp.cse(e2)\r\npprint((cse_subs, cse_reduced))\r\n\r\n# Codegen, etc..\r\nprint \"\\nccode:\"\r\nfor sym, expr in cse_subs:\r\n    constants, not_c, c_expr = sympy.printing.ccode(\r\n        expr,\r\n        human=False,\r\n        assign_to=sympy.printing.ccode(sym),\r\n    )\r\n    assert not constants, constants\r\n    assert not not_c, not_c\r\n    print \"%s\\n\" % c_expr\r\n\r\n```\r\n\r\nThis gives the following output:\r\n\r\n```\r\n([(x0, a),\r\n  (x1, x0[0, 0]),\r\n  (x2, b),\r\n  (x3, x2[0, 0]),\r\n  (x4, x0[0, 1]),\r\n  (x5, x2[1, 0]),\r\n  (x6, x0[0, 2]),\r\n  (x7, x2[2, 0]),\r\n  (x8, x0[0, 3]),\r\n  (x9, x2[3, 0]),\r\n  (x10, x2[0, 1]),\r\n  (x11, x2[1, 1]),\r\n  (x12, x2[2, 1]),\r\n  (x13, x2[3, 1]),\r\n  (x14, x2[0, 2]),\r\n  (x15, x2[1, 2]),\r\n  (x16, x2[2, 2]),\r\n  (x17, x2[3, 2]),\r\n  (x18, x2[0, 3]),\r\n  (x19, x2[1, 3]),\r\n  (x20, x2[2, 3]),\r\n  (x21, x2[3, 3]),\r\n  (x22, x0[1, 0]),\r\n  (x23, x0[1, 1]),\r\n  (x24, x0[1, 2]),\r\n  (x25, x0[1, 3]),\r\n  (x26, x0[2, 0]),\r\n  (x27, x0[2, 1]),\r\n  (x28, x0[2, 2]),\r\n  (x29, x0[2, 3]),\r\n  (x30, x0[3, 0]),\r\n  (x31, x0[3, 1]),\r\n  (x32, x0[3, 2]),\r\n  (x33, x0[3, 3])],\r\n [Matrix([\r\n[    x1*x3 + x4*x5 + x6*x7 + x8*x9,     x1*x10 + x11*x4 + x12*x6 + x13*x8,     x1*x14 + x15*x4 + x16*x6 + x17*x8,     x1*x18 + x19*x4 + x20*x6 + x21*x8],\r\n[x22*x3 + x23*x5 + x24*x7 + x25*x9, x10*x22 + x11*x23 + x12*x24 + x13*x25, x14*x22 + x15*x23 + x16*x24 + x17*x25, x18*x22 + x19*x23 + x20*x24 + x21*x25],\r\n[x26*x3 + x27*x5 + x28*x7 + x29*x9, x10*x26 + x11*x27 + x12*x28 + x13*x29, x14*x26 + x15*x27 + x16*x28 + x17*x29, x18*x26 + x19*x27 + x20*x28 + x21*x29],\r\n[x3*x30 + x31*x5 + x32*x7 + x33*x9, x10*x30 + x11*x31 + x12*x32 + x13*x33, x14*x30 + x15*x31 + x16*x32 + x17*x33, x18*x30 + x19*x31 + x20*x32 + x21*x33]])])\r\n\r\nccode:\r\nx0[0] = a[0];\r\nx0[1] = a[1];\r\nx0[2] = a[2];\r\nx0[3] = a[3];\r\nx0[4] = a[4];\r\nx0[5] = a[5];\r\nx0[6] = a[6];\r\nx0[7] = a[7];\r\nx0[8] = a[8];\r\nx0[9] = a[9];\r\nx0[10] = a[10];\r\nx0[11] = a[11];\r\nx0[12] = a[12];\r\nx0[13] = a[13];\r\nx0[14] = a[14];\r\nx0[15] = a[15];\r\nx1 = x0[0];\r\nx2[0] = b[0];\r\nx2[1] = b[1];\r\nx2[2] = b[2];\r\nx2[3] = b[3];\r\nx2[4] = b[4];\r\nx2[5] = b[5];\r\nx2[6] = b[6];\r\nx2[7] = b[7];\r\nx2[8] = b[8];\r\nx2[9] = b[9];\r\nx2[10] = b[10];\r\nx2[11] = b[11];\r\nx2[12] = b[12];\r\nx2[13] = b[13];\r\nx2[14] = b[14];\r\nx2[15] = b[15];\r\nx3 = x2[0];\r\nx4 = x0[1];\r\nx5 = x2[4];\r\nx6 = x0[2];\r\nx7 = x2[8];\r\nx8 = x0[3];\r\nx9 = x2[12];\r\nx10 = x2[1];\r\nx11 = x2[5];\r\nx12 = x2[9];\r\nx13 = x2[13];\r\nx14 = x2[2];\r\nx15 = x2[6];\r\nx16 = x2[10];\r\nx17 = x2[14];\r\nx18 = x2[3];\r\nx19 = x2[7];\r\nx20 = x2[11];\r\nx21 = x2[15];\r\nx22 = x0[4];\r\nx23 = x0[5];\r\nx24 = x0[6];\r\nx25 = x0[7];\r\nx26 = x0[8];\r\nx27 = x0[9];\r\nx28 = x0[10];\r\nx29 = x0[11];\r\nx30 = x0[12];\r\nx31 = x0[13];\r\nx32 = x0[14];\r\nx33 = x0[15];\r\n```\r\n\r\n`x0` and `x2` are just copies of the matrices `a` and `b`, respectively.\n",
  "hints_text": "Can you create a very simple example using MatrixSymbol and the expected output that you'd like to see?\nI think one would expect the output to be similar to the following (except for the expression returned by CSE being a matrix where the individual elements are terms as defined by matrix multiplication, that is, unchanged by `cse()`).\r\n\r\n```py\r\nimport sympy as sp\r\nfrom pprint import pprint\r\nimport sympy.printing.ccode\r\n\r\n\r\ndef print_ccode(assign_to, expr):\r\n    constants, not_c, c_expr = sympy.printing.ccode(\r\n        expr,\r\n        human=False,\r\n        assign_to=assign_to,\r\n    )\r\n    assert not constants, constants\r\n    assert not not_c, not_c\r\n    print \"%s\" % c_expr\r\n\r\n\r\na = sp.MatrixSymbol(\"a\", 4, 4)\r\nb = sp.MatrixSymbol(\"b\", 4, 4)\r\n\r\n# Set up expression. This is a just a simple example.\r\ne = a * b\r\nprint \"\\nexpr:\"\r\nprint e\r\n\r\ncse_subs, cse_reduced = sp.cse(e)\r\nprint \"\\ncse(expr):\"\r\npprint((cse_subs, cse_reduced))\r\n\r\n# Codegen.\r\nprint \"\\nccode:\"\r\nfor sym, expr in cse_subs:\r\n    print_ccode(sympy.printing.ccode(sym), expr)\r\nassert len(cse_reduced) == 1\r\nprint_ccode(sympy.printing.ccode(sp.symbols(\"result\")), cse_reduced[0])\r\n```\r\n\r\nGives the output:\r\n\r\n```\r\nexpr:\r\na*b\r\n\r\ncse(expr):\r\n([], [a*b])\r\n\r\nccode:\r\nresult[0] = a[0]*b[0] + a[1]*b[4] + a[2]*b[8] + a[3]*b[12];\r\nresult[1] = a[0]*b[1] + a[1]*b[5] + a[2]*b[9] + a[3]*b[13];\r\nresult[2] = a[0]*b[2] + a[1]*b[6] + a[2]*b[10] + a[3]*b[14];\r\nresult[3] = a[0]*b[3] + a[1]*b[7] + a[2]*b[11] + a[3]*b[15];\r\nresult[4] = a[4]*b[0] + a[5]*b[4] + a[6]*b[8] + a[7]*b[12];\r\nresult[5] = a[4]*b[1] + a[5]*b[5] + a[6]*b[9] + a[7]*b[13];\r\nresult[6] = a[4]*b[2] + a[5]*b[6] + a[6]*b[10] + a[7]*b[14];\r\nresult[7] = a[4]*b[3] + a[5]*b[7] + a[6]*b[11] + a[7]*b[15];\r\nresult[8] = a[8]*b[0] + a[9]*b[4] + a[10]*b[8] + a[11]*b[12];\r\nresult[9] = a[8]*b[1] + a[9]*b[5] + a[10]*b[9] + a[11]*b[13];\r\nresult[10] = a[8]*b[2] + a[9]*b[6] + a[10]*b[10] + a[11]*b[14];\r\nresult[11] = a[8]*b[3] + a[9]*b[7] + a[10]*b[11] + a[11]*b[15];\r\nresult[12] = a[12]*b[0] + a[13]*b[4] + a[14]*b[8] + a[15]*b[12];\r\nresult[13] = a[12]*b[1] + a[13]*b[5] + a[14]*b[9] + a[15]*b[13];\r\nresult[14] = a[12]*b[2] + a[13]*b[6] + a[14]*b[10] + a[15]*b[14];\r\nresult[15] = a[12]*b[3] + a[13]*b[7] + a[14]*b[11] + a[15]*b[15];\r\n```\nThanks. Note that it doesn't look like cse is well tested (i.e. designed) for MatrixSymbols based on the unit tests: https://github.com/sympy/sympy/blob/master/sympy/simplify/tests/test_cse.py#L315. Those tests don't really prove that it works as desired. So this definitely needs to be fixed.\nThe first part works as expected:\r\n\r\n```\r\nIn [1]: import sympy as sm\r\n\r\nIn [2]: M = sm.MatrixSymbol('M', 3, 3)\r\n\r\nIn [3]: B = sm.MatrixSymbol('B', 3, 3)\r\n\r\nIn [4]: M * B\r\nOut[4]: M*B\r\n\r\nIn [5]: sm.cse(M * B)\r\nOut[5]: ([], [M*B])\r\n```\nFor the ccode of an expression of MatrixSymbols, I would not expect it to print the results as you have them. MatrixSymbols should map to a matrix algebra library like BLAS and LINPACK. But Matrix, on the other hand, should do what you expect. Note how this works:\r\n\r\n```\r\nIn [8]: M = sm.Matrix(3, 3, lambda i, j: sm.Symbol('M_{}{}'.format(i, j)))\r\n\r\nIn [9]: M\r\nOut[9]: \r\nMatrix([\r\n[M_00, M_01, M_02],\r\n[M_10, M_11, M_12],\r\n[M_20, M_21, M_22]])\r\n\r\nIn [10]: B = sm.Matrix(3, 3, lambda i, j: sm.Symbol('B_{}{}'.format(i, j)))\r\n\r\nIn [11]: B\r\nOut[11]: \r\nMatrix([\r\n[B_00, B_01, B_02],\r\n[B_10, B_11, B_12],\r\n[B_20, B_21, B_22]])\r\n\r\nIn [12]: M * B\r\nOut[12]: \r\nMatrix([\r\n[B_00*M_00 + B_10*M_01 + B_20*M_02, B_01*M_00 + B_11*M_01 + B_21*M_02, B_02*M_00 + B_12*M_01 + B_22*M_02],\r\n[B_00*M_10 + B_10*M_11 + B_20*M_12, B_01*M_10 + B_11*M_11 + B_21*M_12, B_02*M_10 + B_12*M_11 + B_22*M_12],\r\n[B_00*M_20 + B_10*M_21 + B_20*M_22, B_01*M_20 + B_11*M_21 + B_21*M_22, B_02*M_20 + B_12*M_21 + B_22*M_22]])\r\n\r\nIn [13]: sm.cse(M * B)\r\nOut[13]: \r\n([], [Matrix([\r\n  [B_00*M_00 + B_10*M_01 + B_20*M_02, B_01*M_00 + B_11*M_01 + B_21*M_02, B_02*M_00 + B_12*M_01 + B_22*M_02],\r\n  [B_00*M_10 + B_10*M_11 + B_20*M_12, B_01*M_10 + B_11*M_11 + B_21*M_12, B_02*M_10 + B_12*M_11 + B_22*M_12],\r\n  [B_00*M_20 + B_10*M_21 + B_20*M_22, B_01*M_20 + B_11*M_21 + B_21*M_22, B_02*M_20 + B_12*M_21 + B_22*M_22]])])\r\n\r\nIn [17]: print(sm.ccode(M * B, assign_to=sm.MatrixSymbol('E', 3, 3)))\r\nE[0] = B_00*M_00 + B_10*M_01 + B_20*M_02;\r\nE[1] = B_01*M_00 + B_11*M_01 + B_21*M_02;\r\nE[2] = B_02*M_00 + B_12*M_01 + B_22*M_02;\r\nE[3] = B_00*M_10 + B_10*M_11 + B_20*M_12;\r\nE[4] = B_01*M_10 + B_11*M_11 + B_21*M_12;\r\nE[5] = B_02*M_10 + B_12*M_11 + B_22*M_12;\r\nE[6] = B_00*M_20 + B_10*M_21 + B_20*M_22;\r\nE[7] = B_01*M_20 + B_11*M_21 + B_21*M_22;\r\nE[8] = B_02*M_20 + B_12*M_21 + B_22*M_22;\r\n```\nBut in order to get a single input argument from codegen it cannot be different symbols, and if you replace each symbol with a `MatrixSymbol[i, j]` then `cse()` starts doing the above non-optiimizations for some reason.\nAs far as I know, `codegen` does not work with Matrix or MatrixSymbol's in any meaningful way. There are related issues:\r\n\r\n#11456\r\n#4367\r\n#10522\r\n\r\nIn general, there needs to be work done in the code generators to properly support matrices.\r\n\r\nAs a work around, I suggest using `ccode` and a custom template to get the result you want.",
  "created_at": "2022-01-11T17:34:54Z",
  "version": "1.10",
  "FAIL_TO_PASS": "[\"test_cse_MatrixSymbol\", \"test_multidim_c_argument_cse\"]",
  "PASS_TO_PASS": "[\"test_numbered_symbols\", \"test_preprocess_for_cse\", \"test_postprocess_for_cse\", \"test_cse_single\", \"test_cse_single2\", \"test_cse_not_possible\", \"test_nested_substitution\", \"test_subtraction_opt\", \"test_multiple_expressions\", \"test_bypass_non_commutatives\", \"test_issue_4498\", \"test_issue_4020\", \"test_issue_4203\", \"test_issue_6263\", \"test_dont_cse_tuples\", \"test_pow_invpow\", \"test_postprocess\", \"test_issue_4499\", \"test_issue_6169\", \"test_cse_Indexed\", \"test_cse_MatrixExpr\", \"test_Piecewise\", \"test_ignore_order_terms\", \"test_name_conflict\", \"test_name_conflict_cust_symbols\", \"test_symbols_exhausted_error\", \"test_issue_7840\", \"test_issue_8891\", \"test_issue_11230\", \"test_hollow_rejection\", \"test_cse_ignore\", \"test_cse_ignore_issue_15002\", \"test_cse__performance\", \"test_issue_12070\", \"test_issue_13000\", \"test_issue_18203\", \"test_unevaluated_mul\", \"test_cse_release_variables\", \"test_cse_list\", \"test_issue_18991\", \"test_Routine_argument_order\", \"test_empty_c_code\", \"test_empty_c_code_with_comment\", \"test_empty_c_header\", \"test_simple_c_code\", \"test_c_code_reserved_words\", \"test_numbersymbol_c_code\", \"test_c_code_argument_order\", \"test_simple_c_header\", \"test_simple_c_codegen\", \"test_multiple_results_c\", \"test_no_results_c\", \"test_ansi_math1_codegen\", \"test_ansi_math2_codegen\", \"test_complicated_codegen\", \"test_loops_c\", \"test_dummy_loops_c\", \"test_partial_loops_c\", \"test_output_arg_c\", \"test_output_arg_c_reserved_words\", \"test_ccode_results_named_ordered\", \"test_ccode_matrixsymbol_slice\", \"test_ccode_cse\", \"test_ccode_unused_array_arg\", \"test_empty_f_code\", \"test_empty_f_code_with_header\", \"test_empty_f_header\", \"test_simple_f_code\", \"test_numbersymbol_f_code\", \"test_erf_f_code\", \"test_f_code_argument_order\", \"test_simple_f_header\", \"test_simple_f_codegen\", \"test_multiple_results_f\", \"test_no_results_f\", \"test_intrinsic_math_codegen\", \"test_intrinsic_math2_codegen\", \"test_complicated_codegen_f95\", \"test_loops\", \"test_dummy_loops_f95\", \"test_loops_InOut\", \"test_partial_loops_f\", \"test_output_arg_f\", \"test_inline_function\", \"test_f_code_call_signature_wrap\", \"test_check_case\", \"test_check_case_false_positive\", \"test_c_fortran_omit_routine_name\", \"test_fcode_matrix_output\", \"test_fcode_results_named_ordered\", \"test_fcode_matrixsymbol_slice\", \"test_fcode_matrixsymbol_slice_autoname\", \"test_global_vars\", \"test_custom_codegen\", \"test_c_with_printer\"]",
  "environment_setup_commit": "fd40404e72921b9e52a5f9582246e4a6cd96c431",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.150998",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}