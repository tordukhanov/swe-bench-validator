{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-11315",
  "base_commit": "bb5110b8e0b70d98eae2f7f8b6d4deaa5d2de038",
  "patch": "diff --git a/sklearn/compose/_column_transformer.py b/sklearn/compose/_column_transformer.py\n--- a/sklearn/compose/_column_transformer.py\n+++ b/sklearn/compose/_column_transformer.py\n@@ -6,7 +6,7 @@\n # Author: Andreas Mueller\n #         Joris Van den Bossche\n # License: BSD\n-\n+from itertools import chain\n \n import numpy as np\n from scipy import sparse\n@@ -69,7 +69,7 @@ class ColumnTransformer(_BaseComposition, TransformerMixin):\n             ``transformer`` expects X to be a 1d array-like (vector),\n             otherwise a 2d array will be passed to the transformer.\n \n-    remainder : {'passthrough', 'drop'}, default 'passthrough'\n+    remainder : {'passthrough', 'drop'} or estimator, default 'passthrough'\n         By default, all remaining columns that were not specified in\n         `transformers` will be automatically passed through (default of\n         ``'passthrough'``). This subset of columns is concatenated with the\n@@ -77,6 +77,9 @@ class ColumnTransformer(_BaseComposition, TransformerMixin):\n         By using ``remainder='drop'``, only the specified columns in\n         `transformers` are transformed and combined in the output, and the\n         non-specified columns are dropped.\n+        By setting ``remainder`` to be an estimator, the remaining\n+        non-specified columns will use the ``remainder`` estimator. The\n+        estimator must support `fit` and `transform`.\n \n     n_jobs : int, optional\n         Number of jobs to run in parallel (default 1).\n@@ -90,7 +93,13 @@ class ColumnTransformer(_BaseComposition, TransformerMixin):\n     ----------\n     transformers_ : list\n         The collection of fitted transformers as tuples of\n-        (name, fitted_transformer, column).\n+        (name, fitted_transformer, column). `fitted_transformer` can be an\n+        estimator, 'drop', or 'passthrough'. If there are remaining columns,\n+        the final element is a tuple of the form:\n+        ('remainder', transformer, remaining_columns) corresponding to the\n+        ``remainder`` parameter. If there are remaining columns, then\n+        ``len(transformers_)==len(transformers)+1``, otherwise\n+        ``len(transformers_)==len(transformers)``.\n \n     named_transformers_ : Bunch object, a dictionary with attribute access\n         Read-only attribute to access any transformer by given name.\n@@ -188,13 +197,12 @@ def _iter(self, X=None, fitted=False, replace_strings=False):\n             transformers = self.transformers_\n         else:\n             transformers = self.transformers\n+            if self._remainder[2] is not None:\n+                transformers = chain(transformers, [self._remainder])\n         get_weight = (self.transformer_weights or {}).get\n \n         for name, trans, column in transformers:\n-            if X is None:\n-                sub = X\n-            else:\n-                sub = _get_column(X, column)\n+            sub = None if X is None else _get_column(X, column)\n \n             if replace_strings:\n                 # replace 'passthrough' with identity transformer and\n@@ -209,7 +217,10 @@ def _iter(self, X=None, fitted=False, replace_strings=False):\n             yield (name, trans, sub, get_weight(name))\n \n     def _validate_transformers(self):\n-        names, transformers, _, _ = zip(*self._iter())\n+        if not self.transformers:\n+            return\n+\n+        names, transformers, _ = zip(*self.transformers)\n \n         # validate names\n         self._validate_names(names)\n@@ -226,24 +237,27 @@ def _validate_transformers(self):\n                                 (t, type(t)))\n \n     def _validate_remainder(self, X):\n-        \"\"\"Generate list of passthrough columns for 'remainder' case.\"\"\"\n-        if self.remainder not in ('drop', 'passthrough'):\n+        \"\"\"\n+        Validates ``remainder`` and defines ``_remainder`` targeting\n+        the remaining columns.\n+        \"\"\"\n+        is_transformer = ((hasattr(self.remainder, \"fit\")\n+                           or hasattr(self.remainder, \"fit_transform\"))\n+                          and hasattr(self.remainder, \"transform\"))\n+        if (self.remainder not in ('drop', 'passthrough')\n+                and not is_transformer):\n             raise ValueError(\n-                \"The remainder keyword needs to be one of 'drop' or \"\n-                \"'passthrough'. {0:r} was passed instead\")\n+                \"The remainder keyword needs to be one of 'drop', \"\n+                \"'passthrough', or estimator. '%s' was passed instead\" %\n+                self.remainder)\n \n         n_columns = X.shape[1]\n+        cols = []\n+        for _, _, columns in self.transformers:\n+            cols.extend(_get_column_indices(X, columns))\n+        remaining_idx = sorted(list(set(range(n_columns)) - set(cols))) or None\n \n-        if self.remainder == 'passthrough':\n-            cols = []\n-            for _, _, columns in self.transformers:\n-                cols.extend(_get_column_indices(X, columns))\n-            self._passthrough = sorted(list(set(range(n_columns)) - set(cols)))\n-            if not self._passthrough:\n-                # empty list -> no need to select passthrough columns\n-                self._passthrough = None\n-        else:\n-            self._passthrough = None\n+        self._remainder = ('remainder', self.remainder, remaining_idx)\n \n     @property\n     def named_transformers_(self):\n@@ -267,12 +281,6 @@ def get_feature_names(self):\n             Names of the features produced by transform.\n         \"\"\"\n         check_is_fitted(self, 'transformers_')\n-        if self._passthrough is not None:\n-            raise NotImplementedError(\n-                \"get_feature_names is not yet supported when having columns\"\n-                \"that are passed through (you specify remainder='drop' to not \"\n-                \"pass through the unspecified columns).\")\n-\n         feature_names = []\n         for name, trans, _, _ in self._iter(fitted=True):\n             if trans == 'drop':\n@@ -294,7 +302,11 @@ def _update_fitted_transformers(self, transformers):\n         transformers = iter(transformers)\n         transformers_ = []\n \n-        for name, old, column in self.transformers:\n+        transformer_iter = self.transformers\n+        if self._remainder[2] is not None:\n+            transformer_iter = chain(transformer_iter, [self._remainder])\n+\n+        for name, old, column in transformer_iter:\n             if old == 'drop':\n                 trans = 'drop'\n             elif old == 'passthrough':\n@@ -304,7 +316,6 @@ def _update_fitted_transformers(self, transformers):\n                 trans = 'passthrough'\n             else:\n                 trans = next(transformers)\n-\n             transformers_.append((name, trans, column))\n \n         # sanity check that transformers is exhausted\n@@ -335,7 +346,7 @@ def _fit_transform(self, X, y, func, fitted=False):\n             return Parallel(n_jobs=self.n_jobs)(\n                 delayed(func)(clone(trans) if not fitted else trans,\n                               X_sel, y, weight)\n-                for name, trans, X_sel, weight in self._iter(\n+                for _, trans, X_sel, weight in self._iter(\n                     X=X, fitted=fitted, replace_strings=True))\n         except ValueError as e:\n             if \"Expected 2D array, got 1D array instead\" in str(e):\n@@ -361,12 +372,12 @@ def fit(self, X, y=None):\n             This estimator\n \n         \"\"\"\n-        self._validate_transformers()\n         self._validate_remainder(X)\n+        self._validate_transformers()\n \n         transformers = self._fit_transform(X, y, _fit_one_transformer)\n-\n         self._update_fitted_transformers(transformers)\n+\n         return self\n \n     def fit_transform(self, X, y=None):\n@@ -390,31 +401,21 @@ def fit_transform(self, X, y=None):\n             sparse matrices.\n \n         \"\"\"\n-        self._validate_transformers()\n         self._validate_remainder(X)\n+        self._validate_transformers()\n \n         result = self._fit_transform(X, y, _fit_transform_one)\n \n         if not result:\n             # All transformers are None\n-            if self._passthrough is None:\n-                return np.zeros((X.shape[0], 0))\n-            else:\n-                return _get_column(X, self._passthrough)\n+            return np.zeros((X.shape[0], 0))\n \n         Xs, transformers = zip(*result)\n \n         self._update_fitted_transformers(transformers)\n         self._validate_output(Xs)\n \n-        if self._passthrough is not None:\n-            Xs = list(Xs) + [_get_column(X, self._passthrough)]\n-\n-        if any(sparse.issparse(f) for f in Xs):\n-            Xs = sparse.hstack(Xs).tocsr()\n-        else:\n-            Xs = np.hstack(Xs)\n-        return Xs\n+        return _hstack(list(Xs))\n \n     def transform(self, X):\n         \"\"\"Transform X separately by each transformer, concatenate results.\n@@ -440,19 +441,9 @@ def transform(self, X):\n \n         if not Xs:\n             # All transformers are None\n-            if self._passthrough is None:\n-                return np.zeros((X.shape[0], 0))\n-            else:\n-                return _get_column(X, self._passthrough)\n-\n-        if self._passthrough is not None:\n-            Xs = list(Xs) + [_get_column(X, self._passthrough)]\n+            return np.zeros((X.shape[0], 0))\n \n-        if any(sparse.issparse(f) for f in Xs):\n-            Xs = sparse.hstack(Xs).tocsr()\n-        else:\n-            Xs = np.hstack(Xs)\n-        return Xs\n+        return _hstack(list(Xs))\n \n \n def _check_key_type(key, superclass):\n@@ -486,6 +477,19 @@ def _check_key_type(key, superclass):\n     return False\n \n \n+def _hstack(X):\n+    \"\"\"\n+    Stacks X horizontally.\n+\n+    Supports input types (X): list of\n+        numpy arrays, sparse arrays and DataFrames\n+    \"\"\"\n+    if any(sparse.issparse(f) for f in X):\n+        return sparse.hstack(X).tocsr()\n+    else:\n+        return np.hstack(X)\n+\n+\n def _get_column(X, key):\n     \"\"\"\n     Get feature column(s) from input data X.\n@@ -612,7 +616,7 @@ def make_column_transformer(*transformers, **kwargs):\n     ----------\n     *transformers : tuples of column selections and transformers\n \n-    remainder : {'passthrough', 'drop'}, default 'passthrough'\n+    remainder : {'passthrough', 'drop'} or estimator, default 'passthrough'\n         By default, all remaining columns that were not specified in\n         `transformers` will be automatically passed through (default of\n         ``'passthrough'``). This subset of columns is concatenated with the\n@@ -620,6 +624,9 @@ def make_column_transformer(*transformers, **kwargs):\n         By using ``remainder='drop'``, only the specified columns in\n         `transformers` are transformed and combined in the output, and the\n         non-specified columns are dropped.\n+        By setting ``remainder`` to be an estimator, the remaining\n+        non-specified columns will use the ``remainder`` estimator. The\n+        estimator must support `fit` and `transform`.\n \n     n_jobs : int, optional\n         Number of jobs to run in parallel (default 1).\ndiff --git a/sklearn/utils/metaestimators.py b/sklearn/utils/metaestimators.py\n--- a/sklearn/utils/metaestimators.py\n+++ b/sklearn/utils/metaestimators.py\n@@ -23,7 +23,7 @@ def __init__(self):\n         pass\n \n     def _get_params(self, attr, deep=True):\n-        out = super(_BaseComposition, self).get_params(deep=False)\n+        out = super(_BaseComposition, self).get_params(deep=deep)\n         if not deep:\n             return out\n         estimators = getattr(self, attr)\n",
  "test_patch": "diff --git a/sklearn/compose/tests/test_column_transformer.py b/sklearn/compose/tests/test_column_transformer.py\n--- a/sklearn/compose/tests/test_column_transformer.py\n+++ b/sklearn/compose/tests/test_column_transformer.py\n@@ -37,6 +37,14 @@ def transform(self, X, y=None):\n         return X\n \n \n+class DoubleTrans(BaseEstimator):\n+    def fit(self, X, y=None):\n+        return self\n+\n+    def transform(self, X):\n+        return 2*X\n+\n+\n class SparseMatrixTrans(BaseEstimator):\n     def fit(self, X, y=None):\n         return self\n@@ -46,6 +54,23 @@ def transform(self, X, y=None):\n         return sparse.eye(n_samples, n_samples).tocsr()\n \n \n+class TransNo2D(BaseEstimator):\n+    def fit(self, X, y=None):\n+        return self\n+\n+    def transform(self, X, y=None):\n+        return X\n+\n+\n+class TransRaise(BaseEstimator):\n+\n+    def fit(self, X, y=None):\n+        raise ValueError(\"specific message\")\n+\n+    def transform(self, X, y=None):\n+        raise ValueError(\"specific message\")\n+\n+\n def test_column_transformer():\n     X_array = np.array([[0, 1, 2], [2, 4, 6]]).T\n \n@@ -78,6 +103,7 @@ def test_column_transformer():\n                             ('trans2', Trans(), [1])])\n     assert_array_equal(ct.fit_transform(X_array), X_res_both)\n     assert_array_equal(ct.fit(X_array).transform(X_array), X_res_both)\n+    assert len(ct.transformers_) == 2\n \n     # test with transformer_weights\n     transformer_weights = {'trans1': .1, 'trans2': 10}\n@@ -88,11 +114,13 @@ def test_column_transformer():\n                      transformer_weights['trans2'] * X_res_second1D]).T\n     assert_array_equal(both.fit_transform(X_array), res)\n     assert_array_equal(both.fit(X_array).transform(X_array), res)\n+    assert len(both.transformers_) == 2\n \n     both = ColumnTransformer([('trans', Trans(), [0, 1])],\n                              transformer_weights={'trans': .1})\n     assert_array_equal(both.fit_transform(X_array), 0.1 * X_res_both)\n     assert_array_equal(both.fit(X_array).transform(X_array), 0.1 * X_res_both)\n+    assert len(both.transformers_) == 1\n \n \n def test_column_transformer_dataframe():\n@@ -142,11 +170,15 @@ def test_column_transformer_dataframe():\n                             ('trans2', Trans(), ['second'])])\n     assert_array_equal(ct.fit_transform(X_df), X_res_both)\n     assert_array_equal(ct.fit(X_df).transform(X_df), X_res_both)\n+    assert len(ct.transformers_) == 2\n+    assert ct.transformers_[-1][0] != 'remainder'\n \n     ct = ColumnTransformer([('trans1', Trans(), [0]),\n                             ('trans2', Trans(), [1])])\n     assert_array_equal(ct.fit_transform(X_df), X_res_both)\n     assert_array_equal(ct.fit(X_df).transform(X_df), X_res_both)\n+    assert len(ct.transformers_) == 2\n+    assert ct.transformers_[-1][0] != 'remainder'\n \n     # test with transformer_weights\n     transformer_weights = {'trans1': .1, 'trans2': 10}\n@@ -157,17 +189,23 @@ def test_column_transformer_dataframe():\n                      transformer_weights['trans2'] * X_df['second']]).T\n     assert_array_equal(both.fit_transform(X_df), res)\n     assert_array_equal(both.fit(X_df).transform(X_df), res)\n+    assert len(both.transformers_) == 2\n+    assert ct.transformers_[-1][0] != 'remainder'\n \n     # test multiple columns\n     both = ColumnTransformer([('trans', Trans(), ['first', 'second'])],\n                              transformer_weights={'trans': .1})\n     assert_array_equal(both.fit_transform(X_df), 0.1 * X_res_both)\n     assert_array_equal(both.fit(X_df).transform(X_df), 0.1 * X_res_both)\n+    assert len(both.transformers_) == 1\n+    assert ct.transformers_[-1][0] != 'remainder'\n \n     both = ColumnTransformer([('trans', Trans(), [0, 1])],\n                              transformer_weights={'trans': .1})\n     assert_array_equal(both.fit_transform(X_df), 0.1 * X_res_both)\n     assert_array_equal(both.fit(X_df).transform(X_df), 0.1 * X_res_both)\n+    assert len(both.transformers_) == 1\n+    assert ct.transformers_[-1][0] != 'remainder'\n \n     # ensure pandas object is passes through\n \n@@ -195,6 +233,11 @@ def transform(self, X, y=None):\n     assert_array_equal(ct.fit_transform(X_df), X_res_first)\n     assert_array_equal(ct.fit(X_df).transform(X_df), X_res_first)\n \n+    assert len(ct.transformers_) == 2\n+    assert ct.transformers_[-1][0] == 'remainder'\n+    assert ct.transformers_[-1][1] == 'drop'\n+    assert_array_equal(ct.transformers_[-1][2], [1])\n+\n \n def test_column_transformer_sparse_array():\n     X_sparse = sparse.eye(3, 2).tocsr()\n@@ -230,6 +273,8 @@ def test_column_transformer_sparse_stacking():\n     assert_true(sparse.issparse(X_trans))\n     assert_equal(X_trans.shape, (X_trans.shape[0], X_trans.shape[0] + 1))\n     assert_array_equal(X_trans.toarray()[:, 1:], np.eye(X_trans.shape[0]))\n+    assert len(col_trans.transformers_) == 2\n+    assert col_trans.transformers_[-1][0] != 'remainder'\n \n \n def test_column_transformer_error_msg_1D():\n@@ -241,28 +286,12 @@ def test_column_transformer_error_msg_1D():\n     assert_raise_message(ValueError, \"1D data passed to a transformer\",\n                          col_trans.fit_transform, X_array)\n \n-    class TransRaise(BaseEstimator):\n-\n-        def fit(self, X, y=None):\n-            raise ValueError(\"specific message\")\n-\n-        def transform(self, X, y=None):\n-            raise ValueError(\"specific message\")\n-\n     col_trans = ColumnTransformer([('trans', TransRaise(), 0)])\n     for func in [col_trans.fit, col_trans.fit_transform]:\n         assert_raise_message(ValueError, \"specific message\", func, X_array)\n \n \n def test_2D_transformer_output():\n-\n-    class TransNo2D(BaseEstimator):\n-        def fit(self, X, y=None):\n-            return self\n-\n-        def transform(self, X, y=None):\n-            return X\n-\n     X_array = np.array([[0, 1, 2], [2, 4, 6]]).T\n \n     # if one transformer is dropped, test that name is still correct\n@@ -278,13 +307,6 @@ def transform(self, X, y=None):\n def test_2D_transformer_output_pandas():\n     pd = pytest.importorskip('pandas')\n \n-    class TransNo2D(BaseEstimator):\n-        def fit(self, X, y=None):\n-            return self\n-\n-        def transform(self, X, y=None):\n-            return X\n-\n     X_array = np.array([[0, 1, 2], [2, 4, 6]]).T\n     X_df = pd.DataFrame(X_array, columns=['col1', 'col2'])\n \n@@ -344,10 +366,8 @@ def test_make_column_transformer_kwargs():\n     norm = Normalizer()\n     ct = make_column_transformer(('first', scaler), (['second'], norm),\n                                  n_jobs=3, remainder='drop')\n-    assert_equal(\n-        ct.transformers,\n-        make_column_transformer(('first', scaler),\n-                                (['second'], norm)).transformers)\n+    assert_equal(ct.transformers, make_column_transformer(\n+        ('first', scaler), (['second'], norm)).transformers)\n     assert_equal(ct.n_jobs, 3)\n     assert_equal(ct.remainder, 'drop')\n     # invalid keyword parameters should raise an error message\n@@ -359,6 +379,15 @@ def test_make_column_transformer_kwargs():\n     )\n \n \n+def test_make_column_transformer_remainder_transformer():\n+    scaler = StandardScaler()\n+    norm = Normalizer()\n+    remainder = StandardScaler()\n+    ct = make_column_transformer(('first', scaler), (['second'], norm),\n+                                 remainder=remainder)\n+    assert ct.remainder == remainder\n+\n+\n def test_column_transformer_get_set_params():\n     ct = ColumnTransformer([('trans1', StandardScaler(), [0]),\n                             ('trans2', StandardScaler(), [1])])\n@@ -473,12 +502,16 @@ def test_column_transformer_special_strings():\n     exp = np.array([[0.], [1.], [2.]])\n     assert_array_equal(ct.fit_transform(X_array), exp)\n     assert_array_equal(ct.fit(X_array).transform(X_array), exp)\n+    assert len(ct.transformers_) == 2\n+    assert ct.transformers_[-1][0] != 'remainder'\n \n     # all 'drop' -> return shape 0 array\n     ct = ColumnTransformer(\n         [('trans1', 'drop', [0]), ('trans2', 'drop', [1])])\n     assert_array_equal(ct.fit(X_array).transform(X_array).shape, (3, 0))\n     assert_array_equal(ct.fit_transform(X_array).shape, (3, 0))\n+    assert len(ct.transformers_) == 2\n+    assert ct.transformers_[-1][0] != 'remainder'\n \n     # 'passthrough'\n     X_array = np.array([[0., 1., 2.], [2., 4., 6.]]).T\n@@ -487,6 +520,8 @@ def test_column_transformer_special_strings():\n     exp = X_array\n     assert_array_equal(ct.fit_transform(X_array), exp)\n     assert_array_equal(ct.fit(X_array).transform(X_array), exp)\n+    assert len(ct.transformers_) == 2\n+    assert ct.transformers_[-1][0] != 'remainder'\n \n     # None itself / other string is not valid\n     for val in [None, 'other']:\n@@ -509,35 +544,51 @@ def test_column_transformer_remainder():\n     ct = ColumnTransformer([('trans', Trans(), [0])])\n     assert_array_equal(ct.fit_transform(X_array), X_res_both)\n     assert_array_equal(ct.fit(X_array).transform(X_array), X_res_both)\n+    assert len(ct.transformers_) == 2\n+    assert ct.transformers_[-1][0] == 'remainder'\n+    assert ct.transformers_[-1][1] == 'passthrough'\n+    assert_array_equal(ct.transformers_[-1][2], [1])\n \n     # specify to drop remaining columns\n     ct = ColumnTransformer([('trans1', Trans(), [0])],\n                            remainder='drop')\n     assert_array_equal(ct.fit_transform(X_array), X_res_first)\n     assert_array_equal(ct.fit(X_array).transform(X_array), X_res_first)\n+    assert len(ct.transformers_) == 2\n+    assert ct.transformers_[-1][0] == 'remainder'\n+    assert ct.transformers_[-1][1] == 'drop'\n+    assert_array_equal(ct.transformers_[-1][2], [1])\n \n     # column order is not preserved (passed through added to end)\n     ct = ColumnTransformer([('trans1', Trans(), [1])],\n                            remainder='passthrough')\n     assert_array_equal(ct.fit_transform(X_array), X_res_both[:, ::-1])\n     assert_array_equal(ct.fit(X_array).transform(X_array), X_res_both[:, ::-1])\n+    assert len(ct.transformers_) == 2\n+    assert ct.transformers_[-1][0] == 'remainder'\n+    assert ct.transformers_[-1][1] == 'passthrough'\n+    assert_array_equal(ct.transformers_[-1][2], [0])\n \n     # passthrough when all actual transformers are skipped\n     ct = ColumnTransformer([('trans1', 'drop', [0])],\n                            remainder='passthrough')\n     assert_array_equal(ct.fit_transform(X_array), X_res_second)\n     assert_array_equal(ct.fit(X_array).transform(X_array), X_res_second)\n+    assert len(ct.transformers_) == 2\n+    assert ct.transformers_[-1][0] == 'remainder'\n+    assert ct.transformers_[-1][1] == 'passthrough'\n+    assert_array_equal(ct.transformers_[-1][2], [1])\n \n     # error on invalid arg\n     ct = ColumnTransformer([('trans1', Trans(), [0])], remainder=1)\n     assert_raise_message(\n         ValueError,\n-        \"remainder keyword needs to be one of \\'drop\\' or \\'passthrough\\'\",\n-        ct.fit, X_array)\n+        \"remainder keyword needs to be one of \\'drop\\', \\'passthrough\\', \"\n+        \"or estimator.\", ct.fit, X_array)\n     assert_raise_message(\n         ValueError,\n-        \"remainder keyword needs to be one of \\'drop\\' or \\'passthrough\\'\",\n-        ct.fit_transform, X_array)\n+        \"remainder keyword needs to be one of \\'drop\\', \\'passthrough\\', \"\n+        \"or estimator.\", ct.fit_transform, X_array)\n \n \n @pytest.mark.parametrize(\"key\", [[0], np.array([0]), slice(0, 1),\n@@ -551,6 +602,10 @@ def test_column_transformer_remainder_numpy(key):\n                            remainder='passthrough')\n     assert_array_equal(ct.fit_transform(X_array), X_res_both)\n     assert_array_equal(ct.fit(X_array).transform(X_array), X_res_both)\n+    assert len(ct.transformers_) == 2\n+    assert ct.transformers_[-1][0] == 'remainder'\n+    assert ct.transformers_[-1][1] == 'passthrough'\n+    assert_array_equal(ct.transformers_[-1][2], [1])\n \n \n @pytest.mark.parametrize(\n@@ -571,3 +626,154 @@ def test_column_transformer_remainder_pandas(key):\n                            remainder='passthrough')\n     assert_array_equal(ct.fit_transform(X_df), X_res_both)\n     assert_array_equal(ct.fit(X_df).transform(X_df), X_res_both)\n+    assert len(ct.transformers_) == 2\n+    assert ct.transformers_[-1][0] == 'remainder'\n+    assert ct.transformers_[-1][1] == 'passthrough'\n+    assert_array_equal(ct.transformers_[-1][2], [1])\n+\n+\n+@pytest.mark.parametrize(\"key\", [[0], np.array([0]), slice(0, 1),\n+                                 np.array([True, False, False])])\n+def test_column_transformer_remainder_transformer(key):\n+    X_array = np.array([[0, 1, 2],\n+                        [2, 4, 6],\n+                        [8, 6, 4]]).T\n+    X_res_both = X_array.copy()\n+\n+    # second and third columns are doubled when remainder = DoubleTrans\n+    X_res_both[:, 1:3] *= 2\n+\n+    ct = ColumnTransformer([('trans1', Trans(), key)],\n+                           remainder=DoubleTrans())\n+\n+    assert_array_equal(ct.fit_transform(X_array), X_res_both)\n+    assert_array_equal(ct.fit(X_array).transform(X_array), X_res_both)\n+    assert len(ct.transformers_) == 2\n+    assert ct.transformers_[-1][0] == 'remainder'\n+    assert isinstance(ct.transformers_[-1][1], DoubleTrans)\n+    assert_array_equal(ct.transformers_[-1][2], [1, 2])\n+\n+\n+def test_column_transformer_no_remaining_remainder_transformer():\n+    X_array = np.array([[0, 1, 2],\n+                        [2, 4, 6],\n+                        [8, 6, 4]]).T\n+\n+    ct = ColumnTransformer([('trans1', Trans(), [0, 1, 2])],\n+                           remainder=DoubleTrans())\n+\n+    assert_array_equal(ct.fit_transform(X_array), X_array)\n+    assert_array_equal(ct.fit(X_array).transform(X_array), X_array)\n+    assert len(ct.transformers_) == 1\n+    assert ct.transformers_[-1][0] != 'remainder'\n+\n+\n+def test_column_transformer_drops_all_remainder_transformer():\n+    X_array = np.array([[0, 1, 2],\n+                        [2, 4, 6],\n+                        [8, 6, 4]]).T\n+\n+    # columns are doubled when remainder = DoubleTrans\n+    X_res_both = 2 * X_array.copy()[:, 1:3]\n+\n+    ct = ColumnTransformer([('trans1', 'drop', [0])],\n+                           remainder=DoubleTrans())\n+\n+    assert_array_equal(ct.fit_transform(X_array), X_res_both)\n+    assert_array_equal(ct.fit(X_array).transform(X_array), X_res_both)\n+    assert len(ct.transformers_) == 2\n+    assert ct.transformers_[-1][0] == 'remainder'\n+    assert isinstance(ct.transformers_[-1][1], DoubleTrans)\n+    assert_array_equal(ct.transformers_[-1][2], [1, 2])\n+\n+\n+def test_column_transformer_sparse_remainder_transformer():\n+    X_array = np.array([[0, 1, 2],\n+                        [2, 4, 6],\n+                        [8, 6, 4]]).T\n+\n+    ct = ColumnTransformer([('trans1', Trans(), [0])],\n+                           remainder=SparseMatrixTrans())\n+\n+    X_trans = ct.fit_transform(X_array)\n+    assert sparse.issparse(X_trans)\n+    # SparseMatrixTrans creates 3 features for each column. There is\n+    # one column in ``transformers``, thus:\n+    assert X_trans.shape == (3, 3 + 1)\n+\n+    exp_array = np.hstack(\n+        (X_array[:, 0].reshape(-1, 1), np.eye(3)))\n+    assert_array_equal(X_trans.toarray(), exp_array)\n+    assert len(ct.transformers_) == 2\n+    assert ct.transformers_[-1][0] == 'remainder'\n+    assert isinstance(ct.transformers_[-1][1], SparseMatrixTrans)\n+    assert_array_equal(ct.transformers_[-1][2], [1, 2])\n+\n+\n+def test_column_transformer_drop_all_sparse_remainder_transformer():\n+    X_array = np.array([[0, 1, 2],\n+                        [2, 4, 6],\n+                        [8, 6, 4]]).T\n+    ct = ColumnTransformer([('trans1', 'drop', [0])],\n+                           remainder=SparseMatrixTrans())\n+\n+    X_trans = ct.fit_transform(X_array)\n+    assert sparse.issparse(X_trans)\n+\n+    #  SparseMatrixTrans creates 3 features for each column, thus:\n+    assert X_trans.shape == (3, 3)\n+    assert_array_equal(X_trans.toarray(), np.eye(3))\n+    assert len(ct.transformers_) == 2\n+    assert ct.transformers_[-1][0] == 'remainder'\n+    assert isinstance(ct.transformers_[-1][1], SparseMatrixTrans)\n+    assert_array_equal(ct.transformers_[-1][2], [1, 2])\n+\n+\n+def test_column_transformer_get_set_params_with_remainder():\n+    ct = ColumnTransformer([('trans1', StandardScaler(), [0])],\n+                           remainder=StandardScaler())\n+\n+    exp = {'n_jobs': 1,\n+           'remainder': ct.remainder,\n+           'remainder__copy': True,\n+           'remainder__with_mean': True,\n+           'remainder__with_std': True,\n+           'trans1': ct.transformers[0][1],\n+           'trans1__copy': True,\n+           'trans1__with_mean': True,\n+           'trans1__with_std': True,\n+           'transformers': ct.transformers,\n+           'transformer_weights': None}\n+\n+    assert ct.get_params() == exp\n+\n+    ct.set_params(remainder__with_std=False)\n+    assert not ct.get_params()['remainder__with_std']\n+\n+    ct.set_params(trans1='passthrough')\n+    exp = {'n_jobs': 1,\n+           'remainder': ct.remainder,\n+           'remainder__copy': True,\n+           'remainder__with_mean': True,\n+           'remainder__with_std': False,\n+           'trans1': 'passthrough',\n+           'transformers': ct.transformers,\n+           'transformer_weights': None}\n+\n+    assert ct.get_params() == exp\n+\n+\n+def test_column_transformer_no_estimators():\n+    X_array = np.array([[0, 1, 2],\n+                        [2, 4, 6],\n+                        [8, 6, 4]]).astype('float').T\n+    ct = ColumnTransformer([], remainder=StandardScaler())\n+\n+    params = ct.get_params()\n+    assert params['remainder__with_mean']\n+\n+    X_trans = ct.fit_transform(X_array)\n+    assert X_trans.shape == X_array.shape\n+    assert len(ct.transformers_) == 1\n+    assert ct.transformers_[-1][0] == 'remainder'\n+    assert ct.transformers_[-1][2] == [0, 1, 2]\n",
  "problem_statement": "_BaseCompostion._set_params broken where there are no estimators\n`_BaseCompostion._set_params` raises an error when the composition has no estimators.\r\n\r\nThis is a marginal case, but it might be interesting to support alongside #11315.\r\n\r\n\r\n```py\r\n>>> from sklearn.compose import ColumnTransformer\r\n>>> ColumnTransformer([]).set_params(n_jobs=2)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/Users/joel/repos/scikit-learn/sklearn/compose/_column_transformer.py\", line 181, in set_params\r\n    self._set_params('_transformers', **kwargs)\r\n  File \"/Users/joel/repos/scikit-learn/sklearn/utils/metaestimators.py\", line 44, in _set_params\r\n    names, _ = zip(*getattr(self, attr))\r\nValueError: not enough values to unpack (expected 2, got 0)\r\n```\n",
  "hints_text": "",
  "created_at": "2018-06-18T19:56:04Z",
  "version": "0.20",
  "FAIL_TO_PASS": "[\"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_dataframe\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder_numpy[key0]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder_numpy[key1]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder_numpy[key2]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder_numpy[key3]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder_pandas[key0]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder_pandas[key1]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder_pandas[key2]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder_pandas[key3]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder_pandas[pd-index]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder_pandas[key5]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder_pandas[key6]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder_pandas[key7]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder_pandas[key8]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder_transformer[key0]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder_transformer[key1]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder_transformer[key2]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_remainder_transformer[key3]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_no_remaining_remainder_transformer\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_drops_all_remainder_transformer\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_sparse_remainder_transformer\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_drop_all_sparse_remainder_transformer\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_get_set_params_with_remainder\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_no_estimators\"]",
  "PASS_TO_PASS": "[\"sklearn/compose/tests/test_column_transformer.py::test_column_transformer\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_sparse_array\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_sparse_stacking\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_error_msg_1D\", \"sklearn/compose/tests/test_column_transformer.py::test_2D_transformer_output\", \"sklearn/compose/tests/test_column_transformer.py::test_2D_transformer_output_pandas\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_invalid_columns[drop]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_invalid_columns[passthrough]\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_invalid_transformer\", \"sklearn/compose/tests/test_column_transformer.py::test_make_column_transformer\", \"sklearn/compose/tests/test_column_transformer.py::test_make_column_transformer_kwargs\", \"sklearn/compose/tests/test_column_transformer.py::test_make_column_transformer_remainder_transformer\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_get_set_params\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_named_estimators\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_cloning\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_get_feature_names\", \"sklearn/compose/tests/test_column_transformer.py::test_column_transformer_special_strings\"]",
  "environment_setup_commit": "55bf5d93e5674f13a1134d93a11fd0cd11aabcd1",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.961628",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}