{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-23099",
  "base_commit": "42d235924efa64987a19e945035c85414c53d4f0",
  "patch": "diff --git a/sklearn/gaussian_process/_gpr.py b/sklearn/gaussian_process/_gpr.py\n--- a/sklearn/gaussian_process/_gpr.py\n+++ b/sklearn/gaussian_process/_gpr.py\n@@ -110,6 +110,14 @@ def optimizer(obj_func, initial_theta, bounds):\n         which might cause predictions to change if the data is modified\n         externally.\n \n+    n_targets : int, default=None\n+        The number of dimensions of the target values. Used to decide the number\n+        of outputs when sampling from the prior distributions (i.e. calling\n+        :meth:`sample_y` before :meth:`fit`). This parameter is ignored once\n+        :meth:`fit` has been called.\n+\n+        .. versionadded:: 1.3\n+\n     random_state : int, RandomState instance or None, default=None\n         Determines random number generation used to initialize the centers.\n         Pass an int for reproducible results across multiple function calls.\n@@ -181,6 +189,7 @@ def optimizer(obj_func, initial_theta, bounds):\n         \"n_restarts_optimizer\": [Interval(Integral, 0, None, closed=\"left\")],\n         \"normalize_y\": [\"boolean\"],\n         \"copy_X_train\": [\"boolean\"],\n+        \"n_targets\": [Interval(Integral, 1, None, closed=\"left\"), None],\n         \"random_state\": [\"random_state\"],\n     }\n \n@@ -193,6 +202,7 @@ def __init__(\n         n_restarts_optimizer=0,\n         normalize_y=False,\n         copy_X_train=True,\n+        n_targets=None,\n         random_state=None,\n     ):\n         self.kernel = kernel\n@@ -201,6 +211,7 @@ def __init__(\n         self.n_restarts_optimizer = n_restarts_optimizer\n         self.normalize_y = normalize_y\n         self.copy_X_train = copy_X_train\n+        self.n_targets = n_targets\n         self.random_state = random_state\n \n     def fit(self, X, y):\n@@ -243,6 +254,13 @@ def fit(self, X, y):\n             dtype=dtype,\n         )\n \n+        n_targets_seen = y.shape[1] if y.ndim > 1 else 1\n+        if self.n_targets is not None and n_targets_seen != self.n_targets:\n+            raise ValueError(\n+                \"The number of targets seen in `y` is different from the parameter \"\n+                f\"`n_targets`. Got {n_targets_seen} != {self.n_targets}.\"\n+            )\n+\n         # Normalize target value\n         if self.normalize_y:\n             self._y_train_mean = np.mean(y, axis=0)\n@@ -393,12 +411,23 @@ def predict(self, X, return_std=False, return_cov=False):\n                 )\n             else:\n                 kernel = self.kernel\n-            y_mean = np.zeros(X.shape[0])\n+\n+            n_targets = self.n_targets if self.n_targets is not None else 1\n+            y_mean = np.zeros(shape=(X.shape[0], n_targets)).squeeze()\n+\n             if return_cov:\n                 y_cov = kernel(X)\n+                if n_targets > 1:\n+                    y_cov = np.repeat(\n+                        np.expand_dims(y_cov, -1), repeats=n_targets, axis=-1\n+                    )\n                 return y_mean, y_cov\n             elif return_std:\n                 y_var = kernel.diag(X)\n+                if n_targets > 1:\n+                    y_var = np.repeat(\n+                        np.expand_dims(y_var, -1), repeats=n_targets, axis=-1\n+                    )\n                 return y_mean, np.sqrt(y_var)\n             else:\n                 return y_mean\n",
  "test_patch": "diff --git a/sklearn/gaussian_process/tests/test_gpr.py b/sklearn/gaussian_process/tests/test_gpr.py\n--- a/sklearn/gaussian_process/tests/test_gpr.py\n+++ b/sklearn/gaussian_process/tests/test_gpr.py\n@@ -773,6 +773,57 @@ def test_sample_y_shapes(normalize_y, n_targets):\n     assert y_samples.shape == y_test_shape\n \n \n+@pytest.mark.parametrize(\"n_targets\", [None, 1, 2, 3])\n+@pytest.mark.parametrize(\"n_samples\", [1, 5])\n+def test_sample_y_shape_with_prior(n_targets, n_samples):\n+    \"\"\"Check the output shape of `sample_y` is consistent before and after `fit`.\"\"\"\n+    rng = np.random.RandomState(1024)\n+\n+    X = rng.randn(10, 3)\n+    y = rng.randn(10, n_targets if n_targets is not None else 1)\n+\n+    model = GaussianProcessRegressor(n_targets=n_targets)\n+    shape_before_fit = model.sample_y(X, n_samples=n_samples).shape\n+    model.fit(X, y)\n+    shape_after_fit = model.sample_y(X, n_samples=n_samples).shape\n+    assert shape_before_fit == shape_after_fit\n+\n+\n+@pytest.mark.parametrize(\"n_targets\", [None, 1, 2, 3])\n+def test_predict_shape_with_prior(n_targets):\n+    \"\"\"Check the output shape of `predict` with prior distribution.\"\"\"\n+    rng = np.random.RandomState(1024)\n+\n+    n_sample = 10\n+    X = rng.randn(n_sample, 3)\n+    y = rng.randn(n_sample, n_targets if n_targets is not None else 1)\n+\n+    model = GaussianProcessRegressor(n_targets=n_targets)\n+    mean_prior, cov_prior = model.predict(X, return_cov=True)\n+    _, std_prior = model.predict(X, return_std=True)\n+\n+    model.fit(X, y)\n+    mean_post, cov_post = model.predict(X, return_cov=True)\n+    _, std_post = model.predict(X, return_std=True)\n+\n+    assert mean_prior.shape == mean_post.shape\n+    assert cov_prior.shape == cov_post.shape\n+    assert std_prior.shape == std_post.shape\n+\n+\n+def test_n_targets_error():\n+    \"\"\"Check that an error is raised when the number of targets seen at fit is\n+    inconsistent with n_targets.\n+    \"\"\"\n+    rng = np.random.RandomState(0)\n+    X = rng.randn(10, 3)\n+    y = rng.randn(10, 2)\n+\n+    model = GaussianProcessRegressor(n_targets=1)\n+    with pytest.raises(ValueError, match=\"The number of targets seen in `y`\"):\n+        model.fit(X, y)\n+\n+\n class CustomKernel(C):\n     \"\"\"\n     A custom kernel that has a diag method that returns the first column of the\n",
  "problem_statement": "GPR `sample_y` enforce `n_targets=1` before calling `fit`\nIn `GaussianProcessRegressor`, sampling in the prior before calling `fit` via `sample_y` will assume that `y` is made of a single target. However, this is not necessarily the case. Therefore, the shape of the output of `sample_y` before and after `fit` is different.\r\n\r\nIn order to solve this inconsistency, we need to introduce a new parameter `n_targets=None`. Before calling `fit` this parameter should be explicitly set by the user. After `fit`, we can use the information of the target seen during `fit` without explicitly setting the parameter.\n",
  "hints_text": "I see that we have the same issue with `predict` indeed.",
  "created_at": "2022-04-10T13:13:15Z",
  "version": "1.3",
  "FAIL_TO_PASS": "[\"sklearn/gaussian_process/tests/test_gpr.py::test_sample_y_shape_with_prior[1-None]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_y_shape_with_prior[1-1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_y_shape_with_prior[1-2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_y_shape_with_prior[1-3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_y_shape_with_prior[5-None]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_y_shape_with_prior[5-1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_y_shape_with_prior[5-2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_y_shape_with_prior[5-3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_shape_with_prior[None]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_shape_with_prior[1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_shape_with_prior[2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_shape_with_prior[3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_n_targets_error\"]",
  "PASS_TO_PASS": "[\"sklearn/gaussian_process/tests/test_gpr.py::test_gpr_interpolation[kernel0]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_gpr_interpolation[kernel1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_gpr_interpolation[kernel2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_gpr_interpolation[kernel3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_gpr_interpolation[kernel4]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_gpr_interpolation[kernel5]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_gpr_interpolation_structured\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_improving[kernel0]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_improving[kernel1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_improving[kernel2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_improving[kernel3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_improving[kernel4]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_precomputed[kernel0]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_precomputed[kernel1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_precomputed[kernel2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_precomputed[kernel3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_precomputed[kernel4]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_precomputed[kernel5]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_without_cloning_kernel[kernel0]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_without_cloning_kernel[kernel1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_without_cloning_kernel[kernel2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_without_cloning_kernel[kernel3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_without_cloning_kernel[kernel4]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_without_cloning_kernel[kernel5]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_converged_to_local_maximum[kernel0]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_converged_to_local_maximum[kernel1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_converged_to_local_maximum[kernel2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_converged_to_local_maximum[kernel3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_converged_to_local_maximum[kernel4]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_solution_inside_bounds[kernel0]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_solution_inside_bounds[kernel1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_solution_inside_bounds[kernel2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_solution_inside_bounds[kernel3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_solution_inside_bounds[kernel4]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_gradient[kernel0]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_gradient[kernel1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_gradient[kernel2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_gradient[kernel3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_gradient[kernel4]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_lml_gradient[kernel5]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_prior[kernel0]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_prior[kernel1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_prior[kernel2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_prior[kernel3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_prior[kernel4]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_prior[kernel5]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_statistics[kernel0]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_statistics[kernel1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_statistics[kernel2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_statistics[kernel3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_statistics[kernel4]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_statistics[kernel5]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_no_optimizer\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_cov_vs_std[target0-kernel0]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_cov_vs_std[target0-kernel1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_cov_vs_std[target0-kernel2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_cov_vs_std[target0-kernel3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_cov_vs_std[target0-kernel4]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_cov_vs_std[target0-kernel5]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_cov_vs_std[target1-kernel0]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_cov_vs_std[target1-kernel1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_cov_vs_std[target1-kernel2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_cov_vs_std[target1-kernel3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_cov_vs_std[target1-kernel4]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_cov_vs_std[target1-kernel5]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_anisotropic_kernel\", \"sklearn/gaussian_process/tests/test_gpr.py::test_random_starts\", \"sklearn/gaussian_process/tests/test_gpr.py::test_y_normalization[kernel0]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_y_normalization[kernel1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_y_normalization[kernel2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_y_normalization[kernel3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_y_normalization[kernel4]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_y_normalization[kernel5]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_large_variance_y\", \"sklearn/gaussian_process/tests/test_gpr.py::test_y_multioutput\", \"sklearn/gaussian_process/tests/test_gpr.py::test_custom_optimizer[kernel0]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_custom_optimizer[kernel1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_custom_optimizer[kernel2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_custom_optimizer[kernel3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_custom_optimizer[kernel4]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_gpr_correct_error_message\", \"sklearn/gaussian_process/tests/test_gpr.py::test_duplicate_input[kernel0]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_duplicate_input[kernel1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_duplicate_input[kernel2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_duplicate_input[kernel3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_duplicate_input[kernel4]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_duplicate_input[kernel5]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_no_fit_default_predict\", \"sklearn/gaussian_process/tests/test_gpr.py::test_warning_bounds\", \"sklearn/gaussian_process/tests/test_gpr.py::test_bound_check_fixed_hyperparameter\", \"sklearn/gaussian_process/tests/test_gpr.py::test_constant_target[kernel0]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_constant_target[kernel1]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_constant_target[kernel2]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_constant_target[kernel3]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_constant_target[kernel4]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_constant_target[kernel5]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_gpr_consistency_std_cov_non_invertible_kernel\", \"sklearn/gaussian_process/tests/test_gpr.py::test_gpr_fit_error[params0-ValueError-alpha\", \"sklearn/gaussian_process/tests/test_gpr.py::test_gpr_fit_error[params1-ValueError-requires\", \"sklearn/gaussian_process/tests/test_gpr.py::test_gpr_lml_error\", \"sklearn/gaussian_process/tests/test_gpr.py::test_gpr_predict_error\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_shapes[None-True]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_shapes[None-False]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_shapes[1-True]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_shapes[1-False]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_shapes[10-True]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_predict_shapes[10-False]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_y_shapes[None-True]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_y_shapes[None-False]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_y_shapes[1-True]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_y_shapes[1-False]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_y_shapes[10-True]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_sample_y_shapes[10-False]\", \"sklearn/gaussian_process/tests/test_gpr.py::test_gpr_predict_input_not_modified\"]",
  "environment_setup_commit": "1e8a5b833d1b58f3ab84099c4582239af854b23a",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.014557",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}