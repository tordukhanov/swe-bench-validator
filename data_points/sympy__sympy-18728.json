{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-18728",
  "base_commit": "e33d341aa8423c58ddb3d441955108eefbe12a2e",
  "patch": "diff --git a/sympy/core/power.py b/sympy/core/power.py\n--- a/sympy/core/power.py\n+++ b/sympy/core/power.py\n@@ -561,18 +561,20 @@ def _eval_is_zero(self):\n             elif self.exp.is_extended_nonpositive:\n                 return False\n         elif self.base.is_zero is False:\n-            if self.exp.is_negative:\n+            if self.base.is_finite and self.exp.is_finite:\n+                return False\n+            elif self.exp.is_negative:\n                 return self.base.is_infinite\n             elif self.exp.is_nonnegative:\n                 return False\n-            elif self.exp.is_infinite:\n+            elif self.exp.is_infinite and self.exp.is_extended_real:\n                 if (1 - abs(self.base)).is_extended_positive:\n                     return self.exp.is_extended_positive\n                 elif (1 - abs(self.base)).is_extended_negative:\n                     return self.exp.is_extended_negative\n-        else:\n-            # when self.base.is_zero is None\n-            return None\n+        else: # when self.base.is_zero is None\n+            if self.base.is_finite and self.exp.is_negative:\n+                return False\n \n     def _eval_is_integer(self):\n         b, e = self.args\n@@ -647,7 +649,8 @@ def _eval_is_extended_real(self):\n \n         if real_b is False:  # we already know it's not imag\n             i = arg(self.base)*self.exp/S.Pi\n-            return i.is_integer\n+            if i.is_complex: # finite\n+                return i.is_integer\n \n     def _eval_is_complex(self):\n \n",
  "test_patch": "diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1200,6 +1200,108 @@ def test_Pow_is_zero():\n     assert Pow(S.Half, oo, evaluate=False).is_zero\n     assert Pow(S.Half, -oo, evaluate=False).is_zero is False\n \n+    # All combinations of real/complex base/exponent\n+    h = S.Half\n+    T = True\n+    F = False\n+    N = None\n+\n+    pow_iszero = [\n+        ['**',  0,  h,  1,  2, -h, -1,-2,-2*I,-I/2,I/2,1+I,oo,-oo,zoo],\n+        [   0,  F,  T,  T,  T,  F,  F,  F,  F,  F,  F,  N,  T,  F,  N],\n+        [   h,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  F,  N],\n+        [   1,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  N],\n+        [   2,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  N],\n+        [  -h,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  F,  N],\n+        [  -1,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  N],\n+        [  -2,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  N],\n+        [-2*I,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  N],\n+        [-I/2,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  F,  N],\n+        [ I/2,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  F,  N],\n+        [ 1+I,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  N],\n+        [  oo,  F,  F,  F,  F,  T,  T,  T,  F,  F,  F,  F,  F,  T,  N],\n+        [ -oo,  F,  F,  F,  F,  T,  T,  T,  F,  F,  F,  F,  F,  T,  N],\n+        [ zoo,  F,  F,  F,  F,  T,  T,  T,  N,  N,  N,  N,  F,  T,  N]\n+    ]\n+\n+    def test_table(table):\n+        n = len(table[0])\n+        for row in range(1, n):\n+            base = table[row][0]\n+            for col in range(1, n):\n+                exp = table[0][col]\n+                is_zero = table[row][col]\n+                # The actual test here:\n+                assert Pow(base, exp, evaluate=False).is_zero is is_zero\n+\n+    test_table(pow_iszero)\n+\n+    # A zero symbol...\n+    zo, zo2 = symbols('zo, zo2', zero=True)\n+\n+    # All combinations of finite symbols\n+    zf, zf2 = symbols('zf, zf2', finite=True)\n+    wf, wf2 = symbols('wf, wf2', nonzero=True)\n+    xf, xf2 = symbols('xf, xf2', real=True)\n+    yf, yf2 = symbols('yf, yf2', nonzero=True)\n+    af, af2 = symbols('af, af2', positive=True)\n+    bf, bf2 = symbols('bf, bf2', nonnegative=True)\n+    cf, cf2 = symbols('cf, cf2', negative=True)\n+    df, df2 = symbols('df, df2', nonpositive=True)\n+\n+    # Without finiteness:\n+    zi, zi2 = symbols('zi, zi2')\n+    wi, wi2 = symbols('wi, wi2', zero=False)\n+    xi, xi2 = symbols('xi, xi2', extended_real=True)\n+    yi, yi2 = symbols('yi, yi2', zero=False, extended_real=True)\n+    ai, ai2 = symbols('ai, ai2', extended_positive=True)\n+    bi, bi2 = symbols('bi, bi2', extended_nonnegative=True)\n+    ci, ci2 = symbols('ci, ci2', extended_negative=True)\n+    di, di2 = symbols('di, di2', extended_nonpositive=True)\n+\n+    pow_iszero_sym = [\n+        ['**',zo,wf,yf,af,cf,zf,xf,bf,df,zi,wi,xi,yi,ai,bi,ci,di],\n+        [ zo2, F, N, N, T, F, N, N, N, F, N, N, N, N, T, N, F, F],\n+        [ wf2, F, F, F, F, F, F, F, F, F, N, N, N, N, N, N, N, N],\n+        [ yf2, F, F, F, F, F, F, F, F, F, N, N, N, N, N, N, N, N],\n+        [ af2, F, F, F, F, F, F, F, F, F, N, N, N, N, N, N, N, N],\n+        [ cf2, F, F, F, F, F, F, F, F, F, N, N, N, N, N, N, N, N],\n+        [ zf2, N, N, N, N, F, N, N, N, N, N, N, N, N, N, N, N, N],\n+        [ xf2, N, N, N, N, F, N, N, N, N, N, N, N, N, N, N, N, N],\n+        [ bf2, N, N, N, N, F, N, N, N, N, N, N, N, N, N, N, N, N],\n+        [ df2, N, N, N, N, F, N, N, N, N, N, N, N, N, N, N, N, N],\n+        [ zi2, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N],\n+        [ wi2, F, N, N, F, N, N, N, F, N, N, N, N, N, N, N, N, N],\n+        [ xi2, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N],\n+        [ yi2, F, N, N, F, N, N, N, F, N, N, N, N, N, N, N, N, N],\n+        [ ai2, F, N, N, F, N, N, N, F, N, N, N, N, N, N, N, N, N],\n+        [ bi2, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N],\n+        [ ci2, F, N, N, F, N, N, N, F, N, N, N, N, N, N, N, N, N],\n+        [ di2, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N]\n+    ]\n+\n+    test_table(pow_iszero_sym)\n+\n+    # In some cases (x**x).is_zero is different from (x**y).is_zero even if y\n+    # has the same assumptions as x.\n+    assert (zo ** zo).is_zero is False\n+    assert (wf ** wf).is_zero is False\n+    assert (yf ** yf).is_zero is False\n+    assert (af ** af).is_zero is False\n+    assert (cf ** cf).is_zero is False\n+    assert (zf ** zf).is_zero is None\n+    assert (xf ** xf).is_zero is None\n+    assert (bf ** bf).is_zero is False # None in table\n+    assert (df ** df).is_zero is None\n+    assert (zi ** zi).is_zero is None\n+    assert (wi ** wi).is_zero is None\n+    assert (xi ** xi).is_zero is None\n+    assert (yi ** yi).is_zero is None\n+    assert (ai ** ai).is_zero is False # None in table\n+    assert (bi ** bi).is_zero is False # None in table\n+    assert (ci ** ci).is_zero is None\n+    assert (di ** di).is_zero is None\n+\n \n def test_Pow_is_nonpositive_nonnegative():\n     x = Symbol('x', real=True)\n",
  "problem_statement": "Fix is_zero and is_positive for Pow\n<!-- Your title above should be a short description of what\r\nwas changed. Do not include the issue number in the title. -->\r\n\r\n#### References to other Issues or PRs\r\n<!-- If this pull request fixes an issue, write \"Fixes #NNNN\" in that exact\r\nformat, e.g. \"Fixes #1234\". See\r\nhttps://github.com/blog/1506-closing-issues-via-pull-requests . Please also\r\nwrite a comment on that issue linking back to this pull request once it is\r\nopen. -->\r\n\r\nFixes #9532 \r\n\r\n#### Brief description of what is fixed or changed\r\n\r\nStill a work in progress. This attempts to get Pow.is_zero working in all cases.\r\n\r\nThis PR fixes Pow.is_zero so that it doesn't assume finiteness unless justified by assumptions. For example on master:\r\n```julia\r\nIn [1]: a, b = symbols('a b', positive=True)                                                                                                   \r\n\r\nIn [2]: print(a.is_finite)                                                                                                                     \r\nNone\r\n\r\nIn [3]: print(b.is_finite)                                                                                                                     \r\nNone\r\n\r\nIn [4]: print((a**b).is_zero)                                                                                                                  \r\nFalse\r\n```\r\nThis is incorrect because if a or b can be infinite then it is possible for `a**b` to be zero e.g. if\r\n1. a is infinite and b is negative\r\n2. abs(a)<1 and b is positive infinite (oo)\r\n3. abs(a)>1 and b is negative infinite (-oo)\r\n\r\nWith this PR we have\r\n```julia\r\nIn [1]: a, b = symbols('a b', positive=True)                                                                                                   \r\n\r\nIn [2]: print((a**b).is_zero)                                                                                                                  \r\nNone\r\n```\r\nmeaning that `a**b` could be zero or could not be zero.\r\n\r\nAlso on master we have\r\n```julia\r\nIn [1]: a, b = symbols('a b', positive=True)                                                                                                   \r\n\r\nIn [2]: (a**b).is_positive                                                                                                                     \r\nOut[2]: True\r\n```\r\nwhereas this PR gives `None` in that case since `a**b` could be zero and therefore not be positive.\r\n\r\nThis PR also fixes #9532 since\r\n```julia\r\nIn [3]: n = Symbol('n', real=True, finite=True)                                                                                                \r\n\r\nIn [4]: zoo / n                                                                                                                                \r\nOut[4]: zoo\r\n```\r\nThis comes from the fact that `(1/n)` is properly considered nonzero if `n` is declared as finite.\r\n\r\nAt the time of writing we still have this problem with the PR though:\r\n```julia\r\nIn [5]: n = Symbol('n', finite=True)                                                                                                           \r\n\r\nIn [6]: zoo / n                                                                                                                                \r\nOut[6]: \r\nzoo\r\n───\r\n n \r\n```\r\n\r\n#### Other comments\r\n\r\nI'm not sure that this PR should be merged as is. Many of the changes are adding `finite=True` flags that probably shouldn't be there. Those flags would not be necessary if the other assumptions implied finite=True. For example in some cases a symbol is declared as `integer=True` and with this PR I've had to add `finite=True` also.  Probably it would be better to fix those cases by having `integer --> finite` in the assumptions system. Most of the other cases are for symbols declared as `real=True` which could also be fixed.\r\n\r\nNow that I (hopefully) have the tests passing I still want to improve this PR by tidying up the implementation. Also it still doesn't work in all cases as the zoo/n example above shows.\r\n\r\nPerhaps instead of merging this I could build new PRs on top. One could add `Rational --> finite`. Then I could follow that with splitting real into extended_real and real and having `real --> finite` as well. That would be a big change though so maybe it would be better to merge this first.\r\n\r\n#### Release Notes\r\n\r\n<!-- Write the release notes for this release below. See\r\nhttps://github.com/sympy/sympy/wiki/Writing-Release-Notes for more information\r\non how to write release notes. The bot will check your release notes\r\nautomatically to see if they are formatted correctly. -->\r\n\r\n<!-- BEGIN RELEASE NOTES -->\r\n* core\r\n    * Fix is_zero assumptions for `a**b` and `a/b` when `a` or `b` could be infinite.\r\n<!-- END RELEASE NOTES -->\r\n\n",
  "hints_text": ":white_check_mark:\n\nHi, I am the [SymPy bot](https://github.com/sympy/sympy-bot) (v145). I'm here to help you write a release notes entry. Please read the [guide on how to write release notes](https://github.com/sympy/sympy/wiki/Writing-Release-Notes).\n\n\n\nYour release notes are in good order.\n\nHere is what the release notes will look like:\n* core\n  * Fix is_zero assumptions for `a**b` and `a/b` when `a` or `b` could be infinite. ([#16433](https://github.com/sympy/sympy/pull/16433) by [@oscarbenjamin](https://github.com/oscarbenjamin))\n\nThis will be added to https://github.com/sympy/sympy/wiki/Release-Notes-for-1.5.\n\nNote: This comment will be updated with the latest check if you edit the pull request. You need to reload the page to see it. <details><summary>Click here to see the pull request description that was parsed.</summary>\n\n    <!-- Your title above should be a short description of what\r\n    was changed. Do not include the issue number in the title. -->\r\n\r\n    #### References to other Issues or PRs\r\n    <!-- If this pull request fixes an issue, write \"Fixes #NNNN\" in that exact\r\n    format, e.g. \"Fixes #1234\". See\r\n    https://github.com/blog/1506-closing-issues-via-pull-requests . Please also\r\n    write a comment on that issue linking back to this pull request once it is\r\n    open. -->\r\n\r\n    Fixes #9532 \r\n\r\n    #### Brief description of what is fixed or changed\r\n\r\n    Still a work in progress. This attempts to get Pow.is_zero working in all cases.\r\n\r\n    This PR fixes Pow.is_zero so that it doesn't assume finiteness unless justified by assumptions. For example on master:\r\n    ```julia\r\n    In [1]: a, b = symbols('a b', positive=True)                                                                                                   \r\n\r\n    In [2]: print(a.is_finite)                                                                                                                     \r\n    None\r\n\r\n    In [3]: print(b.is_finite)                                                                                                                     \r\n    None\r\n\r\n    In [4]: print((a**b).is_zero)                                                                                                                  \r\n    False\r\n    ```\r\n    This is incorrect because if a or b can be infinite then it is possible for `a**b` to be zero e.g. if\r\n    1. a is infinite and b is negative\r\n    2. abs(a)<1 and b is positive infinite (oo)\r\n    3. abs(a)>1 and b is negative infinite (-oo)\r\n\r\n    With this PR we have\r\n    ```julia\r\n    In [1]: a, b = symbols('a b', positive=True)                                                                                                   \r\n\r\n    In [2]: print((a**b).is_zero)                                                                                                                  \r\n    None\r\n    ```\r\n    meaning that `a**b` could be zero or could not be zero.\r\n\r\n    Also on master we have\r\n    ```julia\r\n    In [1]: a, b = symbols('a b', positive=True)                                                                                                   \r\n\r\n    In [2]: (a**b).is_positive                                                                                                                     \r\n    Out[2]: True\r\n    ```\r\n    whereas this PR gives `None` in that case since `a**b` could be zero and therefore not be positive.\r\n\r\n    This PR also fixes #9532 since\r\n    ```julia\r\n    In [3]: n = Symbol('n', real=True, finite=True)                                                                                                \r\n\r\n    In [4]: zoo / n                                                                                                                                \r\n    Out[4]: zoo\r\n    ```\r\n    This comes from the fact that `(1/n)` is properly considered nonzero if `n` is declared as finite.\r\n\r\n    At the time of writing we still have this problem with the PR though:\r\n    ```julia\r\n    In [5]: n = Symbol('n', finite=True)                                                                                                           \r\n\r\n    In [6]: zoo / n                                                                                                                                \r\n    Out[6]: \r\n    zoo\r\n    ───\r\n     n \r\n    ```\r\n\r\n    #### Other comments\r\n\r\n    I'm not sure that this PR should be merged as is. Many of the changes are adding `finite=True` flags that probably shouldn't be there. Those flags would not be necessary if the other assumptions implied finite=True. For example in some cases a symbol is declared as `integer=True` and with this PR I've had to add `finite=True` also.  Probably it would be better to fix those cases by having `integer --> finite` in the assumptions system. Most of the other cases are for symbols declared as `real=True` which could also be fixed.\r\n\r\n    Now that I (hopefully) have the tests passing I still want to improve this PR by tidying up the implementation. Also it still doesn't work in all cases as the zoo/n example above shows.\r\n\r\n    Perhaps instead of merging this I could build new PRs on top. One could add `Rational --> finite`. Then I could follow that with splitting real into extended_real and real and having `real --> finite` as well. That would be a big change though so maybe it would be better to merge this first.\r\n\r\n    #### Release Notes\r\n\r\n    <!-- Write the release notes for this release below. See\r\n    https://github.com/sympy/sympy/wiki/Writing-Release-Notes for more information\r\n    on how to write release notes. The bot will check your release notes\r\n    automatically to see if they are formatted correctly. -->\r\n\r\n    <!-- BEGIN RELEASE NOTES -->\r\n    * core\r\n        * Fix is_zero assumptions for `a**b` and `a/b` when `a` or `b` could be infinite.\r\n    <!-- END RELEASE NOTES -->\r\n\n\n</details><p>\n\n# [Codecov](https://codecov.io/gh/sympy/sympy/pull/16433?src=pr&el=h1) Report\n> Merging [#16433](https://codecov.io/gh/sympy/sympy/pull/16433?src=pr&el=desc) into [master](https://codecov.io/gh/sympy/sympy/commit/61dd0c8d5de281988eab7668a76cba2088c57d7d?src=pr&el=desc) will **increase** coverage by `0.043%`.\n> The diff coverage is `86.419%`.\n\n```diff\n@@              Coverage Diff              @@\n##            master    #16433       +/-   ##\n=============================================\n+ Coverage   73.693%   73.736%   +0.043%     \n=============================================\n  Files          618       619        +1     \n  Lines       158567    158762      +195     \n  Branches     37224     37218        -6     \n=============================================\n+ Hits        116854    117066      +212     \n+ Misses       36300     36278       -22     \n- Partials      5413      5418        +5\n```\n\nThere seems to be an intermittent failure on Python 3.4 and 3.5 (most likely hash-seed dependent):\r\n```\r\n________________________________________________________________________________\r\n__________ sympy/series/tests/test_limitseq.py:test_alternating_sign ___________\r\nTraceback (most recent call last):\r\n  File \"/home/travis/virtualenv/python3.5.6/lib/python3.5/site-packages/sympy-1.5.dev0-py3.5.egg/sympy/utilities/runtests.py\", line 1306, in _timeout\r\n    function()\r\n  File \"/home/travis/virtualenv/python3.5.6/lib/python3.5/site-packages/sympy-1.5.dev0-py3.5.egg/sympy/series/tests/test_limitseq.py\", line 98, in test_alternating_sign\r\n    assert limit_seq(n/(n + 1) + (I/2)**n, n) == 1\r\n  File \"/home/travis/virtualenv/python3.5.6/lib/python3.5/site-packages/sympy-1.5.dev0-py3.5.egg/sympy/series/limitseq.py\", line 232, in limit_seq\r\n    L1 = _limit_seq(expr.xreplace({n: n_}), n_, trials)\r\n  File \"/home/travis/virtualenv/python3.5.6/lib/python3.5/site-packages/sympy-1.5.dev0-py3.5.egg/sympy/series/limitseq.py\", line 140, in _limit_seq\r\n    num = dominant(num, n)\r\n  File \"/home/travis/virtualenv/python3.5.6/lib/python3.5/site-packages/sympy-1.5.dev0-py3.5.egg/sympy/series/limitseq.py\", line 94, in dominant\r\n    l = limit_seq(e, n)\r\n  File \"/home/travis/virtualenv/python3.5.6/lib/python3.5/site-packages/sympy-1.5.dev0-py3.5.egg/sympy/series/limitseq.py\", line 232, in limit_seq\r\n    L1 = _limit_seq(expr.xreplace({n: n_}), n_, trials)\r\n  File \"/home/travis/virtualenv/python3.5.6/lib/python3.5/site-packages/sympy-1.5.dev0-py3.5.egg/sympy/series/limitseq.py\", line 119, in _limit_seq\r\n    result = _limit_inf(expr, n)\r\n  File \"/home/travis/virtualenv/python3.5.6/lib/python3.5/site-packages/sympy-1.5.dev0-py3.5.egg/sympy/series/limitseq.py\", line 109, in _limit_inf\r\n    return Limit(expr, n, S.Infinity).doit(deep=False)\r\n  File \"/home/travis/virtualenv/python3.5.6/lib/python3.5/site-packages/sympy-1.5.dev0-py3.5.egg/sympy/series/limits.py\", line 263, in doit\r\n    r = gruntz(e, z, z0, dir)\r\n  File \"/home/travis/virtualenv/python3.5.6/lib/python3.5/site-packages/sympy-1.5.dev0-py3.5.egg/sympy/series/gruntz.py\", line 646, in gruntz\r\n    r = limitinf(e, z)\r\n  File \"/home/travis/virtualenv/python3.5.6/lib/python3.5/site-packages/sympy-1.5.dev0-py3.5.egg/sympy/series/gruntz.py\", line 426, in limitinf\r\n    c0, e0 = mrv_leadterm(e, x)\r\n  File \"/home/travis/virtualenv/python3.5.6/lib/python3.5/site-packages/sympy-1.5.dev0-py3.5.egg/sympy/series/gruntz.py\", line 485, in mrv_leadterm\r\n    Omega, exps = mrv(e, x)\r\n  File \"/home/travis/virtualenv/python3.5.6/lib/python3.5/site-packages/sympy-1.5.dev0-py3.5.egg/sympy/series/gruntz.py\", line 244, in mrv\r\n    e = powsimp(e, deep=True, combine='exp')\r\n  File \"/home/travis/virtualenv/python3.5.6/lib/python3.5/site-packages/sympy-1.5.dev0-py3.5.egg/sympy/simplify/powsimp.py\", line 363, in powsimp\r\n    assert len(c_powers) == check  # there should have been no duplicates\r\nAssertionError\r\n```\nI've filled in the PR description and (hopefully) fixed all test failures. I'm not sure if this should be merged or built on further.",
  "created_at": "2020-02-25T21:53:01Z",
  "version": "1.6",
  "FAIL_TO_PASS": "[\"test_Pow_is_zero\"]",
  "PASS_TO_PASS": "[\"test_bug1\", \"test_Symbol\", \"test_arit0\", \"test_div\", \"test_pow\", \"test_pow2\", \"test_pow3\", \"test_mod_pow\", \"test_pow_E\", \"test_pow_issue_3516\", \"test_pow_im\", \"test_real_mul\", \"test_ncmul\", \"test_ncpow\", \"test_powerbug\", \"test_Mul_doesnt_expand_exp\", \"test_Add_Mul_is_integer\", \"test_Add_Mul_is_finite\", \"test_Mul_is_even_odd\", \"test_evenness_in_ternary_integer_product_with_even\", \"test_oddness_in_ternary_integer_product_with_even\", \"test_Mul_is_rational\", \"test_Add_is_rational\", \"test_Add_is_even_odd\", \"test_Mul_is_negative_positive\", \"test_Mul_is_negative_positive_2\", \"test_Mul_is_nonpositive_nonnegative\", \"test_Add_is_negative_positive\", \"test_Add_is_nonpositive_nonnegative\", \"test_Pow_is_integer\", \"test_Pow_is_real\", \"test_real_Pow\", \"test_Pow_is_finite\", \"test_Pow_is_even_odd\", \"test_Pow_is_negative_positive\", \"test_Pow_is_nonpositive_nonnegative\", \"test_Mul_is_imaginary_real\", \"test_Mul_hermitian_antihermitian\", \"test_Add_is_comparable\", \"test_Mul_is_comparable\", \"test_Pow_is_comparable\", \"test_Add_is_positive_2\", \"test_Add_is_irrational\", \"test_Mul_is_irrational\", \"test_issue_3531b\", \"test_bug3\", \"test_suppressed_evaluation\", \"test_Add_as_coeff_mul\", \"test_Pow_as_coeff_mul_doesnt_expand\", \"test_issue_3514_18626\", \"test_make_args\", \"test_issue_5126\", \"test_Rational_as_content_primitive\", \"test_Add_as_content_primitive\", \"test_Mul_as_content_primitive\", \"test_Pow_as_content_primitive\", \"test_issue_5460\", \"test_product_irrational\", \"test_issue_5919\", \"test_Mod\", \"test_Mod_Pow\", \"test_Mod_is_integer\", \"test_Mod_is_nonposneg\", \"test_issue_6001\", \"test_polar\", \"test_issue_6040\", \"test_issue_6082\", \"test_issue_6077\", \"test_mul_flatten_oo\", \"test_add_flatten\", \"test_issue_5160_6087_6089_6090\", \"test_float_int_round\", \"test_issue_6611a\", \"test_denest_add_mul\", \"test_mul_coeff\", \"test_mul_zero_detection\", \"test_Mul_with_zero_infinite\", \"test_Mul_does_not_cancel_infinities\", \"test_Mul_does_not_distribute_infinity\", \"test_issue_8247_8354\", \"test_Add_is_zero\", \"test_issue_14392\", \"test_divmod\", \"test__neg__\"]",
  "environment_setup_commit": "28b41c73c12b70d6ad9f6e45109a80649c4456da",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.126391",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}