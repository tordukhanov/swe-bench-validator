{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-13143",
  "base_commit": "fc65d9ff6ba79c9fb7651a1a690059dc9538e4bc",
  "patch": "diff --git a/sklearn/metrics/classification.py b/sklearn/metrics/classification.py\n--- a/sklearn/metrics/classification.py\n+++ b/sklearn/metrics/classification.py\n@@ -922,6 +922,11 @@ def f1_score(y_true, y_pred, labels=None, pos_label=1, average='binary',\n     >>> f1_score(y_true, y_pred, average=None)\n     array([0.8, 0. , 0. ])\n \n+    Notes\n+    -----\n+    When ``true positive + false positive == 0`` or\n+    ``true positive + false negative == 0``, f-score returns 0 and raises\n+    ``UndefinedMetricWarning``.\n     \"\"\"\n     return fbeta_score(y_true, y_pred, 1, labels=labels,\n                        pos_label=pos_label, average=average,\n@@ -1036,6 +1041,11 @@ def fbeta_score(y_true, y_pred, beta, labels=None, pos_label=1,\n     ... # doctest: +ELLIPSIS\n     array([0.71..., 0.        , 0.        ])\n \n+    Notes\n+    -----\n+    When ``true positive + false positive == 0`` or\n+    ``true positive + false negative == 0``, f-score returns 0 and raises\n+    ``UndefinedMetricWarning``.\n     \"\"\"\n     _, _, f, _ = precision_recall_fscore_support(y_true, y_pred,\n                                                  beta=beta,\n@@ -1233,6 +1243,12 @@ def precision_recall_fscore_support(y_true, y_pred, beta=1.0, labels=None,\n      array([0., 0., 1.]), array([0. , 0. , 0.8]),\n      array([2, 2, 2]))\n \n+    Notes\n+    -----\n+    When ``true positive + false positive == 0``, precision is undefined;\n+    When ``true positive + false negative == 0``, recall is undefined.\n+    In such cases, the metric will be set to 0, as will f-score, and\n+    ``UndefinedMetricWarning`` will be raised.\n     \"\"\"\n     average_options = (None, 'micro', 'macro', 'weighted', 'samples')\n     if average not in average_options and average != 'binary':\n@@ -1247,13 +1263,9 @@ def precision_recall_fscore_support(y_true, y_pred, beta=1.0, labels=None,\n \n     if average == 'binary':\n         if y_type == 'binary':\n-            if pos_label not in present_labels:\n-                if len(present_labels) < 2:\n-                    # Only negative labels\n-                    return (0., 0., 0., 0)\n-                else:\n-                    raise ValueError(\"pos_label=%r is not a valid label: %r\" %\n-                                     (pos_label, present_labels))\n+            if pos_label not in present_labels and len(present_labels) >= 2:\n+                raise ValueError(\"pos_label=%r is not a valid label: %r\" %\n+                                 (pos_label, present_labels))\n             labels = [pos_label]\n         else:\n             raise ValueError(\"Target is %s but average='binary'. Please \"\n@@ -1279,7 +1291,6 @@ def precision_recall_fscore_support(y_true, y_pred, beta=1.0, labels=None,\n         true_sum = np.array([true_sum.sum()])\n \n     # Finally, we have all our sufficient statistics. Divide! #\n-\n     beta2 = beta ** 2\n     with np.errstate(divide='ignore', invalid='ignore'):\n         # Divide, and on zero-division, set scores to 0 and warn:\n@@ -1297,7 +1308,6 @@ def precision_recall_fscore_support(y_true, y_pred, beta=1.0, labels=None,\n         f_score[tp_sum == 0] = 0.0\n \n     # Average the results\n-\n     if average == 'weighted':\n         weights = true_sum\n         if weights.sum() == 0:\n@@ -1410,6 +1420,10 @@ def precision_score(y_true, y_pred, labels=None, pos_label=1,\n     >>> precision_score(y_true, y_pred, average=None)  # doctest: +ELLIPSIS\n     array([0.66..., 0.        , 0.        ])\n \n+    Notes\n+    -----\n+    When ``true positive + false positive == 0``, precision returns 0 and\n+    raises ``UndefinedMetricWarning``.\n     \"\"\"\n     p, _, _, _ = precision_recall_fscore_support(y_true, y_pred,\n                                                  labels=labels,\n@@ -1512,6 +1526,10 @@ def recall_score(y_true, y_pred, labels=None, pos_label=1, average='binary',\n     >>> recall_score(y_true, y_pred, average=None)\n     array([1., 0., 0.])\n \n+    Notes\n+    -----\n+    When ``true positive + false negative == 0``, recall returns 0 and raises\n+    ``UndefinedMetricWarning``.\n     \"\"\"\n     _, r, _, _ = precision_recall_fscore_support(y_true, y_pred,\n                                                  labels=labels,\n",
  "test_patch": "diff --git a/sklearn/metrics/tests/test_classification.py b/sklearn/metrics/tests/test_classification.py\n--- a/sklearn/metrics/tests/test_classification.py\n+++ b/sklearn/metrics/tests/test_classification.py\n@@ -198,6 +198,7 @@ def test_precision_recall_f1_score_binary():\n                             (1 + 2 ** 2) * ps * rs / (2 ** 2 * ps + rs), 2)\n \n \n+@ignore_warnings\n def test_precision_recall_f_binary_single_class():\n     # Test precision, recall and F1 score behave with a single positive or\n     # negative class\n@@ -1065,6 +1066,7 @@ def test_classification_report_no_labels_target_names_unequal_length():\n                          y_true, y_pred, target_names=target_names)\n \n \n+@ignore_warnings\n def test_multilabel_classification_report():\n     n_classes = 4\n     n_samples = 50\n@@ -1446,6 +1448,17 @@ def test_prf_warnings():\n            'being set to 0.0 due to no true samples.')\n     my_assert(w, msg, f, [-1, -1], [1, 1], average='binary')\n \n+    clean_warning_registry()\n+    with warnings.catch_warnings(record=True) as record:\n+        warnings.simplefilter('always')\n+        precision_recall_fscore_support([0, 0], [0, 0], average=\"binary\")\n+        msg = ('Recall and F-score are ill-defined and '\n+               'being set to 0.0 due to no true samples.')\n+        assert_equal(str(record.pop().message), msg)\n+        msg = ('Precision and F-score are ill-defined and '\n+               'being set to 0.0 due to no predicted samples.')\n+        assert_equal(str(record.pop().message), msg)\n+\n \n def test_recall_warnings():\n     assert_no_warnings(recall_score,\n@@ -1461,19 +1474,26 @@ def test_recall_warnings():\n         assert_equal(str(record.pop().message),\n                      'Recall is ill-defined and '\n                      'being set to 0.0 due to no true samples.')\n+        recall_score([0, 0], [0, 0])\n+        assert_equal(str(record.pop().message),\n+                     'Recall is ill-defined and '\n+                     'being set to 0.0 due to no true samples.')\n \n \n def test_precision_warnings():\n     clean_warning_registry()\n     with warnings.catch_warnings(record=True) as record:\n         warnings.simplefilter('always')\n-\n         precision_score(np.array([[1, 1], [1, 1]]),\n                         np.array([[0, 0], [0, 0]]),\n                         average='micro')\n         assert_equal(str(record.pop().message),\n                      'Precision is ill-defined and '\n                      'being set to 0.0 due to no predicted samples.')\n+        precision_score([0, 0], [0, 0])\n+        assert_equal(str(record.pop().message),\n+                     'Precision is ill-defined and '\n+                     'being set to 0.0 due to no predicted samples.')\n \n     assert_no_warnings(precision_score,\n                        np.array([[0, 0], [0, 0]]),\n@@ -1499,6 +1519,13 @@ def test_fscore_warnings():\n             assert_equal(str(record.pop().message),\n                          'F-score is ill-defined and '\n                          'being set to 0.0 due to no true samples.')\n+            score([0, 0], [0, 0])\n+            assert_equal(str(record.pop().message),\n+                         'F-score is ill-defined and '\n+                         'being set to 0.0 due to no true samples.')\n+            assert_equal(str(record.pop().message),\n+                         'F-score is ill-defined and '\n+                         'being set to 0.0 due to no predicted samples.')\n \n \n def test_prf_average_binary_data_non_binary():\n",
  "problem_statement": "precision_score shows incorrect value\n#### Description\r\nprecision_score shows incorrect value\r\n\r\n#### Steps/Code to Reproduce\r\n>>> A=np.array([[0,0,1],[0,1,0],[0,0,1]])\r\n>>> B=A\r\n>>> precision_score(A,B, average=None)\r\narray([ 0.,  1.,  1.])\r\n\r\n#### Expected Results\r\narray([ 1.,  1.,  1.])\r\n\r\n#### Actual Results\r\narray([ 0.,  1.,  1.])\r\n\r\n#### Versions\r\n>>> import platform; print(platform.platform())\r\nDarwin-14.5.0-x86_64-i386-64bit\r\n>>> import sys; print(\"Python\", sys.version)\r\n('Python', '2.7.10 (default, Jul 14 2015, 19:46:27) \\n[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.39)]')\r\n>>> import numpy; print(\"NumPy\", numpy.__version__)\r\n('NumPy', '1.13.3')\r\n>>> import scipy; print(\"SciPy\", scipy.__version__)\r\n('SciPy', '1.0.0')\r\n>>> import sklearn; print(\"Scikit-Learn\", sklearn.__version__)\r\n('Scikit-Learn', '0.18.1')\r\n\r\n\n",
  "hints_text": "You might have expected [nan, 1, 1,] too. We raise a warning to tell you that we will set it to 0.\nI think the problem is that we do not raise a warning when there's only negative labels. E.g.\r\n```python\r\nprecision_score([0, 0, 0], [0, 0, 0])\r\n```\r\nI vote for a warning to tell users that we set precision, recall, fbeta_score and support to 0 in this case. \nYes, that's an issue.\n\nBut that's not the issue here. The complaint is that if y_true and y_pred\nare equal, precision_score should always be 1.\nâ€‹\nA warning is indeed raised for the snippet presented in the issue\ndescription.\n\n> A warning is indeed raised for the snippet presented in the issue description.\r\n\r\nSorry, I haven't noticed that.\r\n\r\nSo my opinion here is:\r\n(1) Keep the current behavior as I suppose there's no clear definition of precision_score when there's only negative labels.\r\n(2) Also raise similar warning for ``precision_score([0, 0, 0], [0, 0, 0])``\nMaybe raising a warning like \"XXX is ill-defined and being set to 0.0 where there is only one label in both true and predicted samples.\" where XXX would be precision/recall/f_score and returning 0 could be added when there is only label in both y_true and y_pred.\r\n\r\nIt could be added right after this, when `present_labels.size == 1` and XXX would be determined by the argument  `warn_for`.\r\n\r\nhttps://github.com/scikit-learn/scikit-learn/blob/158c7a5ea71f96c3af0ea611304d57e4d2ba4994/sklearn/metrics/classification.py#L1027-L1030\nCurrently, `precision_score([0, 0, 0], [0, 0, 0])` returns 1. If 0 is returned, some tests fail (1 is expected) like test_averaging_multilabel_all_ones :\r\nhttps://github.com/scikit-learn/scikit-learn/blob/4e87d93ce6fae938aa366742732b59a730724c73/sklearn/metrics/tests/test_common.py#L937-L946\r\n\r\nand check_averaging calls _check_averaging :\r\nhttps://github.com/scikit-learn/scikit-learn/blob/4e87d93ce6fae938aa366742732b59a730724c73/sklearn/metrics/tests/test_common.py#L833-L838\r\n\r\nThe multilabel case returns 1 and the current binary case returns also 1 (and returns 0 if the changes are made).\r\n\r\nAre these tests supposed to be modified thus? @qinhanmin2014 ",
  "created_at": "2019-02-12T14:41:41Z",
  "version": "0.21",
  "FAIL_TO_PASS": "[\"sklearn/metrics/tests/test_classification.py::test_prf_warnings\", \"sklearn/metrics/tests/test_classification.py::test_recall_warnings\", \"sklearn/metrics/tests/test_classification.py::test_precision_warnings\", \"sklearn/metrics/tests/test_classification.py::test_fscore_warnings\"]",
  "PASS_TO_PASS": "[\"sklearn/metrics/tests/test_classification.py::test_classification_report_dictionary_output\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_accuracy_score_subset_accuracy\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_score_binary\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f_binary_single_class\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f_extra_labels\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f_ignored_labels\", \"sklearn/metrics/tests/test_classification.py::test_average_precision_score_score_non_binary_class\", \"sklearn/metrics/tests/test_classification.py::test_average_precision_score_duplicate_values\", \"sklearn/metrics/tests/test_classification.py::test_average_precision_score_tied_values\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_fscore_support_errors\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f_unused_pos_label\", \"sklearn/metrics/tests/test_classification.py::test_confusion_matrix_binary\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_confusion_matrix_binary\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_confusion_matrix_multiclass\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_confusion_matrix_multilabel\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_confusion_matrix_errors\", \"sklearn/metrics/tests/test_classification.py::test_cohen_kappa\", \"sklearn/metrics/tests/test_classification.py::test_matthews_corrcoef_nan\", \"sklearn/metrics/tests/test_classification.py::test_matthews_corrcoef_against_numpy_corrcoef\", \"sklearn/metrics/tests/test_classification.py::test_matthews_corrcoef_against_jurman\", \"sklearn/metrics/tests/test_classification.py::test_matthews_corrcoef\", \"sklearn/metrics/tests/test_classification.py::test_matthews_corrcoef_multiclass\", \"sklearn/metrics/tests/test_classification.py::test_matthews_corrcoef_overflow[100]\", \"sklearn/metrics/tests/test_classification.py::test_matthews_corrcoef_overflow[10000]\", \"sklearn/metrics/tests/test_classification.py::test_matthews_corrcoef_overflow[1000000]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_score_multiclass\", \"sklearn/metrics/tests/test_classification.py::test_precision_refcall_f1_score_multilabel_unordered_labels[samples]\", \"sklearn/metrics/tests/test_classification.py::test_precision_refcall_f1_score_multilabel_unordered_labels[micro]\", \"sklearn/metrics/tests/test_classification.py::test_precision_refcall_f1_score_multilabel_unordered_labels[macro]\", \"sklearn/metrics/tests/test_classification.py::test_precision_refcall_f1_score_multilabel_unordered_labels[weighted]\", \"sklearn/metrics/tests/test_classification.py::test_precision_refcall_f1_score_multilabel_unordered_labels[None]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_score_binary_averaged\", \"sklearn/metrics/tests/test_classification.py::test_zero_precision_recall\", \"sklearn/metrics/tests/test_classification.py::test_confusion_matrix_multiclass_subset_labels\", \"sklearn/metrics/tests/test_classification.py::test_confusion_matrix_dtype\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_multiclass\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_multiclass_balanced\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_multiclass_with_label_detection\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_multiclass_with_digits\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_multiclass_with_string_label\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_multiclass_with_unicode_label\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_multiclass_with_long_string_label\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_labels_target_names_unequal_length\", \"sklearn/metrics/tests/test_classification.py::test_classification_report_no_labels_target_names_unequal_length\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_classification_report\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_zero_one_loss_subset\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_hamming_loss\", \"sklearn/metrics/tests/test_classification.py::test_multilabel_jaccard_similarity_score\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_score_multilabel_1\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_score_multilabel_2\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_score_with_an_empty_prediction\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels[macro-1]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels[micro-1]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels[weighted-1]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels[samples-1]\", \"sklearn/metrics/tests/test_classification.py::test_precision_recall_f1_no_labels_average_none\", \"sklearn/metrics/tests/test_classification.py::test_prf_average_binary_data_non_binary\", \"sklearn/metrics/tests/test_classification.py::test__check_targets\", \"sklearn/metrics/tests/test_classification.py::test__check_targets_multiclass_with_both_y_true_and_y_pred_binary\", \"sklearn/metrics/tests/test_classification.py::test_hinge_loss_binary\", \"sklearn/metrics/tests/test_classification.py::test_hinge_loss_multiclass\", \"sklearn/metrics/tests/test_classification.py::test_hinge_loss_multiclass_missing_labels_with_labels_none\", \"sklearn/metrics/tests/test_classification.py::test_hinge_loss_multiclass_with_missing_labels\", \"sklearn/metrics/tests/test_classification.py::test_hinge_loss_multiclass_invariance_lists\", \"sklearn/metrics/tests/test_classification.py::test_log_loss\", \"sklearn/metrics/tests/test_classification.py::test_log_loss_pandas_input\", \"sklearn/metrics/tests/test_classification.py::test_brier_score_loss\", \"sklearn/metrics/tests/test_classification.py::test_balanced_accuracy_score_unseen\", \"sklearn/metrics/tests/test_classification.py::test_balanced_accuracy_score[y_true0-y_pred0]\", \"sklearn/metrics/tests/test_classification.py::test_balanced_accuracy_score[y_true1-y_pred1]\", \"sklearn/metrics/tests/test_classification.py::test_balanced_accuracy_score[y_true2-y_pred2]\"]",
  "environment_setup_commit": "7813f7efb5b2012412888b69e73d76f2df2b50b6",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.989876",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}