{
  "repo": "matplotlib/matplotlib",
  "instance_id": "matplotlib__matplotlib-14471",
  "base_commit": "ddb891751d797517e28b9f74d1fffc98716f8c7d",
  "patch": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -1105,6 +1105,10 @@ def use(backend, *, force=True):\n     \"\"\"\n     Select the backend used for rendering and GUI integration.\n \n+    If pyplot is already imported, `~matplotlib.pyplot.switch_backend` is used\n+    and if the new backend is different than the current backend, all Figures\n+    will be closed.\n+\n     Parameters\n     ----------\n     backend : str\n@@ -1135,6 +1139,8 @@ def use(backend, *, force=True):\n     --------\n     :ref:`backends`\n     matplotlib.get_backend\n+    matplotlib.pyplot.switch_backend\n+\n     \"\"\"\n     name = validate_backend(backend)\n     # don't (prematurely) resolve the \"auto\" backend setting\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -209,21 +209,24 @@ def _get_backend_mod():\n \n def switch_backend(newbackend):\n     \"\"\"\n-    Close all open figures and set the Matplotlib backend.\n+    Set the pyplot backend.\n \n-    The argument is case-insensitive.  Switching to an interactive backend is\n-    possible only if no event loop for another interactive backend has started.\n-    Switching to and from non-interactive backends is always possible.\n+    Switching to an interactive backend is possible only if no event loop for\n+    another interactive backend has started.  Switching to and from\n+    non-interactive backends is always possible.\n+\n+    If the new backend is different than the current backend then all open\n+    Figures will be closed via ``plt.close('all')``.\n \n     Parameters\n     ----------\n     newbackend : str\n-        The name of the backend to use.\n+        The case-insensitive name of the backend to use.\n+\n     \"\"\"\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -260,6 +263,8 @@ def switch_backend(newbackend):\n             switch_backend(\"agg\")\n             rcParamsOrig[\"backend\"] = \"agg\"\n             return\n+    # have to escape the switch on access logic\n+    old_backend = dict.__getitem__(rcParams, 'backend')\n \n     backend_mod = importlib.import_module(\n         cbook._backend_module_name(newbackend))\n@@ -323,6 +328,8 @@ def draw_if_interactive():\n     # Need to keep a global reference to the backend for compatibility reasons.\n     # See https://github.com/matplotlib/matplotlib/issues/6092\n     matplotlib.backends.backend = newbackend\n+    if not cbook._str_equal(old_backend, newbackend):\n+        close(\"all\")\n \n     # make sure the repl display hook is installed in case we become\n     # interactive\n",
  "test_patch": "diff --git a/lib/matplotlib/tests/test_pyplot.py b/lib/matplotlib/tests/test_pyplot.py\n--- a/lib/matplotlib/tests/test_pyplot.py\n+++ b/lib/matplotlib/tests/test_pyplot.py\n@@ -398,3 +398,14 @@ def test_minor_ticks():\n     tick_labels = ax.get_yticklabels(minor=True)\n     assert np.all(tick_pos == np.array([3.5, 6.5]))\n     assert [l.get_text() for l in tick_labels] == ['a', 'b']\n+\n+\n+def test_switch_backend_no_close():\n+    plt.switch_backend('agg')\n+    fig = plt.figure()\n+    fig = plt.figure()\n+    assert len(plt.get_fignums()) == 2\n+    plt.switch_backend('agg')\n+    assert len(plt.get_fignums()) == 2\n+    plt.switch_backend('svg')\n+    assert len(plt.get_fignums()) == 0\n",
  "problem_statement": "Existing FigureCanvasQT objects destroyed by call to plt.figure\n### Bug report\r\n\r\n**Bug summary**\r\n\r\nFor a number of years, I have been maintaining an interactive application that embeds subclassed FigureCanvasQT objects within a PyQt application. Up until Matplotlib v3.0.3., it was possible to create standard Matplotlib PyQt figures, i.e., using `plt.figure` within an embedded IPython shell, that coexist with the subclassed canvas objects. Now in Matplotlib v3.1.0, a call to `plt.figure()` destroys all the other canvas objects. \r\n\r\nUnfortunately, I cannot debug this within Visual Studio since I am currently unable to install Matplotlib from the source. By going through the `new_figure_manager` code line by line, I can confirm that the windows are destroyed when calling `FigureCanvasQT.__init__(figure)`, but not when calling `FigureCanvasBase.__init__(figure)`, but I can't work out what triggers the destruction of the other windows. I presume the subclassed canvasses are not being registered somewhere, and `pyplot` assumes they are no longer active, but I am hoping someone will show me where to look. This may not be a Matplotlib bug, but it's certainly an unwelcome side effect in my application.\r\n\r\n**Code for reproduction**\r\nIf you have `nexpy` installed (`pip install nexpy`) and launch it, you can reproduce this from within the embedded IPython shell with the following, which creates a new subclassed window and then attempts to open a regular `pyplot` window.:\r\n\r\n```\r\nIn [1]: new_window=NXPlotView()\r\nIn [2]: plt.get_fignums()\r\nOut[2]: [1, 2]\r\nIn [3]: plt.figure()\r\n```\r\nThere are two figure numbers, because NeXpy automatically creates a window with a figure number of 1 when it is launched.\r\n\r\n**Actual outcome**\r\n\r\nA new window with an updated figure number is created but all other windows not created by `pyplot`  are destroyed.\r\n\r\n```\r\nIn [4]: plt.get_fignums()\r\nOut[4]: [3]\r\n```\r\n\r\n**Expected outcome**\r\n\r\nIn Matplotlib v3.0.3, a new `pyplot` window is created by the PyQt5 backend without destroying anything else.\r\n\r\n```\r\nIn [4]: plt.get_fignums()\r\nOut[4]: [1, 2, 3]\r\n```\r\n\r\n**Matplotlib version**\r\n  * Operating system: Mac OS v10.14.5\r\n  * Matplotlib version: 3.1.0\r\n  * Matplotlib backend: Qt5Agg\r\n  * Python version: 3.7.2\r\n  * Jupyter version (if applicable): 1.0.0\r\n  * Other libraries: \r\n\r\n<!--Please tell us how you installed matplotlib and python e.g., from source, pip, conda-->\r\n<!--If you installed from conda, please specify which channel you used if not the default-->\r\n\n",
  "hints_text": "This bisects to #12637, and is essentially due to the fact that we now initialize ipython/matplotlib support when the first canvas is created (here, by `plt.figure()`), that during initialization, ipython calls `switch_backend`, that `switch_backend` starts by calling `close(\"all\")`, and that NXPlotView() is registered with pyplot and thus gets closed at that point.\r\n\r\nI think we can actually remove the `close(\"all\")` (well, modulo backcompat, yada yada)?  If there are conflicting event loops, closing figures won't help, if there aren't (like in this case), we don't need to close them.\r\n\r\nIn the meantime you can probably get away with creating a figure and immediately closing it -- we only initialize ipython/matplotlib support once.\nThanks for the information. I am subclassing FigureCanvasQT, so I would prefer to preempt the `close(\"all\")` call, perhaps by calling`switch_backend` myself for the first instance, but I can't see how it gets called during the first `plt.figure()` call. I'll look again tomorrow, but if you have any tips, I would appreciate them. I wondered if it was hidden in the `switch_backend_decorator`, but I don't see that being used.\n`switch_backend` is called via `ip.enable_matplotlib()`, which is called in `FigureCanvasBase._fix_ipython_backend2gui`, which is called in the FigureCanvasBase constructor.\nI think removing that `close(\"all\")` might be the only solution for me. I have tried endless permutations of preemptively setting mpl.rcParamsOrig('backend'), calling `pt.enable_matplotlib` or `pt.activate_matplotlib`, adding a dummy `_fix_ipython_backend2gui` to my FigureCanvasQT subclass, even defining my own subclass of _BackendQT5 using the `_Backend.export` decorator (which produces unhelpful side effects) , but none of them stop IPython from calling `switch_backend`, whose first line is `close(\"all\")`. I need to make a new release of NeXpy in the next couple of days, but I am going to have to make Matplotlib v3.0.3 the highest allowed version, unless anyone has other tips for me to try.\nIt looks like the following workaround does suffice: add a call to `FigureCanvas(Figure())` at the toplevel of plotview.py (note that because the figure is not registered with pyplot, it will be immediately garbage collected anyways, but that'll arrange to call _fix_ipython_backend2gui properly).\r\n\r\n(I still do think that we should not call `close(\"all\")`, but that may take longer to change...)\nThanks for the suggestion, which I think would work. In the past few minutes, I have just found an alternative solution. I just have to monkey-patch the IPython InteractiveShell class to do nothing when there is a call to `enable_matplotlib`. Everything else is already initialized so the call is redundant. It also seems to work. \r\n\r\nI haven't thought about this issue nearly as long as you, but I get the impression that the ultimate solution would have to come from IPython allowing alternative backends to be registered in some well-documented way. \nThe way we are registering backends with IPython definitely borders API abuse, sorry for breaking things on your side.  On the other hand, I would rather have as much of that code as possible living on Matplotlib's side, as cross-project coordination is a much harder problem...\nI remilestone to 3.2 as we have a workaround now, although I do think the API needs to be revisited on our side.\nI think the simplest short-term fix would be to add an optional keyword argument to the FigureCanvasBase to allow instances to skip the call to `_fix_ipython_backend2gui` if it's unnecessary. If you are loath to change call signatures, the same thing could be achieved by adding a private class variable (`_fix_ipython=True`) that a subclass could override. \nThat doesn't seem much better than just documenting \"call `FigureCanvas(Figure())` early\"?\nI am a little rushed at the moment, so I may be wrong about this, but I think the problem with calling `FigureCanvas(Figure())` in NeXpy is that the IPython shell doesn't exist when I initialize the plotting windows, so the call to `IPython.get_ipython()` would fail. I could probably reconfigure the initialization process I would prefer not to refactor my code if possible, and I think Matplotlib should allow for situations where the IPython fix is completely unnecessary.\nAs it is written right now, `FigureCanvas(Figure())` will call `_fix_ipython_backend2gui` regardless of whether IPython was already initialized, and `_fix_ipython_backend2gui` will *not* be called a second time (due to the `functools.lru_cache()` decorator) even if IPython is later initialized (I didn't think about the embedding case at all when I wrote this).  So the fix works (... at least for me) even if you call `FigureCanvas(Figure())` at the toplevel of the module.\nI must admit that I had been puzzled about how subsequent calls were suppressed. I didn't know what the `functools.lru_cache()` decorator did. I am happy to leave this to real Matplotlib experts such as you now that I have my own solution and you are aware of the issue. If you reference this issue when any relevant changes are implemented, I should be able to keep my own code compatible. This isn't the first bit of monkey-patching I've had to do - it's one of the hazards of embedding other packages.",
  "created_at": "2019-06-06T22:15:33Z",
  "version": "3.1",
  "FAIL_TO_PASS": "[\"lib/matplotlib/tests/test_pyplot.py::test_switch_backend_no_close\"]",
  "PASS_TO_PASS": "[\"lib/matplotlib/tests/test_pyplot.py::test_pyplot_up_to_date\", \"lib/matplotlib/tests/test_pyplot.py::test_copy_docstring_and_deprecators\", \"lib/matplotlib/tests/test_pyplot.py::test_pyplot_box\", \"lib/matplotlib/tests/test_pyplot.py::test_stackplot_smoke\", \"lib/matplotlib/tests/test_pyplot.py::test_nrows_error\", \"lib/matplotlib/tests/test_pyplot.py::test_ioff\", \"lib/matplotlib/tests/test_pyplot.py::test_ion\", \"lib/matplotlib/tests/test_pyplot.py::test_nested_ion_ioff\", \"lib/matplotlib/tests/test_pyplot.py::test_close\", \"lib/matplotlib/tests/test_pyplot.py::test_subplot_reuse\", \"lib/matplotlib/tests/test_pyplot.py::test_axes_kwargs\", \"lib/matplotlib/tests/test_pyplot.py::test_subplot_replace_projection\", \"lib/matplotlib/tests/test_pyplot.py::test_subplot_kwarg_collision\", \"lib/matplotlib/tests/test_pyplot.py::test_gca\", \"lib/matplotlib/tests/test_pyplot.py::test_subplot_projection_reuse\", \"lib/matplotlib/tests/test_pyplot.py::test_subplot_polar_normalization\", \"lib/matplotlib/tests/test_pyplot.py::test_subplot_change_projection\", \"lib/matplotlib/tests/test_pyplot.py::test_polar_second_call\", \"lib/matplotlib/tests/test_pyplot.py::test_fallback_position\", \"lib/matplotlib/tests/test_pyplot.py::test_set_current_figure_via_subfigure\", \"lib/matplotlib/tests/test_pyplot.py::test_set_current_axes_on_subfigure\", \"lib/matplotlib/tests/test_pyplot.py::test_doc_pyplot_summary\", \"lib/matplotlib/tests/test_pyplot.py::test_minor_ticks\"]",
  "environment_setup_commit": "42259bb9715bbacbbb2abc8005df836f3a7fd080",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.787093",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}