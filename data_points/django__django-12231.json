{
  "repo": "django/django",
  "instance_id": "django__django-12231",
  "base_commit": "5a4d7285bd10bd40d9f7e574a7c421eb21094858",
  "patch": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -999,7 +999,8 @@ def set(self, objs, *, clear=False, through_defaults=None):\n                     for obj in objs:\n                         fk_val = (\n                             self.target_field.get_foreign_related_value(obj)[0]\n-                            if isinstance(obj, self.model) else obj\n+                            if isinstance(obj, self.model)\n+                            else self.target_field.get_prep_value(obj)\n                         )\n                         if fk_val in old_ids:\n                             old_ids.remove(fk_val)\n",
  "test_patch": "diff --git a/tests/many_to_many/tests.py b/tests/many_to_many/tests.py\n--- a/tests/many_to_many/tests.py\n+++ b/tests/many_to_many/tests.py\n@@ -469,6 +469,19 @@ def test_set(self):\n         self.a4.publications.set([], clear=True)\n         self.assertQuerysetEqual(self.a4.publications.all(), [])\n \n+    def test_set_existing_different_type(self):\n+        # Existing many-to-many relations remain the same for values provided\n+        # with a different type.\n+        ids = set(Publication.article_set.through.objects.filter(\n+            article__in=[self.a4, self.a3],\n+            publication=self.p2,\n+        ).values_list('id', flat=True))\n+        self.p2.article_set.set([str(self.a4.pk), str(self.a3.pk)])\n+        new_ids = set(Publication.article_set.through.objects.filter(\n+            publication=self.p2,\n+        ).values_list('id', flat=True))\n+        self.assertEqual(ids, new_ids)\n+\n     def test_assign_forward(self):\n         msg = (\n             \"Direct assignment to the reverse side of a many-to-many set is \"\n",
  "problem_statement": "Related Manager set() should prepare values before checking for missing elements.\nDescription\n\t\nTo update a complete list of foreignkeys, we use set() method of relatedmanager to get a performance gain and avoid remove and add keys not touched by user.\nBut today i noticed our database removes all foreignkeys and adds them again. After some debugging i found the issue in this condition:\nâ€‹https://github.com/django/django/blob/master/django/db/models/fields/related_descriptors.py#L1004\nOur form returns all Foreignkeys as list of strings in cleaned_data, but the strings do not match the pk (int). After converting the strings to int, before calling set(), fixes the problem.\nQuestion:\nHow to avoid this issue? Maybe all code usages of set() are using lists of strings, maybe not. I dont know at the moment.\nIs is possible Django fixes this issue? Should Django fix the issue? Maybe strings should raise an exception?\n",
  "hints_text": "We cannot raise an exception on strings because set() accepts the field the relation points, e.g. CharField. However we can optimize this with preparing values, i.e. diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py index a9445d5d10..9f82ca4e8c 100644 --- a/django/db/models/fields/related_descriptors.py +++ b/django/db/models/fields/related_descriptors.py @@ -999,7 +999,7 @@ def create_forward_many_to_many_manager(superclass, rel, reverse): for obj in objs: fk_val = ( self.target_field.get_foreign_related_value(obj)[0] - if isinstance(obj, self.model) else obj + if isinstance(obj, self.model) else self.target_field.get_prep_value(obj) ) if fk_val in old_ids: old_ids.remove(fk_val)",
  "created_at": "2019-12-19T10:10:59Z",
  "version": "3.1",
  "FAIL_TO_PASS": "[\"test_set_existing_different_type (many_to_many.tests.ManyToManyTests)\"]",
  "PASS_TO_PASS": "[\"test_add (many_to_many.tests.ManyToManyTests)\", \"test_add_after_prefetch (many_to_many.tests.ManyToManyTests)\", \"test_add_remove_invalid_type (many_to_many.tests.ManyToManyTests)\", \"test_add_remove_set_by_pk (many_to_many.tests.ManyToManyTests)\", \"test_add_remove_set_by_to_field (many_to_many.tests.ManyToManyTests)\", \"test_add_then_remove_after_prefetch (many_to_many.tests.ManyToManyTests)\", \"test_assign (many_to_many.tests.ManyToManyTests)\", \"test_assign_forward (many_to_many.tests.ManyToManyTests)\", \"test_assign_ids (many_to_many.tests.ManyToManyTests)\", \"test_assign_reverse (many_to_many.tests.ManyToManyTests)\", \"test_bulk_delete (many_to_many.tests.ManyToManyTests)\", \"test_clear (many_to_many.tests.ManyToManyTests)\", \"test_clear_after_prefetch (many_to_many.tests.ManyToManyTests)\", \"test_custom_default_manager_exists_count (many_to_many.tests.ManyToManyTests)\", \"test_delete (many_to_many.tests.ManyToManyTests)\", \"test_fast_add_ignore_conflicts (many_to_many.tests.ManyToManyTests)\", \"test_forward_assign_with_queryset (many_to_many.tests.ManyToManyTests)\", \"test_inherited_models_selects (many_to_many.tests.ManyToManyTests)\", \"test_related_sets (many_to_many.tests.ManyToManyTests)\", \"test_remove (many_to_many.tests.ManyToManyTests)\", \"test_remove_after_prefetch (many_to_many.tests.ManyToManyTests)\", \"test_reverse_add (many_to_many.tests.ManyToManyTests)\", \"test_reverse_assign_with_queryset (many_to_many.tests.ManyToManyTests)\", \"test_reverse_selects (many_to_many.tests.ManyToManyTests)\", \"test_selects (many_to_many.tests.ManyToManyTests)\", \"test_set (many_to_many.tests.ManyToManyTests)\", \"test_set_after_prefetch (many_to_many.tests.ManyToManyTests)\", \"test_slow_add_ignore_conflicts (many_to_many.tests.ManyToManyTests)\"]",
  "environment_setup_commit": "0668164b4ac93a5be79f5b87fae83c657124d9ab",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.619138",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}