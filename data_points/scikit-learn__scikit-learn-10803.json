{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-10803",
  "base_commit": "a4dcd70e84176a255654586bd20e78779191447f",
  "patch": "diff --git a/sklearn/neighbors/kde.py b/sklearn/neighbors/kde.py\n--- a/sklearn/neighbors/kde.py\n+++ b/sklearn/neighbors/kde.py\n@@ -7,7 +7,8 @@\n import numpy as np\n from scipy.special import gammainc\n from ..base import BaseEstimator\n-from ..utils import check_array, check_random_state\n+from ..utils import check_array, check_random_state, check_consistent_length\n+\n from ..utils.extmath import row_norms\n from .ball_tree import BallTree, DTYPE\n from .kd_tree import KDTree\n@@ -112,7 +113,7 @@ def _choose_algorithm(self, algorithm, metric):\n         else:\n             raise ValueError(\"invalid algorithm: '{0}'\".format(algorithm))\n \n-    def fit(self, X, y=None):\n+    def fit(self, X, y=None, sample_weight=None):\n         \"\"\"Fit the Kernel Density model on the data.\n \n         Parameters\n@@ -120,15 +121,29 @@ def fit(self, X, y=None):\n         X : array_like, shape (n_samples, n_features)\n             List of n_features-dimensional data points.  Each row\n             corresponds to a single data point.\n+        sample_weight: array_like, shape (n_samples,), optional\n+            List of sample weights attached to the data X.\n         \"\"\"\n         algorithm = self._choose_algorithm(self.algorithm, self.metric)\n         X = check_array(X, order='C', dtype=DTYPE)\n \n+        if sample_weight is not None:\n+            sample_weight = check_array(sample_weight, order='C', dtype=DTYPE,\n+                                        ensure_2d=False)\n+            if sample_weight.ndim != 1:\n+                raise ValueError(\"the shape of sample_weight must be ({0},),\"\n+                                 \" but was {1}\".format(X.shape[0],\n+                                                       sample_weight.shape))\n+            check_consistent_length(X, sample_weight)\n+            if sample_weight.min() <= 0:\n+                raise ValueError(\"sample_weight must have positive values\")\n+\n         kwargs = self.metric_params\n         if kwargs is None:\n             kwargs = {}\n         self.tree_ = TREE_DICT[algorithm](X, metric=self.metric,\n                                           leaf_size=self.leaf_size,\n+                                          sample_weight=sample_weight,\n                                           **kwargs)\n         return self\n \n@@ -150,7 +165,10 @@ def score_samples(self, X):\n         # For it to be a probability, we must scale it.  For this reason\n         # we'll also scale atol.\n         X = check_array(X, order='C', dtype=DTYPE)\n-        N = self.tree_.data.shape[0]\n+        if self.tree_.sample_weight is None:\n+            N = self.tree_.data.shape[0]\n+        else:\n+            N = self.tree_.sum_weight\n         atol_N = self.atol * N\n         log_density = self.tree_.kernel_density(\n             X, h=self.bandwidth, kernel=self.kernel, atol=atol_N,\n@@ -202,8 +220,13 @@ def sample(self, n_samples=1, random_state=None):\n         data = np.asarray(self.tree_.data)\n \n         rng = check_random_state(random_state)\n-        i = rng.randint(data.shape[0], size=n_samples)\n-\n+        u = rng.uniform(0, 1, size=n_samples)\n+        if self.tree_.sample_weight is None:\n+            i = (u * data.shape[0]).astype(np.int64)\n+        else:\n+            cumsum_weight = np.cumsum(np.asarray(self.tree_.sample_weight))\n+            sum_weight = cumsum_weight[-1]\n+            i = np.searchsorted(cumsum_weight, u * sum_weight)\n         if self.kernel == 'gaussian':\n             return np.atleast_2d(rng.normal(data[i], self.bandwidth))\n \n",
  "test_patch": "diff --git a/sklearn/neighbors/tests/test_kde.py b/sklearn/neighbors/tests/test_kde.py\n--- a/sklearn/neighbors/tests/test_kde.py\n+++ b/sklearn/neighbors/tests/test_kde.py\n@@ -137,6 +137,11 @@ def test_kde_badargs():\n                   metric='blah')\n     assert_raises(ValueError, KernelDensity,\n                   algorithm='kd_tree', metric='blah')\n+    kde = KernelDensity()\n+    assert_raises(ValueError, kde.fit, np.random.random((200, 10)),\n+                  sample_weight=np.random.random((200, 10)))\n+    assert_raises(ValueError, kde.fit, np.random.random((200, 10)),\n+                  sample_weight=-np.random.random(200))\n \n \n def test_kde_pipeline_gridsearch():\n@@ -149,3 +154,51 @@ def test_kde_pipeline_gridsearch():\n     search = GridSearchCV(pipe1, param_grid=params, cv=5)\n     search.fit(X)\n     assert_equal(search.best_params_['kerneldensity__bandwidth'], .1)\n+\n+\n+def test_kde_sample_weights():\n+    n_samples = 400\n+    size_test = 20\n+    weights_neutral = 3 * np.ones(n_samples)\n+    for d in [1, 2, 10]:\n+        rng = np.random.RandomState(0)\n+        X = rng.rand(n_samples, d)\n+        weights = 1 + (10 * X.sum(axis=1)).astype(np.int8)\n+        X_repetitions = np.repeat(X, weights, axis=0)\n+        n_samples_test = size_test // d\n+        test_points = rng.rand(n_samples_test, d)\n+        for algorithm in ['auto', 'ball_tree', 'kd_tree']:\n+            for metric in ['euclidean', 'minkowski', 'manhattan',\n+                           'chebyshev']:\n+                if algorithm != 'kd_tree' or metric in KDTree.valid_metrics:\n+                    kde = KernelDensity(algorithm=algorithm, metric=metric)\n+\n+                    # Test that adding a constant sample weight has no effect\n+                    kde.fit(X, sample_weight=weights_neutral)\n+                    scores_const_weight = kde.score_samples(test_points)\n+                    sample_const_weight = kde.sample(random_state=1234)\n+                    kde.fit(X)\n+                    scores_no_weight = kde.score_samples(test_points)\n+                    sample_no_weight = kde.sample(random_state=1234)\n+                    assert_allclose(scores_const_weight, scores_no_weight)\n+                    assert_allclose(sample_const_weight, sample_no_weight)\n+\n+                    # Test equivalence between sampling and (integer) weights\n+                    kde.fit(X, sample_weight=weights)\n+                    scores_weight = kde.score_samples(test_points)\n+                    sample_weight = kde.sample(random_state=1234)\n+                    kde.fit(X_repetitions)\n+                    scores_ref_sampling = kde.score_samples(test_points)\n+                    sample_ref_sampling = kde.sample(random_state=1234)\n+                    assert_allclose(scores_weight, scores_ref_sampling)\n+                    assert_allclose(sample_weight, sample_ref_sampling)\n+\n+                    # Test that sample weights has a non-trivial effect\n+                    diff = np.max(np.abs(scores_no_weight - scores_weight))\n+                    assert diff > 0.001\n+\n+                    # Test invariance with respect to arbitrary scaling\n+                    scale_factor = rng.rand()\n+                    kde.fit(X, sample_weight=(scale_factor * weights))\n+                    scores_scaled_weight = kde.score_samples(test_points)\n+                    assert_allclose(scores_scaled_weight, scores_weight)\n",
  "problem_statement": "weighted KDE\nNot sure this is the correct place, but I would very much appreciate the ability to \npass a weight for each sample in kde density estimation. \n\nThere exits a adapted version of scipy.stats.gaussian_kde : \nhttp://stackoverflow.com/questions/27623919/weighted-gaussian-kernel-density-estimation-in-python\n\nweighted KDE\nNot sure this is the correct place, but I would very much appreciate the ability to \npass a weight for each sample in kde density estimation. \n\nThere exits a adapted version of scipy.stats.gaussian_kde : \nhttp://stackoverflow.com/questions/27623919/weighted-gaussian-kernel-density-estimation-in-python\n\n",
  "hints_text": "I think that wouldn't be too hard to add but @jakevdp knows better.\n\nThats good news. \nWell I would use it for astronomy project, so @jakevdp  help/advice would be welcome. \nHope to be able to work on it after paper deadlines, but can't promise anything. \n\nIt's actually not trivial, because of the fast tree-based KDE that sklearn uses. Currently, nodes are ranked by distance and the local estimate is updated until it can be shown that the desired tolerance has been reached. With non-uniform weights, the ranking procedure would have to be based on a combination of minimum distance and maximum weight in each node, which would require a slightly different KD-tree/Ball tree traversal algorithm, along with an updated node data structure to store those weights.\n\nIt would be relatively easy to add a slower brute-force version of KDE which supports weighted points, however.\n\nHum, for some reason I thought the trees did support weights. I guess I was confused by the weighting in KNN which is much easier to implement.\n\nQuick question â€“ I've heard a number of requests for this feature. Though it would be difficult to implement for the tree-based KDE, it would be relatively straightforward to add an `algorithm='brute'` option to `KernelDensity` which could support a `weights` or similar attribute for the class.\n\nDo you think that would be a worthwhile contribution?\n\nI think it would. In practice it means it would it would only be practical for small-ish data sets of course, but I don't see that as not a good reason to implement it. \nFurthermore, if proven popular, it might lead to someone developing a fast version.  \njust my 2 cents\n\nJust a comment - for low dimensional data sets statsmodels already has a weighted KDE.\n\nIt would also be extremely convenient for me if there was a version of the algorithm that accepted weights. I think it's a very important feature and surprisingly almost none of the python libraries have it. Statsmodels does have it, but only for univariate KDE; for multivariate KDE the feature is also missing.\n2 years have passed since this issue was opened and it hasn't been solved yet\nDo you want to contribute it? Go ahead!\nHi, I'm interested in this too. What about this?\r\n\r\nhttps://gist.github.com/afrendeiro/9ab8a1ea379030d10f17\r\n\r\nI can ask and try and integrate this into sklearn if you think it's fine.\nI think that wouldn't be too hard to add but @jakevdp knows better.\n\nThats good news. \nWell I would use it for astronomy project, so @jakevdp  help/advice would be welcome. \nHope to be able to work on it after paper deadlines, but can't promise anything. \n\nIt's actually not trivial, because of the fast tree-based KDE that sklearn uses. Currently, nodes are ranked by distance and the local estimate is updated until it can be shown that the desired tolerance has been reached. With non-uniform weights, the ranking procedure would have to be based on a combination of minimum distance and maximum weight in each node, which would require a slightly different KD-tree/Ball tree traversal algorithm, along with an updated node data structure to store those weights.\n\nIt would be relatively easy to add a slower brute-force version of KDE which supports weighted points, however.\n\nHum, for some reason I thought the trees did support weights. I guess I was confused by the weighting in KNN which is much easier to implement.\n\nQuick question â€“ I've heard a number of requests for this feature. Though it would be difficult to implement for the tree-based KDE, it would be relatively straightforward to add an `algorithm='brute'` option to `KernelDensity` which could support a `weights` or similar attribute for the class.\n\nDo you think that would be a worthwhile contribution?\n\nI think it would. In practice it means it would it would only be practical for small-ish data sets of course, but I don't see that as not a good reason to implement it. \nFurthermore, if proven popular, it might lead to someone developing a fast version.  \njust my 2 cents\n\nJust a comment - for low dimensional data sets statsmodels already has a weighted KDE.\n\nIt would also be extremely convenient for me if there was a version of the algorithm that accepted weights. I think it's a very important feature and surprisingly almost none of the python libraries have it. Statsmodels does have it, but only for univariate KDE; for multivariate KDE the feature is also missing.\n2 years have passed since this issue was opened and it hasn't been solved yet\nDo you want to contribute it? Go ahead!\nHi, I'm interested in this too. What about this?\r\n\r\nhttps://gist.github.com/afrendeiro/9ab8a1ea379030d10f17\r\n\r\nI can ask and try and integrate this into sklearn if you think it's fine.",
  "created_at": "2018-03-13T08:01:30Z",
  "version": "0.20",
  "FAIL_TO_PASS": "[\"sklearn/neighbors/tests/test_kde.py::test_kde_badargs\"]",
  "PASS_TO_PASS": "[\"sklearn/neighbors/tests/test_kde.py::test_kde_algorithm_metric_choice[haversine-kd_tree]\", \"sklearn/neighbors/tests/test_kde.py::test_kde_score\"]",
  "environment_setup_commit": "55bf5d93e5674f13a1134d93a11fd0cd11aabcd1",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.955200",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}