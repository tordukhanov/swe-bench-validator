{
  "repo": "pydata/xarray",
  "instance_id": "pydata__xarray-6400",
  "base_commit": "728b648d5c7c3e22fe3704ba163012840408bf66",
  "patch": "diff --git a/xarray/core/formatting.py b/xarray/core/formatting.py\n--- a/xarray/core/formatting.py\n+++ b/xarray/core/formatting.py\n@@ -520,7 +520,11 @@ def short_numpy_repr(array):\n \n     # default to lower precision so a full (abbreviated) line can fit on\n     # one line with the default display_width\n-    options = {\"precision\": 6, \"linewidth\": OPTIONS[\"display_width\"], \"threshold\": 200}\n+    options = {\n+        \"precision\": 6,\n+        \"linewidth\": OPTIONS[\"display_width\"],\n+        \"threshold\": OPTIONS[\"display_values_threshold\"],\n+    }\n     if array.ndim < 3:\n         edgeitems = 3\n     elif array.ndim == 3:\ndiff --git a/xarray/core/indexing.py b/xarray/core/indexing.py\n--- a/xarray/core/indexing.py\n+++ b/xarray/core/indexing.py\n@@ -5,6 +5,7 @@\n from contextlib import suppress\n from dataclasses import dataclass, field\n from datetime import timedelta\n+from html import escape\n from typing import (\n     TYPE_CHECKING,\n     Any,\n@@ -25,6 +26,7 @@\n \n from . import duck_array_ops, nputils, utils\n from .npcompat import DTypeLike\n+from .options import OPTIONS\n from .pycompat import dask_version, integer_types, is_duck_dask_array, sparse_array_type\n from .types import T_Xarray\n from .utils import either_dict_or_kwargs, get_valid_numpy_dtype\n@@ -1507,23 +1509,31 @@ def __repr__(self) -> str:\n             )\n             return f\"{type(self).__name__}{props}\"\n \n-    def _repr_inline_(self, max_width) -> str:\n-        # special implementation to speed-up the repr for big multi-indexes\n+    def _get_array_subset(self) -> np.ndarray:\n+        # used to speed-up the repr for big multi-indexes\n+        threshold = max(100, OPTIONS[\"display_values_threshold\"] + 2)\n+        if self.size > threshold:\n+            pos = threshold // 2\n+            indices = np.concatenate([np.arange(0, pos), np.arange(-pos, 0)])\n+            subset = self[OuterIndexer((indices,))]\n+        else:\n+            subset = self\n+\n+        return np.asarray(subset)\n+\n+    def _repr_inline_(self, max_width: int) -> str:\n+        from .formatting import format_array_flat\n+\n         if self.level is None:\n             return \"MultiIndex\"\n         else:\n-            from .formatting import format_array_flat\n+            return format_array_flat(self._get_array_subset(), max_width)\n \n-            if self.size > 100 and max_width < self.size:\n-                n_values = max_width\n-                indices = np.concatenate(\n-                    [np.arange(0, n_values), np.arange(-n_values, 0)]\n-                )\n-                subset = self[OuterIndexer((indices,))]\n-            else:\n-                subset = self\n+    def _repr_html_(self) -> str:\n+        from .formatting import short_numpy_repr\n \n-            return format_array_flat(np.asarray(subset), max_width)\n+        array_repr = short_numpy_repr(self._get_array_subset())\n+        return f\"<pre>{escape(array_repr)}</pre>\"\n \n     def copy(self, deep: bool = True) -> \"PandasMultiIndexingAdapter\":\n         # see PandasIndexingAdapter.copy\ndiff --git a/xarray/core/options.py b/xarray/core/options.py\n--- a/xarray/core/options.py\n+++ b/xarray/core/options.py\n@@ -15,6 +15,7 @@ class T_Options(TypedDict):\n     cmap_divergent: Union[str, \"Colormap\"]\n     cmap_sequential: Union[str, \"Colormap\"]\n     display_max_rows: int\n+    display_values_threshold: int\n     display_style: Literal[\"text\", \"html\"]\n     display_width: int\n     display_expand_attrs: Literal[\"default\", True, False]\n@@ -33,6 +34,7 @@ class T_Options(TypedDict):\n     \"cmap_divergent\": \"RdBu_r\",\n     \"cmap_sequential\": \"viridis\",\n     \"display_max_rows\": 12,\n+    \"display_values_threshold\": 200,\n     \"display_style\": \"html\",\n     \"display_width\": 80,\n     \"display_expand_attrs\": \"default\",\n@@ -57,6 +59,7 @@ def _positive_integer(value):\n _VALIDATORS = {\n     \"arithmetic_join\": _JOIN_OPTIONS.__contains__,\n     \"display_max_rows\": _positive_integer,\n+    \"display_values_threshold\": _positive_integer,\n     \"display_style\": _DISPLAY_OPTIONS.__contains__,\n     \"display_width\": _positive_integer,\n     \"display_expand_attrs\": lambda choice: choice in [True, False, \"default\"],\n@@ -154,6 +157,9 @@ class set_options:\n         * ``default`` : to expand unless over a pre-defined limit\n     display_max_rows : int, default: 12\n         Maximum display rows.\n+    display_values_threshold : int, default: 200\n+        Total number of array elements which trigger summarization rather\n+        than full repr for variable data views (numpy arrays).\n     display_style : {\"text\", \"html\"}, default: \"html\"\n         Display style to use in jupyter for xarray objects.\n     display_width : int, default: 80\n",
  "test_patch": "diff --git a/xarray/tests/test_formatting.py b/xarray/tests/test_formatting.py\n--- a/xarray/tests/test_formatting.py\n+++ b/xarray/tests/test_formatting.py\n@@ -479,6 +479,12 @@ def test_short_numpy_repr() -> None:\n         num_lines = formatting.short_numpy_repr(array).count(\"\\n\") + 1\n         assert num_lines < 30\n \n+    # threshold option (default: 200)\n+    array = np.arange(100)\n+    assert \"...\" not in formatting.short_numpy_repr(array)\n+    with xr.set_options(display_values_threshold=10):\n+        assert \"...\" in formatting.short_numpy_repr(array)\n+\n \n def test_large_array_repr_length() -> None:\n \n",
  "problem_statement": "Very poor html repr performance on large multi-indexes\n<!-- Please include a self-contained copy-pastable example that generates the issue if possible.\r\n\r\nPlease be concise with code posted. See guidelines below on how to provide a good bug report:\r\n\r\n- Craft Minimal Bug Reports: http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports\r\n- Minimal Complete Verifiable Examples: https://stackoverflow.com/help/mcve\r\n\r\nBug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.\r\n-->\r\n\r\n**What happened**:\r\n\r\nWe have catestrophic performance on the  html repr of some long multi-indexed data arrays. Here's a case of it taking 12s.\r\n\r\n\r\n**Minimal Complete Verifiable Example**:\r\n\r\n```python\r\nimport xarray as xr\r\n\r\nds = xr.tutorial.load_dataset(\"air_temperature\")\r\nda = ds[\"air\"].stack(z=[...])\r\n\r\nda.shape \r\n\r\n# (3869000,)\r\n\r\n%timeit -n 1 -r 1 da._repr_html_()\r\n\r\n# 12.4 s !!\r\n\r\n```\r\n\r\n**Anything else we need to know?**:\r\n\r\nI thought we'd fixed some issues here: https://github.com/pydata/xarray/pull/4846/files\r\n\r\n**Environment**:\r\n\r\n<details><summary>Output of <tt>xr.show_versions()</tt></summary>\r\n\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit: None\r\npython: 3.8.10 (default, May  9 2021, 13:21:55) \r\n[Clang 12.0.5 (clang-1205.0.22.9)]\r\npython-bits: 64\r\nOS: Darwin\r\nOS-release: 20.4.0\r\nmachine: x86_64\r\nprocessor: i386\r\nbyteorder: little\r\nLC_ALL: None\r\nLANG: None\r\nLOCALE: ('en_US', 'UTF-8')\r\nlibhdf5: None\r\nlibnetcdf: None\r\n\r\nxarray: 0.18.2\r\npandas: 1.2.4\r\nnumpy: 1.20.3\r\nscipy: 1.6.3\r\nnetCDF4: None\r\npydap: None\r\nh5netcdf: None\r\nh5py: None\r\nNio: None\r\nzarr: 2.8.3\r\ncftime: 1.4.1\r\nnc_time_axis: None\r\nPseudoNetCDF: None\r\nrasterio: 1.2.3\r\ncfgrib: None\r\niris: None\r\nbottleneck: 1.3.2\r\ndask: 2021.06.1\r\ndistributed: 2021.06.1\r\nmatplotlib: 3.4.2\r\ncartopy: None\r\nseaborn: 0.11.1\r\nnumbagg: 0.2.1\r\npint: None\r\nsetuptools: 56.0.0\r\npip: 21.1.2\r\nconda: None\r\npytest: 6.2.4\r\nIPython: 7.24.0\r\nsphinx: 4.0.1\r\n\r\n\r\n</details>\r\n\n",
  "hints_text": "I think it's some lazy calculation that kicks in. Because I can reproduce using np.asarray.\r\n\r\n```python\r\nimport numpy as np\r\nimport xarray as xr\r\n\r\nds = xr.tutorial.load_dataset(\"air_temperature\")\r\nda = ds[\"air\"].stack(z=[...])\r\n\r\ncoord = da.z.variable.to_index_variable()\r\n\r\n# This is very slow:\r\na = np.asarray(coord)\r\n\r\nda._repr_html_()\r\n```\r\n![image](https://user-images.githubusercontent.com/14371165/123465543-8c6fc500-d5ee-11eb-90b3-e814b3411ad4.png)\r\n\nYes, I think it's materializing the multiindex as an array of tuples. Which we definitely shouldn't be doing for reprs.\r\n\r\n@Illviljan nice profiling view! What is that?\nOne way of solving it could be to slice the arrays to a smaller size but still showing the same repr. Because `coords[0:12]` seems easy to print, not sure how tricky it is to slice it in this way though.\r\n\r\nI'm using https://github.com/spyder-ide/spyder for the profiling and general hacking.\nYes very much so @Illviljan . But weirdly the linked PR is attempting to do that — so maybe this code path doesn't hit that change?\r\n\r\nSpyder's profiler looks good! \n> But weirdly the linked PR is attempting to do that — so maybe this code path doesn't hit that change?\r\n\r\nI think the linked PR only fixed the summary (inline) repr. The bottleneck here is when formatting the array detailed view for the multi-index coordinates, which triggers the conversion of the whole pandas MultiIndex (tuple elements) and each of its levels as a numpy arrays.",
  "created_at": "2022-03-22T12:57:37Z",
  "version": "2022.03",
  "FAIL_TO_PASS": "[\"xarray/tests/test_formatting.py::test_short_numpy_repr\"]",
  "PASS_TO_PASS": "[\"xarray/tests/test_formatting.py::TestFormatting::test_get_indexer_at_least_n_items\", \"xarray/tests/test_formatting.py::TestFormatting::test_first_n_items\", \"xarray/tests/test_formatting.py::TestFormatting::test_last_n_items\", \"xarray/tests/test_formatting.py::TestFormatting::test_last_item\", \"xarray/tests/test_formatting.py::TestFormatting::test_format_item\", \"xarray/tests/test_formatting.py::TestFormatting::test_format_items\", \"xarray/tests/test_formatting.py::TestFormatting::test_format_array_flat\", \"xarray/tests/test_formatting.py::TestFormatting::test_pretty_print\", \"xarray/tests/test_formatting.py::TestFormatting::test_maybe_truncate\", \"xarray/tests/test_formatting.py::TestFormatting::test_format_timestamp_invalid_pandas_format\", \"xarray/tests/test_formatting.py::TestFormatting::test_format_timestamp_out_of_bounds\", \"xarray/tests/test_formatting.py::TestFormatting::test_attribute_repr\", \"xarray/tests/test_formatting.py::TestFormatting::test_diff_array_repr\", \"xarray/tests/test_formatting.py::TestFormatting::test_diff_attrs_repr_with_array\", \"xarray/tests/test_formatting.py::TestFormatting::test_diff_dataset_repr\", \"xarray/tests/test_formatting.py::TestFormatting::test_array_repr\", \"xarray/tests/test_formatting.py::TestFormatting::test_array_repr_variable\", \"xarray/tests/test_formatting.py::test_inline_variable_array_repr_custom_repr\", \"xarray/tests/test_formatting.py::test_set_numpy_options\", \"xarray/tests/test_formatting.py::test_large_array_repr_length\", \"xarray/tests/test_formatting.py::test_repr_file_collapsed\", \"xarray/tests/test_formatting.py::test__mapping_repr[50-40-30]\", \"xarray/tests/test_formatting.py::test__mapping_repr[35-40-30]\", \"xarray/tests/test_formatting.py::test__mapping_repr[11-40-30]\", \"xarray/tests/test_formatting.py::test__mapping_repr[1-40-30]\", \"xarray/tests/test_formatting.py::test__element_formatter\"]",
  "environment_setup_commit": "d7931f9014a26e712ff5f30c4082cf0261f045d3",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.892310",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}