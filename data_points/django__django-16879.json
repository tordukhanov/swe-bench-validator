{
  "repo": "django/django",
  "instance_id": "django__django-16879",
  "base_commit": "89f10a80d7e681cd0cccf22d932e380f51bd3524",
  "patch": "diff --git a/django/db/models/aggregates.py b/django/db/models/aggregates.py\n--- a/django/db/models/aggregates.py\n+++ b/django/db/models/aggregates.py\n@@ -65,7 +65,14 @@ def resolve_expression(\n         c.filter = c.filter and c.filter.resolve_expression(\n             query, allow_joins, reuse, summarize\n         )\n-        if not summarize:\n+        if summarize:\n+            # Summarized aggregates cannot refer to summarized aggregates.\n+            for ref in c.get_refs():\n+                if query.annotations[ref].is_summary:\n+                    raise FieldError(\n+                        f\"Cannot compute {c.name}('{ref}'): '{ref}' is an aggregate\"\n+                    )\n+        elif not self.is_summary:\n             # Call Aggregate.get_source_expressions() to avoid\n             # returning self.filter and including that in this loop.\n             expressions = super(Aggregate, c).get_source_expressions()\ndiff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1541,6 +1541,7 @@ class Subquery(BaseExpression, Combinable):\n     template = \"(%(subquery)s)\"\n     contains_aggregate = False\n     empty_result_set_value = None\n+    subquery = True\n \n     def __init__(self, queryset, output_field=None, **extra):\n         # Allow the usage of both QuerySet and sql.Query objects.\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -400,7 +400,11 @@ def get_aggregation(self, using, aggregate_exprs):\n         \"\"\"\n         if not aggregate_exprs:\n             return {}\n-        aggregates = {}\n+        # Store annotation mask prior to temporarily adding aggregations for\n+        # resolving purpose to facilitate their subsequent removal.\n+        refs_subquery = False\n+        replacements = {}\n+        annotation_select_mask = self.annotation_select_mask\n         for alias, aggregate_expr in aggregate_exprs.items():\n             self.check_alias(alias)\n             aggregate = aggregate_expr.resolve_expression(\n@@ -408,7 +412,20 @@ def get_aggregation(self, using, aggregate_exprs):\n             )\n             if not aggregate.contains_aggregate:\n                 raise TypeError(\"%s is not an aggregate expression\" % alias)\n-            aggregates[alias] = aggregate\n+            # Temporarily add aggregate to annotations to allow remaining\n+            # members of `aggregates` to resolve against each others.\n+            self.append_annotation_mask([alias])\n+            refs_subquery |= any(\n+                getattr(self.annotations[ref], \"subquery\", False)\n+                for ref in aggregate.get_refs()\n+            )\n+            aggregate = aggregate.replace_expressions(replacements)\n+            self.annotations[alias] = aggregate\n+            replacements[Ref(alias, aggregate)] = aggregate\n+        # Stash resolved aggregates now that they have been allowed to resolve\n+        # against each other.\n+        aggregates = {alias: self.annotations.pop(alias) for alias in aggregate_exprs}\n+        self.set_annotation_mask(annotation_select_mask)\n         # Existing usage of aggregation can be determined by the presence of\n         # selected aggregates but also by filters against aliased aggregates.\n         _, having, qualify = self.where.split_having_qualify()\n@@ -433,6 +450,7 @@ def get_aggregation(self, using, aggregate_exprs):\n             isinstance(self.group_by, tuple)\n             or self.is_sliced\n             or has_existing_aggregation\n+            or refs_subquery\n             or qualify\n             or self.distinct\n             or self.combinator\n",
  "test_patch": "diff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py\n--- a/tests/aggregation/tests.py\n+++ b/tests/aggregation/tests.py\n@@ -1260,7 +1260,7 @@ def test_annotate_over_annotate(self):\n         self.assertEqual(author.sum_age, other_author.sum_age)\n \n     def test_aggregate_over_aggregate(self):\n-        msg = \"Cannot resolve keyword 'age_agg' into field.\"\n+        msg = \"Cannot compute Avg('age_agg'): 'age_agg' is an aggregate\"\n         with self.assertRaisesMessage(FieldError, msg):\n             Author.objects.aggregate(\n                 age_agg=Sum(F(\"age\")),\n@@ -2102,12 +2102,17 @@ def test_exists_extra_where_with_aggregate(self):\n         )\n         self.assertEqual(len(qs), 6)\n \n-    def test_aggregation_over_annotation_shared_alias(self):\n+    def test_multiple_aggregate_references(self):\n+        aggregates = Author.objects.aggregate(\n+            total_books=Count(\"book\"),\n+            coalesced_total_books=Coalesce(\"total_books\", 0),\n+        )\n         self.assertEqual(\n-            Publisher.objects.annotate(agg=Count(\"book__authors\")).aggregate(\n-                agg=Count(\"agg\"),\n-            ),\n-            {\"agg\": 5},\n+            aggregates,\n+            {\n+                \"total_books\": 10,\n+                \"coalesced_total_books\": 10,\n+            },\n         )\n \n \n@@ -2182,3 +2187,23 @@ def test_referenced_group_by_annotation_kept(self):\n             mod_count=Count(\"*\")\n         )\n         self.assertEqual(queryset.count(), 1)\n+\n+    def test_referenced_subquery_requires_wrapping(self):\n+        total_books_qs = (\n+            Author.book_set.through.objects.values(\"author\")\n+            .filter(author=OuterRef(\"pk\"))\n+            .annotate(total=Count(\"book\"))\n+        )\n+        with self.assertNumQueries(1) as ctx:\n+            aggregate = (\n+                Author.objects.annotate(\n+                    total_books=Subquery(total_books_qs.values(\"total\"))\n+                )\n+                .values(\"pk\", \"total_books\")\n+                .aggregate(\n+                    sum_total_books=Sum(\"total_books\"),\n+                )\n+            )\n+        sql = ctx.captured_queries[0][\"sql\"].lower()\n+        self.assertEqual(sql.count(\"select\"), 3, \"Subquery wrapping required\")\n+        self.assertEqual(aggregate, {\"sum_total_books\": 3})\n",
  "problem_statement": "Case-When aggregation over aggregated fields doesn't work since 4.2\nDescription\n\t \n\t\t(last modified by Denis Rold√°n)\n\t \nThis same QuerySet was working on 4.1.X and prior versions and stopped working on 4.2.X:\nannotated_users = users_qs.annotate(\n\t\t\ttotal_things=Subquery(\n\t\t\t\tOtherModel.objects.filter(user_id=OuterRef(\"pk\")).annotate(\n\t\t\t\t\ttotal_objs=F(\"total\")\n\t\t\t\t).values(\"total_objs\")\n\t\t\t)\n)\nannotated_users.aggregate(\n\t\t\tsum_total_objs=Sum(\"total_things\"),\n\t\t\tavg_conversion_rate=Case(\n\t\t\t\tWhen(\n\t\t\t\t\tsum_total_objs=0,\n\t\t\t\t\tthen=0,\n\t\t\t\t),\n\t\t\t\tdefault=Round(\n\t\t\t\t\t(Sum(\"sum_total_confirmed_objs\") / Sum(\"sum_total_objs\")) * 100, 2\n\t\t\t\t),\n\t\t\t\toutput_field=FloatField(),\n\t\t\t)\n)\nAs you can see sum_total_objs is an aggregated field that is also used on a second field to calculate the conversion rate. To avoid a zero division problem, we were using a Case-When clause over that field. It works well on any 4.1 and prior versions but stopped working since 4.2, raising a FieldError like: \nCannot resolve keyword 'sum_total_objs' into field\nThe bug is reproducible with an extra test on the django aggregation test suite:\n\tdef test_referenced_group_by_aggregation_over_annotation(self):\n\t\ttotal_books_qs = (\n\t\t\tBook.objects.filter(authors__pk=OuterRef(\"pk\"))\n\t\t\t.order_by()\n\t\t\t.values(\"pk\")\n\t\t\t.annotate(total=Count(\"pk\"))\n\t\t\t.values(\"total\")\n\t\t)\n\t\t\n\t\tannotated_authors = Author.objects.annotate(\n\t\t\ttotal_books=Subquery(total_books_qs.annotate(\n\t\t\t\t\ttotal_books=F(\"total\")\n\t\t\t).values(\"total_books\")),\n\t\t\ttotal_books_a=Subquery(total_books_qs.filter(\n\t\t\t\tname__istartswith=\"a\"\n\t\t\t).annotate(\n\t\t\t\t\ttotal_books_a=F(\"total\")\n\t\t\t).values(\"total_books_a\")),\n\t\t).values(\n\t\t\t\"pk\",\n\t\t\t\"total_books\",\n\t\t\t\"total_books_a\",\n\t\t).order_by(\"-total_books\")\n\t\t\n\t\ttotals = annotated_authors.aggregate(\n\t\t\tsum_total_books=Sum(\"total_books\"),\n\t\t\tsum_total_books_a=Sum(\"total_books_a\"),\n\t\t\ta_over_total_rate=Case(\n\t\t\t\tWhen(\n\t\t\t\t\tsum_total_books=0,\n\t\t\t\t\tthen=0,\n\t\t\t\t),\n\t\t\t\tdefault=Round(\n\t\t\t\t\t(Sum(\"total_books_a\") / Sum(\"total_books\")) * 100, 2\n\t\t\t\t),\n\t\t\t\toutput_field=FloatField(),\n\t\t\t),\n\t\t)\n\t\t\n\t\tself.assertEqual(totals['sum_total_books'], 3)\n\t\tself.assertEqual(totals['sum_total_books_a'], 0)\n\t\tself.assertEqual(totals['a_over_total_rate'], 0)\nThanks for the support!\n",
  "hints_text": "Can you reproduce your issue with Django 4.2.1 (see 511dc3db539122577aaba71f5a24d65d5adab092)? If yes, please share your models.\nReplying to Mariusz Felisiak: Can you reproduce your issue with Django 4.2.1 (see 511dc3db539122577aaba71f5a24d65d5adab092)? If yes, please share your models. Correct. It doesn't work on Django 4.2.1 neither. I can reproduce the issue with a test on aggregation/tests.py def test_referenced_group_by_aggregation_over_annotation(self): total_books_qs = ( Book.objects.filter(authors__pk=OuterRef(\"pk\")) .order_by() .values(\"pk\") .annotate(total=Count(\"pk\")) .values(\"total\") ) annotated_authors = Author.objects.annotate( total_books=Subquery(total_books_qs.annotate( total_books=F(\"total\") ).values(\"total_books\")), total_books_a=Subquery(total_books_qs.filter( name__istartswith=\"a\" ).annotate( total_books_a=F(\"total\") ).values(\"total_books_a\")), ).values( \"pk\", \"total_books\", \"total_books_a\", ).order_by(\"-total_books\") totals = annotated_authors.aggregate( sum_total_books=Sum(\"total_books\"), sum_total_books_a=Sum(\"total_books_a\"), a_over_total_rate=Case( When( sum_total_books=0, then=0, ), default=Round( (Sum(\"total_books_a\") / Sum(\"total_books\")) * 100, 2 ), output_field=FloatField(), ), ) self.assertEqual(totals['sum_total_books'], 3) self.assertEqual(totals['sum_total_books_a'], 0) self.assertEqual(totals['a_over_total_rate'], 0)\nYou can find the test here: ‚Äãhttps://github.com/django/django/pull/16838\nThanks for the report. Regression in 1297c0d0d76a708017fe196b61a0ab324df76954. Reproduced at 59262c294d26d2aa9346284519545c0f988bf353.",
  "created_at": "2023-05-20T05:40:20Z",
  "version": "5.0",
  "FAIL_TO_PASS": "[\"test_referenced_subquery_requires_wrapping (aggregation.tests.AggregateAnnotationPruningTests.test_referenced_subquery_requires_wrapping)\", \"test_aggregate_over_aggregate (aggregation.tests.AggregateTestCase.test_aggregate_over_aggregate)\", \"test_multiple_aggregate_references (aggregation.tests.AggregateTestCase.test_multiple_aggregate_references)\"]",
  "PASS_TO_PASS": "[\"test_non_aggregate_annotation_pruned (aggregation.tests.AggregateAnnotationPruningTests.test_non_aggregate_annotation_pruned)\", \"test_referenced_aggregate_annotation_kept (aggregation.tests.AggregateAnnotationPruningTests.test_referenced_aggregate_annotation_kept)\", \"test_referenced_group_by_annotation_kept (aggregation.tests.AggregateAnnotationPruningTests.test_referenced_group_by_annotation_kept)\", \"test_unreferenced_aggregate_annotation_pruned (aggregation.tests.AggregateAnnotationPruningTests.test_unreferenced_aggregate_annotation_pruned)\", \"test_unused_aliased_aggregate_pruned (aggregation.tests.AggregateAnnotationPruningTests.test_unused_aliased_aggregate_pruned)\", \"test_add_implementation (aggregation.tests.AggregateTestCase.test_add_implementation)\", \"test_aggregate_alias (aggregation.tests.AggregateTestCase.test_aggregate_alias)\", \"test_aggregate_annotation (aggregation.tests.AggregateTestCase.test_aggregate_annotation)\", \"test_aggregate_in_order_by (aggregation.tests.AggregateTestCase.test_aggregate_in_order_by)\", \"test_aggregate_join_transform (aggregation.tests.AggregateTestCase.test_aggregate_join_transform)\", \"test_aggregate_multi_join (aggregation.tests.AggregateTestCase.test_aggregate_multi_join)\", \"test_aggregate_over_complex_annotation (aggregation.tests.AggregateTestCase.test_aggregate_over_complex_annotation)\", \"test_aggregate_transform (aggregation.tests.AggregateTestCase.test_aggregate_transform)\", \"test_aggregation_default_after_annotation (aggregation.tests.AggregateTestCase.test_aggregation_default_after_annotation)\", \"test_aggregation_default_compound_expression (aggregation.tests.AggregateTestCase.test_aggregation_default_compound_expression)\", \"test_aggregation_default_expression (aggregation.tests.AggregateTestCase.test_aggregation_default_expression)\", \"test_aggregation_default_group_by (aggregation.tests.AggregateTestCase.test_aggregation_default_group_by)\", \"test_aggregation_default_integer (aggregation.tests.AggregateTestCase.test_aggregation_default_integer)\", \"test_aggregation_default_not_in_aggregate (aggregation.tests.AggregateTestCase.test_aggregation_default_not_in_aggregate)\", \"test_aggregation_default_passed_another_aggregate (aggregation.tests.AggregateTestCase.test_aggregation_default_passed_another_aggregate)\", \"test_aggregation_default_unset (aggregation.tests.AggregateTestCase.test_aggregation_default_unset)\", \"test_aggregation_default_unsupported_by_count (aggregation.tests.AggregateTestCase.test_aggregation_default_unsupported_by_count)\", \"test_aggregation_default_using_date_from_database (aggregation.tests.AggregateTestCase.test_aggregation_default_using_date_from_database)\", \"test_aggregation_default_using_date_from_python (aggregation.tests.AggregateTestCase.test_aggregation_default_using_date_from_python)\", \"test_aggregation_default_using_datetime_from_database (aggregation.tests.AggregateTestCase.test_aggregation_default_using_datetime_from_database)\", \"test_aggregation_default_using_datetime_from_python (aggregation.tests.AggregateTestCase.test_aggregation_default_using_datetime_from_python)\", \"test_aggregation_default_using_decimal_from_database (aggregation.tests.AggregateTestCase.test_aggregation_default_using_decimal_from_database)\", \"test_aggregation_default_using_decimal_from_python (aggregation.tests.AggregateTestCase.test_aggregation_default_using_decimal_from_python)\", \"test_aggregation_default_using_duration_from_database (aggregation.tests.AggregateTestCase.test_aggregation_default_using_duration_from_database)\", \"test_aggregation_default_using_duration_from_python (aggregation.tests.AggregateTestCase.test_aggregation_default_using_duration_from_python)\", \"test_aggregation_default_using_time_from_database (aggregation.tests.AggregateTestCase.test_aggregation_default_using_time_from_database)\", \"test_aggregation_default_using_time_from_python (aggregation.tests.AggregateTestCase.test_aggregation_default_using_time_from_python)\", \"test_aggregation_default_zero (aggregation.tests.AggregateTestCase.test_aggregation_default_zero)\", \"test_aggregation_exists_annotation (aggregation.tests.AggregateTestCase.test_aggregation_exists_annotation)\", \"test_aggregation_exists_multivalued_outeref (aggregation.tests.AggregateTestCase.test_aggregation_exists_multivalued_outeref)\", \"test_aggregation_expressions (aggregation.tests.AggregateTestCase.test_aggregation_expressions)\", \"test_aggregation_filter_exists (aggregation.tests.AggregateTestCase.test_aggregation_filter_exists)\", \"test_aggregation_nested_subquery_outerref (aggregation.tests.AggregateTestCase.test_aggregation_nested_subquery_outerref)\", \"test_aggregation_order_by_not_selected_annotation_values (aggregation.tests.AggregateTestCase.test_aggregation_order_by_not_selected_annotation_values)\", \"Random() is not included in the GROUP BY when used for ordering.\", \"Subquery annotations are excluded from the GROUP BY if they are\", \"test_aggregation_subquery_annotation_exists (aggregation.tests.AggregateTestCase.test_aggregation_subquery_annotation_exists)\", \"Subquery annotations must be included in the GROUP BY if they use\", \"test_aggregation_subquery_annotation_related_field (aggregation.tests.AggregateTestCase.test_aggregation_subquery_annotation_related_field)\", \"Subquery annotations and external aliases are excluded from the GROUP\", \"test_aggregation_subquery_annotation_values_collision (aggregation.tests.AggregateTestCase.test_aggregation_subquery_annotation_values_collision)\", \"test_alias_sql_injection (aggregation.tests.AggregateTestCase.test_alias_sql_injection)\", \"test_annotate_basic (aggregation.tests.AggregateTestCase.test_annotate_basic)\", \"test_annotate_defer (aggregation.tests.AggregateTestCase.test_annotate_defer)\", \"test_annotate_defer_select_related (aggregation.tests.AggregateTestCase.test_annotate_defer_select_related)\", \"test_annotate_m2m (aggregation.tests.AggregateTestCase.test_annotate_m2m)\", \"test_annotate_ordering (aggregation.tests.AggregateTestCase.test_annotate_ordering)\", \"test_annotate_over_annotate (aggregation.tests.AggregateTestCase.test_annotate_over_annotate)\", \"test_annotate_values (aggregation.tests.AggregateTestCase.test_annotate_values)\", \"test_annotate_values_aggregate (aggregation.tests.AggregateTestCase.test_annotate_values_aggregate)\", \"test_annotate_values_list (aggregation.tests.AggregateTestCase.test_annotate_values_list)\", \"test_annotated_aggregate_over_annotated_aggregate (aggregation.tests.AggregateTestCase.test_annotated_aggregate_over_annotated_aggregate)\", \"test_annotation (aggregation.tests.AggregateTestCase.test_annotation)\", \"test_annotation_expressions (aggregation.tests.AggregateTestCase.test_annotation_expressions)\", \"test_arguments_must_be_expressions (aggregation.tests.AggregateTestCase.test_arguments_must_be_expressions)\", \"test_avg_decimal_field (aggregation.tests.AggregateTestCase.test_avg_decimal_field)\", \"test_avg_duration_field (aggregation.tests.AggregateTestCase.test_avg_duration_field)\", \"test_backwards_m2m_annotate (aggregation.tests.AggregateTestCase.test_backwards_m2m_annotate)\", \"test_coalesced_empty_result_set (aggregation.tests.AggregateTestCase.test_coalesced_empty_result_set)\", \"test_combine_different_types (aggregation.tests.AggregateTestCase.test_combine_different_types)\", \"test_complex_aggregations_require_kwarg (aggregation.tests.AggregateTestCase.test_complex_aggregations_require_kwarg)\", \"test_complex_values_aggregation (aggregation.tests.AggregateTestCase.test_complex_values_aggregation)\", \"test_count (aggregation.tests.AggregateTestCase.test_count)\", \"test_count_distinct_expression (aggregation.tests.AggregateTestCase.test_count_distinct_expression)\", \"test_count_star (aggregation.tests.AggregateTestCase.test_count_star)\", \".dates() returns a distinct set of dates when applied to a\", \"test_decimal_max_digits_has_no_effect (aggregation.tests.AggregateTestCase.test_decimal_max_digits_has_no_effect)\", \"test_distinct_on_aggregate (aggregation.tests.AggregateTestCase.test_distinct_on_aggregate)\", \"test_empty_aggregate (aggregation.tests.AggregateTestCase.test_empty_aggregate)\", \"test_empty_result_optimization (aggregation.tests.AggregateTestCase.test_empty_result_optimization)\", \"test_even_more_aggregate (aggregation.tests.AggregateTestCase.test_even_more_aggregate)\", \"test_exists_extra_where_with_aggregate (aggregation.tests.AggregateTestCase.test_exists_extra_where_with_aggregate)\", \"test_exists_none_with_aggregate (aggregation.tests.AggregateTestCase.test_exists_none_with_aggregate)\", \"test_expression_on_aggregation (aggregation.tests.AggregateTestCase.test_expression_on_aggregation)\", \"test_filter_aggregate (aggregation.tests.AggregateTestCase.test_filter_aggregate)\", \"Filtering against an aggregate requires the usage of the HAVING clause.\", \"test_filtering (aggregation.tests.AggregateTestCase.test_filtering)\", \"test_fkey_aggregate (aggregation.tests.AggregateTestCase.test_fkey_aggregate)\", \"Exists annotations are included in the GROUP BY if they are\", \"test_group_by_nested_expression_with_params (aggregation.tests.AggregateTestCase.test_group_by_nested_expression_with_params)\", \"Subquery annotations are included in the GROUP BY if they are\", \"An annotation included in values() before an aggregate should be\", \"test_more_aggregation (aggregation.tests.AggregateTestCase.test_more_aggregation)\", \"test_multi_arg_aggregate (aggregation.tests.AggregateTestCase.test_multi_arg_aggregate)\", \"test_multiple_aggregates (aggregation.tests.AggregateTestCase.test_multiple_aggregates)\", \"An annotation not included in values() before an aggregate should be\", \"test_nonaggregate_aggregation_throws (aggregation.tests.AggregateTestCase.test_nonaggregate_aggregation_throws)\", \"test_nonfield_annotation (aggregation.tests.AggregateTestCase.test_nonfield_annotation)\", \"test_order_of_precedence (aggregation.tests.AggregateTestCase.test_order_of_precedence)\", \"test_related_aggregate (aggregation.tests.AggregateTestCase.test_related_aggregate)\", \"test_reverse_fkey_annotate (aggregation.tests.AggregateTestCase.test_reverse_fkey_annotate)\", \"test_single_aggregate (aggregation.tests.AggregateTestCase.test_single_aggregate)\", \"Sum on a distinct() QuerySet should aggregate only the distinct items.\", \"test_sum_duration_field (aggregation.tests.AggregateTestCase.test_sum_duration_field)\", \"Subqueries do not needlessly contain ORDER BY, SELECT FOR UPDATE or\", \"Aggregation over sliced queryset works correctly.\", \"Doing exclude() on a foreign model after annotate() doesn't crash.\", \"test_values_aggregation (aggregation.tests.AggregateTestCase.test_values_aggregation)\", \"test_values_annotation_with_expression (aggregation.tests.AggregateTestCase.test_values_annotation_with_expression)\"]",
  "environment_setup_commit": "4a72da71001f154ea60906a2f74898d32b7322a7",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.774389",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}