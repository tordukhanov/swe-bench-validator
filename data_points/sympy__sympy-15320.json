{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-15320",
  "base_commit": "ddcf91eef02de6e8de18ff49eb4967ddc98a96f1",
  "patch": "diff --git a/sympy/polys/rootoftools.py b/sympy/polys/rootoftools.py\n--- a/sympy/polys/rootoftools.py\n+++ b/sympy/polys/rootoftools.py\n@@ -176,7 +176,8 @@ class ComplexRootOf(RootOf):\n     Roots of a univariate polynomial separated into disjoint\n     real or complex intervals and indexed in a fixed order.\n     Currently only rational coefficients are allowed.\n-    Can be imported as ``CRootOf``.\n+    Can be imported as ``CRootOf``. To avoid confusion, the\n+    generator must be a Symbol.\n \n \n     Examples\n@@ -270,6 +271,23 @@ class ComplexRootOf(RootOf):\n     >>> t.eval_rational(n=2)\n     104755/2097152 - 6634255*I/2097152\n \n+    Notes\n+    =====\n+\n+    Although a PurePoly can be constructed from a non-symbol generator\n+    RootOf instances of non-symbols are disallowed to avoid confusion\n+    over what root is being represented.\n+\n+    >>> from sympy import exp, PurePoly\n+    >>> PurePoly(x) == PurePoly(exp(x))\n+    True\n+    >>> CRootOf(x - 1, 0)\n+    1\n+    >>> CRootOf(exp(x) - 1, 0)  # would correspond to x == 0\n+    Traceback (most recent call last):\n+    ...\n+    sympy.polys.polyerrors.PolynomialError: generator must be a Symbol\n+\n     See Also\n     ========\n     eval_approx\n@@ -306,6 +324,11 @@ def __new__(cls, f, x, index=None, radicals=False, expand=True):\n         if not poly.is_univariate:\n             raise PolynomialError(\"only univariate polynomials are allowed\")\n \n+        if not poly.gen.is_Symbol:\n+            # PurePoly(sin(x) + 1) == PurePoly(x + 1) but the roots of\n+            # x for each are not the same: issue 8617\n+            raise PolynomialError(\"generator must be a Symbol\")\n+\n         degree = poly.degree()\n \n         if degree <= 0:\n",
  "test_patch": "diff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\n--- a/sympy/polys/tests/test_polytools.py\n+++ b/sympy/polys/tests/test_polytools.py\n@@ -2500,10 +2500,9 @@ def test_factor_large():\n             x**6 - x**5 + x**4 - x**3 + x**2 - x + 1, 1)])\n \n \n-@XFAIL\n def test_factor_noeval():\n-    assert factor(6*x - 10) == 2*(3*x - 5)\n-    assert factor((6*x - 10)/(3*x - 6)) == S(2)/3*((3*x - 5)/(x - 2))\n+    assert factor(6*x - 10) == Mul(2, 3*x - 5, evaluate=False)\n+    assert factor((6*x - 10)/(3*x - 6)) == Mul(S(2)/3, 3*x - 5, 1/(x - 2))\n \n \n def test_intervals():\ndiff --git a/sympy/polys/tests/test_rootoftools.py b/sympy/polys/tests/test_rootoftools.py\n--- a/sympy/polys/tests/test_rootoftools.py\n+++ b/sympy/polys/tests/test_rootoftools.py\n@@ -79,8 +79,9 @@ def test_CRootOf___new__():\n \n     raises(PolynomialError, lambda: rootof(Poly(0, x), 0))\n     raises(PolynomialError, lambda: rootof(Poly(1, x), 0))\n-\n     raises(PolynomialError, lambda: rootof(x - y, 0))\n+    # issue 8617\n+    raises(PolynomialError, lambda: rootof(exp(x), 0))\n \n     raises(NotImplementedError, lambda: rootof(x**3 - x + sqrt(2), 0))\n     raises(NotImplementedError, lambda: rootof(x**3 - x + I, 0))\n@@ -237,9 +238,6 @@ def test_CRootOf_evalf():\n     # issue 6451\n     r = rootof(legendre_poly(64, x), 7)\n     assert r.n(2) == r.n(100).n(2)\n-    # issue 8617\n-    ans = [w.n(2) for w in solve(x**3 - x - 4)]\n-    assert rootof(exp(x)**3 - exp(x) - 4, 0).n(2) in ans\n     # issue 9019\n     r0 = rootof(x**2 + 1, 0, radicals=False)\n     r1 = rootof(x**2 + 1, 1, radicals=False)\n",
  "problem_statement": "RootOf might ignore generator\nThis is related to #8551 but a little different. I'm not sure of all the ramifications but just want to document this.\n\nNote how feeding RootOf an expression in terms of a new generator might ignore that generator if the form of the polynomial is the same\n\n```\n>>> RootOf(x**3+x-1,0)\nRootOf(x**3 + x - 1, 0)\n>>> RootOf((x**3+x-1).subs(x,tan(x)),0)\nRootOf(x**3 + x - 1, 0)\n>>> _.poly.gen\nx  <----------------/!\\ When you solve for RootOf values you will be getting tan(x) values\n```\n\n```\n>>> RootOf(tan(x)**3 + 2*tan(x) - 1, 0)  # a new form\nRootOf(tan(x)**3 + 2*tan(x) - 1, 0)\n>>> RootOf((x**3+2*x-1),0)  # same form but new generator (x instead of tan(x)\nRootOf(tan(x)**3 + 2*tan(x) - 1, 0)  <--------/!\\ generator is tan(x) instead of x\n>>> _.poly.gen\ntan(x)\n```\n\n",
  "hints_text": "Here's a place where the presence of the non-symbol generator creates problems: checking of the solution to the following equation:\n\n```\n>>> eq=737280.0*exp(-t)**24 - 576000.0*exp(-t)**15 + 46080.0*exp(-t)**6\n>>> var('t', real=1);sol=solve(eq)\nt\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"sympy\\solvers\\solvers.py\", line 909, in solve\n    solution = _solve(f[0], *symbols, **flags)\n  File \"sympy\\solvers\\solvers.py\", line 1427, in _solve\n    for den in dens)]\n  File \"sympy\\solvers\\solvers.py\", line 1427, in <genexpr>\n    for den in dens)]\n  File \"sympy\\solvers\\solvers.py\", line 290, in checksol\n    return bool(abs(val.n(18).n(12, chop=True)) < 1e-9)\n  File \"sympy\\core\\evalf.py\", line 1331, in evalf\n    result = evalf(self, prec + 4, options)\n  File \"sympy\\core\\evalf.py\", line 1225, in evalf\n    r = rf(x, prec, options)\n  File \"sympy\\core\\evalf.py\", line 620, in evalf_pow\n    re, im, re_acc, im_acc = evalf(base, prec + 5, options)\n  File \"sympy\\core\\evalf.py\", line 1231, in evalf\n    re, im = x._eval_evalf(prec).as_real_imag()\n  File \"sympy\\polys\\rootoftools.py\", line 557, in _eval_evalf\n    root = findroot(func, x0)\n  File \"sympy\\mpmath\\calculus\\optimization.py\", line 931, in findroot\n    fx = f(x0[0])\n  File \"<string>\", line 1, in <lambda>\n  File \"sympy\\core\\expr.py\", line 225, in __float__\n    raise TypeError(\"can't convert expression to float\")\nTypeError: can't convert expression to float\n```\n\n`solve` may have worked a way around this but the issue still remains.\r\n```python\r\n>>> RootOf(x**3+x-1, 0).poly.gen\r\nx\r\n>>> RootOf(sin(x)**3+sin(x)-1, 0)\r\nCRootOf(x**3 + x - 1, 0)\r\n```\r\nRootOf represents a number, so it's proper to hash the above as the same. But from a user perspective one has to realize that it doesn't represent a solution for `x` unless `x` is a symbol.\r\n```\r\n>>> RootOf(sin(x)-1,0)  # sin(x) == 1 so x = (2*i+1)*pi/2\r\n1\r\n```\r\nPerhaps the safest solution is to disallow anything but a symbol to be the generator.\n>  the safest solution is to disallow anything but a symbol to be the generator.\r\n\r\n+1",
  "created_at": "2018-10-02T12:32:41Z",
  "version": "1.4",
  "FAIL_TO_PASS": "[\"test_CRootOf___new__\"]",
  "PASS_TO_PASS": "[\"test_Poly_from_dict\", \"test_Poly_from_list\", \"test_Poly_from_poly\", \"test_Poly_from_expr\", \"test_Poly__new__\", \"test_Poly__args\", \"test_Poly__gens\", \"test_Poly_zero\", \"test_Poly_one\", \"test_Poly__unify\", \"test_Poly_free_symbols\", \"test_PurePoly_free_symbols\", \"test_Poly__eq__\", \"test_PurePoly__eq__\", \"test_PurePoly_Poly\", \"test_Poly_get_domain\", \"test_Poly_set_domain\", \"test_Poly_get_modulus\", \"test_Poly_set_modulus\", \"test_Poly_add_ground\", \"test_Poly_sub_ground\", \"test_Poly_mul_ground\", \"test_Poly_quo_ground\", \"test_Poly_exquo_ground\", \"test_Poly_abs\", \"test_Poly_neg\", \"test_Poly_add\", \"test_Poly_sub\", \"test_Poly_mul\", \"test_issue_13079\", \"test_Poly_sqr\", \"test_Poly_pow\", \"test_Poly_divmod\", \"test_Poly_eq_ne\", \"test_Poly_nonzero\", \"test_Poly_properties\", \"test_Poly_is_irreducible\", \"test_Poly_subs\", \"test_Poly_replace\", \"test_Poly_reorder\", \"test_Poly_ltrim\", \"test_Poly_has_only_gens\", \"test_Poly_to_ring\", \"test_Poly_to_field\", \"test_Poly_to_exact\", \"test_Poly_retract\", \"test_Poly_slice\", \"test_Poly_coeffs\", \"test_Poly_monoms\", \"test_Poly_terms\", \"test_Poly_all_coeffs\", \"test_Poly_all_monoms\", \"test_Poly_all_terms\", \"test_Poly_termwise\", \"test_Poly_length\", \"test_Poly_as_dict\", \"test_Poly_as_expr\", \"test_Poly_lift\", \"test_Poly_deflate\", \"test_Poly_inject\", \"test_Poly_eject\", \"test_Poly_exclude\", \"test_Poly__gen_to_level\", \"test_Poly_degree\", \"test_Poly_degree_list\", \"test_Poly_total_degree\", \"test_Poly_homogenize\", \"test_Poly_homogeneous_order\", \"test_Poly_LC\", \"test_Poly_TC\", \"test_Poly_EC\", \"test_Poly_coeff\", \"test_Poly_nth\", \"test_Poly_LM\", \"test_Poly_LM_custom_order\", \"test_Poly_EM\", \"test_Poly_LT\", \"test_Poly_ET\", \"test_Poly_max_norm\", \"test_Poly_l1_norm\", \"test_Poly_clear_denoms\", \"test_Poly_rat_clear_denoms\", \"test_Poly_integrate\", \"test_Poly_diff\", \"test_issue_9585\", \"test_Poly_eval\", \"test_Poly___call__\", \"test_parallel_poly_from_expr\", \"test_pdiv\", \"test_div\", \"test_gcdex\", \"test_revert\", \"test_subresultants\", \"test_resultant\", \"test_discriminant\", \"test_dispersion\", \"test_gcd_list\", \"test_lcm_list\", \"test_gcd\", \"test_gcd_numbers_vs_polys\", \"test_terms_gcd\", \"test_trunc\", \"test_monic\", \"test_content\", \"test_primitive\", \"test_compose\", \"test_shift\", \"test_transform\", \"test_sturm\", \"test_gff\", \"test_norm\", \"test_sqf_norm\", \"test_sqf\", \"test_factor\", \"test_factor_large\", \"test_factor_noeval\", \"test_intervals\", \"test_refine_root\", \"test_count_roots\", \"test_Poly_root\", \"test_real_roots\", \"test_all_roots\", \"test_nroots\", \"test_ground_roots\", \"test_nth_power_roots_poly\", \"test_torational_factor_list\", \"test_cancel\", \"test_reduced\", \"test_groebner\", \"test_fglm\", \"test_is_zero_dimensional\", \"test_GroebnerBasis\", \"test_poly\", \"test_keep_coeff\", \"test_noncommutative\", \"test_to_rational_coeffs\", \"test_factor_terms\", \"test_as_list\", \"test_issue_11198\", \"test_Poly_precision\", \"test_issue_12400\", \"test_CRootOf_attributes\", \"test_CRootOf___eq__\", \"test_CRootOf___eval_Eq__\", \"test_CRootOf_is_real\", \"test_CRootOf_is_complex\", \"test_CRootOf_subs\", \"test_CRootOf_diff\", \"test_CRootOf_evalf\", \"test_CRootOf_evalf_caching_bug\", \"test_CRootOf_real_roots\", \"test_CRootOf_all_roots\", \"test_CRootOf_eval_rational\", \"test_RootSum___new__\", \"test_RootSum_free_symbols\", \"test_RootSum___eq__\", \"test_RootSum_doit\", \"test_RootSum_evalf\", \"test_RootSum_diff\", \"test_RootSum_subs\", \"test_RootSum_rational\", \"test_RootSum_independent\", \"test_issue_7876\", \"test_issue_8316\", \"test__imag_count\", \"test_RootOf_is_imaginary\", \"test_is_disjoint\", \"test_pure_key_dict\"]",
  "environment_setup_commit": "73b3f90093754c5ed1561bd885242330e3583004",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.098861",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}