{
  "repo": "django/django",
  "instance_id": "django__django-15324",
  "base_commit": "0f6946495a8ec955b471ca1baaf408ceb53d4796",
  "patch": "diff --git a/django/http/multipartparser.py b/django/http/multipartparser.py\n--- a/django/http/multipartparser.py\n+++ b/django/http/multipartparser.py\n@@ -320,6 +320,8 @@ def sanitize_file_name(self, file_name):\n         file_name = html.unescape(file_name)\n         file_name = file_name.rsplit('/')[-1]\n         file_name = file_name.rsplit('\\\\')[-1]\n+        # Remove non-printable characters.\n+        file_name = ''.join([char for char in file_name if char.isprintable()])\n \n         if file_name in {'', '.', '..'}:\n             return None\n",
  "test_patch": "diff --git a/tests/file_uploads/tests.py b/tests/file_uploads/tests.py\n--- a/tests/file_uploads/tests.py\n+++ b/tests/file_uploads/tests.py\n@@ -283,6 +283,29 @@ def test_blank_filenames(self):\n         for i, name in enumerate(filenames):\n             self.assertIsNone(received.get('file%s' % i))\n \n+    def test_non_printable_chars_in_file_names(self):\n+        file_name = 'non-\\x00printable\\x00\\n_chars.txt\\x00'\n+        payload = client.FakePayload()\n+        payload.write('\\r\\n'.join([\n+            '--' + client.BOUNDARY,\n+            f'Content-Disposition: form-data; name=\"file\"; filename=\"{file_name}\"',\n+            'Content-Type: application/octet-stream',\n+            '',\n+            'You got pwnd.\\r\\n'\n+        ]))\n+        payload.write('\\r\\n--' + client.BOUNDARY + '--\\r\\n')\n+        r = {\n+            'CONTENT_LENGTH': len(payload),\n+            'CONTENT_TYPE': client.MULTIPART_CONTENT,\n+            'PATH_INFO': '/echo/',\n+            'REQUEST_METHOD': 'POST',\n+            'wsgi.input': payload,\n+        }\n+        response = self.client.request(**r)\n+        # Non-printable chars are sanitized.\n+        received = response.json()\n+        self.assertEqual(received['file'], 'non-printable_chars.txt')\n+\n     def test_dangerous_file_names(self):\n         \"\"\"Uploaded file names should be sanitized before ever reaching the view.\"\"\"\n         # This test simulates possible directory traversal attacks by a\n",
  "problem_statement": "File upload crash when a file extension contains null characters.\nDescription\n\t\nA >2.5M file uploaded with a raw null byte anyplace after the . in its filename means that Django attempts to create a tempfile with that same \"extension,\" which errors out with ValueError: embedded null byte.\nIt's almost certainly a violation of RFC to have a filename with a raw null byte in it, but it shouldn't result in a 500 when parsing the form.\nHere's code to generate a bad request:\n#!/usr/bin/env python3\nimport io\nimport requests\ncontents = io.StringIO(\".\" * (1024 * 1024 * 3))\nfiles = {\"docfile\": (b\"bogus.txt!\", contents, \"text/plain\")}\nreq = requests.Request(\"POST\", \"http://localhost:8000/\", files=files, data={})\nprepared = req.prepare()\nbody = prepared.body\nassert isinstance(body, bytes)\nprepared.body = body.replace(b\"!\", b\"\\x00\")\nrequests.Session().send(prepared)\n...which produces an error with the view:\nfrom django import forms\nfrom django.http import HttpResponseRedirect\nfrom django.shortcuts import render\nfrom django.views.decorators.csrf import csrf_exempt\nclass UploadFileForm(forms.Form):\n\tdocfile = forms.FileField()\n@csrf_exempt\ndef index(request):\n\tif request.method == 'POST':\n\t\tform = UploadFileForm(request.POST, request.FILES)\n\t\tif form.is_valid():\n\t\t\tprint(repr(request.FILES['docfile']))\n\t\t\treturn HttpResponseRedirect('/')\n\t\telse:\n\t\t\tprint(\"Not valid!\")\n\t\t\treturn HttpResponseRedirect('/')\n\telse:\n\t\tform = UploadFileForm()\n\treturn render(request, 'uploads/index.html', {'form': form})\nI'm not sure what the goal is of preserving the \"extension\" of the uploaded file in the tempfile that is made; if that's important enough a behaviour to keep, some amount of escaping on the parsed-out extension may be necessary.\n",
  "hints_text": "Oh, and for completeness, this is the traceback: Traceback (most recent call last): File \"/usr/local/lib/python3.9/site-packages/django/core/handlers/exception.py\", line 47, in inner response = get_response(request) File \"/usr/local/lib/python3.9/site-packages/django/core/handlers/base.py\", line 181, in _get_response response = wrapped_callback(request, *callback_args, **callback_kwargs) File \"/usr/local/lib/python3.9/site-packages/django/views/decorators/csrf.py\", line 54, in wrapped_view return view_func(*args, **kwargs) File \"/Users/chmrr/src/test-django/upload_null_byte/uploads/views.py\", line 14, in index form = UploadFileForm(request.POST, request.FILES) File \"/usr/local/lib/python3.9/site-packages/django/core/handlers/wsgi.py\", line 102, in _get_post self._load_post_and_files() File \"/usr/local/lib/python3.9/site-packages/django/http/request.py\", line 362, in _load_post_and_files self._post, self._files = self.parse_file_upload(self.META, data) File \"/usr/local/lib/python3.9/site-packages/django/http/request.py\", line 322, in parse_file_upload return parser.parse() File \"/usr/local/lib/python3.9/site-packages/django/http/multipartparser.py\", line 233, in parse handler.new_file( File \"/usr/local/lib/python3.9/site-packages/django/core/files/uploadhandler.py\", line 147, in new_file self.file = TemporaryUploadedFile(self.file_name, self.content_type, 0, self.charset, self.content_type_extra) File \"/usr/local/lib/python3.9/site-packages/django/core/files/uploadedfile.py\", line 64, in __init__ file = tempfile.NamedTemporaryFile(suffix='.upload' + ext, dir=settings.FILE_UPLOAD_TEMP_DIR) File \"/usr/local/Cellar/python@3.9/3.9.5/Frameworks/Python.framework/Versions/3.9/lib/python3.9/tempfile.py\", line 541, in NamedTemporaryFile (fd, name) = _mkstemp_inner(dir, prefix, suffix, flags, output_type) File \"/usr/local/Cellar/python@3.9/3.9.5/Frameworks/Python.framework/Versions/3.9/lib/python3.9/tempfile.py\", line 251, in _mkstemp_inner fd = _os.open(file, flags, 0o600) ValueError: embedded null byte\nThanks for the detailed report! I'd remove null characters in MultiPartParser.sanitize_file_name().\nâ€‹PR",
  "created_at": "2022-01-17T10:12:43Z",
  "version": "4.1",
  "FAIL_TO_PASS": "[\"test_non_printable_chars_in_file_names (file_uploads.tests.FileUploadTests)\"]",
  "PASS_TO_PASS": "[\"test_bad_type_content_length (file_uploads.tests.MultiParserTests)\", \"test_empty_upload_handlers (file_uploads.tests.MultiParserTests)\", \"test_invalid_content_type (file_uploads.tests.MultiParserTests)\", \"test_negative_content_length (file_uploads.tests.MultiParserTests)\", \"test_rfc2231_parsing (file_uploads.tests.MultiParserTests)\", \"Test wrongly formatted RFC 2231 headers (missing double single quotes).\", \"test_sanitize_file_name (file_uploads.tests.MultiParserTests)\", \"test_sanitize_invalid_file_name (file_uploads.tests.MultiParserTests)\", \"test_not_a_directory (file_uploads.tests.DirectoryCreationTests)\", \"test_base64_upload (file_uploads.tests.FileUploadTests)\", \"test_big_base64_newlines_upload (file_uploads.tests.FileUploadTests)\", \"test_big_base64_upload (file_uploads.tests.FileUploadTests)\", \"Receiving file upload when filename is blank (before and after\", \"test_broken_custom_upload_handler (file_uploads.tests.FileUploadTests)\", \"Uploaded files may have content type parameters available.\", \"test_custom_upload_handler (file_uploads.tests.FileUploadTests)\", \"Uploaded file names should be sanitized before ever reaching the view.\", \"If passed an empty multipart message, MultiPartParser will return\", \"test_file_content (file_uploads.tests.FileUploadTests)\", \"The server should not block when there are upload errors (bug #8622).\", \"The storage backend shouldn't mess with the case of the filenames\", \"File names over 256 characters (dangerous on some platforms) get fixed up.\", \"test_filename_traversal_upload (file_uploads.tests.FileUploadTests)\", \"test_fileupload_getlist (file_uploads.tests.FileUploadTests)\", \"test_fileuploads_closed_at_request_end (file_uploads.tests.FileUploadTests)\", \"test_large_upload (file_uploads.tests.FileUploadTests)\", \"test_no_parsing_triggered_by_fd_closing (file_uploads.tests.FileUploadTests)\", \"test_simple_upload (file_uploads.tests.FileUploadTests)\", \"test_stop_upload_temporary_file_handler (file_uploads.tests.FileUploadTests)\", \"If passed an incomplete multipart message, MultiPartParser does not\", \"test_unicode_file_name (file_uploads.tests.FileUploadTests)\", \"Test receiving file upload when filename is encoded with RFC2231\", \"test_unicode_file_name_rfc2231_with_double_quotes (file_uploads.tests.FileUploadTests)\", \"test_unicode_name_rfc2231_with_double_quotes (file_uploads.tests.FileUploadTests)\", \"test_upload_interrupted_temporary_file_handler (file_uploads.tests.FileUploadTests)\", \"test_upload_name_is_validated (file_uploads.tests.FileUploadTests)\"]",
  "environment_setup_commit": "647480166bfe7532e8c471fef0146e3a17e6c0c9",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.725805",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}