{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-19091",
  "base_commit": "64d28fe0534f6993695d11244ea740f783958dc8",
  "patch": "diff --git a/sympy/tensor/tensor.py b/sympy/tensor/tensor.py\n--- a/sympy/tensor/tensor.py\n+++ b/sympy/tensor/tensor.py\n@@ -2084,9 +2084,19 @@ def recursor(expr, pos):\n         return recursor(self, ())\n \n     @staticmethod\n-    def _match_indices_with_other_tensor(array, free_ind1, free_ind2, replacement_dict):\n+    def _contract_and_permute_with_metric(metric, array, pos, dim):\n+        # TODO: add possibility of metric after (spinors)\n         from .array import tensorcontraction, tensorproduct, permutedims\n \n+        array = tensorcontraction(tensorproduct(metric, array), (1, 2+pos))\n+        permu = list(range(dim))\n+        permu[0], permu[pos] = permu[pos], permu[0]\n+        return permutedims(array, permu)\n+\n+    @staticmethod\n+    def _match_indices_with_other_tensor(array, free_ind1, free_ind2, replacement_dict):\n+        from .array import permutedims\n+\n         index_types1 = [i.tensor_index_type for i in free_ind1]\n \n         # Check if variance of indices needs to be fixed:\n@@ -2121,13 +2131,6 @@ def _match_indices_with_other_tensor(array, free_ind1, free_ind2, replacement_di\n         if len(set(free_ind1) & set(free_ind2)) < len(free_ind1):\n             raise ValueError(\"incompatible indices: %s and %s\" % (free_ind1, free_ind2))\n \n-        # TODO: add possibility of metric after (spinors)\n-        def contract_and_permute(metric, array, pos):\n-            array = tensorcontraction(tensorproduct(metric, array), (1, 2+pos))\n-            permu = list(range(len(free_ind1)))\n-            permu[0], permu[pos] = permu[pos], permu[0]\n-            return permutedims(array, permu)\n-\n         # Raise indices:\n         for pos in pos2up:\n             index_type_pos = index_types1[pos]  # type: TensorIndexType\n@@ -2135,14 +2138,14 @@ def contract_and_permute(metric, array, pos):\n                 raise ValueError(\"No metric provided to lower index\")\n             metric = replacement_dict[index_type_pos]\n             metric_inverse = _TensorDataLazyEvaluator.inverse_matrix(metric)\n-            array = contract_and_permute(metric_inverse, array, pos)\n+            array = TensExpr._contract_and_permute_with_metric(metric_inverse, array, pos, len(free_ind1))\n         # Lower indices:\n         for pos in pos2down:\n             index_type_pos = index_types1[pos]  # type: TensorIndexType\n             if index_type_pos not in replacement_dict:\n                 raise ValueError(\"No metric provided to lower index\")\n             metric = replacement_dict[index_type_pos]\n-            array = contract_and_permute(metric, array, pos)\n+            array = TensExpr._contract_and_permute_with_metric(metric, array, pos, len(free_ind1))\n \n         if free_ind1:\n             permutation = TensExpr._get_indices_permutation(free_ind2, free_ind1)\n@@ -2920,10 +2923,17 @@ def _extract_data(self, replacement_dict):\n             # Remove elements in `dum2` from `dum1`:\n             dum1 = [pair for pair in dum1 if pair not in dum2]\n         if len(dum1) > 0:\n+            indices1 = self.get_indices()\n             indices2 = other.get_indices()\n             repl = {}\n             for p1, p2 in dum1:\n                 repl[indices2[p2]] = -indices2[p1]\n+                for pos in (p1, p2):\n+                    if indices1[pos].is_up ^ indices2[pos].is_up:\n+                        metric = replacement_dict[indices1[pos].tensor_index_type]\n+                        if indices1[pos].is_up:\n+                            metric = _TensorDataLazyEvaluator.inverse_matrix(metric)\n+                        array = self._contract_and_permute_with_metric(metric, array, pos, len(indices2))\n             other = other.xreplace(repl).doit()\n             array = _TensorDataLazyEvaluator.data_contract_dum([array], dum1, len(indices2))\n \n",
  "test_patch": "diff --git a/sympy/tensor/tests/test_tensor.py b/sympy/tensor/tests/test_tensor.py\n--- a/sympy/tensor/tests/test_tensor.py\n+++ b/sympy/tensor/tests/test_tensor.py\n@@ -1910,6 +1910,13 @@ def test_tensor_replacement():\n     repl = {H(i, -i): 42}\n     assert expr._extract_data(repl) == ([], 42)\n \n+    expr = H(i, -i)\n+    repl = {\n+        H(-i, -j): Array([[1, 0, 0, 0], [0, -1, 0, 0], [0, 0, -1, 0], [0, 0, 0, -1]]),\n+        L: Array([[1, 0, 0, 0], [0, -1, 0, 0], [0, 0, -1, 0], [0, 0, 0, -1]]),\n+    }\n+    assert expr._extract_data(repl) == ([], 4)\n+\n     # Replace with array, raise exception if indices are not compatible:\n     expr = A(i)*A(j)\n     repl = {A(i): [1, 2]}\n",
  "problem_statement": "Tensor contractions are wrong\nThis is essentially a generalization of #17328.\r\n\r\nThe problem in the current implementation is that contractions are handled before applications of the metric, which leads to incorrect results such as in #17328.\r\n\r\nIn `tensor/tensor.py`:\r\n```python\r\nclass Tensor(TensExpr):\r\n# ...\r\n    def _extract_data(self, replacement_dict):\r\n    # ...\r\n        if len(dum1) > 0:\r\n            indices2 = other.get_indices()\r\n            repl = {}\r\n            for p1, p2 in dum1:\r\n                repl[indices2[p2]] = -indices2[p1]\r\n            other = other.xreplace(repl).doit()\r\n            array = _TensorDataLazyEvaluator.data_contract_dum([array], dum1, len(indices2))\r\n\r\n        free_ind1 = self.get_free_indices()\r\n        free_ind2 = other.get_free_indices()\r\n\r\n        return self._match_indices_with_other_tensor(array, free_ind1, free_ind2, replacement_dict)\r\n```\r\nAnd thus, the issue is that `_TensorDataLazyEvaluator.data_contract_dum` is being called prior to `self._match_indices_with_other_tensor` (where the metric is applied).\r\n\r\nThe reason that this ordering matters is because tensor contraction is itself the abstraction of applying the metric to the tensors that represent psuedo-riemannian manifolds. In essence, it means that we must have it that ![equation](https://latex.codecogs.com/svg.latex?T^\\mu_\\mu=g_{\\mu\\nu}T^{\\mu\\nu}); however, this isn't the case here.\r\n\r\nI've tried tampering with the code above, but by the way tensors have been designed, this bug is essentially unavoidable. As a consequence, the tensor module needs to be refactored in order to get accurate results. (Also, I couldn't help but notice that the last argument to `_TensorDataLazyEvaluator.data_contract_dum` isn't used).\r\n\r\n@drybalka had mentioned that he had this sort of refactoring in the works, but based on his fork, progress seems to be slow. I think discussions should be in order for reorganizing how tensors actually represent their components in this module.\n",
  "hints_text": "Hi! This is @drybalka.\n\nI totally agree, due to the module design it is impossible to solve this problem without overhaul. Tensor indices contraction is placed inside TensorMul class (for some reason twice, if I’m not mistaken) even though you can have contractions in a single tensor. This code is intertwined with tensor canonicalization and explicit tensor value calculations, which in their turn depend on TensorManager. In short, this is almost all functionality of the tensor module. At some point I noticed I was almost rewriting everything from scratch in order not to lose any functionality. If it was possible, I would have downgraded the module to basics, implemented TensorIndexManager with tensor contractions uniformly both for Tensor and TensorMul, and only then used this functionality to do everything else. However, this is hard to do in one commit and even harder without braking any half-functioning functionality.\n\nI’d be glad to hear your thoughts on this matter because so far I don’t have any progress.\n\n> On 26 Jan 2020, at 04:57, Calvin Jay Ross <notifications@github.com> wrote:\n> \n> ﻿\n> This is essentially a generalization of #17328.\n> \n> The problem in the current implementation is that contractions are handled before applications of the metric, which leads to incorrect results such as in #17328.\n> \n> In tensor/tensor.py:\n> \n> class Tensor(TensExpr):\n> # ...\n>     def _extract_data(self, replacement_dict):\n>     # ...\n>         if len(dum1) > 0:\n>             indices2 = other.get_indices()\n>             repl = {}\n>             for p1, p2 in dum1:\n>                 repl[indices2[p2]] = -indices2[p1]\n>             other = other.xreplace(repl).doit()\n>             array = _TensorDataLazyEvaluator.data_contract_dum([array], dum1, len(indices2))\n> \n>         free_ind1 = self.get_free_indices()\n>         free_ind2 = other.get_free_indices()\n> \n>         return self._match_indices_with_other_tensor(array, free_ind1, free_ind2, replacement_dict)\n> And thus, the issue is that _TensorDataLazyEvaluator.data_contract_dum is being called prior to self._match_indices_with_other_tensor (where the metric is applied).\n> \n> The reason that this ordering matters is because tensor contraction is itself the abstraction of applying the metric to the tensors that represent psuedo-riemannian manifolds. In essence, it means that we must have it that ; however, this isn't the case here.\n> \n> I've tried tampering with the code above, but by the way tensors have been designed, this bug is essentially unavoidable. As a consequence, the tensor module needs to be refactored in order to get accurate results. (Also, the last argument to _TensorDataLazyEvaluator.data_contract_dum isn't used).\n> \n> @drybalka, I believe mentioned that he had this sort of refactoring in the works, but based on his fork, progress seems to be slow. I think discussions should be in order for reorganizing how tensors actually represent their components in this module.\n> \n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n\n> I’d be glad to hear your thoughts on this matter because so far I don’t have any progress.\r\n\r\nI would be totally down for restructuring the module and would be down for collaborating on a pull request. Is anyone in particular in charge of the module? If so, they should definitely have a say; especially if we are going to be potentially breaking any functionality.\n@Upabjojr I noticed that you are responsible for the current implementation of `replace_with_arrays`. Do you have any thoughts on this issue?",
  "created_at": "2020-04-08T07:43:30Z",
  "version": "1.6",
  "FAIL_TO_PASS": "[\"test_tensor_replacement\"]",
  "PASS_TO_PASS": "[\"test_canonicalize_no_slot_sym\", \"test_canonicalize_no_dummies\", \"test_tensorhead_construction_without_symmetry\", \"test_no_metric_symmetry\", \"test_canonicalize1\", \"test_bug_correction_tensor_indices\", \"test_riemann_invariants\", \"test_riemann_products\", \"test_canonicalize2\", \"test_canonicalize3\", \"test_TensorIndexType\", \"test_indices\", \"test_TensorSymmetry\", \"test_TensExpr\", \"test_TensorHead\", \"test_add1\", \"test_special_eq_ne\", \"test_add2\", \"test_add3\", \"test_mul\", \"test_substitute_indices\", \"test_riemann_cyclic_replace\", \"test_riemann_cyclic\", \"test_contract_metric1\", \"test_contract_metric2\", \"test_metric_contract3\", \"test_epsilon\", \"test_contract_delta1\", \"test_fun\", \"test_TensorManager\", \"test_hash\", \"test_valued_tensor_iter\", \"test_valued_tensor_covariant_contravariant_elements\", \"test_valued_tensor_get_matrix\", \"test_valued_tensor_contraction\", \"test_valued_tensor_self_contraction\", \"test_valued_tensor_pow\", \"test_valued_tensor_expressions\", \"test_valued_tensor_add_scalar\", \"test_noncommuting_components\", \"test_valued_non_diagonal_metric\", \"test_valued_assign_numpy_ndarray\", \"test_valued_metric_inverse\", \"test_valued_canon_bp_swapaxes\", \"test_valued_components_with_wrong_symmetry\", \"test_issue_10972_TensMul_data\", \"test_TensMul_data\", \"test_issue_11020_TensAdd_data\", \"test_index_iteration\", \"test_tensor_expand\", \"test_tensor_alternative_construction\", \"test_rewrite_tensor_to_Indexed\", \"test_tensorsymmetry\", \"test_tensorhead\"]",
  "environment_setup_commit": "28b41c73c12b70d6ad9f6e45109a80649c4456da",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.131353",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}