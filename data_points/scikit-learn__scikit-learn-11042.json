{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-11042",
  "base_commit": "f049ec72eb70443ec8d7826066c4246035677c11",
  "patch": "diff --git a/sklearn/preprocessing/data.py b/sklearn/preprocessing/data.py\n--- a/sklearn/preprocessing/data.py\n+++ b/sklearn/preprocessing/data.py\n@@ -1825,7 +1825,7 @@ def add_dummy_feature(X, value=1.0):\n         return np.hstack((np.ones((n_samples, 1)) * value, X))\n \n \n-def _transform_selected(X, transform, selected=\"all\", copy=True):\n+def _transform_selected(X, transform, dtype, selected=\"all\", copy=True):\n     \"\"\"Apply a transform function to portion of selected features\n \n     Parameters\n@@ -1836,6 +1836,9 @@ def _transform_selected(X, transform, selected=\"all\", copy=True):\n     transform : callable\n         A callable transform(X) -> X_transformed\n \n+    dtype : number type\n+        Desired dtype of output.\n+\n     copy : boolean, optional\n         Copy X even if it could be avoided.\n \n@@ -1869,7 +1872,10 @@ def _transform_selected(X, transform, selected=\"all\", copy=True):\n         return transform(X)\n     else:\n         X_sel = transform(X[:, ind[sel]])\n-        X_not_sel = X[:, ind[not_sel]]\n+        # The columns of X which are not transformed need\n+        # to be casted to the desire dtype before concatenation.\n+        # Otherwise, the stacking will cast to the higher-precision dtype.\n+        X_not_sel = X[:, ind[not_sel]].astype(dtype)\n \n         if sparse.issparse(X_sel) or sparse.issparse(X_not_sel):\n             return sparse.hstack((X_sel, X_not_sel))\n@@ -2061,7 +2067,7 @@ def fit_transform(self, X, y=None):\n         X : array-like, shape [n_samples, n_feature]\n             Input array of type int.\n         \"\"\"\n-        return _transform_selected(X, self._fit_transform,\n+        return _transform_selected(X, self._fit_transform, self.dtype,\n                                    self.categorical_features, copy=True)\n \n     def _transform(self, X):\n@@ -2117,7 +2123,7 @@ def transform(self, X):\n         X_out : sparse matrix if sparse=True else a 2-d array, dtype=int\n             Transformed input.\n         \"\"\"\n-        return _transform_selected(X, self._transform,\n+        return _transform_selected(X, self._transform, self.dtype,\n                                    self.categorical_features, copy=True)\n \n \n",
  "test_patch": "diff --git a/sklearn/preprocessing/tests/test_data.py b/sklearn/preprocessing/tests/test_data.py\n--- a/sklearn/preprocessing/tests/test_data.py\n+++ b/sklearn/preprocessing/tests/test_data.py\n@@ -1909,40 +1909,45 @@ def test_one_hot_encoder_dense():\n                                  [1., 0., 1., 0., 1.]]))\n \n \n-def _check_transform_selected(X, X_expected, sel):\n+def _check_transform_selected(X, X_expected, dtype, sel):\n     for M in (X, sparse.csr_matrix(X)):\n-        Xtr = _transform_selected(M, Binarizer().transform, sel)\n+        Xtr = _transform_selected(M, Binarizer().transform, dtype, sel)\n         assert_array_equal(toarray(Xtr), X_expected)\n \n \n-def test_transform_selected():\n-    X = [[3, 2, 1], [0, 1, 1]]\n+@pytest.mark.parametrize(\"output_dtype\", [np.int32, np.float32, np.float64])\n+@pytest.mark.parametrize(\"input_dtype\", [np.int32, np.float32, np.float64])\n+def test_transform_selected(output_dtype, input_dtype):\n+    X = np.asarray([[3, 2, 1], [0, 1, 1]], dtype=input_dtype)\n \n-    X_expected = [[1, 2, 1], [0, 1, 1]]\n-    _check_transform_selected(X, X_expected, [0])\n-    _check_transform_selected(X, X_expected, [True, False, False])\n+    X_expected = np.asarray([[1, 2, 1], [0, 1, 1]], dtype=output_dtype)\n+    _check_transform_selected(X, X_expected, output_dtype, [0])\n+    _check_transform_selected(X, X_expected, output_dtype,\n+                              [True, False, False])\n \n-    X_expected = [[1, 1, 1], [0, 1, 1]]\n-    _check_transform_selected(X, X_expected, [0, 1, 2])\n-    _check_transform_selected(X, X_expected, [True, True, True])\n-    _check_transform_selected(X, X_expected, \"all\")\n+    X_expected = np.asarray([[1, 1, 1], [0, 1, 1]], dtype=output_dtype)\n+    _check_transform_selected(X, X_expected, output_dtype, [0, 1, 2])\n+    _check_transform_selected(X, X_expected, output_dtype, [True, True, True])\n+    _check_transform_selected(X, X_expected, output_dtype, \"all\")\n \n-    _check_transform_selected(X, X, [])\n-    _check_transform_selected(X, X, [False, False, False])\n+    _check_transform_selected(X, X, output_dtype, [])\n+    _check_transform_selected(X, X, output_dtype, [False, False, False])\n \n \n-def test_transform_selected_copy_arg():\n+@pytest.mark.parametrize(\"output_dtype\", [np.int32, np.float32, np.float64])\n+@pytest.mark.parametrize(\"input_dtype\", [np.int32, np.float32, np.float64])\n+def test_transform_selected_copy_arg(output_dtype, input_dtype):\n     # transformer that alters X\n     def _mutating_transformer(X):\n         X[0, 0] = X[0, 0] + 1\n         return X\n \n-    original_X = np.asarray([[1, 2], [3, 4]])\n-    expected_Xtr = [[2, 2], [3, 4]]\n+    original_X = np.asarray([[1, 2], [3, 4]], dtype=input_dtype)\n+    expected_Xtr = np.asarray([[2, 2], [3, 4]], dtype=output_dtype)\n \n     X = original_X.copy()\n-    Xtr = _transform_selected(X, _mutating_transformer, copy=True,\n-                              selected='all')\n+    Xtr = _transform_selected(X, _mutating_transformer, output_dtype,\n+                              copy=True, selected='all')\n \n     assert_array_equal(toarray(X), toarray(original_X))\n     assert_array_equal(toarray(Xtr), expected_Xtr)\n@@ -1987,6 +1992,17 @@ def test_one_hot_encoder_categorical_features():\n     _check_one_hot(X, X2, cat, 5)\n \n \n+@pytest.mark.parametrize(\"output_dtype\", [np.int32, np.float32, np.float64])\n+@pytest.mark.parametrize(\"input_dtype\",  [np.int32, np.float32, np.float64])\n+@pytest.mark.parametrize(\"sparse\", [True, False])\n+def test_one_hot_encoder_preserve_type(input_dtype, output_dtype, sparse):\n+    X = np.array([[0, 1, 0, 0], [1, 2, 0, 0]], dtype=input_dtype)\n+    transformer = OneHotEncoder(categorical_features=[0, 1],\n+                                dtype=output_dtype, sparse=sparse)\n+    X_trans = transformer.fit_transform(X)\n+    assert X_trans.dtype == output_dtype\n+\n+\n def test_one_hot_encoder_unknown_transform():\n     X = np.array([[0, 2, 1], [1, 0, 3], [1, 0, 2]])\n     y = np.array([[4, 1, 1]])\n",
  "problem_statement": "OneHotEncoder does not output scipy sparse matrix of given dtype\n#### Description\r\nOneHotEncoder ignores the specified dtype in the construction of the sparse array when mixed input data are passed, i.e with both categorical and real data type\r\n\r\n#### Steps/Code to Reproduce\r\n```python\r\nimport numpy as np\r\n\r\nfrom sklearn.preprocessing import OneHotEncoder\r\nenc = OneHotEncoder(dtype=np.float32, categorical_features=[0, 1])\r\n\r\nx = np.array([[0, 1, 0, 0], [1, 2, 0, 0]], dtype=int)\r\nsparse = enc.fit(x).transform(x)\r\n```\r\n\r\n#### Expected Results\r\n```python\r\nsparse: <2x6 sparse matrix of type '<class 'numpy.float32'>'\r\n\twith 4 stored elements in COOrdinate format>\r\n```\r\n\r\n#### Actual Results\r\n```python\r\nsparse: <2x6 sparse matrix of type '<class 'numpy.float64'>'\r\n\twith 4 stored elements in COOrdinate format>\r\n```\r\n\r\n#### Versions\r\n__Platform__: Linux-4.13.0-38-generic-x86_64-with-debian-stretch-sid\r\n__Python__: 3.6.3 |Anaconda custom (64-bit)| (default, Oct 13 2017, 12:02:49) [GCC 7.2.0]\r\n__NumPy__: NumPy \r\n__SciPy__: SciPy 1.0.1\r\n__Scikit-Learn__: Scikit-Learn 0.19.1\r\n\n",
  "hints_text": "Thanks for the report. Please provide [a minimal reproducible example](http://scikit-learn.org/dev/faq.html#what-s-the-best-way-to-get-help-on-scikit-learn-usage).\n@rth, I have just finished editing the issue. \nThis seems like a bug which happens when `categorical_features != 'all'`, quickly looking at this, this comes from:\r\nhttps://github.com/scikit-learn/scikit-learn/blob/96a02f3934952d486589dddd3f00b40d5a5ab5f2/sklearn/preprocessing/data.py#L1871-L1872\r\n\r\n`X_sel` has the right dtype (float32, because it goes through `OneHotEncoder._fit_transform`)) but `X_not_sel` dtype is float64 so that when you stack them up you end up with a float64 array.\r\n\r\nAn easy work-around is to convert the array you are calling `fit_transform` on to float32, e.g.:\r\n```py\r\nimport numpy as np\r\n\r\nfrom sklearn.preprocessing import OneHotEncoder\r\nenc = OneHotEncoder(dtype=np.float32, categorical_features=[0, 1])\r\n\r\nx = np.array([[0, 1, 0, 0], [1, 2, 0, 0]], dtype=int)\r\nsparse = enc.fit(x).transform(x.astype(np.float32))\r\n```\r\n\r\nA PR fixing this would be more than welcome though!\nI'm not sure what a fix to this should look like. but a note in the dtype\nparameter's documentation is worthwhile.\n",
  "created_at": "2018-04-28T11:35:27Z",
  "version": "0.20",
  "FAIL_TO_PASS": "[\"sklearn/preprocessing/tests/test_data.py::test_transform_selected[int32-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected[int32-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected[int32-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected[float32-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected[float32-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected[float32-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected[float64-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected[float64-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected[float64-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[int32-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[int32-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[int32-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[float32-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[float32-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[float32-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[float64-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[float64-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[float64-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-int32-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-int32-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-float32-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-float64-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-float64-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-int32-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-int32-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-float32-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-float64-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-float64-float32]\"]",
  "PASS_TO_PASS": "[\"sklearn/preprocessing/tests/test_data.py::test_polynomial_features\", \"sklearn/preprocessing/tests/test_data.py::test_polynomial_feature_names\", \"sklearn/preprocessing/tests/test_data.py::test_polynomial_features_sparse_X[1-True-False-int]\", \"sklearn/preprocessing/tests/test_data.py::test_polynomial_features_sparse_X[2-True-False-int]\", \"sklearn/preprocessing/tests/test_data.py::test_polynomial_features_sparse_X[2-True-False-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_polynomial_features_sparse_X[2-True-False-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_polynomial_features_sparse_X[3-False-False-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_polynomial_features_sparse_X[3-False-True-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_standard_scaler_1d\", \"sklearn/preprocessing/tests/test_data.py::test_scale_1d\", \"sklearn/preprocessing/tests/test_data.py::test_standard_scaler_numerical_stability\", \"sklearn/preprocessing/tests/test_data.py::test_scaler_2d_arrays\", \"sklearn/preprocessing/tests/test_data.py::test_handle_zeros_in_scale\", \"sklearn/preprocessing/tests/test_data.py::test_minmax_scaler_partial_fit\", \"sklearn/preprocessing/tests/test_data.py::test_standard_scaler_partial_fit\", \"sklearn/preprocessing/tests/test_data.py::test_standard_scaler_partial_fit_numerical_stability\", \"sklearn/preprocessing/tests/test_data.py::test_partial_fit_sparse_input\", \"sklearn/preprocessing/tests/test_data.py::test_standard_scaler_trasform_with_partial_fit\", \"sklearn/preprocessing/tests/test_data.py::test_min_max_scaler_iris\", \"sklearn/preprocessing/tests/test_data.py::test_min_max_scaler_zero_variance_features\", \"sklearn/preprocessing/tests/test_data.py::test_minmax_scale_axis1\", \"sklearn/preprocessing/tests/test_data.py::test_min_max_scaler_1d\", \"sklearn/preprocessing/tests/test_data.py::test_scaler_without_centering\", \"sklearn/preprocessing/tests/test_data.py::test_scaler_int\", \"sklearn/preprocessing/tests/test_data.py::test_scaler_without_copy\", \"sklearn/preprocessing/tests/test_data.py::test_scale_sparse_with_mean_raise_exception\", \"sklearn/preprocessing/tests/test_data.py::test_scale_input_finiteness_validation\", \"sklearn/preprocessing/tests/test_data.py::test_robust_scaler_2d_arrays\", \"sklearn/preprocessing/tests/test_data.py::test_robust_scaler_transform_one_row_csr\", \"sklearn/preprocessing/tests/test_data.py::test_robust_scaler_iris\", \"sklearn/preprocessing/tests/test_data.py::test_robust_scaler_iris_quantiles\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_iris\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_check_error\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_sparse_ignore_zeros\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_dense_toy\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_subsampling\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_sparse_toy\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_axis1\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_bounds\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_and_inverse\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_nan\", \"sklearn/preprocessing/tests/test_data.py::test_robust_scaler_invalid_range\", \"sklearn/preprocessing/tests/test_data.py::test_scale_function_without_centering\", \"sklearn/preprocessing/tests/test_data.py::test_robust_scale_axis1\", \"sklearn/preprocessing/tests/test_data.py::test_robust_scale_1d_array\", \"sklearn/preprocessing/tests/test_data.py::test_robust_scaler_zero_variance_features\", \"sklearn/preprocessing/tests/test_data.py::test_maxabs_scaler_zero_variance_features\", \"sklearn/preprocessing/tests/test_data.py::test_maxabs_scaler_large_negative_value\", \"sklearn/preprocessing/tests/test_data.py::test_maxabs_scaler_transform_one_row_csr\", \"sklearn/preprocessing/tests/test_data.py::test_warning_scaling_integers\", \"sklearn/preprocessing/tests/test_data.py::test_maxabs_scaler_1d\", \"sklearn/preprocessing/tests/test_data.py::test_maxabs_scaler_partial_fit\", \"sklearn/preprocessing/tests/test_data.py::test_normalizer_l1\", \"sklearn/preprocessing/tests/test_data.py::test_normalizer_l2\", \"sklearn/preprocessing/tests/test_data.py::test_normalizer_max\", \"sklearn/preprocessing/tests/test_data.py::test_normalize\", \"sklearn/preprocessing/tests/test_data.py::test_binarizer\", \"sklearn/preprocessing/tests/test_data.py::test_center_kernel\", \"sklearn/preprocessing/tests/test_data.py::test_cv_pipeline_precomputed\", \"sklearn/preprocessing/tests/test_data.py::test_fit_transform\", \"sklearn/preprocessing/tests/test_data.py::test_add_dummy_feature\", \"sklearn/preprocessing/tests/test_data.py::test_add_dummy_feature_coo\", \"sklearn/preprocessing/tests/test_data.py::test_add_dummy_feature_csc\", \"sklearn/preprocessing/tests/test_data.py::test_add_dummy_feature_csr\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_sparse\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_dense\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_categorical_features\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-int32-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-float32-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-float32-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-float64-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-int32-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-float32-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-float32-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-float64-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_unknown_transform\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_onehot\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_onehot_inverse\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_handle_unknown\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_categories\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_specified_categories\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_pandas\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_ordinal\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_ordinal_inverse\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_dtypes\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_dtypes_pandas\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_warning\", \"sklearn/preprocessing/tests/test_data.py::test_fit_cold_start\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_valid_axis\", \"sklearn/preprocessing/tests/test_data.py::test_power_transformer_notfitted\", \"sklearn/preprocessing/tests/test_data.py::test_power_transformer_1d\", \"sklearn/preprocessing/tests/test_data.py::test_power_transformer_2d\", \"sklearn/preprocessing/tests/test_data.py::test_power_transformer_strictly_positive_exception\", \"sklearn/preprocessing/tests/test_data.py::test_power_transformer_shape_exception\", \"sklearn/preprocessing/tests/test_data.py::test_power_transformer_method_exception\", \"sklearn/preprocessing/tests/test_data.py::test_power_transformer_lambda_zero\"]",
  "environment_setup_commit": "55bf5d93e5674f13a1134d93a11fd0cd11aabcd1",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.957214",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}