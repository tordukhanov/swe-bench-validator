{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-11232",
  "base_commit": "4c8a8590be682e74ec91ab217c646baa4686a255",
  "patch": "diff --git a/sympy/core/expr.py b/sympy/core/expr.py\n--- a/sympy/core/expr.py\n+++ b/sympy/core/expr.py\n@@ -1044,7 +1044,7 @@ def args_cnc(self, cset=False, warn=True, split_1=True):\n         Note: -1 is always separated from a Number unless split_1 is False.\n \n         >>> from sympy import symbols, oo\n-        >>> A, B = symbols('A B', commutative=0)\n+        >>> A, B = symbols('A B', commutative=False)\n         >>> x, y = symbols('x y')\n         >>> (-2*x*y).args_cnc()\n         [[-1, 2, x, y], []]\ndiff --git a/sympy/matrices/expressions/matmul.py b/sympy/matrices/expressions/matmul.py\n--- a/sympy/matrices/expressions/matmul.py\n+++ b/sympy/matrices/expressions/matmul.py\n@@ -120,9 +120,11 @@ def doit(self, **kwargs):\n     # Needed for partial compatibility with Mul\n     def args_cnc(self, **kwargs):\n         coeff, matrices = self.as_coeff_matrices()\n-        # I don't know how coeff could have noncommutative factors, but this\n-        # handles it.\n         coeff_c, coeff_nc = coeff.args_cnc(**kwargs)\n+        if coeff_c == [1]:\n+            coeff_c = []\n+        elif coeff_c == set([1]):\n+            coeff_c = set()\n \n         return coeff_c, coeff_nc + matrices\n \ndiff --git a/sympy/printing/llvmjitcode.py b/sympy/printing/llvmjitcode.py\n--- a/sympy/printing/llvmjitcode.py\n+++ b/sympy/printing/llvmjitcode.py\n@@ -428,9 +428,9 @@ def llvm_callable(args, expr, callback_type=None):\n     >>> from sympy.abc import x,y\n     >>> e1 = x*x + y*y\n     >>> e2 = 4*(x*x + y*y) + 8.0\n-    >>> after_cse = cse([e1,e2])\n+    >>> after_cse = cse([e1, e2])\n     >>> after_cse\n-    ([(x0, x**2), (x1, y**2)], [x0 + x1, 4*x0 + 4*x1 + 8.0])\n+    ([(x0, x**2 + y**2)], [x0, 4*x0 + 8.0])\n     >>> j1 = jit.llvm_callable([x,y], after_cse)\n     >>> j1(1.0, 2.0)\n     (5.0, 28.0)\ndiff --git a/sympy/simplify/cse_main.py b/sympy/simplify/cse_main.py\n--- a/sympy/simplify/cse_main.py\n+++ b/sympy/simplify/cse_main.py\n@@ -2,13 +2,14 @@\n \"\"\"\n from __future__ import print_function, division\n \n-from sympy.core import Basic, Mul, Add, Pow, sympify, Symbol, Tuple\n+from sympy.core import Basic, Mul, Add, Pow, sympify, Symbol, Tuple, igcd\n+from sympy.core.numbers import Integer\n from sympy.core.singleton import S\n from sympy.core.function import _coeff_isneg\n from sympy.core.exprtools import factor_terms\n-from sympy.core.compatibility import iterable, range\n+from sympy.core.compatibility import iterable, range, as_int\n from sympy.utilities.iterables import filter_symbols, \\\n-    numbered_symbols, sift, topological_sort, ordered\n+    numbered_symbols, sift, topological_sort, ordered, subsets\n \n from . import cse_opts\n \n@@ -136,7 +137,46 @@ def postprocess_for_cse(expr, optimizations):\n     return expr\n \n \n-def opt_cse(exprs, order='canonical'):\n+def pairwise_most_common(sets):\n+    \"\"\"Return a list of `(s, L)` tuples where `s` is the largest subset\n+    of elements that appear in pairs of sets given by `sets` and `L`\n+    is a list of tuples giving the indices of the pairs of sets in\n+    which those elements appeared. All `s` will be of the same length.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy.simplify.cse_main import pairwise_most_common\n+    >>> pairwise_most_common((\n+    ...     set([1,2,3]),\n+    ...     set([1,3,5]),\n+    ...     set([1,2,3,4,5]),\n+    ...     set([1,2,3,6])))\n+    [(set([1, 3, 5]), [(1, 2)]), (set([1, 2, 3]), [(0, 2), (0, 3), (2, 3)])]\n+    >>>\n+    \"\"\"\n+    from sympy.utilities.iterables import subsets\n+    from collections import defaultdict\n+    most = -1\n+    for i, j in subsets(list(range(len(sets))), 2):\n+        com = sets[i] & sets[j]\n+        if com and len(com) > most:\n+            best = defaultdict(list)\n+            best_keys = []\n+            most = len(com)\n+        if len(com) == most:\n+            if com not in best_keys:\n+                best_keys.append(com)\n+            best[best_keys.index(com)].append((i,j))\n+    if most == -1:\n+        return []\n+    for k in range(len(best)):\n+        best_keys[k] = (best_keys[k], best[k])\n+    best_keys.sort(key=lambda x: len(x[1]))\n+    return best_keys\n+\n+\n+def opt_cse(exprs, order='canonical', verbose=False):\n     \"\"\"Find optimization opportunities in Adds, Muls, Pows and negative\n     coefficient Muls\n \n@@ -147,6 +187,8 @@ def opt_cse(exprs, order='canonical'):\n     order : string, 'none' or 'canonical'\n         The order by which Mul and Add arguments are processed. For large\n         expressions where speed is a concern, use the setting order='none'.\n+    verbose : bool\n+        Print debug information (default=False)\n \n     Returns\n     -------\n@@ -218,51 +260,149 @@ def _match_common_args(Func, funcs):\n         else:\n             funcs = sorted(funcs, key=lambda x: len(x.args))\n \n-        func_args = [set(e.args) for e in funcs]\n-        for i in range(len(func_args)):\n-            for j in range(i + 1, len(func_args)):\n-                com_args = func_args[i].intersection(func_args[j])\n-                if len(com_args) > 1:\n-                    com_func = Func(*com_args)\n-\n-                    # for all sets, replace the common symbols by the function\n-                    # over them, to allow recursive matches\n-\n-                    diff_i = func_args[i].difference(com_args)\n-                    func_args[i] = diff_i | {com_func}\n-                    if diff_i:\n-                        opt_subs[funcs[i]] = Func(Func(*diff_i), com_func,\n-                                                  evaluate=False)\n-\n-                    diff_j = func_args[j].difference(com_args)\n-                    func_args[j] = diff_j | {com_func}\n-                    opt_subs[funcs[j]] = Func(Func(*diff_j), com_func,\n-                                              evaluate=False)\n-\n-                    for k in range(j + 1, len(func_args)):\n-                        if not com_args.difference(func_args[k]):\n-                            diff_k = func_args[k].difference(com_args)\n-                            func_args[k] = diff_k | {com_func}\n-                            opt_subs[funcs[k]] = Func(Func(*diff_k), com_func,\n-                                                      evaluate=False)\n+        if Func is Mul:\n+            F = Pow\n+            meth = 'as_powers_dict'\n+            from sympy.core.add import _addsort as inplace_sorter\n+        elif Func is Add:\n+            F = Mul\n+            meth = 'as_coefficients_dict'\n+            from sympy.core.mul import _mulsort as inplace_sorter\n+        else:\n+            assert None  # expected Mul or Add\n+\n+        # ----------------- helpers ---------------------------\n+        def ufunc(*args):\n+            # return a well formed unevaluated function from the args\n+            # SHARES Func, inplace_sorter\n+            args = list(args)\n+            inplace_sorter(args)\n+            return Func(*args, evaluate=False)\n+\n+        def as_dict(e):\n+            # creates a dictionary of the expression using either\n+            # as_coefficients_dict or as_powers_dict, depending on Func\n+            # SHARES meth\n+            d = getattr(e, meth, lambda: {a: S.One for a in e.args})()\n+            for k in list(d.keys()):\n+                try:\n+                    as_int(d[k])\n+                except ValueError:\n+                    d[F(k, d.pop(k))] = S.One\n+            return d\n+\n+        def from_dict(d):\n+            # build expression from dict from\n+            # as_coefficients_dict or as_powers_dict\n+            # SHARES F\n+            return ufunc(*[F(k, v) for k, v in d.items()])\n+\n+        def update(k):\n+            # updates all of the info associated with k using\n+            # the com_dict: func_dicts, func_args, opt_subs\n+            # returns True if all values were updated, else None\n+            # SHARES com_dict, com_func, func_dicts, func_args,\n+            #        opt_subs, funcs, verbose\n+            for di in com_dict:\n+                # don't allow a sign to change\n+                if com_dict[di] > func_dicts[k][di]:\n+                    return\n+            # remove it\n+            if Func is Add:\n+                take = min(func_dicts[k][i] for i in com_dict)\n+                com_func_take = Mul(take, from_dict(com_dict), evaluate=False)\n+            else:\n+                take = igcd(*[func_dicts[k][i] for i in com_dict])\n+                com_func_take = Pow(from_dict(com_dict), take, evaluate=False)\n+            for di in com_dict:\n+                func_dicts[k][di] -= take*com_dict[di]\n+            # compute the remaining expression\n+            rem = from_dict(func_dicts[k])\n+            # reject hollow change, e.g extracting x + 1 from x + 3\n+            if Func is Add and rem and rem.is_Integer and 1 in com_dict:\n+                return\n+            if verbose:\n+                print('\\nfunc %s (%s) \\ncontains %s \\nas %s \\nleaving %s' %\n+                    (funcs[k], func_dicts[k], com_func, com_func_take, rem))\n+            # recompute the dict since some keys may now\n+            # have corresponding values of 0; one could\n+            # keep track of which ones went to zero but\n+            # this seems cleaner\n+            func_dicts[k] = as_dict(rem)\n+            # update associated info\n+            func_dicts[k][com_func] = take\n+            func_args[k] = set(func_dicts[k])\n+            # keep the constant separate from the remaining\n+            # part of the expression, e.g. 2*(a*b) rather than 2*a*b\n+            opt_subs[funcs[k]] = ufunc(rem, com_func_take)\n+            # everything was updated\n+            return True\n+\n+        def get_copy(i):\n+            return [func_dicts[i].copy(), func_args[i].copy(), funcs[i], i]\n+\n+        def restore(dafi):\n+            i = dafi.pop()\n+            func_dicts[i], func_args[i], funcs[i] = dafi\n+\n+        # ----------------- end helpers -----------------------\n+\n+        func_dicts = [as_dict(f) for f in funcs]\n+        func_args = [set(d) for d in func_dicts]\n+        while True:\n+            hit = pairwise_most_common(func_args)\n+            if not hit or len(hit[0][0]) <= 1:\n+                break\n+            changed = False\n+            for com_args, ij in hit:\n+                take = len(com_args)\n+                ALL = list(ordered(com_args))\n+                while take >= 2:\n+                    for com_args in subsets(ALL, take):\n+                        com_func = Func(*com_args)\n+                        com_dict = as_dict(com_func)\n+                        for i, j in ij:\n+                            dafi = None\n+                            if com_func != funcs[i]:\n+                                dafi = get_copy(i)\n+                                ch = update(i)\n+                                if not ch:\n+                                    restore(dafi)\n+                                    continue\n+                            if com_func != funcs[j]:\n+                                dafj = get_copy(j)\n+                                ch = update(j)\n+                                if not ch:\n+                                    if dafi is not None:\n+                                        restore(dafi)\n+                                    restore(dafj)\n+                                    continue\n+                            changed = True\n+                        if changed:\n+                            break\n+                    else:\n+                        take -= 1\n+                        continue\n+                    break\n+                else:\n+                    continue\n+                break\n+            if not changed:\n+                break\n \n     # split muls into commutative\n-    comutative_muls = set()\n+    commutative_muls = set()\n     for m in muls:\n         c, nc = m.args_cnc(cset=True)\n         if c:\n             c_mul = m.func(*c)\n             if nc:\n-                if c_mul == 1:\n-                    new_obj = m.func(*nc)\n-                else:\n-                    new_obj = m.func(c_mul, m.func(*nc), evaluate=False)\n-                opt_subs[m] = new_obj\n+                opt_subs[m] = m.func(c_mul, m.func(*nc), evaluate=False)\n             if len(c) > 1:\n-                comutative_muls.add(c_mul)\n+                commutative_muls.add(c_mul)\n \n     _match_common_args(Add, adds)\n-    _match_common_args(Mul, comutative_muls)\n+    _match_common_args(Mul, commutative_muls)\n \n     return opt_subs\n \n@@ -394,6 +534,30 @@ def _rebuild(expr):\n             reduced_e = e\n         reduced_exprs.append(reduced_e)\n \n+    # don't allow hollow nesting\n+    # e.g if p = [b + 2*d + e + f, b + 2*d + f + g, a + c + d + f + g]\n+    # and R, C = cse(p) then\n+    #     R = [(x0, d + f), (x1, b + d)]\n+    #     C = [e + x0 + x1, g + x0 + x1, a + c + d + f + g]\n+    # but the args of C[-1] should not be `(a + c, d + f + g)`\n+    nested = [[i for i in f.args if isinstance(i, f.func)] for f in exprs]\n+    for i in range(len(exprs)):\n+        F = reduced_exprs[i].func\n+        if not (F is Mul or F is Add):\n+            continue\n+        nested = [a for a in exprs[i].args if isinstance(a, F)]\n+        args = []\n+        for a in reduced_exprs[i].args:\n+            if isinstance(a, F):\n+                for ai in a.args:\n+                    if isinstance(ai, F) and ai not in nested:\n+                        args.extend(ai.args)\n+                    else:\n+                        args.append(ai)\n+            else:\n+                args.append(a)\n+        reduced_exprs[i] = F(*args)\n+\n     return replacements, reduced_exprs\n \n \n@@ -444,7 +608,7 @@ def cse(exprs, symbols=None, optimizations=None, postprocess=None,\n     >>> from sympy import cse, SparseMatrix\n     >>> from sympy.abc import x, y, z, w\n     >>> cse(((w + x + y + z)*(w + y + z))/(w + x)**3)\n-    ([(x0, y + z), (x1, w + x)], [(w + x0)*(x0 + x1)/x1**3])\n+    ([(x0, w + y + z)], [x0*(x + x0)/(w + x)**3])\n \n     Note that currently, y + z will not get substituted if -y - z is used.\n \ndiff --git a/sympy/solvers/ode.py b/sympy/solvers/ode.py\n--- a/sympy/solvers/ode.py\n+++ b/sympy/solvers/ode.py\n@@ -4338,8 +4338,6 @@ def ode_linear_coefficients(eq, func, order, match):\n     >>> f = Function('f')\n     >>> df = f(x).diff(x)\n     >>> eq = (x + f(x) + 1)*df + (f(x) - 6*x + 1)\n-    >>> dsolve(eq, hint='linear_coefficients')\n-    [Eq(f(x), -x - sqrt(C1 + 7*x**2) - 1), Eq(f(x), -x + sqrt(C1 + 7*x**2) - 1)]\n     >>> pprint(dsolve(eq, hint='linear_coefficients'))\n                       ___________                     ___________\n                    /         2                     /         2\n@@ -4403,8 +4401,6 @@ def ode_separable_reduced(eq, func, order, match):\n     >>> f = Function('f')\n     >>> d = f(x).diff(x)\n     >>> eq = (x - x**2*f(x))*d - f(x)\n-    >>> dsolve(eq, hint='separable_reduced')\n-    [Eq(f(x), (-sqrt(C1*x**2 + 1) + 1)/x), Eq(f(x), (sqrt(C1*x**2 + 1) + 1)/x)]\n     >>> pprint(dsolve(eq, hint='separable_reduced'))\n                  ___________                ___________\n                 /     2                    /     2\n",
  "test_patch": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -595,9 +595,9 @@ def test_issue_6559():\n     # though this involves cse it generated a failure in Mul._eval_subs\n     x0, x1 = symbols('x0 x1')\n     e = -log(-12*sqrt(2) + 17)/24 - log(-2*sqrt(2) + 3)/12 + sqrt(2)/3\n-    # XXX modify cse so x1 is eliminated and x0 = -sqrt(2)?\n     assert cse(e) == (\n-        [(x0, sqrt(2))], [x0/3 - log(-12*x0 + 17)/24 - log(-2*x0 + 3)/12])\n+        [(x0, sqrt(2))],\n+        [x0/3 - log(-12*x0 + 17)/24 - log(-2*x0 + 3)/12])\n \n \n def test_issue_5261():\ndiff --git a/sympy/matrices/expressions/tests/test_matmul.py b/sympy/matrices/expressions/tests/test_matmul.py\n--- a/sympy/matrices/expressions/tests/test_matmul.py\n+++ b/sympy/matrices/expressions/tests/test_matmul.py\n@@ -130,4 +130,4 @@ def test_matmul_no_matrices():\n def test_matmul_args_cnc():\n     a, b = symbols('a b', commutative=False)\n     assert MatMul(n, a, b, A, A.T).args_cnc() == ([n], [a, b, A, A.T])\n-    assert MatMul(A, A.T).args_cnc() == ([1], [A, A.T])\n+    assert MatMul(A, A.T).args_cnc() == ([], [A, A.T])\ndiff --git a/sympy/simplify/tests/test_cse.py b/sympy/simplify/tests/test_cse.py\n--- a/sympy/simplify/tests/test_cse.py\n+++ b/sympy/simplify/tests/test_cse.py\n@@ -2,10 +2,11 @@\n \n from sympy import (Add, Pow, Symbol, exp, sqrt, symbols, sympify, cse,\n                    Matrix, S, cos, sin, Eq, Function, Tuple, CRootOf,\n-                   IndexedBase, Idx, Piecewise, O)\n+                   IndexedBase, Idx, Piecewise, O, Mul)\n from sympy.simplify.cse_opts import sub_pre, sub_post\n from sympy.functions.special.hyper import meijerg\n from sympy.simplify import cse_main, cse_opts\n+from sympy.utilities.iterables import subsets\n from sympy.utilities.pytest import XFAIL, raises\n from sympy.matrices import (eye, SparseMatrix, MutableDenseMatrix,\n     MutableSparseMatrix, ImmutableDenseMatrix, ImmutableSparseMatrix)\n@@ -15,7 +16,7 @@\n \n \n w, x, y, z = symbols('w,x,y,z')\n-x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12 = symbols('x:13')\n+x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18 = symbols('x:19')\n \n \n def test_numbered_symbols():\n@@ -174,9 +175,17 @@ def test_non_commutative_order():\n     assert cse(l) == ([(x0, B+C)], [x0, A*x0])\n \n \n-@XFAIL\n-def test_powers():\n-    assert cse(x*y**2 + x*y) == ([(x0, x*y)], [x0*y + x0])\n+def test_issue_10228():\n+    assert cse([x*y**2 + x*y]) == ([(x0, x*y)], [x0*y + x0])\n+    assert cse([x + y, 2*x + y]) == ([(x0, x + y)], [x0, x + x0])\n+    assert cse((w + 2*x + y + z, w + x + 1)) == (\n+        [(x0, w + x)], [x0 + x + y + z, x0 + 1])\n+    assert cse(((w + x + y + z)*(w - x))/(w + x)) == (\n+        [(x0, w + x)], [(x0 + y + z)*(w - x)/x0])\n+    a, b, c, d, f, g, j, m = symbols('a, b, c, d, f, g, j, m')\n+    exprs = (d*g**2*j*m, 4*a*f*g*m, a*b*c*f**2)\n+    assert cse(exprs) == (\n+        [(x0, g*m), (x1, a*f)], [d*g*j*x0, 4*x0*x1, b*c*f*x1])\n \n \n def test_issue_4498():\n@@ -264,12 +273,21 @@ def test_issue_4499():\n         sqrt(z))*G(b)*G(2*a - b + 1), 1, 0, S(1)/2, z/2, -b + 1, -2*a + b,\n         -2*a))\n     c = cse(t)\n+    # check rebuild\n+    r = c[0]\n+    tt = list(c[1][0])\n+    for i in range(len(tt)):\n+        for re in reversed(r):\n+            tt[i] = tt[i].subs(*re)\n+        assert tt[i] == t[i]\n+    # check answer\n     ans = (\n-        [(x0, 2*a), (x1, -b), (x2, x1 + 1), (x3, x0 + x2), (x4, sqrt(z)), (x5,\n-        B(x0 + x1, x4)), (x6, G(b)), (x7, G(x3)), (x8, -x0), (x9,\n-        (x4/2)**(x8 + 1)), (x10, x6*x7*x9*B(b - 1, x4)), (x11, x6*x7*x9*B(b,\n-        x4)), (x12, B(x3, x4))], [(a, a + S(1)/2, x0, b, x3, x10*x5,\n-        x11*x4*x5, x10*x12*x4, x11*x12, 1, 0, S(1)/2, z/2, x2, b + x8, x8)])\n+        [(x0, 2*a), (x1, -b), (x2, x0 + x1 + 1), (x3, sqrt(z)), (x4,\n+        B(x0 + x1, x3)), (x5, G(b)), (x6, G(x2)), (x7, -x0), (x8,\n+        (x3/2)**(x7 + 1)), (x9, x5*x6*x8*B(b - 1, x3)), (x10,\n+        x5*x6*x8*B(b, x3)), (x11, B(x2, x3))], [(a, a + 1/2, x0, b,\n+        x2, x4*x9, x10*x3*x4, x11*x3*x9, x10*x11, 1, 0, 1/2, z/2, x1 +\n+        1, b + x7, x7)])\n     assert ans == c\n \n \n@@ -303,12 +321,13 @@ def test_cse_MatrixSymbol():\n     B = MatrixSymbol(\"B\", n, n)\n     assert cse(B) == ([], [B])\n \n+\n def test_cse_MatrixExpr():\n     from sympy import MatrixSymbol\n     A = MatrixSymbol('A', 3, 3)\n     y = MatrixSymbol('y', 3, 1)\n \n-    expr1 = (A.T*A).I * A * y\n+    expr1 = 2*(A.T*A).I * A * y\n     expr2 = (A.T*A) * A * y\n     replacements, reduced_exprs = cse([expr1, expr2])\n     assert len(replacements) > 0\n@@ -319,6 +338,7 @@ def test_cse_MatrixExpr():\n     replacements, reduced_exprs = cse([A**2, A + A**2])\n     assert replacements\n \n+\n def test_Piecewise():\n     f = Piecewise((-z + x*y, Eq(y, 0)), (-z - x*y, True))\n     ans = cse(f)\n@@ -399,3 +419,61 @@ def test_issue_8891():\n         ans = ([(x0, x + y)], [x0, cls([[x0, 0], [0, 0]])])\n         assert res == ans\n         assert isinstance(res[1][-1], cls)\n+\n+\n+def test_issue_11230():\n+    from random import choice\n+    from sympy.core.function import expand_mul\n+    s = symbols('a:m')\n+    # 35 Mul tests, none of which should ever fail\n+    ex = [Mul(*[choice(s) for i in range(5)]) for i in range(7)]\n+    for p in subsets(ex, 3):\n+        p = list(p)\n+        R, C = cse(p)\n+        assert not any(i.is_Mul for a in C for i in a.args)\n+        for ri in reversed(R):\n+            for i in range(len(C)):\n+                C[i] = C[i].subs(*ri)\n+        assert p == C\n+    # 35 Add tests, none of which should ever fail\n+    ex = [Add(*[choice(s[:7]) for i in range(5)]) for i in range(7)]\n+    for p in subsets(ex, 3):\n+        p = list(p)\n+        was = R, C = cse(p)\n+        assert not any(i.is_Add for a in C for i in a.args)\n+        for ri in reversed(R):\n+            for i in range(len(C)):\n+                C[i] = C[i].subs(*ri)\n+        # use expand_mul to handle cases like this:\n+        # p = [a + 2*b + 2*e, 2*b + c + 2*e, b + 2*c + 2*g]\n+        # x0 = 2*(b + e) is identified giving a rebuilt p that\n+        # is now `[a + 2*(b + e), c + 2*(b + e), b + 2*c + 2*g]`\n+        assert p == [expand_mul(i) for i in C]\n+\n+\n+@XFAIL\n+def test_issue_11577():\n+    def check(eq):\n+        from sympy.core.function import count_ops\n+        r, c = cse(eq)\n+        assert eq.count_ops() >= \\\n+            len(r) + sum([i[1].count_ops() for i in r]) + \\\n+            count_ops(c)\n+\n+    eq = x**5*y**2 + x**5*y + x**5\n+    assert cse(eq) == (\n+        [(x0, x**4), (x1, x*y)], [x**5 + x0*x1*y + x0*x1])\n+        # ([(x0, x**5*y)], [x0*y + x0 + x**5]) or\n+        # ([(x0, x**5)], [x0*y**2 + x0*y + x0])\n+    check(eq)\n+\n+    eq = x**2/(y + 1)**2 + x/(y + 1)\n+    assert cse(eq) == (\n+        [(x0, y + 1)], [x**2/x0**2 + x/x0])\n+        # ([(x0, x/(y + 1))], [x0**2 + x0])\n+    check(eq)\n+\n+\n+def test_hollow_rejection():\n+    eq = [x + 3, x + 4]\n+    assert cse(eq) == ([], eq)\n",
  "problem_statement": "cse leaves behind unevaluated subexpressions\n``` python\n>>> cse((j*l**2*y, j*l*o*r*y, k*o*r*s))\n([(x0, j*y)], [l**2*x0, l*o*r*x0, (k*s)*(o*r)])\n>>> u = _[1][-1]\n>>> u.args\n(k*s, o*r)\n\nThis can lead to problems when trying to work with the result:\n\n>>> u.subs(s*o, 2)\n(k*s)*(o*r)\n>>> Mul(*flatten([i.args for i in u.args]))\nk*o*r*s\n>>> _.subs(s*o,2)\n2*k*r\n```\n\n",
  "hints_text": "",
  "created_at": "2016-06-12T14:14:58Z",
  "version": "1.0",
  "FAIL_TO_PASS": "[\"test_issue_10228\", \"test_issue_4499\", \"test_issue_11230\"]",
  "PASS_TO_PASS": "[\"test_subs\", \"test_subs_AccumBounds\", \"test_trigonometric\", \"test_powers\", \"test_bug\", \"test_subbug1\", \"test_subbug2\", \"test_dict_set\", \"test_dict_ambigous\", \"test_deriv_sub_bug3\", \"test_equality_subs1\", \"test_equality_subs2\", \"test_issue_3742\", \"test_subs_dict1\", \"test_mul\", \"test_subs_simple\", \"test_subs_constants\", \"test_subs_commutative\", \"test_subs_noncommutative\", \"test_subs_basic_funcs\", \"test_subs_wild\", \"test_division\", \"test_add\", \"test_subs_issue_4009\", \"test_functions_subs\", \"test_derivative_subs\", \"test_derivative_subs2\", \"test_derivative_subs3\", \"test_issue_5284\", \"test_subs_iter\", \"test_subs_dict\", \"test_no_arith_subs_on_floats\", \"test_issue_5651\", \"test_issue_6075\", \"test_issue_6079\", \"test_issue_4680\", \"test_issue_6158\", \"test_Function_subs\", \"test_simultaneous_subs\", \"test_issue_6419_6421\", \"test_issue_5261\", \"test_2arg_hack\", \"test_noncommutative_subs\", \"test_issue_2877\", \"test_issue_5910\", \"test_issue_5217\", \"test_issue_10829\", \"test_adjoint\", \"test_transpose\", \"test_factor_in_front\", \"test_remove_ids\", \"test_xxinv\", \"test_any_zeros\", \"test_unpack\", \"test_only_squares\", \"test_determinant\", \"test_doit\", \"test_doit_drills_down\", \"test_doit_deep_false_still_canonical\", \"test_matmul_scalar_Matrix_doit\", \"test_matmul_sympify\", \"test_collapse_MatrixBase\", \"test_matmul_no_matrices\", \"test_numbered_symbols\", \"test_preprocess_for_cse\", \"test_postprocess_for_cse\", \"test_cse_single\", \"test_cse_single2\", \"test_cse_not_possible\", \"test_nested_substitution\", \"test_subtraction_opt\", \"test_multiple_expressions\", \"test_bypass_non_commutatives\", \"test_issue_4498\", \"test_issue_4020\", \"test_issue_4203\", \"test_issue_6263\", \"test_dont_cse_tuples\", \"test_pow_invpow\", \"test_postprocess\", \"test_issue_6169\", \"test_cse_Indexed\", \"test_cse_MatrixSymbol\", \"test_cse_MatrixExpr\", \"test_Piecewise\", \"test_name_conflict\", \"test_name_conflict_cust_symbols\", \"test_symbols_exhausted_error\", \"test_issue_7840\", \"test_issue_8891\"]",
  "environment_setup_commit": "50b81f9f6be151014501ffac44e5dc6b2416938f",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.071639",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}