{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-18116",
  "base_commit": "4a735bb4f38f7534f11c6634ab1cc36a8d57885e",
  "patch": "diff --git a/sympy/codegen/array_utils.py b/sympy/codegen/array_utils.py\n--- a/sympy/codegen/array_utils.py\n+++ b/sympy/codegen/array_utils.py\n@@ -86,6 +86,18 @@ def __new__(cls, expr, *contraction_indices, **kwargs):\n         obj._shape = shape\n         return obj\n \n+    def __mul__(self, other):\n+        if other == 1:\n+            return self\n+        else:\n+            raise NotImplementedError(\"Product of N-dim arrays is not uniquely defined. Use another method.\")\n+\n+    def __rmul__(self, other):\n+        if other == 1:\n+            return self\n+        else:\n+            raise NotImplementedError(\"Product of N-dim arrays is not uniquely defined. Use another method.\")\n+\n     @staticmethod\n     def _validate(expr, *contraction_indices):\n         shape = expr.shape\ndiff --git a/sympy/core/decorators.py b/sympy/core/decorators.py\n--- a/sympy/core/decorators.py\n+++ b/sympy/core/decorators.py\n@@ -129,3 +129,127 @@ def binary_op_wrapper(self, other):\n             return func(self, other)\n         return binary_op_wrapper\n     return priority_decorator\n+\n+\n+def sympify_method_args(cls):\n+    '''Decorator for a class with methods that sympify arguments.\n+\n+    The sympify_method_args decorator is to be used with the sympify_return\n+    decorator for automatic sympification of method arguments. This is\n+    intended for the common idiom of writing a class like\n+\n+    >>> from sympy.core.basic import Basic\n+    >>> from sympy.core.sympify import _sympify, SympifyError\n+\n+    >>> class MyTuple(Basic):\n+    ...     def __add__(self, other):\n+    ...         try:\n+    ...             other = _sympify(other)\n+    ...         except SympifyError:\n+    ...             return NotImplemented\n+    ...         if not isinstance(other, MyTuple):\n+    ...             return NotImplemented\n+    ...         return MyTuple(*(self.args + other.args))\n+\n+    >>> MyTuple(1, 2) + MyTuple(3, 4)\n+    MyTuple(1, 2, 3, 4)\n+\n+    In the above it is important that we return NotImplemented when other is\n+    not sympifiable and also when the sympified result is not of the expected\n+    type. This allows the MyTuple class to be used cooperatively with other\n+    classes that overload __add__ and want to do something else in combination\n+    with instance of Tuple.\n+\n+    Using this decorator the above can be written as\n+\n+    >>> from sympy.core.decorators import sympify_method_args, sympify_return\n+\n+    >>> @sympify_method_args\n+    ... class MyTuple(Basic):\n+    ...     @sympify_return([('other', 'MyTuple')], NotImplemented)\n+    ...     def __add__(self, other):\n+    ...          return MyTuple(*(self.args + other.args))\n+\n+    >>> MyTuple(1, 2) + MyTuple(3, 4)\n+    MyTuple(1, 2, 3, 4)\n+\n+    The idea here is that the decorators take care of the boiler-plate code\n+    for making this happen in each method that potentially needs to accept\n+    unsympified arguments. Then the body of e.g. the __add__ method can be\n+    written without needing to worry about calling _sympify or checking the\n+    type of the resulting object.\n+\n+    The parameters for sympify_return are a list of tuples of the form\n+    (parameter_name, expected_type) and the value to return (e.g.\n+    NotImplemented). The expected_type parameter can be a type e.g. Tuple or a\n+    string 'Tuple'. Using a string is useful for specifying a Type within its\n+    class body (as in the above example).\n+\n+    Notes: Currently sympify_return only works for methods that take a single\n+    argument (not including self). Specifying an expected_type as a string\n+    only works for the class in which the method is defined.\n+    '''\n+    # Extract the wrapped methods from each of the wrapper objects created by\n+    # the sympify_return decorator. Doing this here allows us to provide the\n+    # cls argument which is used for forward string referencing.\n+    for attrname, obj in cls.__dict__.items():\n+        if isinstance(obj, _SympifyWrapper):\n+            setattr(cls, attrname, obj.make_wrapped(cls))\n+    return cls\n+\n+\n+def sympify_return(*args):\n+    '''Function/method decorator to sympify arguments automatically\n+\n+    See the docstring of sympify_method_args for explanation.\n+    '''\n+    # Store a wrapper object for the decorated method\n+    def wrapper(func):\n+        return _SympifyWrapper(func, args)\n+    return wrapper\n+\n+\n+class _SympifyWrapper(object):\n+    '''Internal class used by sympify_return and sympify_method_args'''\n+\n+    def __init__(self, func, args):\n+        self.func = func\n+        self.args = args\n+\n+    def make_wrapped(self, cls):\n+        func = self.func\n+        parameters, retval = self.args\n+\n+        # XXX: Handle more than one parameter?\n+        [(parameter, expectedcls)] = parameters\n+\n+        # Handle forward references to the current class using strings\n+        if expectedcls == cls.__name__:\n+            expectedcls = cls\n+\n+        # Raise RuntimeError since this is a failure at import time and should\n+        # not be recoverable.\n+        nargs = get_function_code(func).co_argcount\n+        # we support f(a, b) only\n+        if nargs != 2:\n+            raise RuntimeError('sympify_return can only be used with 2 argument functions')\n+        # only b is _sympified\n+        if get_function_code(func).co_varnames[1] != parameter:\n+            raise RuntimeError('parameter name mismatch \"%s\" in %s' %\n+                    (parameter, func.__name__))\n+\n+        @wraps(func)\n+        def _func(self, other):\n+            # XXX: The check for _op_priority here should be removed. It is\n+            # needed to stop mutable matrices from being sympified to\n+            # immutable matrices which breaks things in quantum...\n+            if not hasattr(other, '_op_priority'):\n+                try:\n+                    other = sympify(other, strict=True)\n+                except SympifyError:\n+                    return retval\n+            if not isinstance(other, expectedcls):\n+                return retval\n+            return func(self, other)\n+\n+        return _func\ndiff --git a/sympy/core/expr.py b/sympy/core/expr.py\n--- a/sympy/core/expr.py\n+++ b/sympy/core/expr.py\n@@ -4,7 +4,7 @@\n from .basic import Basic, Atom\n from .singleton import S\n from .evalf import EvalfMixin, pure_complex\n-from .decorators import _sympifyit, call_highest_priority\n+from .decorators import call_highest_priority, sympify_method_args, sympify_return\n from .cache import cacheit\n from .compatibility import reduce, as_int, default_sort_key, range, Iterable\n from sympy.utilities.misc import func_name\n@@ -12,6 +12,8 @@\n \n from collections import defaultdict\n \n+\n+@sympify_method_args\n class Expr(Basic, EvalfMixin):\n     \"\"\"\n     Base class for algebraic expressions.\n@@ -170,37 +172,37 @@ def __abs__(self):\n         from sympy import Abs\n         return Abs(self)\n \n-    @_sympifyit('other', NotImplemented)\n+    @sympify_return([('other', 'Expr')], NotImplemented)\n     @call_highest_priority('__radd__')\n     def __add__(self, other):\n         return Add(self, other)\n \n-    @_sympifyit('other', NotImplemented)\n+    @sympify_return([('other', 'Expr')], NotImplemented)\n     @call_highest_priority('__add__')\n     def __radd__(self, other):\n         return Add(other, self)\n \n-    @_sympifyit('other', NotImplemented)\n+    @sympify_return([('other', 'Expr')], NotImplemented)\n     @call_highest_priority('__rsub__')\n     def __sub__(self, other):\n         return Add(self, -other)\n \n-    @_sympifyit('other', NotImplemented)\n+    @sympify_return([('other', 'Expr')], NotImplemented)\n     @call_highest_priority('__sub__')\n     def __rsub__(self, other):\n         return Add(other, -self)\n \n-    @_sympifyit('other', NotImplemented)\n+    @sympify_return([('other', 'Expr')], NotImplemented)\n     @call_highest_priority('__rmul__')\n     def __mul__(self, other):\n         return Mul(self, other)\n \n-    @_sympifyit('other', NotImplemented)\n+    @sympify_return([('other', 'Expr')], NotImplemented)\n     @call_highest_priority('__mul__')\n     def __rmul__(self, other):\n         return Mul(other, self)\n \n-    @_sympifyit('other', NotImplemented)\n+    @sympify_return([('other', 'Expr')], NotImplemented)\n     @call_highest_priority('__rpow__')\n     def _pow(self, other):\n         return Pow(self, other)\n@@ -222,17 +224,17 @@ def __pow__(self, other, mod=None):\n             except TypeError:\n                 return NotImplemented\n \n-    @_sympifyit('other', NotImplemented)\n+    @sympify_return([('other', 'Expr')], NotImplemented)\n     @call_highest_priority('__pow__')\n     def __rpow__(self, other):\n         return Pow(other, self)\n \n-    @_sympifyit('other', NotImplemented)\n+    @sympify_return([('other', 'Expr')], NotImplemented)\n     @call_highest_priority('__rdiv__')\n     def __div__(self, other):\n         return Mul(self, Pow(other, S.NegativeOne))\n \n-    @_sympifyit('other', NotImplemented)\n+    @sympify_return([('other', 'Expr')], NotImplemented)\n     @call_highest_priority('__div__')\n     def __rdiv__(self, other):\n         return Mul(other, Pow(self, S.NegativeOne))\n@@ -240,36 +242,36 @@ def __rdiv__(self, other):\n     __truediv__ = __div__\n     __rtruediv__ = __rdiv__\n \n-    @_sympifyit('other', NotImplemented)\n+    @sympify_return([('other', 'Expr')], NotImplemented)\n     @call_highest_priority('__rmod__')\n     def __mod__(self, other):\n         return Mod(self, other)\n \n-    @_sympifyit('other', NotImplemented)\n+    @sympify_return([('other', 'Expr')], NotImplemented)\n     @call_highest_priority('__mod__')\n     def __rmod__(self, other):\n         return Mod(other, self)\n \n-    @_sympifyit('other', NotImplemented)\n+    @sympify_return([('other', 'Expr')], NotImplemented)\n     @call_highest_priority('__rfloordiv__')\n     def __floordiv__(self, other):\n         from sympy.functions.elementary.integers import floor\n         return floor(self / other)\n \n-    @_sympifyit('other', NotImplemented)\n+    @sympify_return([('other', 'Expr')], NotImplemented)\n     @call_highest_priority('__floordiv__')\n     def __rfloordiv__(self, other):\n         from sympy.functions.elementary.integers import floor\n         return floor(other / self)\n \n \n-    @_sympifyit('other', NotImplemented)\n+    @sympify_return([('other', 'Expr')], NotImplemented)\n     @call_highest_priority('__rdivmod__')\n     def __divmod__(self, other):\n         from sympy.functions.elementary.integers import floor\n         return floor(self / other), Mod(self, other)\n \n-    @_sympifyit('other', NotImplemented)\n+    @sympify_return([('other', 'Expr')], NotImplemented)\n     @call_highest_priority('__divmod__')\n     def __rdivmod__(self, other):\n         from sympy.functions.elementary.integers import floor\n@@ -334,7 +336,11 @@ def _cmp(self, other, op, cls):\n         try:\n             other = _sympify(other)\n         except SympifyError:\n-            raise TypeError(\"Invalid comparison %s %s %s\" % (self, op, other))\n+            return NotImplemented\n+\n+        if not isinstance(other, Expr):\n+            return NotImplemented\n+\n         for me in (self, other):\n             if me.is_extended_real is False:\n                 raise TypeError(\"Invalid comparison of non-real %s\" % me)\ndiff --git a/sympy/core/numbers.py b/sympy/core/numbers.py\n--- a/sympy/core/numbers.py\n+++ b/sympy/core/numbers.py\n@@ -632,8 +632,7 @@ def __divmod__(self, other):\n             if self.is_infinite or S.NaN in (self, other):\n                 return (S.NaN, S.NaN)\n         except TypeError:\n-            msg = \"unsupported operand type(s) for divmod(): '%s' and '%s'\"\n-            raise TypeError(msg % (type(self).__name__, type(other).__name__))\n+            return NotImplemented\n         if not other:\n             raise ZeroDivisionError('modulo by zero')\n         if self.is_Integer and other.is_Integer:\n@@ -654,8 +653,7 @@ def __rdivmod__(self, other):\n         try:\n             other = Number(other)\n         except TypeError:\n-            msg = \"unsupported operand type(s) for divmod(): '%s' and '%s'\"\n-            raise TypeError(msg % (type(other).__name__, type(self).__name__))\n+            return NotImplemented\n         return divmod(other, self)\n \n     def _as_mpf_val(self, prec):\n@@ -1423,7 +1421,7 @@ def _Frel(self, other, op):\n         try:\n             other = _sympify(other)\n         except SympifyError:\n-            raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n+            return NotImplemented\n         if other.is_Rational:\n             # test self*other.q <?> other.p without losing precision\n             '''\n@@ -1918,7 +1916,7 @@ def _Rrel(self, other, attr):\n         try:\n             other = _sympify(other)\n         except SympifyError:\n-            raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n+            return NotImplemented\n         if other.is_Number:\n             op = None\n             s, o = self, other\n@@ -2254,7 +2252,7 @@ def __gt__(self, other):\n         try:\n             other = _sympify(other)\n         except SympifyError:\n-            raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n+            return NotImplemented\n         if other.is_Integer:\n             return _sympify(self.p > other.p)\n         return Rational.__gt__(self, other)\n@@ -2263,7 +2261,7 @@ def __lt__(self, other):\n         try:\n             other = _sympify(other)\n         except SympifyError:\n-            raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n+            return NotImplemented\n         if other.is_Integer:\n             return _sympify(self.p < other.p)\n         return Rational.__lt__(self, other)\n@@ -2272,7 +2270,7 @@ def __ge__(self, other):\n         try:\n             other = _sympify(other)\n         except SympifyError:\n-            raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n+            return NotImplemented\n         if other.is_Integer:\n             return _sympify(self.p >= other.p)\n         return Rational.__ge__(self, other)\n@@ -2281,7 +2279,7 @@ def __le__(self, other):\n         try:\n             other = _sympify(other)\n         except SympifyError:\n-            raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n+            return NotImplemented\n         if other.is_Integer:\n             return _sympify(self.p <= other.p)\n         return Rational.__le__(self, other)\n@@ -2416,7 +2414,10 @@ def _eval_is_composite(self):\n     def as_numer_denom(self):\n         return self, S.One\n \n+    @_sympifyit('other', NotImplemented)\n     def __floordiv__(self, other):\n+        if not isinstance(other, Expr):\n+            return NotImplemented\n         if isinstance(other, Integer):\n             return Integer(self.p // other)\n         return Integer(divmod(self, other)[0])\n@@ -2954,7 +2955,10 @@ def __ne__(self, other):\n     __lt__ = Expr.__lt__\n     __le__ = Expr.__le__\n \n+    @_sympifyit('other', NotImplemented)\n     def __mod__(self, other):\n+        if not isinstance(other, Expr):\n+            return NotImplemented\n         return S.NaN\n \n     __rmod__ = __mod__\n@@ -3116,7 +3120,10 @@ def __ne__(self, other):\n     __lt__ = Expr.__lt__\n     __le__ = Expr.__le__\n \n+    @_sympifyit('other', NotImplemented)\n     def __mod__(self, other):\n+        if not isinstance(other, Expr):\n+            return NotImplemented\n         return S.NaN\n \n     __rmod__ = __mod__\ndiff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -8,7 +8,8 @@\n     ordered, range, PY3, reduce)\n from sympy.core.cache import cacheit\n from sympy.core.containers import Tuple\n-from sympy.core.decorators import deprecated\n+from sympy.core.decorators import (deprecated, sympify_method_args,\n+    sympify_return)\n from sympy.core.evalf import EvalfMixin\n from sympy.core.evaluate import global_evaluate\n from sympy.core.expr import Expr\n@@ -35,6 +36,8 @@\n     False: S.false,\n     S.false: S.false})\n \n+\n+@sympify_method_args\n class Set(Basic):\n     \"\"\"\n     The base class for any kind of set.\n@@ -625,31 +628,38 @@ def _boundary(self):\n     def _measure(self):\n         raise NotImplementedError(\"(%s)._measure\" % self)\n \n+    @sympify_return([('other', 'Set')], NotImplemented)\n     def __add__(self, other):\n         return self.union(other)\n \n+    @sympify_return([('other', 'Set')], NotImplemented)\n     def __or__(self, other):\n         return self.union(other)\n \n+    @sympify_return([('other', 'Set')], NotImplemented)\n     def __and__(self, other):\n         return self.intersect(other)\n \n+    @sympify_return([('other', 'Set')], NotImplemented)\n     def __mul__(self, other):\n         return ProductSet(self, other)\n \n+    @sympify_return([('other', 'Set')], NotImplemented)\n     def __xor__(self, other):\n         return SymmetricDifference(self, other)\n \n+    @sympify_return([('exp', Expr)], NotImplemented)\n     def __pow__(self, exp):\n-        if not (sympify(exp).is_Integer and exp >= 0):\n+        if not (exp.is_Integer and exp >= 0):\n             raise ValueError(\"%s: Exponent must be a positive Integer\" % exp)\n         return ProductSet(*[self]*exp)\n \n+    @sympify_return([('other', 'Set')], NotImplemented)\n     def __sub__(self, other):\n         return Complement(self, other)\n \n     def __contains__(self, other):\n-        other = sympify(other)\n+        other = _sympify(other)\n         c = self._contains(other)\n         b = tfn[c]\n         if b is None:\ndiff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -1124,7 +1124,7 @@ def _futrig(e, **kwargs):\n     if e.is_Mul:\n         coeff, e = e.as_independent(TrigonometricFunction)\n     else:\n-        coeff = S.One\n+        coeff = None\n \n     Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)\n     trigs = lambda x: x.has(TrigonometricFunction)\n@@ -1167,7 +1167,11 @@ def _futrig(e, **kwargs):\n             factor_terms, TR12(x), trigs)],  # expand tan of sum\n         )]\n     e = greedy(tree, objective=Lops)(e)\n-    return coeff*e\n+\n+    if coeff is not None:\n+        e = coeff * e\n+\n+    return e\n \n \n def _is_Expr(e):\ndiff --git a/sympy/solvers/ode.py b/sympy/solvers/ode.py\n--- a/sympy/solvers/ode.py\n+++ b/sympy/solvers/ode.py\n@@ -1466,7 +1466,11 @@ def _test_term(coeff, order):\n         if r is not None:\n             coeff = r[order]\n             factor = x**order / coeff\n-            r_rescaled = {i: factor*r[i] for i in r}\n+            r_rescaled = {i: factor*r[i] for i in r if i != 'trialset'}\n+\n+        # XXX: Mixing up the trialset with the coefficients is error-prone.\n+        # These should be separated as something like r['coeffs'] and\n+        # r['trialset']\n \n         if r_rescaled and not any(not _test_term(r_rescaled[i], i) for i in\n                 r_rescaled if i != 'trialset' and i >= 0):\n",
  "test_patch": "diff --git a/sympy/core/tests/test_expr.py b/sympy/core/tests/test_expr.py\n--- a/sympy/core/tests/test_expr.py\n+++ b/sympy/core/tests/test_expr.py\n@@ -165,6 +165,190 @@ def s(a, b):\n     assert dotest(s)\n \n \n+class NonBasic(object):\n+    '''This class represents an object that knows how to implement binary\n+    operations like +, -, etc with Expr but is not a subclass of Basic itself.\n+    The NonExpr subclass below does subclass Basic but not Expr.\n+\n+    For both NonBasic and NonExpr it should be possible for them to override\n+    Expr.__add__ etc because Expr.__add__ should be returning NotImplemented\n+    for non Expr classes. Otherwise Expr.__add__ would create meaningless\n+    objects like Add(Integer(1), FiniteSet(2)) and it wouldn't be possible for\n+    other classes to override these operations when interacting with Expr.\n+    '''\n+    def __add__(self, other):\n+        return SpecialOp('+', self, other)\n+\n+    def __radd__(self, other):\n+        return SpecialOp('+', other, self)\n+\n+    def __sub__(self, other):\n+        return SpecialOp('-', self, other)\n+\n+    def __rsub__(self, other):\n+        return SpecialOp('-', other, self)\n+\n+    def __mul__(self, other):\n+        return SpecialOp('*', self, other)\n+\n+    def __rmul__(self, other):\n+        return SpecialOp('*', other, self)\n+\n+    def __div__(self, other):\n+        return SpecialOp('/', self, other)\n+\n+    def __rdiv__(self, other):\n+        return SpecialOp('/', other, self)\n+\n+    __truediv__ = __div__\n+    __rtruediv__ = __rdiv__\n+\n+    def __floordiv__(self, other):\n+        return SpecialOp('//', self, other)\n+\n+    def __rfloordiv__(self, other):\n+        return SpecialOp('//', other, self)\n+\n+    def __mod__(self, other):\n+        return SpecialOp('%', self, other)\n+\n+    def __rmod__(self, other):\n+        return SpecialOp('%', other, self)\n+\n+    def __divmod__(self, other):\n+        return SpecialOp('divmod', self, other)\n+\n+    def __rdivmod__(self, other):\n+        return SpecialOp('divmod', other, self)\n+\n+    def __pow__(self, other):\n+        return SpecialOp('**', self, other)\n+\n+    def __rpow__(self, other):\n+        return SpecialOp('**', other, self)\n+\n+    def __lt__(self, other):\n+        return SpecialOp('<', self, other)\n+\n+    def __gt__(self, other):\n+        return SpecialOp('>', self, other)\n+\n+    def __le__(self, other):\n+        return SpecialOp('<=', self, other)\n+\n+    def __ge__(self, other):\n+        return SpecialOp('>=', self, other)\n+\n+\n+class NonExpr(Basic, NonBasic):\n+    '''Like NonBasic above except this is a subclass of Basic but not Expr'''\n+    pass\n+\n+\n+class SpecialOp(Basic):\n+    '''Represents the results of operations with NonBasic and NonExpr'''\n+    def __new__(cls, op, arg1, arg2):\n+        return Basic.__new__(cls, op, arg1, arg2)\n+\n+\n+class NonArithmetic(Basic):\n+    '''Represents a Basic subclass that does not support arithmetic operations'''\n+    pass\n+\n+\n+def test_cooperative_operations():\n+    '''Tests that Expr uses binary operations cooperatively.\n+\n+    In particular it should be possible for non-Expr classes to override\n+    binary operators like +, - etc when used with Expr instances. This should\n+    work for non-Expr classes whether they are Basic subclasses or not. Also\n+    non-Expr classes that do not define binary operators with Expr should give\n+    TypeError.\n+    '''\n+    # A bunch of instances of Expr subclasses\n+    exprs = [\n+        Expr(),\n+        S.Zero,\n+        S.One,\n+        S.Infinity,\n+        S.NegativeInfinity,\n+        S.ComplexInfinity,\n+        S.Half,\n+        Float(0.5),\n+        Integer(2),\n+        Symbol('x'),\n+        Mul(2, Symbol('x')),\n+        Add(2, Symbol('x')),\n+        Pow(2, Symbol('x')),\n+    ]\n+\n+    for e in exprs:\n+        # Test that these classes can override arithmetic operations in\n+        # combination with various Expr types.\n+        for ne in [NonBasic(), NonExpr()]:\n+\n+            results = [\n+                (ne + e, ('+', ne, e)),\n+                (e + ne, ('+', e, ne)),\n+                (ne - e, ('-', ne, e)),\n+                (e - ne, ('-', e, ne)),\n+                (ne * e, ('*', ne, e)),\n+                (e * ne, ('*', e, ne)),\n+                (ne / e, ('/', ne, e)),\n+                (e / ne, ('/', e, ne)),\n+                (ne // e, ('//', ne, e)),\n+                (e // ne, ('//', e, ne)),\n+                (ne % e, ('%', ne, e)),\n+                (e % ne, ('%', e, ne)),\n+                (divmod(ne, e), ('divmod', ne, e)),\n+                (divmod(e, ne), ('divmod', e, ne)),\n+                (ne ** e, ('**', ne, e)),\n+                (e ** ne, ('**', e, ne)),\n+                (e < ne, ('>', ne, e)),\n+                (ne < e, ('<', ne, e)),\n+                (e > ne, ('<', ne, e)),\n+                (ne > e, ('>', ne, e)),\n+                (e <= ne, ('>=', ne, e)),\n+                (ne <= e, ('<=', ne, e)),\n+                (e >= ne, ('<=', ne, e)),\n+                (ne >= e, ('>=', ne, e)),\n+            ]\n+\n+            for res, args in results:\n+                assert type(res) is SpecialOp and res.args == args\n+\n+        # These classes do not support binary operators with Expr. Every\n+        # operation should raise in combination with any of the Expr types.\n+        for na in [NonArithmetic(), object()]:\n+\n+            raises(TypeError, lambda : e + na)\n+            raises(TypeError, lambda : na + e)\n+            raises(TypeError, lambda : e - na)\n+            raises(TypeError, lambda : na - e)\n+            raises(TypeError, lambda : e * na)\n+            raises(TypeError, lambda : na * e)\n+            raises(TypeError, lambda : e / na)\n+            raises(TypeError, lambda : na / e)\n+            raises(TypeError, lambda : e // na)\n+            raises(TypeError, lambda : na // e)\n+            raises(TypeError, lambda : e % na)\n+            raises(TypeError, lambda : na % e)\n+            raises(TypeError, lambda : divmod(e, na))\n+            raises(TypeError, lambda : divmod(na, e))\n+            raises(TypeError, lambda : e ** na)\n+            raises(TypeError, lambda : na ** e)\n+            # XXX: Remove the if when PY2 support is dropped:\n+            if PY3:\n+                raises(TypeError, lambda : e > na)\n+                raises(TypeError, lambda : na > e)\n+                raises(TypeError, lambda : e < na)\n+                raises(TypeError, lambda : na < e)\n+                raises(TypeError, lambda : e >= na)\n+                raises(TypeError, lambda : na >= e)\n+                raises(TypeError, lambda : e <= na)\n+                raises(TypeError, lambda : na <= e)\n+\n+\n def test_relational():\n     from sympy import Lt\n     assert (pi < 3) is S.false\ndiff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py\n--- a/sympy/core/tests/test_numbers.py\n+++ b/sympy/core/tests/test_numbers.py\n@@ -7,7 +7,7 @@\n                    Number, zoo, log, Mul, Pow, Tuple, latex, Gt, Lt, Ge, Le,\n                    AlgebraicNumber, simplify, sin, fibonacci, RealField,\n                    sympify, srepr, Dummy, Sum)\n-from sympy.core.compatibility import long\n+from sympy.core.compatibility import long, PY3\n from sympy.core.logic import fuzzy_not\n from sympy.core.numbers import (igcd, ilcm, igcdex, seterr,\n     igcd2, igcd_lehmer, mpf_norm, comp, mod_inverse)\n@@ -1901,14 +1901,15 @@ class Foo(object):\n         assert foo != n\n         assert not n == foo\n         assert not foo == n\n-        raises(TypeError, lambda: n < foo)\n-        raises(TypeError, lambda: foo > n)\n-        raises(TypeError, lambda: n > foo)\n-        raises(TypeError, lambda: foo < n)\n-        raises(TypeError, lambda: n <= foo)\n-        raises(TypeError, lambda: foo >= n)\n-        raises(TypeError, lambda: n >= foo)\n-        raises(TypeError, lambda: foo <= n)\n+        if PY3:\n+            raises(TypeError, lambda: n < foo)\n+            raises(TypeError, lambda: foo > n)\n+            raises(TypeError, lambda: n > foo)\n+            raises(TypeError, lambda: foo < n)\n+            raises(TypeError, lambda: n <= foo)\n+            raises(TypeError, lambda: foo >= n)\n+            raises(TypeError, lambda: n >= foo)\n+            raises(TypeError, lambda: foo <= n)\n \n     class Bar(object):\n         \"\"\"\n@@ -1942,14 +1943,15 @@ def __ne__(self, other):\n         assert not bar == n\n \n     for n in ni, nf, nr, oo, -oo, zoo, nan:\n-        raises(TypeError, lambda: n < bar)\n-        raises(TypeError, lambda: bar > n)\n-        raises(TypeError, lambda: n > bar)\n-        raises(TypeError, lambda: bar < n)\n-        raises(TypeError, lambda: n <= bar)\n-        raises(TypeError, lambda: bar >= n)\n-        raises(TypeError, lambda: n >= bar)\n-        raises(TypeError, lambda: bar <= n)\n+        if PY3:\n+            raises(TypeError, lambda: n < bar)\n+            raises(TypeError, lambda: bar > n)\n+            raises(TypeError, lambda: n > bar)\n+            raises(TypeError, lambda: bar < n)\n+            raises(TypeError, lambda: n <= bar)\n+            raises(TypeError, lambda: bar >= n)\n+            raises(TypeError, lambda: n >= bar)\n+            raises(TypeError, lambda: bar <= n)\n \n def test_NumberSymbol_comparison():\n     from sympy.core.tests.test_relational import rel_check\n@@ -2018,11 +2020,12 @@ def test_NegativeInfinity():\n     assert (-oo)**12 is oo\n \n def test_issue_6133():\n-    raises(TypeError, lambda: (-oo < None))\n-    raises(TypeError, lambda: (S(-2) < None))\n-    raises(TypeError, lambda: (oo < None))\n-    raises(TypeError, lambda: (oo > None))\n-    raises(TypeError, lambda: (S(2) < None))\n+    if PY3:\n+        raises(TypeError, lambda: (-oo < None))\n+        raises(TypeError, lambda: (S(-2) < None))\n+        raises(TypeError, lambda: (oo < None))\n+        raises(TypeError, lambda: (oo > None))\n+        raises(TypeError, lambda: (S(2) < None))\n \n def test_abc():\n     x = numbers.Float(5)\ndiff --git a/sympy/core/tests/test_relational.py b/sympy/core/tests/test_relational.py\n--- a/sympy/core/tests/test_relational.py\n+++ b/sympy/core/tests/test_relational.py\n@@ -2,7 +2,7 @@\n from sympy import (S, Symbol, symbols, nan, oo, I, pi, Float, And, Or,\n     Not, Implies, Xor, zoo, sqrt, Rational, simplify, Function,\n     log, cos, sin, Add, floor, ceiling, trigsimp)\n-from sympy.core.compatibility import range\n+from sympy.core.compatibility import range, PY3\n from sympy.core.relational import (Relational, Equality, Unequality,\n                                    GreaterThan, LessThan, StrictGreaterThan,\n                                    StrictLessThan, Rel, Eq, Lt, Le,\n@@ -611,7 +611,8 @@ def test_inequalities_cant_sympify_other():\n \n     for a in (x, S.Zero, S.One/3, pi, I, zoo, oo, -oo, nan, Rational(1, 3)):\n         for op in (lt, gt, le, ge):\n-            raises(TypeError, lambda: op(a, bar))\n+            if PY3:\n+                raises(TypeError, lambda: op(a, bar))\n \n \n def test_ineq_avoid_wild_symbol_flip():\ndiff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -311,6 +311,43 @@ def test_Complement():\n     assert B3 - A2 == B3\n \n \n+def test_set_operations_nonsets():\n+    '''Tests that e.g. FiniteSet(1) * 2 raises TypeError'''\n+    ops = [\n+        lambda a, b: a + b,\n+        lambda a, b: a - b,\n+        lambda a, b: a * b,\n+        lambda a, b: a / b,\n+        lambda a, b: a // b,\n+        lambda a, b: a | b,\n+        lambda a, b: a & b,\n+        lambda a, b: a ^ b,\n+        # FiniteSet(1) ** 2 gives a ProductSet\n+        #lambda a, b: a ** b,\n+    ]\n+    Sx = FiniteSet(x)\n+    Sy = FiniteSet(y)\n+    sets = [\n+        {1},\n+        FiniteSet(1),\n+        Interval(1, 2),\n+        Union(Sx, Interval(1, 2)),\n+        Intersection(Sx, Sy),\n+        Complement(Sx, Sy),\n+        ProductSet(Sx, Sy),\n+        S.EmptySet,\n+    ]\n+    nums = [0, 1, 2, S(0), S(1), S(2)]\n+\n+    for s in sets:\n+        for n in nums:\n+            for op in ops:\n+                raises(TypeError, lambda : op(s, n))\n+                raises(TypeError, lambda : op(n, s))\n+        raises(TypeError, lambda: s ** object())\n+        raises(TypeError, lambda: s ** {1})\n+\n+\n def test_complement():\n     assert Interval(0, 1).complement(S.Reals) == \\\n         Union(Interval(-oo, 0, True, True), Interval(1, oo, True, True))\n",
  "problem_statement": "Separate boolean and symbolic relationals\nWell, it seems obvious that a Relational is a Boolean. The problem is that\r\nthere are a few places where Expr methods are called on them.\r\n\r\nOriginal issue for #4986: http://code.google.com/p/sympy/issues/detail?id=1887\r\nOriginal author: https://code.google.com/u/101272611947379421629/\r\nOriginal owner: https://code.google.com/u/101272611947379421629/\r\n\n",
  "hints_text": "I guess it should be a Boolean in order to do things like x > y => Assume(x - y, Q.positive).\r\n\r\nAlso, I think just about all Expr methods on a relational should just apply themselves to the lhs and rhs (except \r\nfor inequalities when it would not be correct).  Is there any way to make it do this automatically, for Eq at least?\r\n\r\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c1\r\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\r\n\n```\nIssue 2030 has been merged into this issue.\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c2\nOriginal author: https://code.google.com/u/101069955704897915480/\n\nI think this is the best place to make this issue.  \r\n\r\nIn light of issue #5031 and others, I think we need two classes, Eq and Eqn (and ditto for the inequalities).  \r\n\r\nOne of them would be a Boolean, and would be used for the assumptions.  The other would be a container class for symbolic equalities/inequalities.  The Boolean would auto-reduce to True or False whenever possible.  The other one would never reduce (even if it is something like 1 == 1 or 1 == 2 or Pi > 3).  Arithmetic would work on the symbolic ones ( issue #5031 ).  I'm not sure which one would be called Eq and which Eqn, or what to call the Le, Lt, etc. versions.\r\n\r\nI think maybe x > y should return the symbolic version by default, but it would be converted to the boolean version when something like Ask(x >y) or Assume(x > y) was called.  \r\n\r\nRonan, do you agree with this?\r\n\r\nAlso, postponing the release milestone.\r\n\r\n**Summary:** Separate boolean and symbolic relationals  \r\n**Labels:** -Milestone-Release0.7.0 Milestone-Release0.7.1  \r\n\r\nReferenced issues: #5031\r\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c3\r\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\r\n\n```\n**Blocking:** 5030  \n\n```\n\nReferenced issues: #5030\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c4\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n\"I'm not sure which one would be called Eq and which Eqn\".\r\n\r\nIMO, Eq would best fit for a boolean (standing for \"equality\"), while Eqn would be a symbolic equation, with operations attached to its members.\r\n\r\nAlso, I think we should have Eq(a, b) always reduced to Eq(a - b, 0), but Eqn(a, b) should be kept as it.\r\n\r\n(And docstrings should indicate clearly the differences between both classes, since there is a big risk of confusion anyway...)\r\n\r\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c5\r\nOriginal author: https://code.google.com/u/117997262464115802198/\r\n\nThe only problem with this is that Eq() is presently used for equations, so it would break compatibility.\r\n\r\nWhat would you suggest naming the inequality functions?\r\n\r\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c6\r\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\r\n\n```\nMmmm... that's not obvious.\n\nFirst, concerning (symbolic) equations, I successively concidered:\n\n1. Using Ineqn:\n---------------\nI thought about having an Ineqn(a, b, comp) class. Something like that:\n>>> Ineqn(x, 2, '>')\nx > 2\n>>> Ineqn('x>2')\nx > 2\n>>> Ineqn('3>2')\n3 > 2\n\n(Le, Lt etc. might then be kept as shortcuts for inequations...)\n\nBut Ineqn.args should all be of Basic type, so this would require to convert third argument ('>', '<', '>=', '<=' and maybe '!=') to Integers for example, for internal storage. That's feasable but not so elegant.\n\nNevertheless, I like the name Ineqn, which IMO does not suggest booleans as much as Le or Lt.\n\n2. Keeping Lt, Le...\n--------------------\nAnother option is of course to use Le, Lt... for symbolic inequations, but I don't like it so much, I think it really looks like boolean names.\n\n3. Using GtEqn, LeEqn\n---------------------\nGtEqn, LeEqn (and so on...) are less ambiguous, but not so short to tape.\n>>> GtEqn(x, 2)\nx > 2\n>>> LeEqn(3, 5)\n3 <= 5\n\nFor now, I think it's the solution I prefer.\n\n\n\n\nConcerning inequalities:\n\nThe real challenge is to find suitable names for symbolic inequations (ie. short and unambiguous ones).\n\nAs for (boolean) inequalities,  I think names are not so important, since x < 2 is an easy shortcut.\nAlso, inequalities (but not inequations) should auto-reduce to True or False in cases like S(3) < S(4) and S(3) > S(4).\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c7\nOriginal author: https://code.google.com/u/117997262464115802198/\n\n```\nSee comment 3 above.  I think >, <, >=, and <= should default to the symbolic version, but perhaps they could be automatically converted to the boolean version when necessary.  \n\nThus, we can make it LtEqn, etc. for the equation version (which will have the shortcut of <), and make Lt() be the boolean version.\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c8\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n\"I think >, <, >=, and <= should default to the symbolic version, but perhaps they could be automatically converted to the boolean version when necessary.\"\r\n\r\nWell, I don't think they should default to the symbolic version, I think I'd rather expect those to be booleans instead.\r\n\r\nAnyway, we have to be sure that things like the following work:\r\n```\r\nif S(2) < S(3):\r\n   print('2 is smaller !')\r\n```\r\nSo, if you choose to keep those for the symbolic version, there should indeed be a .__bool__() method attached, to avoid more common misuses (though testing inequalities in such a way might be a bit slow).\r\n\r\nIf not, it would be *really* confusing.\r\n\r\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c9\r\nOriginal author: https://code.google.com/u/117997262464115802198/\r\n\nOf course bool(Le) should work.  That's part of what I meant when I said it should convert to the boolean type automatically.\r\n\r\nConsider the main uses of <.  I think that most people will use it in the symbolic sense, like solve(x**2 > x, x).  We can easily convert it to the boolean type if the user says assume(x > 0).  But consider especially that if we follow your suggestion to automatically rewrite a > b as a - b > 0 (for the boolean inequality), then it will not be so easy to convert the boolean inequality to a symbolic inequality, because you will have lost the information about which parts of the expression were on which side of the inequality.\r\n\r\nBy the way, another thing that bothers me about the inequalities that we might as well fix when we fix this is the way that Ge() is automatically converted to Le().  This leads to things like 0 < x when the user entered x > 0, which looks bad and is confusing.  Of course, internally, they could be store the same (or maybe we could just have properties of all the comparative inequalities like .smaller_part and .large_part (except better names than that), and just use those everywhere.\r\n\r\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c10\r\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\r\n\n> Of course bool(Le) should work.\r\n\r\nI have serious doubts about that. bool(x < 3) needs to return either True or False, but neither is really meaningful or obviously correct, and we'll be forced to have bool(x > 3) == bool(Not(x > 3)), which is seriously confusing and dangerous if you try to use a construct like 'if x > 3:'.\r\n\r\nAlso, I don't really understand what you call \"symbolic\". Both kinds of objects considered here are symbolic. The boolean inequalities need to be efficient, while the inequations should give complete control to the user and will only be used for presentation. In `solve(x**2 > x, x)`, it's clearly the boolean meaning that is implied: the result should be exactly the same as the one for `solve(x**2 - x > 0, x)` or `solve(x < x**2, x)`.\r\n\r\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c11\r\nOriginal author: https://code.google.com/u/101272611947379421629/\r\n\n```\nI'd like to do a small 0.7.1 release with IPython 0.11 support, so these will be postponed until 0.7.2.\n\n**Labels:** Milestone-Release0.7.2  \n\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c12\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\nOperators defaulting to bools would make my life substantially easier.\r\n\r\nI also think that writing a<3 and expecting a bool is more common than writing a<b as a symbolic inequality. \r\n```\r\nx = Symbol('x', positive=True)\r\nI'd like x>0 to be True\r\n```\r\nOther issues that affect my code specifically \r\nEq(x, x) != True\r\nNe(x, 0) != True (in the above, x positive example)\r\n\r\nThe second bit also affects Tom's integration code where any variable might be required to be positive or non-zero.\r\n\r\n**Cc:** ness...@googlemail.com  \r\n\r\n```\r\n\r\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c13\r\nOriginal author: https://code.google.com/u/109882876523836932473/\r\n\n```\n**Blocking:** 5719  \n\n```\n\nReferenced issues: #5719\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c14\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n> I also think that writing a<3 and expecting a bool is more common than writing a<b as a symbolic inequality. \r\n\r\nMaybe in your use case.  To me, the most common use would be something like solve(x**2 < 1), which should be symbolic.  Also, it's easy to convert a symbolic inequality to a boolean one in the right context, but hard to do the reverse.\r\n\r\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c15\r\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\r\n\n```\n**Blocking:** 5820  \n\n```\n\nReferenced issues: #5820\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c16\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n```\n**Blocking:** 5023  \n\n```\n\nReferenced issues: #5023\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c17\nOriginal author: https://code.google.com/u/101272611947379421629/\n\n```\n**Blocking:** 5931  \n\n```\n\nReferenced issues: #5931\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c18\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n```\nVery optimistically postponing (instead of removing) the milestone...\n\n**Labels:** -Priority-Medium -Milestone-Release0.7.2 Priority-High Milestone-Release0.7.3  \n\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c19\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n```\n**Blocking:** 6059  \n\n```\n\nReferenced issues: #6059\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c20\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\nSee issue 6059 for some things that need to be fixed in Relationals.  That issue talks mostly about inequalities, but many of them actually apply to all inequalities (e.g., nested Eq() is currently allowed as well).\r\n\r\nReferenced issues: #6059\r\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c21\r\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\r\n\n```\n**Blocking:** 6078  \n\n```\n\nReferenced issues: #6078\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c22\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n```\n**Blocking:** 6116  \n\n```\n\nReferenced issues: #6116\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c23\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n```\n**Blocking:** 6204  \n\n```\n\nReferenced issues: #6204\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c24\nOriginal author: https://code.google.com/u/101272611947379421629/\n\n```\n**Status:** Valid  \n\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c25\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\nThere was recently a discussion on the maling list about this (actually issue #6204 , but the key here is this issue).  See https://groups.google.com/d/topic/sympy/TTmZMxpeXn4/discussion .\r\n\r\nOne thing I noted there is that Symbol has exactly the same problem as Relational.  We currently have Symbol as both an Expr and a Boolean.  But clearly we should have both.  We could have intelligent coercion with things like x | y so that it automatically converts a Symbol to a BooleanSymbol, assuming that x and y don't have any assumptions on them that explicitly make them non-boolean.  But whatever we do, the solution for Symbol and the solution for Relational should probably be more or less the same.\r\n\r\nReferenced issues: #6204\r\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c26\r\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\r\n\n```\n**Blocking:** 5820  \n\n```\n\nReferenced issues: #5820\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c27\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n```\n**Blocking:** -sympy:1932 -sympy:1931 -sympy:2620 -sympy:2721 -sympy:1924 -sympy:2832 -sympy:2960 -sympy:2979 -sympy:3017 -sympy:3105 sympy:1932 sympy:1931 sympy:2620 sympy:1924 sympy:2832 sympy:2960 sympy:2979 sympy:3017 sympy:3105 sympy:3105  \n\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c28\nOriginal author: https://code.google.com/u/102137482174297837682/\n\n```\nIssue 370 has been merged into this issue.\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c29\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n```\n@asmeurer, mind me working on this?\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c30\nOriginal author: https://code.google.com/u/106302547764750990775/\n\n```\nMind? I think it would be great if someone worked on this. \n\nTake a look at the blocking issues for some inspiration.\n\n**Cc:** -ness...@googlemail.com  \n\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c31\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n```\n**Labels:** -Milestone-Release0.7.3  \n\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=1887#c32\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\nI felt a personal need for an Eqn class so I wrote one to meet my needs, and I've found it very useful. I'm new to sympy and not keen on delving deep into this so maybe I'm missing a better way to do this. I'm afraid I'm not very interested in working this into a pull request, but if somebody else would like to pick it up and add it so Sympy, be my guest.\n\n```\nimport sympy\nfrom sympy import S\nimport operator\n\nclass Eqn(object):\n  \"\"\"\n  This class represents an equation. It is meant for reasoning with equations: adding\n  equations, subtracting equations, multiplying them, making substitutions etc.\n\n  >>> from sympy import var\n  >>> var('x')\n  x\n  >>> eq1 = Eqn(2*x, 5)\n  >>> eq1 += 4\n  >>> eq1.solve()\n  {x: 5/2}\n  \"\"\"\n\n  __slots__ = ['sides']\n\n  def __init__(self, *sides):\n    self.sides = map(S, sides)\n\n  def map(self, *fs):\n    res = self\n    for f in fs:\n      res = Eqn(*map(f, res.sides))\n    return res\n\n  def __iadd__(self, other):\n    self.sides = (self+other).sides\n    return self\n\n  def __imul__(self, other):\n    self.sides = (self*other).sides\n    return self\n\n  def __isub__(self, other):\n    self.sides = (self-other).sides\n    return self\n\n  def __itruediv__(self, other):\n    self.sides = operator.truediv(self,other).sides\n    return self\n\n  def __rmul__(self, other):\n    return self.binary_op(operator.mul, other, self)\n\n  def __radd__(self, other):\n    return self.binary_op(operator.add, other, self)\n\n  def __rtruediv__(self, other):\n    return self.binary_op(operator.truediv, other, self)\n\n  def __rsub__(self, other):\n    return self.binary_op(operator.sub, other, self)\n\n  def __neg__(self):\n    return self.map(operator.neg)\n\n  def as_eqs(self):\n    return [sympy.Eq(self.sides[i-1], self.sides[i])\n            for i in xrange(1, len(self.sides))]\n\n  def solve(self, *args, **kwArgs):\n    return sympy.solve(self.as_eqs(), *args, **kwArgs)\n\n  def isolate(self, x):\n    solution = sympy.solve(self.as_eqs(), x, dict=True)\n    if isinstance(solution,list):\n      solution, = solution\n    return Eqn(x, solution[x])\n\n  def __str__(self):\n    return ' = '.join(map(str,self.sides))\n\n  def foreach(self, *fs):\n    for f in fs:\n      self.sides = map(f, self.sides)\n\n  def __getitem__(self,idx):\n    return self.sides[idx]\n\n  def __setitem__(self,idx,val):\n    self.sides[idx] = val\n\n  @classmethod\n  def binary_op(cls, op, a, b):\n    if isinstance(b, Eqn) and isinstance(a, Eqn):\n      return Eqn(*map(op, a.sides, b.sides))\n    if isinstance(a, Eqn):\n      return Eqn(*[op(x,b) for x in a.sides])\n    assert isinstance(b, Eqn)\n    return Eqn(*[op(a,y) for y in b.sides])\n\n  def __pow__(self, other):\n    return self.binary_op(operator.pow, self, other)\n\n  def __mul__(self, other):\n    return self.binary_op(operator.mul, self, other)\n\n  def __truediv__(self, other):\n    return self.binary_op(operator.truediv, self, other)\n\n  def __add__(self, other):\n    return self.binary_op(operator.add, self, other)\n\n  def __sub__(self, other):\n    return self.binary_op(operator.sub, self, other)\n\n  def reverse(self):\n    return Eqn(*self.sides[::-1])\n\n  def revert(self):\n    self.sides = self.sides[::-1]\n\n  def sides_ratio(self, numerator=1, denominator=0):\n    return operator.truediv(self.sides[numerator], self.sides[denominator])\n\n  def sides_diff(self, added=1, subtracted=0):\n    return self.sides[added]-self.sides[subtracted]\n\n  def subs(self, other):\n    return self.map(lambda s: s.subs(other.sides[0], other.sides[1]))\n\nif __name__=='__main__':\n  import doctest\n  doctest.testmod()  \n```\n\nThere is an implementation in the comments here and also in #8023.\r\n\r\nI've opened #18053 which makes current `Relational` a proper `Boolean` (not a subclass of `Expr`). What remains is to introduce a new class that implements \"symbolic\" equations and supports arithmetic operations in the way that users clearly want.",
  "created_at": "2019-12-24T12:10:27Z",
  "version": "1.6",
  "FAIL_TO_PASS": "[\"test_cooperative_operations\", \"test_set_operations_nonsets\"]",
  "PASS_TO_PASS": "[\"test_basic\", \"test_ibasic\", \"test_relational\", \"test_relational_assumptions\", \"test_basic_nostr\", \"test_series_expansion_for_uniform_order\", \"test_leadterm\", \"test_as_leading_term\", \"test_leadterm2\", \"test_leadterm3\", \"test_as_leading_term2\", \"test_as_leading_term3\", \"test_as_leading_term4\", \"test_as_leading_term_stub\", \"test_as_leading_term_deriv_integral\", \"test_atoms\", \"test_is_polynomial\", \"test_is_rational_function\", \"test_is_algebraic_expr\", \"test_SAGE1\", \"test_SAGE2\", \"test_SAGE3\", \"test_len\", \"test_doit\", \"test_attribute_error\", \"test_args\", \"test_noncommutative_expand_issue_3757\", \"test_as_numer_denom\", \"test_trunc\", \"test_as_independent\", \"test_replace\", \"test_find\", \"test_count\", \"test_has_basics\", \"test_has_multiple\", \"test_has_piecewise\", \"test_has_iterative\", \"test_has_integrals\", \"test_has_tuple\", \"test_has_units\", \"test_has_polys\", \"test_has_physics\", \"test_as_poly_as_expr\", \"test_nonzero\", \"test_is_number\", \"test_as_coeff_add\", \"test_as_coeff_mul\", \"test_as_coeff_exponent\", \"test_extractions\", \"test_nan_extractions\", \"test_coeff\", \"test_coeff2\", \"test_coeff2_0\", \"test_coeff_expand\", \"test_integrate\", \"test_as_base_exp\", \"test_issue_4963\", \"test_action_verbs\", \"test_as_powers_dict\", \"test_as_coefficients_dict\", \"test_args_cnc\", \"test_new_rawargs\", \"test_issue_5226\", \"test_free_symbols\", \"test_issue_5300\", \"test_floordiv\", \"test_as_coeff_Mul\", \"test_as_coeff_Add\", \"test_expr_sorting\", \"test_as_ordered_factors\", \"test_as_ordered_terms\", \"test_sort_key_atomic_expr\", \"test_eval_interval\", \"test_eval_interval_zoo\", \"test_primitive\", \"test_issue_5843\", \"test_is_constant\", \"test_equals\", \"test_random\", \"test_round\", \"test_held_expression_UnevaluatedExpr\", \"test_round_exception_nostr\", \"test_extract_branch_factor\", \"test_identity_removal\", \"test_float_0\", \"test_issue_6325\", \"test_issue_7426\", \"test_issue_11122\", \"test_issue_10651\", \"test_issue_10161\", \"test_issue_10755\", \"test_issue_11877\", \"test_normal\", \"test_expr\", \"test_ExprBuilder\", \"test_seterr\", \"test_mod\", \"test_divmod\", \"test_igcd\", \"test_igcd_lehmer\", \"test_igcd2\", \"test_ilcm\", \"test_igcdex\", \"test_Integer_new\", \"test_Rational_new\", \"test_Number_new\", \"test_Number_cmp\", \"test_Rational_cmp\", \"test_Float\", \"test_float_mpf\", \"test_Float_RealElement\", \"test_Float_default_to_highprec_from_str\", \"test_Float_eval\", \"test_Float_issue_2107\", \"test_issue_14289\", \"test_Float_from_tuple\", \"test_Infinity\", \"test_Infinity_2\", \"test_Mul_Infinity_Zero\", \"test_Div_By_Zero\", \"test_Infinity_inequations\", \"test_NaN\", \"test_special_numbers\", \"test_powers\", \"test_integer_nthroot_overflow\", \"test_integer_log\", \"test_isqrt\", \"test_powers_Integer\", \"test_powers_Rational\", \"test_powers_Float\", \"test_abs1\", \"test_accept_int\", \"test_dont_accept_str\", \"test_int\", \"test_long\", \"test_real_bug\", \"test_bug_sqrt\", \"test_pi_Pi\", \"test_no_len\", \"test_issue_3321\", \"test_issue_3692\", \"test_issue_3423\", \"test_issue_3449\", \"test_issue_13890\", \"test_Integer_factors\", \"test_Rational_factors\", \"test_issue_4107\", \"test_IntegerInteger\", \"test_Rational_gcd_lcm_cofactors\", \"test_Float_gcd_lcm_cofactors\", \"test_issue_4611\", \"test_conversion_to_mpmath\", \"test_Integer_as_index\", \"test_Rational_int\", \"test_zoo\", \"test_issue_4122\", \"test_GoldenRatio_expand\", \"test_TribonacciConstant_expand\", \"test_as_content_primitive\", \"test_hashing_sympy_integers\", \"test_rounding_issue_4172\", \"test_Catalan_EulerGamma_prec\", \"test_Catalan_rewrite\", \"test_bool_eq\", \"test_Float_eq\", \"test_int_NumberSymbols\", \"test_issue_6640\", \"test_issue_6349\", \"test_mpf_norm\", \"test_latex\", \"test_issue_7742\", \"test_simplify_AlgebraicNumber\", \"test_Float_idempotence\", \"test_comp1\", \"test_issue_9491\", \"test_issue_10063\", \"test_issue_10020\", \"test_invert_numbers\", \"test_mod_inverse\", \"test_golden_ratio_rewrite_as_sqrt\", \"test_tribonacci_constant_rewrite_as_sqrt\", \"test_comparisons_with_unknown_type\", \"test_NumberSymbol_comparison\", \"test_Integer_precision\", \"test_Integer_ceiling_floor\", \"test_ComplexInfinity\", \"test_Infinity_floor_ceiling_power\", \"test_One_power\", \"test_NegativeInfinity\", \"test_issue_6133\", \"test_abc\", \"test_rel_ne\", \"test_rel_subs\", \"test_wrappers\", \"test_Eq\", \"test_rel_Infinity\", \"test_infinite_symbol_inequalities\", \"test_bool\", \"test_rich_cmp\", \"test_new_relational\", \"test_relational_bool_output\", \"test_relational_logic_symbols\", \"test_univariate_relational_as_set\", \"test_Not\", \"test_evaluate\", \"test_imaginary_compare_raises_TypeError\", \"test_complex_compare_not_real\", \"test_imaginary_and_inf_compare_raises_TypeError\", \"test_complex_pure_imag_not_ordered\", \"test_x_minus_y_not_same_as_x_lt_y\", \"test_nan_equality_exceptions\", \"test_nan_inequality_raise_errors\", \"test_nan_complex_inequalities\", \"test_complex_infinity_inequalities\", \"test_inequalities_symbol_name_same\", \"test_inequalities_symbol_name_same_complex\", \"test_inequalities_cant_sympify_other\", \"test_ineq_avoid_wild_symbol_flip\", \"test_issue_8245\", \"test_issue_8449\", \"test_simplify_relational\", \"test_reversed\", \"test_canonical\", \"test_issue_8444_workingtests\", \"test_issue_10304\", \"test_issue_10401\", \"test_issue_10633\", \"test_issue_10927\", \"test_issues_13081_12583_12534\", \"test_binary_symbols\", \"test_rel_args\", \"test_Equality_rewrite_as_Add\", \"test_issue_15847\", \"test_negated_property\", \"test_reversedsign_property\", \"test_reversed_reversedsign_property\", \"test_improved_canonical\", \"test_set_equality_canonical\", \"test_trigsimp\", \"test_polynomial_relation_simplification\", \"test_multivariate_linear_function_simplification\", \"test_imageset\", \"test_is_empty\", \"test_is_finiteset\", \"test_deprecated_is_EmptySet\", \"test_interval_arguments\", \"test_interval_symbolic_end_points\", \"test_interval_is_empty\", \"test_union\", \"test_union_iter\", \"test_union_is_empty\", \"test_difference\", \"test_Complement\", \"test_complement\", \"test_intersect1\", \"test_intersection\", \"test_issue_9623\", \"test_is_disjoint\", \"test_ProductSet__len__\", \"test_ProductSet\", \"test_ProductSet_of_single_arg_is_not_arg\", \"test_ProductSet_is_empty\", \"test_interval_subs\", \"test_interval_to_mpi\", \"test_measure\", \"test_is_subset\", \"test_is_proper_subset\", \"test_is_superset\", \"test_is_proper_superset\", \"test_contains\", \"test_interval_symbolic\", \"test_union_contains\", \"test_Interval_is_left_unbounded\", \"test_Interval_is_right_unbounded\", \"test_Interval_as_relational\", \"test_Finite_as_relational\", \"test_Union_as_relational\", \"test_Intersection_as_relational\", \"test_Complement_as_relational\", \"test_SymmetricDifference_as_relational\", \"test_EmptySet\", \"test_finite_basic\", \"test_product_basic\", \"test_real\", \"test_supinf\", \"test_universalset\", \"test_Union_of_ProductSets_shares\", \"test_Interval_free_symbols\", \"test_image_interval\", \"test_image_piecewise\", \"test_image_FiniteSet\", \"test_image_Union\", \"test_image_EmptySet\", \"test_issue_5724_7680\", \"test_boundary\", \"test_boundary_Union\", \"test_boundary_ProductSet\", \"test_boundary_ProductSet_line\", \"test_is_open\", \"test_is_closed\", \"test_closure\", \"test_interior\", \"test_issue_7841\", \"test_SymmetricDifference\", \"test_issue_9536\", \"test_issue_9637\", \"test_issue_9808\", \"test_issue_9956\", \"test_issue_Symbol_inter\", \"test_issue_11827\", \"test_issue_10113\", \"test_issue_10248\", \"test_issue_9447\", \"test_issue_10337\", \"test_issue_10326\", \"test_issue_2799\", \"test_issue_9706\", \"test_issue_8257\", \"test_issue_10931\", \"test_issue_11174\", \"test_finite_set_intersection\", \"test_union_intersection_constructor\", \"test_Union_contains\"]",
  "environment_setup_commit": "28b41c73c12b70d6ad9f6e45109a80649c4456da",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.120362",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}