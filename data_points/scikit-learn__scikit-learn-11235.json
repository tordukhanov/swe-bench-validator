{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-11235",
  "base_commit": "90a2c57951a9ae32e80246b171e4b47a74252090",
  "patch": "diff --git a/sklearn/preprocessing/data.py b/sklearn/preprocessing/data.py\n--- a/sklearn/preprocessing/data.py\n+++ b/sklearn/preprocessing/data.py\n@@ -652,6 +652,10 @@ def partial_fit(self, X, y=None):\n             else:\n                 self.mean_ = None\n                 self.var_ = None\n+                if not hasattr(self, 'n_samples_seen_'):\n+                    self.n_samples_seen_ = X.shape[0]\n+                else:\n+                    self.n_samples_seen_ += X.shape[0]\n         else:\n             # First pass\n             if not hasattr(self, 'n_samples_seen_'):\n@@ -662,9 +666,14 @@ def partial_fit(self, X, y=None):\n                 else:\n                     self.var_ = None\n \n-            self.mean_, self.var_, self.n_samples_seen_ = \\\n-                _incremental_mean_and_var(X, self.mean_, self.var_,\n-                                          self.n_samples_seen_)\n+            if not self.with_mean and not self.with_std:\n+                self.mean_ = None\n+                self.var_ = None\n+                self.n_samples_seen_ += X.shape[0]\n+            else:\n+                self.mean_, self.var_, self.n_samples_seen_ = \\\n+                    _incremental_mean_and_var(X, self.mean_, self.var_,\n+                                              self.n_samples_seen_)\n \n         if self.with_std:\n             self.scale_ = _handle_zeros_in_scale(np.sqrt(self.var_))\n",
  "test_patch": "diff --git a/sklearn/preprocessing/tests/test_data.py b/sklearn/preprocessing/tests/test_data.py\n--- a/sklearn/preprocessing/tests/test_data.py\n+++ b/sklearn/preprocessing/tests/test_data.py\n@@ -7,6 +7,7 @@\n \n import warnings\n import re\n+import itertools\n \n import numpy as np\n import numpy.linalg as la\n@@ -60,6 +61,7 @@\n from sklearn.preprocessing.data import power_transform\n from sklearn.exceptions import DataConversionWarning, NotFittedError\n \n+from sklearn.base import clone\n from sklearn.pipeline import Pipeline\n from sklearn.model_selection import cross_val_predict\n from sklearn.svm import SVR\n@@ -701,6 +703,63 @@ def test_scaler_without_centering():\n     assert_array_almost_equal(X_csc_scaled_back.toarray(), X)\n \n \n+def _check_identity_scalers_attributes(scaler_1, scaler_2):\n+    assert scaler_1.mean_ is scaler_2.mean_ is None\n+    assert scaler_1.var_ is scaler_2.var_ is None\n+    assert scaler_1.scale_ is scaler_2.scale_ is None\n+    assert scaler_1.n_samples_seen_ == scaler_2.n_samples_seen_\n+\n+\n+def test_scaler_return_identity():\n+    # test that the scaler return identity when with_mean and with_std are\n+    # False\n+    X_dense = np.array([[0, 1, 3],\n+                        [5, 6, 0],\n+                        [8, 0, 10]],\n+                       dtype=np.float64)\n+    X_csr = sparse.csr_matrix(X_dense)\n+    X_csc = X_csr.tocsc()\n+\n+    transformer_dense = StandardScaler(with_mean=False, with_std=False)\n+    X_trans_dense = transformer_dense.fit_transform(X_dense)\n+\n+    transformer_csr = clone(transformer_dense)\n+    X_trans_csr = transformer_csr.fit_transform(X_csr)\n+\n+    transformer_csc = clone(transformer_dense)\n+    X_trans_csc = transformer_csc.fit_transform(X_csc)\n+\n+    assert_allclose(X_trans_csr.toarray(), X_csr.toarray())\n+    assert_allclose(X_trans_csc.toarray(), X_csc.toarray())\n+    assert_allclose(X_trans_dense, X_dense)\n+\n+    for trans_1, trans_2 in itertools.combinations([transformer_dense,\n+                                                    transformer_csr,\n+                                                    transformer_csc],\n+                                                   2):\n+        _check_identity_scalers_attributes(trans_1, trans_2)\n+\n+    transformer_dense.partial_fit(X_dense)\n+    transformer_csr.partial_fit(X_csr)\n+    transformer_csc.partial_fit(X_csc)\n+\n+    for trans_1, trans_2 in itertools.combinations([transformer_dense,\n+                                                    transformer_csr,\n+                                                    transformer_csc],\n+                                                   2):\n+        _check_identity_scalers_attributes(trans_1, trans_2)\n+\n+    transformer_dense.fit(X_dense)\n+    transformer_csr.fit(X_csr)\n+    transformer_csc.fit(X_csc)\n+\n+    for trans_1, trans_2 in itertools.combinations([transformer_dense,\n+                                                    transformer_csr,\n+                                                    transformer_csc],\n+                                                   2):\n+        _check_identity_scalers_attributes(trans_1, trans_2)\n+\n+\n def test_scaler_int():\n     # test that scaler converts integer input to floating\n     # for both sparse and dense matrices\n",
  "problem_statement": "Consistency issue in StandardScaler\nThere is an issue of consistency with `StandardScaler` with `with_mean=False` and `with_std=False` between the sparse and dense case.\r\n\r\n1. Does it make sense to support this case. It will return the identity matrix which is not the use case for the `StandardScaler`. If we wish a transformer to do so, one should use the `FunctionTransformer` I assume.\r\n2. If we consider this behaviour normal, we need to:\r\n\r\n    * In the dense case, force `self.mean_` to be `None` after each iteration of `partial_fit`.\r\n    * In the sparse case, compute the non-NaNs values and update `self.n_samples_seen_` which is not computed. It leads currently to an error if calling twice `fit` (i.e. `del self.n_samples_seen_` will fail).\r\n\r\nIMO, we should make a checking at `fit` raise an error.\r\n\r\n@jnothman @ogrisel WDYT?\n",
  "hints_text": "See also #11181  where @amueller suggests deprecating with_mean\r\n\r\nI haven't understood the inconsistency here though. Please give an expected/actual\n> See also #11181 where @amueller suggests deprecating with_mean.\r\n\r\nSo 2. will be better then.\r\n\r\n> I haven't understood the inconsistency here though. Please give an expected/actual\r\n\r\nLet's suppose the following\r\n\r\n```python\r\nfrom scipy import sparse                                                   \r\nfrom sklearn.preprocessing import StandardScaler                                                                                                        \r\nX_sparse = sparse.random(1000, 10).tocsr()                                                              \r\nX_dense = X_sparse.A\r\ntransformer = StandardScaler(with_mean=False, with_std=False)   \r\n```\r\n\r\n### sparse case\r\n\r\n```python\r\ntransformer.fit(X_sparse)\r\nStandardScaler(copy=True, with_mean=False, with_std=False)\r\nprint(transformer.mean_)\r\nNone\r\n```\r\n\r\n### dense case\r\n\r\n```python\r\ntransformer.fit(X_dense)\r\nStandardScaler(copy=True, with_mean=False, with_std=False)\r\nprint(transformer.mean_)\r\n[0.00178285 0.00319143 0.00503664 0.00550827 0.00728271 0.00623176\r\n 0.00537122 0.00937145 0.00786976 0.00254072]\r\n```\r\n\r\n### issue with `n_samples_seen_` not created at fit with sparse.\r\n\r\n```python\r\ntransformer.fit(X_sparse)\r\nStandardScaler(copy=True, with_mean=False, with_std=False)\r\ntransformer.fit(X_sparse)\r\n```\r\n```\r\n---------------------------------------------------------------------------\r\nAttributeError                            Traceback (most recent call last)\r\n<ipython-input-19-66c50efa396c> in <module>()\r\n----> 1 transformer.fit(X_sparse)\r\n\r\n~/Documents/code/toolbox/scikit-learn/sklearn/preprocessing/data.py in fit(self, X, y)\r\n    610 \r\n    611         # Reset internal state before fitting\r\n--> 612         self._reset()\r\n    613         return self.partial_fit(X, y)\r\n    614 \r\n\r\n~/Documents/code/toolbox/scikit-learn/sklearn/preprocessing/data.py in _reset(self)\r\n    585         if hasattr(self, 'scale_'):\r\n    586             del self.scale_\r\n--> 587             del self.n_samples_seen_\r\n    588             del self.mean_\r\n    589             del self.var_\r\n\r\nAttributeError: n_samples_seen_\r\n```",
  "created_at": "2018-06-11T12:45:38Z",
  "version": "0.20",
  "FAIL_TO_PASS": "[\"sklearn/preprocessing/tests/test_data.py::test_scaler_return_identity\"]",
  "PASS_TO_PASS": "[\"sklearn/preprocessing/tests/test_data.py::test_polynomial_features\", \"sklearn/preprocessing/tests/test_data.py::test_polynomial_feature_names\", \"sklearn/preprocessing/tests/test_data.py::test_polynomial_features_sparse_X[1-True-False-int]\", \"sklearn/preprocessing/tests/test_data.py::test_polynomial_features_sparse_X[2-True-False-int]\", \"sklearn/preprocessing/tests/test_data.py::test_polynomial_features_sparse_X[2-True-False-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_polynomial_features_sparse_X[2-True-False-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_polynomial_features_sparse_X[3-False-False-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_polynomial_features_sparse_X[3-False-True-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_standard_scaler_1d\", \"sklearn/preprocessing/tests/test_data.py::test_scale_1d\", \"sklearn/preprocessing/tests/test_data.py::test_standard_scaler_numerical_stability\", \"sklearn/preprocessing/tests/test_data.py::test_scaler_2d_arrays\", \"sklearn/preprocessing/tests/test_data.py::test_handle_zeros_in_scale\", \"sklearn/preprocessing/tests/test_data.py::test_minmax_scaler_partial_fit\", \"sklearn/preprocessing/tests/test_data.py::test_standard_scaler_partial_fit\", \"sklearn/preprocessing/tests/test_data.py::test_standard_scaler_partial_fit_numerical_stability\", \"sklearn/preprocessing/tests/test_data.py::test_partial_fit_sparse_input\", \"sklearn/preprocessing/tests/test_data.py::test_standard_scaler_trasform_with_partial_fit\", \"sklearn/preprocessing/tests/test_data.py::test_min_max_scaler_iris\", \"sklearn/preprocessing/tests/test_data.py::test_min_max_scaler_zero_variance_features\", \"sklearn/preprocessing/tests/test_data.py::test_minmax_scale_axis1\", \"sklearn/preprocessing/tests/test_data.py::test_min_max_scaler_1d\", \"sklearn/preprocessing/tests/test_data.py::test_scaler_without_centering\", \"sklearn/preprocessing/tests/test_data.py::test_scaler_int\", \"sklearn/preprocessing/tests/test_data.py::test_scaler_without_copy\", \"sklearn/preprocessing/tests/test_data.py::test_scale_sparse_with_mean_raise_exception\", \"sklearn/preprocessing/tests/test_data.py::test_scale_input_finiteness_validation\", \"sklearn/preprocessing/tests/test_data.py::test_robust_scaler_2d_arrays\", \"sklearn/preprocessing/tests/test_data.py::test_robust_scaler_transform_one_row_csr\", \"sklearn/preprocessing/tests/test_data.py::test_robust_scaler_iris\", \"sklearn/preprocessing/tests/test_data.py::test_robust_scaler_iris_quantiles\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_iris\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_check_error\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_sparse_ignore_zeros\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_dense_toy\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_subsampling\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_sparse_toy\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_axis1\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_bounds\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_and_inverse\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_nan\", \"sklearn/preprocessing/tests/test_data.py::test_robust_scaler_invalid_range\", \"sklearn/preprocessing/tests/test_data.py::test_scale_function_without_centering\", \"sklearn/preprocessing/tests/test_data.py::test_robust_scale_axis1\", \"sklearn/preprocessing/tests/test_data.py::test_robust_scale_1d_array\", \"sklearn/preprocessing/tests/test_data.py::test_robust_scaler_zero_variance_features\", \"sklearn/preprocessing/tests/test_data.py::test_maxabs_scaler_zero_variance_features\", \"sklearn/preprocessing/tests/test_data.py::test_maxabs_scaler_large_negative_value\", \"sklearn/preprocessing/tests/test_data.py::test_maxabs_scaler_transform_one_row_csr\", \"sklearn/preprocessing/tests/test_data.py::test_warning_scaling_integers\", \"sklearn/preprocessing/tests/test_data.py::test_maxabs_scaler_1d\", \"sklearn/preprocessing/tests/test_data.py::test_maxabs_scaler_partial_fit\", \"sklearn/preprocessing/tests/test_data.py::test_normalizer_l1\", \"sklearn/preprocessing/tests/test_data.py::test_normalizer_l2\", \"sklearn/preprocessing/tests/test_data.py::test_normalizer_max\", \"sklearn/preprocessing/tests/test_data.py::test_normalize\", \"sklearn/preprocessing/tests/test_data.py::test_binarizer\", \"sklearn/preprocessing/tests/test_data.py::test_center_kernel\", \"sklearn/preprocessing/tests/test_data.py::test_cv_pipeline_precomputed\", \"sklearn/preprocessing/tests/test_data.py::test_fit_transform\", \"sklearn/preprocessing/tests/test_data.py::test_add_dummy_feature\", \"sklearn/preprocessing/tests/test_data.py::test_add_dummy_feature_coo\", \"sklearn/preprocessing/tests/test_data.py::test_add_dummy_feature_csc\", \"sklearn/preprocessing/tests/test_data.py::test_add_dummy_feature_csr\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_sparse\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_dense\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected[int32-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected[int32-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected[int32-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected[float32-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected[float32-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected[float32-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected[float64-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected[float64-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected[float64-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[int32-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[int32-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[int32-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[float32-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[float32-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[float32-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[float64-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[float64-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_transform_selected_copy_arg[float64-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_categorical_features\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-int32-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-int32-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-int32-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-float32-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-float32-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-float32-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-float64-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-float64-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[True-float64-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-int32-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-int32-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-int32-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-float32-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-float32-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-float32-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-float64-int32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-float64-float32]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_preserve_type[False-float64-float64]\", \"sklearn/preprocessing/tests/test_data.py::test_one_hot_encoder_unknown_transform\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_onehot\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_onehot_inverse\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_handle_unknown\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_categories\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_specified_categories\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_pandas\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_ordinal\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_ordinal_inverse\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_dtypes\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_dtypes_pandas\", \"sklearn/preprocessing/tests/test_data.py::test_categorical_encoder_warning\", \"sklearn/preprocessing/tests/test_data.py::test_fit_cold_start\", \"sklearn/preprocessing/tests/test_data.py::test_quantile_transform_valid_axis\", \"sklearn/preprocessing/tests/test_data.py::test_power_transformer_notfitted\", \"sklearn/preprocessing/tests/test_data.py::test_power_transformer_1d\", \"sklearn/preprocessing/tests/test_data.py::test_power_transformer_2d\", \"sklearn/preprocessing/tests/test_data.py::test_power_transformer_strictly_positive_exception\", \"sklearn/preprocessing/tests/test_data.py::test_power_transformer_shape_exception\", \"sklearn/preprocessing/tests/test_data.py::test_power_transformer_method_exception\", \"sklearn/preprocessing/tests/test_data.py::test_power_transformer_lambda_zero\"]",
  "environment_setup_commit": "55bf5d93e5674f13a1134d93a11fd0cd11aabcd1",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.959673",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}