{
  "repo": "sphinx-doc/sphinx",
  "instance_id": "sphinx-doc__sphinx-8684",
  "base_commit": "6101077aab43529128496915c1c30ba3b1ce373c",
  "patch": "diff --git a/sphinx/directives/code.py b/sphinx/directives/code.py\n--- a/sphinx/directives/code.py\n+++ b/sphinx/directives/code.py\n@@ -7,6 +7,7 @@\n \"\"\"\n \n import sys\n+import textwrap\n import warnings\n from difflib import unified_diff\n from typing import Any, Dict, List, Tuple\n@@ -19,6 +20,7 @@\n from sphinx import addnodes\n from sphinx.config import Config\n from sphinx.deprecation import RemovedInSphinx40Warning\n+from sphinx.directives import optional_int\n from sphinx.locale import __\n from sphinx.util import logging, parselinenos\n from sphinx.util.docutils import SphinxDirective\n@@ -68,7 +70,7 @@ def run(self) -> List[Node]:\n \n def dedent_lines(lines: List[str], dedent: int, location: Tuple[str, int] = None) -> List[str]:\n     if not dedent:\n-        return lines\n+        return textwrap.dedent(''.join(lines)).splitlines(True)\n \n     if any(s[:dedent].strip() for s in lines):\n         logger.warning(__('non-whitespace stripped by dedent'), location=location)\n@@ -117,7 +119,7 @@ class CodeBlock(SphinxDirective):\n     option_spec = {\n         'force': directives.flag,\n         'linenos': directives.flag,\n-        'dedent': int,\n+        'dedent': optional_int,\n         'lineno-start': int,\n         'emphasize-lines': directives.unchanged_required,\n         'caption': directives.unchanged_required,\n@@ -391,7 +393,7 @@ class LiteralInclude(SphinxDirective):\n     optional_arguments = 0\n     final_argument_whitespace = True\n     option_spec = {\n-        'dedent': int,\n+        'dedent': optional_int,\n         'linenos': directives.flag,\n         'lineno-start': int,\n         'lineno-match': directives.flag,\n",
  "test_patch": "diff --git a/tests/test_directive_code.py b/tests/test_directive_code.py\n--- a/tests/test_directive_code.py\n+++ b/tests/test_directive_code.py\n@@ -250,6 +250,14 @@ def test_LiteralIncludeReader_dedent(literal_inc_path):\n                        \"  pass\\n\"\n                        \"\\n\")\n \n+    # dedent: None\n+    options = {'lines': '9-11', 'dedent': None}\n+    reader = LiteralIncludeReader(literal_inc_path, options, DUMMY_CONFIG)\n+    content, lines = reader.read()\n+    assert content == (\"def baz():\\n\"\n+                       \"    pass\\n\"\n+                       \"\\n\")\n+\n \n @pytest.mark.xfail(os.name != 'posix', reason=\"Not working on windows\")\n def test_LiteralIncludeReader_tabwidth(testroot):\n",
  "problem_statement": "ROI: extend dedent for code-block and literalinclude\nHi,\nI think it would be nice to let `:dedent:` behave like the corresponding Python one:\n\nhttps://docs.python.org/2/library/textwrap.html#textwrap.dedent\n\nIt may just that if nod edent value is provided, then a full dedent is performed.\n\n",
  "hints_text": "Hi,\nassuming to pass the _unsplitted_ code, I guess we could think to modify \n\n```\ndef dedent_lines(lines, dedent):\n    if not dedent:\n        return lines\n\n    new_lines = []\n    for line in lines:\n        new_line = line[dedent:]\n        if line.endswith('\\n') and not new_line:\n            new_line = '\\n'  # keep CRLF\n        new_lines.append(new_line)\n\n    return new_lines\n```\n\nwith \n\n```\nimport textwrap\n\ndef dedent_lines(lines, dedent):\n    if dedent==0 or not dedent:\n        return lines\n\n   if dedent == -1:\n    return textwrap.dedent(lines)\n\n\n    new_lines = []\n    for line in lines:\n        new_line = line[dedent:]\n        if line.endswith('\\n') and not new_line:\n            new_line = '\\n'  # keep CRLF\n        new_lines.append(new_line)\n\n    return '\\n'.join(new_lines)\n```\n\nIn this way\n- using `:dedent:` equals to `-1` we obtain a maximal dedent\n- we do nothing if `:dedent:` is 0 or not passed, saving time\n- we dedent using standard Python without the need to know how many spaces must be remove.\n\nThe original intent of `:dedent:` was, as you describe, to remove all common leading whitespace as seen in #939 where @shimizukawa talks about it as a boolean option. For some reason, the code subsequently merged by @zsiddiqui2 (commit a425949c360a0f6c0f910ada0bc8baec3452a154) added it as an integer and it has been kept this way ever since.\r\n\r\nI reckon that it is very error-prone to specify an integer which, as it is implemented now, eats characters from the left independently of whether they are whitespace characters or not. I have two solutions which are more sain in my opinion:\r\n1. Keep `:dedent:` as an integer, but interpret it as a maximum dedentation level. It will then remove leading characters up untill the first non-whitespace character or the specified maximum is reached. Non-negative values will behave as now with added robustness.  Default is zero (no dedentation). Negative values means no maximum (giving the requested behavior).\r\n2. Reimplement `:dedent:` as a flag and use the standard `textwrap.dedent()` function as a replacement for the custom made `dedent_lines()` function. This will add support for tabs as well, but breaks backwards compatibility. If backwards compatibility is a must, we could still make a `:dedent-auto:` alternative with this functionality.\r\n\r\nI have no problem making a pull request for this issue if someone will take up the discussion and tell me the preferred solutions.\nIf it were for my personal taste I will agree with point 2 and make `dedent`  behave as the corresponding Python function\r\n\r\nhttps://docs.python.org/3.1/library/textwrap.html#textwrap.dedent\r\n\r\n\nI am in need of this functionality as it is impractical to have o find the indent of the specific code block. If any indent changes are made to the code, this will break the docs or make it look bad. using :dedent-auto: seems like a decent solution imo, but it can't dedent all lines using the textwrap.dedent(). When I tried that, this was the result:\r\nbefore:\r\n```\r\n    def func():\r\n        some_code\r\n```\r\nwill look like this:\r\n```\r\ndef func():\r\nsome_code\r\n```\r\nwhen it should be this: \r\n```\r\ndef func():\r\n    some_code\r\n```\nIt would be better to change the argument of `:dedent:` optional. And it behaves like `textwrap.dedent()` when no argument passed. Of course, it behaves as is when we passed an integer as an argument.\nI did find a work-around for this for my project, but I still think this is a nice to have enhancement.",
  "created_at": "2021-01-12T14:52:00Z",
  "version": "3.5",
  "FAIL_TO_PASS": "[\"tests/test_directive_code.py::test_LiteralIncludeReader_dedent\"]",
  "PASS_TO_PASS": "[\"tests/test_directive_code.py::test_LiteralIncludeReader\", \"tests/test_directive_code.py::test_LiteralIncludeReader_lineno_start\", \"tests/test_directive_code.py::test_LiteralIncludeReader_pyobject1\", \"tests/test_directive_code.py::test_LiteralIncludeReader_pyobject2\", \"tests/test_directive_code.py::test_LiteralIncludeReader_pyobject3\", \"tests/test_directive_code.py::test_LiteralIncludeReader_pyobject_and_lines\", \"tests/test_directive_code.py::test_LiteralIncludeReader_lines1\", \"tests/test_directive_code.py::test_LiteralIncludeReader_lines2\", \"tests/test_directive_code.py::test_LiteralIncludeReader_lines_and_lineno_match1\", \"tests/test_directive_code.py::test_LiteralIncludeReader_lines_and_lineno_match2\", \"tests/test_directive_code.py::test_LiteralIncludeReader_lines_and_lineno_match3\", \"tests/test_directive_code.py::test_LiteralIncludeReader_start_at\", \"tests/test_directive_code.py::test_LiteralIncludeReader_start_after\", \"tests/test_directive_code.py::test_LiteralIncludeReader_start_after_and_lines\", \"tests/test_directive_code.py::test_LiteralIncludeReader_start_at_and_lines\", \"tests/test_directive_code.py::test_LiteralIncludeReader_missing_start_and_end\", \"tests/test_directive_code.py::test_LiteralIncludeReader_end_before\", \"tests/test_directive_code.py::test_LiteralIncludeReader_prepend\", \"tests/test_directive_code.py::test_LiteralIncludeReader_tabwidth\", \"tests/test_directive_code.py::test_LiteralIncludeReader_tabwidth_dedent\", \"tests/test_directive_code.py::test_LiteralIncludeReader_diff\", \"tests/test_directive_code.py::test_code_block\", \"tests/test_directive_code.py::test_force_option\", \"tests/test_directive_code.py::test_code_block_namedlink_latex\", \"tests/test_directive_code.py::test_code_block_emphasize_latex\", \"tests/test_directive_code.py::test_literal_include\", \"tests/test_directive_code.py::test_literal_include_block_start_with_comment_or_brank\", \"tests/test_directive_code.py::test_literalinclude_file_whole_of_emptyline\", \"tests/test_directive_code.py::test_literalinclude_namedlink_latex\", \"tests/test_directive_code.py::test_literalinclude_classes\", \"tests/test_directive_code.py::test_literalinclude_pydecorators\", \"tests/test_directive_code.py::test_code_block_highlighted\"]",
  "environment_setup_commit": "4f8cb861e3b29186b38248fe81e4944fd987fcce",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.059999",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}