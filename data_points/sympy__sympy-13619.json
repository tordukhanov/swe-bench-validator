{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-13619",
  "base_commit": "7f83b89a2e644a8762c5bb02dcd5937f2a7ebe6e",
  "patch": "diff --git a/sympy/calculus/util.py b/sympy/calculus/util.py\n--- a/sympy/calculus/util.py\n+++ b/sympy/calculus/util.py\n@@ -1225,15 +1225,16 @@ def __contains__(self, other):\n \n         \"\"\"\n         other = _sympify(other)\n-        if not (other.is_Symbol or other.is_number):\n-            raise TypeError(\"Input of type real symbol or Number expected\")\n \n         if other is S.Infinity or other is S.NegativeInfinity:\n             if self.min is S.NegativeInfinity or self.max is S.Infinity:\n                 return True\n             return False\n \n-        return And(self.min <= other and self.max >= other)\n+        rv = And(self.min <= other, self.max >= other)\n+        if rv not in (True, False):\n+            raise TypeError(\"input failed to evaluate\")\n+        return rv\n \n     def intersection(self, other):\n         \"\"\"\ndiff --git a/sympy/core/basic.py b/sympy/core/basic.py\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -600,12 +600,13 @@ def is_comparable(self):\n         is_real = self.is_real\n         if is_real is False:\n             return False\n-        is_number = self.is_number\n-        if is_number is False:\n+        if not self.is_number:\n             return False\n+        # don't re-eval numbers that are already evaluated since\n+        # this will create spurious precision\n         n, i = [p.evalf(2) if not p.is_Number else p\n             for p in self.as_real_imag()]\n-        if not i.is_Number or not n.is_Number:\n+        if not (i.is_Number and n.is_Number):\n             return False\n         if i:\n             # if _prec = 1 we can't decide and if not,\ndiff --git a/sympy/core/expr.py b/sympy/core/expr.py\n--- a/sympy/core/expr.py\n+++ b/sympy/core/expr.py\n@@ -359,27 +359,53 @@ def _from_mpmath(x, prec):\n \n     @property\n     def is_number(self):\n-        \"\"\"Returns True if ``self`` has no free symbols.\n-        It will be faster than ``if not self.free_symbols``, however, since\n-        ``is_number`` will fail as soon as it hits a free symbol.\n+        \"\"\"Returns True if ``self`` has no free symbols and no\n+        undefined functions (AppliedUndef, to be precise). It will be\n+        faster than ``if not self.free_symbols``, however, since\n+        ``is_number`` will fail as soon as it hits a free symbol\n+        or undefined function.\n \n         Examples\n         ========\n \n-        >>> from sympy import log, Integral\n+        >>> from sympy import log, Integral, cos, sin, pi\n+        >>> from sympy.core.function import Function\n         >>> from sympy.abc import x\n+        >>> f = Function('f')\n \n         >>> x.is_number\n         False\n+        >>> f(1).is_number\n+        False\n         >>> (2*x).is_number\n         False\n-        >>> (2 + log(2)).is_number\n-        True\n         >>> (2 + Integral(2, x)).is_number\n         False\n         >>> (2 + Integral(2, (x, 1, 2))).is_number\n         True\n \n+        Not all numbers are Numbers in the SymPy sense:\n+\n+        >>> pi.is_number, pi.is_Number\n+        (True, False)\n+\n+        If something is a number it should evaluate to a number with\n+        real and imaginary parts that are Numbers; the result may not\n+        be comparable, however, since the real and/or imaginary part\n+        of the result may not have precision.\n+\n+        >>> cos(1).is_number and cos(1).is_comparable\n+        True\n+\n+        >>> z = cos(1)**2 + sin(1)**2 - 1\n+        >>> z.is_number\n+        True\n+        >>> z.is_comparable\n+        False\n+\n+        See Also\n+        ========\n+        sympy.core.basic.is_comparable\n         \"\"\"\n         return all(obj.is_number for obj in self.args)\n \n@@ -531,20 +557,11 @@ def is_constant(self, *wrt, **flags):\n \n         simplify = flags.get('simplify', True)\n \n-        # Except for expressions that contain units, only one of these should\n-        # be necessary since if something is\n-        # known to be a number it should also know that there are no\n-        # free symbols. But is_number quits as soon as it hits a non-number\n-        # whereas free_symbols goes until all free symbols have been collected,\n-        # thus is_number should be faster. But a double check on free symbols\n-        # is made just in case there is a discrepancy between the two.\n-        free = self.free_symbols\n-        if self.is_number or not free:\n-            # if the following assertion fails then that object's free_symbols\n-            # method needs attention: if an expression is a number it cannot\n-            # have free symbols\n-            assert not free\n+        if self.is_number:\n             return True\n+        free = self.free_symbols\n+        if not free:\n+            return True  # assume f(1) is some constant\n \n         # if we are only interested in some symbols and they are not in the\n         # free symbols then this expression is constant wrt those symbols\n@@ -3411,12 +3428,10 @@ def doit(self, *args, **kwargs):\n \n \n def _n2(a, b):\n-    \"\"\"Return (a - b).evalf(2) if it, a and b are comparable, else None.\n+    \"\"\"Return (a - b).evalf(2) if a and b are comparable, else None.\n     This should only be used when a and b are already sympified.\n     \"\"\"\n-    if not all(i.is_number for i in (a, b)):\n-        return\n-    # /!\\ if is very important (see issue 8245) not to\n+    # /!\\ it is very important (see issue 8245) not to\n     # use a re-evaluated number in the calculation of dif\n     if a.is_comparable and b.is_comparable:\n         dif = (a - b).evalf(2)\ndiff --git a/sympy/core/function.py b/sympy/core/function.py\n--- a/sympy/core/function.py\n+++ b/sympy/core/function.py\n@@ -778,6 +778,8 @@ class AppliedUndef(Function):\n     function.\n     \"\"\"\n \n+    is_number = False\n+\n     def __new__(cls, *args, **options):\n         args = list(map(sympify, args))\n         obj = super(AppliedUndef, cls).__new__(cls, *args, **options)\ndiff --git a/sympy/functions/elementary/miscellaneous.py b/sympy/functions/elementary/miscellaneous.py\n--- a/sympy/functions/elementary/miscellaneous.py\n+++ b/sympy/functions/elementary/miscellaneous.py\n@@ -5,7 +5,7 @@\n from sympy.core.containers import Tuple\n from sympy.core.operations import LatticeOp, ShortCircuit\n from sympy.core.function import (Application, Lambda,\n-    ArgumentIndexError, AppliedUndef)\n+    ArgumentIndexError)\n from sympy.core.expr import Expr\n from sympy.core.mul import Mul\n from sympy.core.numbers import Rational\n@@ -516,7 +516,6 @@ def _new_args_filter(cls, arg_sequence):\n             # pre-filter, checking comparability of arguments\n             if not isinstance(arg, Expr) or arg.is_real is False or (\n                     arg.is_number and\n-                    not arg.has(AppliedUndef) and\n                     not arg.is_comparable):\n                 raise ValueError(\"The argument '%s' is not comparable.\" % arg)\n \n",
  "test_patch": "diff --git a/sympy/calculus/tests/test_util.py b/sympy/calculus/tests/test_util.py\n--- a/sympy/calculus/tests/test_util.py\n+++ b/sympy/calculus/tests/test_util.py\n@@ -354,5 +354,8 @@ def test_comparison_AccumBounds():\n def test_contains_AccumBounds():\n     assert (1 in AccumBounds(1, 2)) == S.true\n     raises(TypeError, lambda: a in AccumBounds(1, 2))\n+    assert 0 in AccumBounds(-1, 0)\n+    raises(TypeError, lambda:\n+        (cos(1)**2 + sin(1)**2 - 1) in AccumBounds(-1, 0))\n     assert (-oo in AccumBounds(1, oo)) == S.true\n     assert (oo in AccumBounds(-oo, 0)) == S.true\ndiff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -245,11 +245,10 @@ def test_literal_evalf_is_number_is_zero_is_comparable():\n     x = symbols('x')\n     f = Function('f')\n \n-    # the following should not be changed without a lot of dicussion\n-    # `foo.is_number` should be equivalent to `not foo.free_symbols`\n-    # it should not attempt anything fancy; see is_zero, is_constant\n-    # and equals for more rigorous tests.\n-    assert f(1).is_number is True\n+    # issue 5033\n+    assert f.is_number is False\n+    # issue 6646\n+    assert f(1).is_number is False\n     i = Integral(0, (x, x, x))\n     # expressions that are symbolically 0 can be difficult to prove\n     # so in case there is some easy way to know if something is 0\ndiff --git a/sympy/core/tests/test_expr.py b/sympy/core/tests/test_expr.py\n--- a/sympy/core/tests/test_expr.py\n+++ b/sympy/core/tests/test_expr.py\n@@ -1522,6 +1522,7 @@ def test_is_constant():\n     assert checksol(x, x, Sum(x, (x, 1, n))) is False\n     assert checksol(x, x, Sum(x, (x, 1, n))) is False\n     f = Function('f')\n+    assert f(1).is_constant\n     assert checksol(x, x, f(x)) is False\n \n     p = symbols('p', positive=True)\n",
  "problem_statement": "Undefined functions with number arguments should have is_number be False\n```\n>>> Function('f')(1).is_number\nTrue\n\nPerhaps it would be better to have this be False since it can't be evaluated to a number with evalf. Alternatively, such quantitites should be disallowed in solve (solve(f(1) - 2, f(1)) gives [2]) and Indexed variables used instead.\n```\n\nOriginal issue for #6646: http://code.google.com/p/sympy/issues/detail?id=3547\nOriginal author: https://code.google.com/u/117933771799683895267/\n\n",
  "hints_text": "```\nBut our assumptions on Function mean it is a number, even if we don't know what that number is. \n\nRegarding solve, I don't see how it's related, nor why we should arbitrarily disallow that.\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=3547#c1\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n```\nIf we don't know what it is, then we can't evalf() it or compare it to a real real number, which means that is_number should be False. We could easily make the change in AppliedUndef, I think.\n```\n\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=3547#c2\nOriginal author: https://code.google.com/u/101272611947379421629/\n\n```\nI guess it's fine if defining is_number that way makes it more useful. This again goes back to issue 6015 .\n```\n\nReferenced issues: #6015\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=3547#c3\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n```\nMake that issue 5295 .\n\n**Labels:** Assumptions  \n\n```\n\nReferenced issues: #5295\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=3547#c4\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n\n```\n**Blockedon:** 5295  \n\n```\n\nReferenced issues: #5295\nOriginal comment: http://code.google.com/p/sympy/issues/detail?id=3547#c5\nOriginal author: https://code.google.com/u/asmeurer@gmail.com/\n",
  "created_at": "2017-11-17T20:18:34Z",
  "version": "1.1",
  "FAIL_TO_PASS": "[\"test_literal_evalf_is_number_is_zero_is_comparable\"]",
  "PASS_TO_PASS": "[\"test_continuous_domain\", \"test_not_empty_in\", \"test_periodicity_check\", \"test_lcim\", \"test_AccumBounds\", \"test_AccumBounds_mul\", \"test_AccumBounds_div\", \"test_AccumBounds_func\", \"test_AccumBounds_pow\", \"test_comparison_AccumBounds\", \"test_structure\", \"test_equality\", \"test_matches_basic\", \"test_has\", \"test_subs\", \"test_atoms\", \"test_free_symbols_empty\", \"test_doit\", \"test_S\", \"test_xreplace\", \"test_Singleton\", \"test_preorder_traversal\", \"test_sorted_args\", \"test_call\", \"test_rewrite\", \"test_basic\", \"test_ibasic\", \"test_relational\", \"test_relational_assumptions\", \"test_relational_noncommutative\", \"test_basic_nostr\", \"test_series_expansion_for_uniform_order\", \"test_leadterm\", \"test_as_leading_term\", \"test_leadterm2\", \"test_leadterm3\", \"test_as_leading_term2\", \"test_as_leading_term3\", \"test_as_leading_term4\", \"test_as_leading_term_stub\", \"test_as_leading_term_deriv_integral\", \"test_is_polynomial\", \"test_is_rational_function\", \"test_is_algebraic_expr\", \"test_SAGE1\", \"test_SAGE2\", \"test_SAGE3\", \"test_len\", \"test_attribute_error\", \"test_args\", \"test_noncommutative_expand_issue_3757\", \"test_as_numer_denom\", \"test_as_independent\", \"test_replace\", \"test_find\", \"test_count\", \"test_has_basics\", \"test_has_multiple\", \"test_has_piecewise\", \"test_has_iterative\", \"test_has_integrals\", \"test_has_tuple\", \"test_has_units\", \"test_has_polys\", \"test_has_physics\", \"test_as_poly_as_expr\", \"test_nonzero\", \"test_is_number\", \"test_as_coeff_add\", \"test_as_coeff_mul\", \"test_as_coeff_exponent\", \"test_extractions\", \"test_nan_extractions\", \"test_coeff\", \"test_coeff2\", \"test_coeff2_0\", \"test_coeff_expand\", \"test_integrate\", \"test_as_base_exp\", \"test_issue_4963\", \"test_as_powers_dict\", \"test_as_coefficients_dict\", \"test_args_cnc\", \"test_new_rawargs\", \"test_issue_5226\", \"test_free_symbols\", \"test_issue_5300\", \"test_floordiv\", \"test_as_coeff_Mul\", \"test_as_coeff_Add\", \"test_expr_sorting\", \"test_as_ordered_factors\", \"test_as_ordered_terms\", \"test_sort_key_atomic_expr\", \"test_eval_interval\", \"test_primitive\", \"test_issue_5843\", \"test_is_constant\", \"test_equals\", \"test_random\", \"test_round\", \"test_held_expression_UnevaluatedExpr\", \"test_round_exception_nostr\", \"test_extract_branch_factor\", \"test_identity_removal\", \"test_float_0\", \"test_issue_6325\", \"test_issue_7426\", \"test_issue_1112\", \"test_issue_10161\", \"test_issue_10755\", \"test_issue_11877\"]",
  "environment_setup_commit": "ec9e3c0436fbff934fa84e22bf07f1b3ef5bfac3",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.085351",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}