{
  "repo": "sphinx-doc/sphinx",
  "instance_id": "sphinx-doc__sphinx-8125",
  "base_commit": "a163bbe870dc5bc7f3863ead37cd391be81fb0cc",
  "patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -258,6 +258,32 @@ def __getattr__(self, name: str) -> Any:\n             return None\n \n \n+class ObjectMember(tuple):\n+    \"\"\"A member of object.\n+\n+    This is used for the result of `Documenter.get_object_members()` to\n+    represent each member of the object.\n+\n+    .. Note::\n+\n+       An instance of this class behaves as a tuple of (name, object)\n+       for compatibility to old Sphinx.  The behavior will be dropped\n+       in the future.  Therefore extensions should not use the tuple\n+       interface.\n+    \"\"\"\n+\n+    def __new__(cls, name: str, obj: Any, **kwargs: Any) -> Any:\n+        return super().__new__(cls, (name, obj))  # type: ignore\n+\n+    def __init__(self, name: str, obj: Any, skipped: bool = False) -> None:\n+        self.__name__ = name\n+        self.object = obj\n+        self.skipped = skipped\n+\n+\n+ObjectMembers = Union[List[ObjectMember], List[Tuple[str, Any]]]\n+\n+\n class Documenter:\n     \"\"\"\n     A Documenter knows how to autodocument a single object type.  When\n@@ -589,7 +615,7 @@ def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n             for line, src in zip(more_content.data, more_content.items):\n                 self.add_line(line, src[0], src[1])\n \n-    def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:\n+    def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n         \"\"\"Return `(members_check_module, members)` where `members` is a\n         list of `(membername, member)` pairs of the members of *self.object*.\n \n@@ -599,10 +625,10 @@ def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]\n         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)\n         if not want_all:\n             if not self.options.members:\n-                return False, []\n+                return False, []  # type: ignore\n             # specific members given\n             selected = []\n-            for name in self.options.members:\n+            for name in self.options.members:  # type: str\n                 if name in members:\n                     selected.append((name, members[name].value))\n                 else:\n@@ -615,7 +641,7 @@ def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]\n             return False, [(m.name, m.value) for m in members.values()\n                            if m.directly_defined]\n \n-    def filter_members(self, members: List[Tuple[str, Any]], want_all: bool\n+    def filter_members(self, members: ObjectMembers, want_all: bool\n                        ) -> List[Tuple[str, Any, bool]]:\n         \"\"\"Filter the given member list.\n \n@@ -654,7 +680,8 @@ def is_filtered_inherited_member(name: str) -> bool:\n             attr_docs = {}\n \n         # process members and determine which to skip\n-        for (membername, member) in members:\n+        for obj in members:\n+            membername, member = obj\n             # if isattr is True, the member is documented as an attribute\n             if member is INSTANCEATTR:\n                 isattr = True\n@@ -731,6 +758,10 @@ def is_filtered_inherited_member(name: str) -> bool:\n                     # ignore undocumented members if :undoc-members: is not given\n                     keep = has_doc or self.options.undoc_members\n \n+            if isinstance(obj, ObjectMember) and obj.skipped:\n+                # forcedly skipped member (ex. a module attribute not defined in __all__)\n+                keep = False\n+\n             # give the user a chance to decide whether this member\n             # should be skipped\n             if self.env.app:\n@@ -992,28 +1023,35 @@ def add_directive_header(self, sig: str) -> None:\n         if self.options.deprecated:\n             self.add_line('   :deprecated:', sourcename)\n \n-    def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:\n+    def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n         if want_all:\n-            if self.__all__:\n-                memberlist = self.__all__\n-            else:\n+            members = get_module_members(self.object)\n+            if not self.__all__:\n                 # for implicit module members, check __module__ to avoid\n                 # documenting imported objects\n-                return True, get_module_members(self.object)\n+                return True, members\n+            else:\n+                ret = []\n+                for name, value in members:\n+                    if name in self.__all__:\n+                        ret.append(ObjectMember(name, value))\n+                    else:\n+                        ret.append(ObjectMember(name, value, skipped=True))\n+\n+                return False, ret\n         else:\n             memberlist = self.options.members or []\n-        ret = []\n-        for mname in memberlist:\n-            try:\n-                ret.append((mname, safe_getattr(self.object, mname)))\n-            except AttributeError:\n-                logger.warning(\n-                    __('missing attribute mentioned in :members: or __all__: '\n-                       'module %s, attribute %s') %\n-                    (safe_getattr(self.object, '__name__', '???'), mname),\n-                    type='autodoc'\n-                )\n-        return False, ret\n+            ret = []\n+            for name in memberlist:\n+                try:\n+                    value = safe_getattr(self.object, name)\n+                    ret.append(ObjectMember(name, value))\n+                except AttributeError:\n+                    logger.warning(__('missing attribute mentioned in :members: option: '\n+                                      'module %s, attribute %s') %\n+                                   (safe_getattr(self.object, '__name__', '???'), name),\n+                                   type='autodoc')\n+            return False, ret\n \n     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n",
  "test_patch": "diff --git a/tests/test_ext_autodoc_events.py b/tests/test_ext_autodoc_events.py\n--- a/tests/test_ext_autodoc_events.py\n+++ b/tests/test_ext_autodoc_events.py\n@@ -80,3 +80,28 @@ def test_between_exclude(app):\n         '   third line',\n         '',\n     ]\n+\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_skip_module_member(app):\n+    def autodoc_skip_member(app, what, name, obj, skip, options):\n+        if name == \"Class\":\n+            return True  # Skip \"Class\" class in __all__\n+        elif name == \"raises\":\n+            return False  # Show \"raises()\" function (not in __all__)\n+\n+    app.connect('autodoc-skip-member', autodoc_skip_member)\n+\n+    options = {\"members\": None}\n+    actual = do_autodoc(app, 'module', 'target', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: target',\n+        '',\n+        '',\n+        '.. py:function:: raises(exc, func, *args, **kwds)',\n+        '   :module: target',\n+        '',\n+        '   Raise AssertionError if ``func(*args, **kwds)`` does not raise *exc*.',\n+        '',\n+    ]\n",
  "problem_statement": "All identifiers should be passed to autodoc-skip-member, even if not in __all__\n**Is your feature request related to a problem? Please describe.**\r\nI have a Python project for which I've generated docs. It did well. Almost everything was doc'ed. I knew about the default of excluding anything starting with '_' so I created an autodoc-skip-member function that would include those. It works. I see a bunch of private methods and functions included.\r\n\r\nBut...I have a module, let's call it XYZ that has both private and public functions. Sphinx is only doc'ing the public functions of XYZ, but not its private functions. I have other modules that have private functions, and it's doc'ing those .I added a print() to the autodoc-skip-member function and it doesn't even print out the `name` of those private functions so it seems it's not even seeing it.\r\n\r\nI figured it out. The module had certain identifiers listed in `__all__`, and was not passing anything else in that module to autodoc-skip-member.\r\n\r\n**Describe the solution you'd like**\r\nSphinx should pass through *all* members, not just the ones in `__all__`. Maybe add something to the `options` object that is passed to autodoc-skip-members that indicates it would have been excluded by the `__all__` designator, or some such.\r\n\r\n**Describe alternatives you've considered**\r\nI simply removed the `__all__` from the file.\r\n\n",
  "hints_text": "",
  "created_at": "2020-08-14T15:50:26Z",
  "version": "3.4",
  "FAIL_TO_PASS": "[\"tests/test_ext_autodoc_events.py::test_skip_module_member\"]",
  "PASS_TO_PASS": "[\"tests/test_ext_autodoc_events.py::test_process_docstring\", \"tests/test_ext_autodoc_events.py::test_cut_lines\", \"tests/test_ext_autodoc_events.py::test_between\", \"tests/test_ext_autodoc_events.py::test_between_exclude\"]",
  "environment_setup_commit": "3f560cd67239f75840cc7a439ab54d8509c855f6",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.052086",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}