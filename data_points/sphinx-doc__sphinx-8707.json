{
  "repo": "sphinx-doc/sphinx",
  "instance_id": "sphinx-doc__sphinx-8707",
  "base_commit": "d5d072bc3a561b0d462aa27b9f85662da1a5bd93",
  "patch": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -10,6 +10,7 @@\n \n import posixpath\n import traceback\n+import warnings\n from os import path\n from typing import Any, Dict, Generator, Iterable, Optional, Set, Tuple, cast\n \n@@ -19,10 +20,13 @@\n import sphinx\n from sphinx import addnodes\n from sphinx.application import Sphinx\n+from sphinx.builders import Builder\n from sphinx.builders.html import StandaloneHTMLBuilder\n+from sphinx.deprecation import RemovedInSphinx50Warning\n from sphinx.environment import BuildEnvironment\n from sphinx.locale import _, __\n from sphinx.pycode import ModuleAnalyzer\n+from sphinx.transforms.post_transforms import SphinxPostTransform\n from sphinx.util import get_full_modname, logging, status_iterator\n from sphinx.util.nodes import make_refnode\n \n@@ -32,6 +36,15 @@\n OUTPUT_DIRNAME = '_modules'\n \n \n+class viewcode_anchor(Element):\n+    \"\"\"Node for viewcode anchors.\n+\n+    This node will be processed in the resolving phase.\n+    For viewcode supported builders, they will be all converted to the anchors.\n+    For not supported builders, they will be removed.\n+    \"\"\"\n+\n+\n def _get_full_modname(app: Sphinx, modname: str, attribute: str) -> Optional[str]:\n     try:\n         return get_full_modname(modname, attribute)\n@@ -50,14 +63,21 @@ def _get_full_modname(app: Sphinx, modname: str, attribute: str) -> Optional[str\n         return None\n \n \n+def is_supported_builder(builder: Builder) -> bool:\n+    if builder.format != 'html':\n+        return False\n+    elif builder.name == 'singlehtml':\n+        return False\n+    elif builder.name.startswith('epub') and not builder.config.viewcode_enable_epub:\n+        return False\n+    else:\n+        return True\n+\n+\n def doctree_read(app: Sphinx, doctree: Node) -> None:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         env._viewcode_modules = {}  # type: ignore\n-    if app.builder.name == \"singlehtml\":\n-        return\n-    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n-        return\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -115,12 +135,7 @@ def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n                 continue\n             names.add(fullname)\n             pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n-            inline = nodes.inline('', _('[source]'), classes=['viewcode-link'])\n-            onlynode = addnodes.only(expr='html')\n-            onlynode += addnodes.pending_xref('', inline, reftype='viewcode', refdomain='std',\n-                                              refexplicit=False, reftarget=pagename,\n-                                              refid=fullname, refdoc=env.docname)\n-            signode += onlynode\n+            signode += viewcode_anchor(reftarget=pagename, refid=fullname, refdoc=env.docname)\n \n \n def env_merge_info(app: Sphinx, env: BuildEnvironment, docnames: Iterable[str],\n@@ -134,10 +149,34 @@ def env_merge_info(app: Sphinx, env: BuildEnvironment, docnames: Iterable[str],\n     env._viewcode_modules.update(other._viewcode_modules)  # type: ignore\n \n \n+class ViewcodeAnchorTransform(SphinxPostTransform):\n+    \"\"\"Convert or remove viewcode_anchor nodes depends on builder.\"\"\"\n+    default_priority = 100\n+\n+    def run(self, **kwargs: Any) -> None:\n+        if is_supported_builder(self.app.builder):\n+            self.convert_viewcode_anchors()\n+        else:\n+            self.remove_viewcode_anchors()\n+\n+    def convert_viewcode_anchors(self) -> None:\n+        for node in self.document.traverse(viewcode_anchor):\n+            anchor = nodes.inline('', _('[source]'), classes=['viewcode-link'])\n+            refnode = make_refnode(self.app.builder, node['refdoc'], node['reftarget'],\n+                                   node['refid'], anchor)\n+            node.replace_self(refnode)\n+\n+    def remove_viewcode_anchors(self) -> None:\n+        for node in self.document.traverse(viewcode_anchor):\n+            node.parent.remove(node)\n+\n+\n def missing_reference(app: Sphinx, env: BuildEnvironment, node: Element, contnode: Node\n                       ) -> Optional[Node]:\n     # resolve our \"viewcode\" reference nodes -- they need special treatment\n     if node['reftype'] == 'viewcode':\n+        warnings.warn('viewcode extension is no longer use pending_xref node. '\n+                      'Please update your extension.', RemovedInSphinx50Warning)\n         return make_refnode(app.builder, node['refdoc'], node['reftarget'],\n                             node['refid'], contnode)\n \n@@ -182,9 +221,7 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n-    if app.builder.name == \"singlehtml\":\n-        return\n-    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+    if not is_supported_builder(app.builder):\n         return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n@@ -292,6 +329,7 @@ def setup(app: Sphinx) -> Dict[str, Any]:\n     # app.add_config_value('viewcode_exclude_modules', [], 'env')\n     app.add_event('viewcode-find-source')\n     app.add_event('viewcode-follow-imported')\n+    app.add_post_transform(ViewcodeAnchorTransform)\n     return {\n         'version': sphinx.__display_version__,\n         'env_version': 1,\n",
  "test_patch": "diff --git a/tests/test_ext_viewcode.py b/tests/test_ext_viewcode.py\n--- a/tests/test_ext_viewcode.py\n+++ b/tests/test_ext_viewcode.py\n@@ -55,6 +55,9 @@ def test_viewcode_epub_default(app, status, warning):\n \n     assert not (app.outdir / '_modules/spam/mod1.xhtml').exists()\n \n+    result = (app.outdir / 'index.xhtml').read_text()\n+    assert result.count('href=\"_modules/spam/mod1.xhtml#func1\"') == 0\n+\n \n @pytest.mark.sphinx('epub', testroot='ext-viewcode',\n                     confoverrides={'viewcode_enable_epub': True})\n@@ -63,6 +66,9 @@ def test_viewcode_epub_enabled(app, status, warning):\n \n     assert (app.outdir / '_modules/spam/mod1.xhtml').exists()\n \n+    result = (app.outdir / 'index.xhtml').read_text()\n+    assert result.count('href=\"_modules/spam/mod1.xhtml#func1\"') == 2\n+\n \n @pytest.mark.sphinx(testroot='ext-viewcode', tags=['test_linkcode'])\n def test_linkcode(app, status, warning):\n",
  "problem_statement": "viewcode does not work when `make singlehtml html`\n**Describe the bug**\r\nviewcode does not work when `make clean html`\r\n\r\n**To Reproduce**\r\n\r\n```\r\n$ make clean singlehtml html\r\n```\r\n\r\n**Expected behavior**\r\nAlways enabled for HTML builds (except singlehtml and epub)\r\n\r\n**Your project**\r\nNo\r\n\r\n**Screenshots**\r\nNo\r\n\r\n**Environment info**\r\n- OS: Mac\r\n- Python version: 3.9.1\r\n- Sphinx version: HEAD of 3.x\r\n- Sphinx extensions: sphinx.ext.viewcode\r\n- Extra tools: No\r\n\r\n**Additional context**\r\nNo\n",
  "hints_text": "",
  "created_at": "2021-01-19T17:04:10Z",
  "version": "3.5",
  "FAIL_TO_PASS": "[\"tests/test_ext_viewcode.py::test_viewcode_epub_default\"]",
  "PASS_TO_PASS": "[\"tests/test_ext_viewcode.py::test_viewcode_epub_enabled\", \"tests/test_ext_viewcode.py::test_linkcode\", \"tests/test_ext_viewcode.py::test_local_source_files\"]",
  "environment_setup_commit": "4f8cb861e3b29186b38248fe81e4944fd987fcce",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.060375",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}