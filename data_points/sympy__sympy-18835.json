{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-18835",
  "base_commit": "516fa83e69caf1e68306cfc912a13f36c434d51c",
  "patch": "diff --git a/sympy/utilities/iterables.py b/sympy/utilities/iterables.py\n--- a/sympy/utilities/iterables.py\n+++ b/sympy/utilities/iterables.py\n@@ -2088,8 +2088,13 @@ def has_variety(seq):\n def uniq(seq, result=None):\n     \"\"\"\n     Yield unique elements from ``seq`` as an iterator. The second\n-    parameter ``result``  is used internally; it is not necessary to pass\n-    anything for this.\n+    parameter ``result``  is used internally; it is not necessary\n+    to pass anything for this.\n+\n+    Note: changing the sequence during iteration will raise a\n+    RuntimeError if the size of the sequence is known; if you pass\n+    an iterator and advance the iterator you will change the\n+    output of this routine but there will be no warning.\n \n     Examples\n     ========\n@@ -2106,15 +2111,27 @@ def uniq(seq, result=None):\n     >>> list(uniq([[1], [2, 1], [1]]))\n     [[1], [2, 1]]\n     \"\"\"\n+    try:\n+        n = len(seq)\n+    except TypeError:\n+        n = None\n+    def check():\n+        # check that size of seq did not change during iteration;\n+        # if n == None the object won't support size changing, e.g.\n+        # an iterator can't be changed\n+        if n is not None and len(seq) != n:\n+            raise RuntimeError('sequence changed size during iteration')\n     try:\n         seen = set()\n         result = result or []\n         for i, s in enumerate(seq):\n             if not (s in seen or seen.add(s)):\n                 yield s\n+                check()\n     except TypeError:\n         if s not in result:\n             yield s\n+            check()\n             result.append(s)\n         if hasattr(seq, '__getitem__'):\n             for s in uniq(seq[i + 1:], result):\n",
  "test_patch": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -703,6 +703,10 @@ def test_uniq():\n         [([1], 2, 2), (2, [1], 2), (2, 2, [1])]\n     assert list(uniq([2, 3, 2, 4, [2], [1], [2], [3], [1]])) == \\\n         [2, 3, 4, [2], [1], [3]]\n+    f = [1]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+    f = [[1]]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n \n \n def test_kbins():\n",
  "problem_statement": "uniq modifies list argument\nWhen you iterate over a dictionary or set and try to modify it while doing so you get an error from Python:\r\n```python\r\n>>> multiset('THISTLE')\r\n{'T': 2, 'H': 1, 'I': 1, 'S': 1, 'L': 1, 'E': 1}\r\n>>> for i in _:\r\n...   _.pop(i)\r\n...\r\n2\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nRuntimeError: dictionary changed size during iteration\r\n```\r\nIt would be good to do the same thing from within `uniq` because the output will silently be wrong if you modify a passed list:\r\n```python\r\n>>> f=list('THISTLE')\r\n>>> for i in uniq(f):\r\n...   f.remove(i)\r\n...   i\r\n...\r\n'T'\r\n'I'\r\n'L'\r\n```\r\nI think this would entail recording the size at the start and then checking the size and raising a similar RuntimeError if the size changes.\n",
  "hints_text": "I'm not sure there is a need to handle this case. Users should know not to mutate something while iterating over it.\nWith regards to the above discussion, I believe it would indeed be helpful if modifying a passed list to ``uniq`` raises an error while iterating over it, because it does not immediately follow that ``uniq(f)`` would get updated if ``f`` gets updated, as the user might think something like ``uniq`` stores a copy of ``f``, computes the list of unique elements in it, and returns that list. The user may not know, that yield is being used internally instead of return.\r\n\r\nI have a doubt regarding the implementation of ``uniq``:\r\n[https://github.com/sympy/sympy/blob/5bfe93281866f0841b36a429f4090c04a0e81d21/sympy/utilities/iterables.py#L2109-L2124](url)\r\nHere, if the first argument, ``seq`` in ``uniq`` does not have a ``__getitem__`` method, and a TypeError is raised somehow, then we call the ``uniq`` function again on ``seq`` with the updated ``result``, won't that yield ALL of the elements of ``seq`` again, even those which have already been _yielded_? \r\nSo mainly what I wanted to point out was, that if we're assuming that the given ``seq`` is iterable (which we must, since we pass it on to the ``enumerate`` function), by definition, ``seq`` must have either ``__getitem__`` or ``__iter__``, both of which can be used to iterate over the **remaining elements** if the TypeError is raised. \r\nAlso, I'm unable to understand the role of ``result`` in all of this, kindly explain.\r\n\r\nSo should I work on the error handling bit in this function?",
  "created_at": "2020-03-11T23:39:56Z",
  "version": "1.6",
  "FAIL_TO_PASS": "[\"test_uniq\"]",
  "PASS_TO_PASS": "[\"test_is_palindromic\", \"test_postorder_traversal\", \"test_flatten\", \"test_iproduct\", \"test_group\", \"test_subsets\", \"test_variations\", \"test_cartes\", \"test_filter_symbols\", \"test_numbered_symbols\", \"test_sift\", \"test_take\", \"test_dict_merge\", \"test_prefixes\", \"test_postfixes\", \"test_topological_sort\", \"test_strongly_connected_components\", \"test_connected_components\", \"test_rotate\", \"test_multiset_partitions\", \"test_multiset_combinations\", \"test_multiset_permutations\", \"test_partitions\", \"test_binary_partitions\", \"test_bell_perm\", \"test_involutions\", \"test_derangements\", \"test_necklaces\", \"test_bracelets\", \"test_generate_oriented_forest\", \"test_unflatten\", \"test_common_prefix_suffix\", \"test_minlex\", \"test_ordered\", \"test_runs\", \"test_reshape\", \"test_kbins\", \"test_has_dups\", \"test__partition\", \"test_ordered_partitions\", \"test_rotations\"]",
  "environment_setup_commit": "28b41c73c12b70d6ad9f6e45109a80649c4456da",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.128168",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}