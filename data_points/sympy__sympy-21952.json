{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-21952",
  "base_commit": "b8156f36f0f3144c5e3b66002b9e8fcbe2ee66c4",
  "patch": "diff --git a/sympy/core/mul.py b/sympy/core/mul.py\n--- a/sympy/core/mul.py\n+++ b/sympy/core/mul.py\n@@ -1334,6 +1334,7 @@ def _eval_is_zero(self):\n     #_eval_is_integer = lambda self: _fuzzy_group(\n     #    (a.is_integer for a in self.args), quick_exit=True)\n     def _eval_is_integer(self):\n+        from sympy import trailing\n         is_rational = self._eval_is_rational()\n         if is_rational is False:\n             return False\n@@ -1342,11 +1343,14 @@ def _eval_is_integer(self):\n         denominators = []\n         for a in self.args:\n             if a.is_integer:\n-                numerators.append(a)\n+                if abs(a) is not S.One:\n+                    numerators.append(a)\n             elif a.is_Rational:\n                 n, d = a.as_numer_denom()\n-                numerators.append(n)\n-                denominators.append(d)\n+                if abs(n) is not S.One:\n+                    numerators.append(n)\n+                if d is not S.One:\n+                    denominators.append(d)\n             elif a.is_Pow:\n                 b, e = a.as_base_exp()\n                 if not b.is_integer or not e.is_integer: return\n@@ -1364,13 +1368,36 @@ def _eval_is_integer(self):\n         if not denominators:\n             return True\n \n-        odd = lambda ints: all(i.is_odd for i in ints)\n-        even = lambda ints: any(i.is_even for i in ints)\n+        allodd = lambda x: all(i.is_odd for i in x)\n+        alleven = lambda x: all(i.is_even for i in x)\n+        anyeven = lambda x: any(i.is_even for i in x)\n \n-        if odd(numerators) and even(denominators):\n+        if allodd(numerators) and anyeven(denominators):\n             return False\n-        elif even(numerators) and denominators == [2]:\n+        elif anyeven(numerators) and denominators == [2]:\n             return True\n+        elif alleven(numerators) and allodd(denominators\n+                ) and (Mul(*denominators, evaluate=False) - 1\n+                ).is_positive:\n+            return False\n+        if len(denominators) == 1:\n+            d = denominators[0]\n+            if d.is_Integer and d.is_even:\n+                # if minimal power of 2 in num vs den is not\n+                # negative then we have an integer\n+                if (Add(*[i.as_base_exp()[1] for i in\n+                        numerators if i.is_even]) - trailing(d.p)\n+                        ).is_nonnegative:\n+                    return True\n+        if len(numerators) == 1:\n+            n = numerators[0]\n+            if n.is_Integer and n.is_even:\n+                # if minimal power of 2 in den vs num is positive\n+                # then we have have a non-integer\n+                if (Add(*[i.as_base_exp()[1] for i in\n+                        denominators if i.is_even]) - trailing(n.p)\n+                        ).is_positive:\n+                    return False\n \n     def _eval_is_polar(self):\n         has_polar = any(arg.is_polar for arg in self.args)\n@@ -1545,37 +1572,54 @@ def _eval_is_extended_negative(self):\n         return self._eval_pos_neg(-1)\n \n     def _eval_is_odd(self):\n+        from sympy import trailing, fraction\n         is_integer = self.is_integer\n-\n         if is_integer:\n+            if self.is_zero:\n+                return False\n+            n, d = fraction(self)\n+            if d.is_Integer and d.is_even:\n+                # if minimal power of 2 in num vs den is\n+                # positive then we have an even number\n+                if (Add(*[i.as_base_exp()[1] for i in\n+                        Mul.make_args(n) if i.is_even]) - trailing(d.p)\n+                        ).is_positive:\n+                    return False\n+                return\n             r, acc = True, 1\n             for t in self.args:\n-                if not t.is_integer:\n-                    return None\n-                elif t.is_even:\n+                if abs(t) is S.One:\n+                    continue\n+                assert t.is_integer\n+                if t.is_even:\n+                    return False\n+                if r is False:\n+                    pass\n+                elif acc != 1 and (acc + t).is_odd:\n                     r = False\n-                elif t.is_integer:\n-                    if r is False:\n-                        pass\n-                    elif acc != 1 and (acc + t).is_odd:\n-                        r = False\n-                    elif t.is_odd is None:\n-                        r = None\n+                elif t.is_even is None:\n+                    r = None\n                 acc = t\n             return r\n-\n-        # !integer -> !odd\n-        elif is_integer is False:\n-            return False\n+        return is_integer # !integer -> !odd\n \n     def _eval_is_even(self):\n+        from sympy import trailing, fraction\n         is_integer = self.is_integer\n \n         if is_integer:\n             return fuzzy_not(self.is_odd)\n \n-        elif is_integer is False:\n-            return False\n+        n, d = fraction(self)\n+        if n.is_Integer and n.is_even:\n+            # if minimal power of 2 in den vs num is not\n+            # negative then this is not an integer and\n+            # can't be even\n+            if (Add(*[i.as_base_exp()[1] for i in\n+                    Mul.make_args(d) if i.is_even]) - trailing(n.p)\n+                    ).is_nonnegative:\n+                return False\n+        return is_integer\n \n     def _eval_is_composite(self):\n         \"\"\"\ndiff --git a/sympy/core/numbers.py b/sympy/core/numbers.py\n--- a/sympy/core/numbers.py\n+++ b/sympy/core/numbers.py\n@@ -1572,6 +1572,16 @@ class Rational(Number):\n     >>> r.p/r.q\n     0.75\n \n+    If an unevaluated Rational is desired, ``gcd=1`` can be passed and\n+    this will keep common divisors of the numerator and denominator\n+    from being eliminated. It is not possible, however, to leave a\n+    negative value in the denominator.\n+\n+    >>> Rational(2, 4, gcd=1)\n+    2/4\n+    >>> Rational(2, -4, gcd=1).q\n+    4\n+\n     See Also\n     ========\n     sympy.core.sympify.sympify, sympy.simplify.simplify.nsimplify\n",
  "test_patch": "diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -512,6 +512,12 @@ def test_Mul_is_even_odd():\n     assert (x*(x + k)).is_odd is False\n     assert (x*(x + m)).is_odd is None\n \n+    # issue 8648\n+    assert (m**2/2).is_even\n+    assert (m**2/3).is_even is False\n+    assert (2/m**2).is_odd is False\n+    assert (2/m).is_odd is None\n+\n \n @XFAIL\n def test_evenness_in_ternary_integer_product_with_odd():\n@@ -1051,6 +1057,18 @@ def test_Pow_is_integer():\n     assert (1/(x + 1)).is_integer is False\n     assert (1/(-x - 1)).is_integer is False\n \n+    # issue 8648-like\n+    k = Symbol('k', even=True)\n+    assert (k**3/2).is_integer\n+    assert (k**3/8).is_integer\n+    assert (k**3/16).is_integer is None\n+    assert (2/k).is_integer is None\n+    assert (2/k**2).is_integer is False\n+    o = Symbol('o', odd=True)\n+    assert (k/o).is_integer is None\n+    o = Symbol('o', odd=True, prime=True)\n+    assert (k/o).is_integer is False\n+\n \n def test_Pow_is_real():\n     x = Symbol('x', real=True)\ndiff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py\n--- a/sympy/core/tests/test_numbers.py\n+++ b/sympy/core/tests/test_numbers.py\n@@ -343,6 +343,11 @@ def test_Rational_new():\n     assert Rational(mpq(2, 6)) == Rational(1, 3)\n     assert Rational(PythonRational(2, 6)) == Rational(1, 3)\n \n+    assert Rational(2, 4, gcd=1).q == 4\n+    n = Rational(2, -4, gcd=1)\n+    assert n.q == 4\n+    assert n.p == -2\n+\n \n def test_Number_new():\n     \"\"\"\"\n",
  "problem_statement": "If n is even, n**2/2 should also be even\nThe following:\n\n``` python\n>>> n = Symbol('n', integer=True, even=True)\n>>> (n**2/2).is_even\n```\n\nshould return `True`, but it returns `None` (of course, this is also an enhancement).\n\nThat makes me think that perhaps symbolic integers should keep a more complex \"assumptions\" method, which generalizes \"is_even\" and \"is_odd\" to instead contain a dictionary of primes that are known to divide that integer, mapping to minimum and maximum known multiplicity.\n\nI would like to think about it and post a proposition/plan, but I am not sure what is the correct github way of doing this.\n\nUpdated _eval_is_odd to handle more complex inputs\nChanged the function _eval_is_odd to handle integer inputs that have a denominator, such as \r\n```\r\nn = Symbol('n',integer=True,even=True)\r\nm = Symbol('m',integer=true,even=True)\r\nx = Mul(n,m,S.Half)\r\n```\r\nThe example expression x is recognized by SymPy as an integer, but can be decomposed into n,m,and 1/2.  My new function evaluates the oddness of each part and uses this to calculate the oddness of the entire integer.\r\n\r\nAddresses issue #8648 \n",
  "hints_text": "I have added some handling for this instance in this [PR](https://github.com/sympy/sympy/pull/12320).  I did put thought into generalizing this even more for any integer divisor, but because we don't have the factorizations for the symbols, this does not seem easily possible.\nCan you add some tests (based on the other tests, it looks like `sympy/core/tests/test_arit.py` is the proper file). \n@asmeurer , [here](https://github.com/mikaylazgrace/sympy/blob/Working-on-issue-8648/sympy/core/mul.py) is the updated work (line 1266) incorporating some of the ideas we discussed above.  I'm unsure if I am calling the functions .fraction() and .as_coeff_mul() correctly.\r\n\r\nAn error raised by Travis in the original PR said that when I called the functions (around line 90 in mul.py), \"self is not defined\".  Any ideas on how to call the functions?  Below is how I did it (which didn't work):\r\n\r\n```\r\nclass Mul(Expr, AssocOp):\r\n\r\n    __slots__ = []\r\n\r\n    is_Mul = True\r\n    is_odd = self._eval_is_odd()\r\n    is_even = self._eval_is_even()\r\n```\r\n\r\n\r\n\nself is only defined inside of methods (where self is the first argument). There's no need to define is_odd or is_even. SymPy defines those automatically from _eval_is_odd and _eval_is_even.\n@asmeurer , Travis is giving me this error:       \r\n```\r\nFile \"/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/sympy/core/mul.py\", line 1291, in _eval_is_odd\r\n        symbols = list(chain.from_iterable(symbols)) #.as_coeff_mul() returns a tuple for arg[1] so we change it to a list\r\n    TypeError: 'exp_polar' object is not iterable\r\n```\r\n\r\nI'm a bit unsure how to approach/fix this.  The added symbols = list... was in response to the fact that .as_coeff_mul() returns a tuple in arg[1] which isn't iterable.\nI'm not clear what you are trying to do on that line. You should be able to just have \r\n\r\n```\r\ncoeff, args = self.as_coeff_mul()\r\nfor arg in args:\r\n    ...\r\n```\nI had some equivalent of that, but Travis said that I was trying to iterate over a tuple. I thought .as_coeff_mul() returned a tuple for the second part? Maybe I'm incorrect there. \nI just made a small change that might solve it:  I'm looping over symbols instead of symbols.arg[1].  \r\n\r\nI also changed .as_coeff_mul() per your suggestion (around line 1288):\r\n```\r\n        if is_integer:\r\n            coeff,symbols = self.as_coeff_mul()\r\n            if coeff == 1 or coeff == -1:\r\n                r = True\r\n                for symbol in symbols:\r\n                ...\r\n```\r\n\n@mikaylazgrace Are you still interested to work on it?\nI will takeover and come up with a PR soon.",
  "created_at": "2021-08-26T11:12:47Z",
  "version": "1.9",
  "FAIL_TO_PASS": "[\"test_Mul_is_even_odd\", \"test_Pow_is_integer\"]",
  "PASS_TO_PASS": "[\"test_bug1\", \"test_Symbol\", \"test_arit0\", \"test_div\", \"test_pow\", \"test_pow2\", \"test_pow3\", \"test_mod_pow\", \"test_pow_E\", \"test_pow_issue_3516\", \"test_pow_im\", \"test_real_mul\", \"test_ncmul\", \"test_mul_add_identity\", \"test_ncpow\", \"test_powerbug\", \"test_Mul_doesnt_expand_exp\", \"test_Mul_is_integer\", \"test_Add_Mul_is_integer\", \"test_Add_Mul_is_finite\", \"test_evenness_in_ternary_integer_product_with_even\", \"test_oddness_in_ternary_integer_product_with_even\", \"test_Mul_is_rational\", \"test_Add_is_rational\", \"test_Add_is_even_odd\", \"test_Mul_is_negative_positive\", \"test_Mul_is_negative_positive_2\", \"test_Mul_is_nonpositive_nonnegative\", \"test_Add_is_negative_positive\", \"test_Add_is_nonpositive_nonnegative\", \"test_Pow_is_real\", \"test_real_Pow\", \"test_Pow_is_finite\", \"test_Pow_is_even_odd\", \"test_Pow_is_negative_positive\", \"test_Pow_is_zero\", \"test_Pow_is_nonpositive_nonnegative\", \"test_Mul_is_imaginary_real\", \"test_Mul_hermitian_antihermitian\", \"test_Add_is_comparable\", \"test_Mul_is_comparable\", \"test_Pow_is_comparable\", \"test_Add_is_positive_2\", \"test_Add_is_irrational\", \"test_Mul_is_irrational\", \"test_issue_3531\", \"test_issue_3531b\", \"test_bug3\", \"test_suppressed_evaluation\", \"test_AssocOp_doit\", \"test_Add_Mul_Expr_args\", \"test_Add_as_coeff_mul\", \"test_Pow_as_coeff_mul_doesnt_expand\", \"test_issue_3514_18626\", \"test_make_args\", \"test_issue_5126\", \"test_Rational_as_content_primitive\", \"test_Add_as_content_primitive\", \"test_Mul_as_content_primitive\", \"test_Pow_as_content_primitive\", \"test_issue_5460\", \"test_product_irrational\", \"test_issue_5919\", \"test_Mod\", \"test_Mod_Pow\", \"test_Mod_is_integer\", \"test_Mod_is_nonposneg\", \"test_issue_6001\", \"test_polar\", \"test_issue_6040\", \"test_issue_6082\", \"test_issue_6077\", \"test_mul_flatten_oo\", \"test_add_flatten\", \"test_issue_5160_6087_6089_6090\", \"test_float_int_round\", \"test_issue_6611a\", \"test_denest_add_mul\", \"test_mul_coeff\", \"test_mul_zero_detection\", \"test_Mul_with_zero_infinite\", \"test_Mul_does_not_cancel_infinities\", \"test_Mul_does_not_distribute_infinity\", \"test_issue_8247_8354\", \"test_Add_is_zero\", \"test_issue_14392\", \"test_divmod\", \"test__neg__\", \"test_issue_18507\", \"test_issue_17130\", \"test_seterr\", \"test_mod\", \"test_igcd\", \"test_igcd_lehmer\", \"test_igcd2\", \"test_ilcm\", \"test_igcdex\", \"test_Integer_new\", \"test_Rational_new\", \"test_Number_new\", \"test_Number_cmp\", \"test_Rational_cmp\", \"test_Float\", \"test_zero_not_false\", \"test_float_mpf\", \"test_Float_RealElement\", \"test_Float_default_to_highprec_from_str\", \"test_Float_eval\", \"test_Float_issue_2107\", \"test_issue_14289\", \"test_Float_from_tuple\", \"test_Infinity\", \"test_Infinity_2\", \"test_Mul_Infinity_Zero\", \"test_Div_By_Zero\", \"test_Infinity_inequations\", \"test_NaN\", \"test_special_numbers\", \"test_powers\", \"test_integer_nthroot_overflow\", \"test_integer_log\", \"test_isqrt\", \"test_powers_Integer\", \"test_powers_Rational\", \"test_powers_Float\", \"test_lshift_Integer\", \"test_rshift_Integer\", \"test_and_Integer\", \"test_xor_Integer\", \"test_or_Integer\", \"test_invert_Integer\", \"test_abs1\", \"test_accept_int\", \"test_dont_accept_str\", \"test_int\", \"test_int_NumberSymbols\", \"test_real_bug\", \"test_bug_sqrt\", \"test_pi_Pi\", \"test_no_len\", \"test_issue_3321\", \"test_issue_3692\", \"test_issue_3423\", \"test_issue_3449\", \"test_issue_13890\", \"test_Integer_factors\", \"test_Rational_factors\", \"test_issue_4107\", \"test_IntegerInteger\", \"test_Rational_gcd_lcm_cofactors\", \"test_Float_gcd_lcm_cofactors\", \"test_issue_4611\", \"test_conversion_to_mpmath\", \"test_relational\", \"test_Integer_as_index\", \"test_Rational_int\", \"test_zoo\", \"test_issue_4122\", \"test_GoldenRatio_expand\", \"test_TribonacciConstant_expand\", \"test_as_content_primitive\", \"test_hashing_sympy_integers\", \"test_rounding_issue_4172\", \"test_Catalan_EulerGamma_prec\", \"test_Catalan_rewrite\", \"test_bool_eq\", \"test_Float_eq\", \"test_issue_6640\", \"test_issue_6349\", \"test_mpf_norm\", \"test_latex\", \"test_issue_7742\", \"test_simplify_AlgebraicNumber\", \"test_Float_idempotence\", \"test_comp1\", \"test_issue_9491\", \"test_issue_10063\", \"test_issue_10020\", \"test_invert_numbers\", \"test_mod_inverse\", \"test_golden_ratio_rewrite_as_sqrt\", \"test_tribonacci_constant_rewrite_as_sqrt\", \"test_comparisons_with_unknown_type\", \"test_NumberSymbol_comparison\", \"test_Integer_precision\", \"test_Integer_ceiling_floor\", \"test_ComplexInfinity\", \"test_Infinity_floor_ceiling_power\", \"test_One_power\", \"test_NegativeInfinity\", \"test_issue_6133\", \"test_abc\"]",
  "environment_setup_commit": "f9a6f50ec0c74d935c50a6e9c9b2cb0469570d91",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.148104",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}