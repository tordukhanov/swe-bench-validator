{
  "repo": "django/django",
  "instance_id": "django__django-16027",
  "base_commit": "99bd5fb4c2d51f7bf8a19b2c12a603ab38b85ec9",
  "patch": "diff --git a/django/utils/timesince.py b/django/utils/timesince.py\n--- a/django/utils/timesince.py\n+++ b/django/utils/timesince.py\n@@ -1,4 +1,3 @@\n-import calendar\n import datetime\n \n from django.utils.html import avoid_wrapping\n@@ -14,14 +13,16 @@\n     \"minute\": ngettext_lazy(\"%(num)d minute\", \"%(num)d minutes\", \"num\"),\n }\n \n-TIMESINCE_CHUNKS = (\n-    (60 * 60 * 24 * 365, \"year\"),\n-    (60 * 60 * 24 * 30, \"month\"),\n-    (60 * 60 * 24 * 7, \"week\"),\n-    (60 * 60 * 24, \"day\"),\n-    (60 * 60, \"hour\"),\n-    (60, \"minute\"),\n-)\n+TIME_STRINGS_KEYS = list(TIME_STRINGS.keys())\n+\n+TIME_CHUNKS = [\n+    60 * 60 * 24 * 7,  # week\n+    60 * 60 * 24,  # day\n+    60 * 60,  # hour\n+    60,  # minute\n+]\n+\n+MONTHS_DAYS = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n \n \n def timesince(d, now=None, reversed=False, time_strings=None, depth=2):\n@@ -31,9 +32,16 @@ def timesince(d, now=None, reversed=False, time_strings=None, depth=2):\n     \"0 minutes\".\n \n     Units used are years, months, weeks, days, hours, and minutes.\n-    Seconds and microseconds are ignored. Up to `depth` adjacent units will be\n-    displayed.  For example, \"2 weeks, 3 days\" and \"1 year, 3 months\" are\n-    possible outputs, but \"2 weeks, 3 hours\" and \"1 year, 5 days\" are not.\n+    Seconds and microseconds are ignored.\n+\n+    The algorithm takes into account the varying duration of years and months.\n+    There is exactly \"1 year, 1 month\" between 2013/02/10 and 2014/03/10,\n+    but also between 2007/08/10 and 2008/09/10 despite the delta being 393 days\n+    in the former case and 397 in the latter.\n+\n+    Up to `depth` adjacent units will be displayed.  For example,\n+    \"2 weeks, 3 days\" and \"1 year, 3 months\" are possible outputs, but\n+    \"2 weeks, 3 hours\" and \"1 year, 5 days\" are not.\n \n     `time_strings` is an optional dict of strings to replace the default\n     TIME_STRINGS dict.\n@@ -41,8 +49,9 @@ def timesince(d, now=None, reversed=False, time_strings=None, depth=2):\n     `depth` is an optional integer to control the number of adjacent time\n     units returned.\n \n-    Adapted from\n+    Originally adapted from\n     https://web.archive.org/web/20060617175230/http://blog.natbat.co.uk/archive/2003/Jun/14/time_since\n+    Modified to improve results for years and months.\n     \"\"\"\n     if time_strings is None:\n         time_strings = TIME_STRINGS\n@@ -60,37 +69,64 @@ def timesince(d, now=None, reversed=False, time_strings=None, depth=2):\n         d, now = now, d\n     delta = now - d\n \n-    # Deal with leapyears by subtracing the number of leapdays\n-    leapdays = calendar.leapdays(d.year, now.year)\n-    if leapdays != 0:\n-        if calendar.isleap(d.year):\n-            leapdays -= 1\n-        elif calendar.isleap(now.year):\n-            leapdays += 1\n-    delta -= datetime.timedelta(leapdays)\n-\n-    # ignore microseconds\n+    # Ignore microseconds.\n     since = delta.days * 24 * 60 * 60 + delta.seconds\n     if since <= 0:\n         # d is in the future compared to now, stop processing.\n         return avoid_wrapping(time_strings[\"minute\"] % {\"num\": 0})\n-    for i, (seconds, name) in enumerate(TIMESINCE_CHUNKS):\n-        count = since // seconds\n-        if count != 0:\n+\n+    # Get years and months.\n+    total_months = (now.year - d.year) * 12 + (now.month - d.month)\n+    if d.day > now.day or (d.day == now.day and d.time() > now.time()):\n+        total_months -= 1\n+    years, months = divmod(total_months, 12)\n+\n+    # Calculate the remaining time.\n+    # Create a \"pivot\" datetime shifted from d by years and months, then use\n+    # that to determine the other parts.\n+    if years or months:\n+        pivot_year = d.year + years\n+        pivot_month = d.month + months\n+        if pivot_month > 12:\n+            pivot_month -= 12\n+            pivot_year += 1\n+        pivot = datetime.datetime(\n+            pivot_year,\n+            pivot_month,\n+            min(MONTHS_DAYS[pivot_month - 1], d.day),\n+            d.hour,\n+            d.minute,\n+            d.second,\n+        )\n+    else:\n+        pivot = d\n+    remaining_time = (now - pivot).total_seconds()\n+    partials = [years, months]\n+    for chunk in TIME_CHUNKS:\n+        count = remaining_time // chunk\n+        partials.append(count)\n+        remaining_time -= chunk * count\n+\n+    # Find the first non-zero part (if any) and then build the result, until\n+    # depth.\n+    i = 0\n+    for i, value in enumerate(partials):\n+        if value != 0:\n             break\n     else:\n         return avoid_wrapping(time_strings[\"minute\"] % {\"num\": 0})\n+\n     result = []\n     current_depth = 0\n-    while i < len(TIMESINCE_CHUNKS) and current_depth < depth:\n-        seconds, name = TIMESINCE_CHUNKS[i]\n-        count = since // seconds\n-        if count == 0:\n+    while i < len(TIME_STRINGS_KEYS) and current_depth < depth:\n+        value = partials[i]\n+        if value == 0:\n             break\n-        result.append(avoid_wrapping(time_strings[name] % {\"num\": count}))\n-        since -= seconds * count\n+        name = TIME_STRINGS_KEYS[i]\n+        result.append(avoid_wrapping(time_strings[name] % {\"num\": value}))\n         current_depth += 1\n         i += 1\n+\n     return gettext(\", \").join(result)\n \n \n",
  "test_patch": "diff --git a/tests/humanize_tests/tests.py b/tests/humanize_tests/tests.py\n--- a/tests/humanize_tests/tests.py\n+++ b/tests/humanize_tests/tests.py\n@@ -506,8 +506,8 @@ def test_inflection_for_timedelta(self):\n             # \"%(delta)s from now\" translations\n             now + datetime.timedelta(days=1),\n             now + datetime.timedelta(days=2),\n-            now + datetime.timedelta(days=30),\n-            now + datetime.timedelta(days=60),\n+            now + datetime.timedelta(days=31),\n+            now + datetime.timedelta(days=61),\n             now + datetime.timedelta(days=500),\n             now + datetime.timedelta(days=865),\n         ]\ndiff --git a/tests/template_tests/filter_tests/test_timesince.py b/tests/template_tests/filter_tests/test_timesince.py\n--- a/tests/template_tests/filter_tests/test_timesince.py\n+++ b/tests/template_tests/filter_tests/test_timesince.py\n@@ -147,6 +147,23 @@ def test_timesince18(self):\n         )\n         self.assertEqual(output, \"1\\xa0day\")\n \n+    # Tests for #33879 (wrong results for 11 months + several weeks).\n+    @setup({\"timesince19\": \"{{ earlier|timesince }}\"})\n+    def test_timesince19(self):\n+        output = self.engine.render_to_string(\n+            \"timesince19\", {\"earlier\": self.today - timedelta(days=358)}\n+        )\n+        self.assertEqual(output, \"11\\xa0months, 3\\xa0weeks\")\n+\n+    @setup({\"timesince20\": \"{{ a|timesince:b }}\"})\n+    def test_timesince20(self):\n+        now = datetime(2018, 5, 9)\n+        output = self.engine.render_to_string(\n+            \"timesince20\",\n+            {\"a\": now, \"b\": now + timedelta(days=365) + timedelta(days=364)},\n+        )\n+        self.assertEqual(output, \"1\\xa0year, 11\\xa0months\")\n+\n \n class FunctionTests(SimpleTestCase):\n     def test_since_now(self):\ndiff --git a/tests/utils_tests/test_timesince.py b/tests/utils_tests/test_timesince.py\n--- a/tests/utils_tests/test_timesince.py\n+++ b/tests/utils_tests/test_timesince.py\n@@ -16,8 +16,8 @@ def setUp(self):\n         self.onehour = datetime.timedelta(hours=1)\n         self.oneday = datetime.timedelta(days=1)\n         self.oneweek = datetime.timedelta(days=7)\n-        self.onemonth = datetime.timedelta(days=30)\n-        self.oneyear = datetime.timedelta(days=365)\n+        self.onemonth = datetime.timedelta(days=31)\n+        self.oneyear = datetime.timedelta(days=366)\n \n     def test_equal_datetimes(self):\n         \"\"\"equal datetimes.\"\"\"\n@@ -205,6 +205,37 @@ def test_depth(self):\n                 self.assertEqual(timesince(self.t, value, depth=depth), expected)\n                 self.assertEqual(timeuntil(value, self.t, depth=depth), expected)\n \n+    def test_months_edge(self):\n+        t = datetime.datetime(2022, 1, 1)\n+        tests = [\n+            (datetime.datetime(2022, 1, 31), \"4\\xa0weeks, 2\\xa0days\"),\n+            (datetime.datetime(2022, 2, 1), \"1\\xa0month\"),\n+            (datetime.datetime(2022, 2, 28), \"1\\xa0month, 3\\xa0weeks\"),\n+            (datetime.datetime(2022, 3, 1), \"2\\xa0months\"),\n+            (datetime.datetime(2022, 3, 31), \"2\\xa0months, 4\\xa0weeks\"),\n+            (datetime.datetime(2022, 4, 1), \"3\\xa0months\"),\n+            (datetime.datetime(2022, 4, 30), \"3\\xa0months, 4\\xa0weeks\"),\n+            (datetime.datetime(2022, 5, 1), \"4\\xa0months\"),\n+            (datetime.datetime(2022, 5, 31), \"4\\xa0months, 4\\xa0weeks\"),\n+            (datetime.datetime(2022, 6, 1), \"5\\xa0months\"),\n+            (datetime.datetime(2022, 6, 30), \"5\\xa0months, 4\\xa0weeks\"),\n+            (datetime.datetime(2022, 7, 1), \"6\\xa0months\"),\n+            (datetime.datetime(2022, 7, 31), \"6\\xa0months, 4\\xa0weeks\"),\n+            (datetime.datetime(2022, 8, 1), \"7\\xa0months\"),\n+            (datetime.datetime(2022, 8, 31), \"7\\xa0months, 4\\xa0weeks\"),\n+            (datetime.datetime(2022, 9, 1), \"8\\xa0months\"),\n+            (datetime.datetime(2022, 9, 30), \"8\\xa0months, 4\\xa0weeks\"),\n+            (datetime.datetime(2022, 10, 1), \"9\\xa0months\"),\n+            (datetime.datetime(2022, 10, 31), \"9\\xa0months, 4\\xa0weeks\"),\n+            (datetime.datetime(2022, 11, 1), \"10\\xa0months\"),\n+            (datetime.datetime(2022, 11, 30), \"10\\xa0months, 4\\xa0weeks\"),\n+            (datetime.datetime(2022, 12, 1), \"11\\xa0months\"),\n+            (datetime.datetime(2022, 12, 31), \"11\\xa0months, 4\\xa0weeks\"),\n+        ]\n+        for value, expected in tests:\n+            with self.subTest():\n+                self.assertEqual(timesince(t, value), expected)\n+\n     def test_depth_invalid(self):\n         msg = \"depth must be greater than 0.\"\n         with self.assertRaisesMessage(ValueError, msg):\n",
  "problem_statement": "timesince - wrong results for 11 months + several weeks\nDescription\n\t \n\t\t(last modified by אורי)\n\t \nHi,\nI'm using timesince to format how much time passed since the user last visited my website. The code is:\n_(\"On {date} ({timesince} ago)\").format(\n\tdate=formats.date_format(value=last_visit_date),\n\ttimesince=timesince(d=last_visit_date, now=today)\n)\nNow I created a test to test these times, and I noticed that for a year minus a week, the result is \"(11\\u00A0months, 4\\u00A0weeks ago)\" (why the \"\\u00A0\" and not a space?), and for a year minus 2 weeks, the result is \"(11\\u00A0months, 3\\u00A0weeks ago)\":\n\t\t\t\tuser_18 = ActiveUserFactory()\n\t\t\t\tuser_18.profile.last_visit -= (relativedelta(years=1) - relativedelta(weeks=1))\n\t\t\t\tuser_18.save_user_and_profile()\n\t\t\t\tself.assertIs(expr1={'en': \"(11\\u00A0months, 4\\u00A0weeks ago)\", 'he': \"(לפני 11\\u00A0חודשים, 4\\u00A0שבועות)\"}[self.language_code] in user_18.profile.last_visit_str, expr2=True)\n\t\t\t\tuser_19 = ActiveUserFactory()\n\t\t\t\tuser_19.profile.last_visit -= (relativedelta(years=1) - relativedelta(weeks=2))\n\t\t\t\tuser_19.save_user_and_profile()\n\t\t\t\tself.assertIs(expr1={'en': \"(11\\u00A0months, 3\\u00A0weeks ago)\", 'he': \"(לפני 11\\u00A0חודשים, 3\\u00A0שבועות)\"}[self.language_code] in user_19.profile.last_visit_str, expr2=True)\nNow, a year is 365 days, a year minus one week is 358 days, which is 11 months and 3 weeks. I think the problem is because each month is considered as 30 days, so 11 months are 330 days. But 11 months are about 334 days actually, so we receive a result of 11 months and 4 weeks, instead of 11 months and 3 weeks.\nA fix would be to change the number of days in a month to 30.4 (the average), optionally only for more than 2 months (because it makes sense to calculate exactly 30 days for the first 2 months).\nAlso, it's important to calculate the number of days in 11 (or any number) of months as an integer, so that the result will not display hours and minutes (if depth is big enough).\n",
  "hints_text": "Tentatively accepting, we might certainly improve this calculation a bit. (why the \"\\u00A0\" and not a space?) \"\\u00A0\" is the non-breaking space, as a line break between the digit and the text is bad behavior.\nThank you, Claude. I suggest calculating the number of days per month: If months <= 2: 30 * months else: int(30.4 * months) (I confirm that int(30.4 * months) == 30 * months if months is 1 or 2) I'm not sure if I know how to submit a PR since currently TIMESINCE_CHUNKS doesn't support this. And I don't know how to change the algorithm to support this.\nHi Claude, I just looked at the algorithm and I found another bug: If I add to my test this code: user_21 = ActiveUserFactory() user_21.profile.last_visit -= (relativedelta(years=2) - relativedelta(days=1)) user_21.save_user_and_profile() import re print(re.sub(r'[^ -~]', lambda m: '\\\\u%04X' % ord(m[0]), user_21.profile.last_visit_str)) user_22 = ActiveUserFactory() user_22.profile.last_visit -= (relativedelta(years=2) - relativedelta(days=2)) user_22.save_user_and_profile() import re print(re.sub(r'[^ -~]', lambda m: '\\\\u%04X' % ord(m[0]), user_22.profile.last_visit_str)) Then, I get printed: On 1 August 2020 (1\\u00A0year, 12\\u00A0months ago) On 2 August 2020 (1\\u00A0year, 12\\u00A0months ago) (In English) So it returns 1 year, 12 months ago in both cases. Also I guess with 364 days it will return 12 months and not 1 year.\nYou might want to take a look at ​this answer, and then maybe convert the days to weeks and days.\nYou can calculate something like this: from dateutil.relativedelta import relativedelta diff = relativedelta(date2, date1) years = diff.years months = diff.months weeks = diff.days // 7 days = diff.days - weeks * 7 And then calculate the hours and minutes from delta.seconds in the original function.\nReplying to אורי: You can calculate something like this: from dateutil.relativedelta import relativedelta diff = relativedelta(date2, date1) years = diff.years months = diff.months weeks = diff.days // 7 days = diff.days - weeks * 7 And then calculate the hours and minutes from delta.seconds in the original function. Adding a new dependency is not an option, IMO. However you can always start a discussion on the DevelopersMailingList (see comment).\nHi, I created my own utility function: from dateutil.relativedelta import relativedelta from django.utils.timesince import TIME_STRINGS as timesince_time_strings from django.utils.html import avoid_wrapping from django.utils.translation import gettext, get_language def timesince(d, now): delta = relativedelta(now, d) years = delta.years months = delta.months weeks = delta.days // 7 days = delta.days - weeks * 7 timesince_counts = [(years, \"year\"), (months, \"month\")] if (years == 0): timesince_counts.append((weeks, \"week\")) if (months == 0): timesince_counts.append((days, \"day\")) result = [] for (count, name) in timesince_counts: if (count > 0): result.append(avoid_wrapping(value=timesince_time_strings[name] % {\"num\": count})) return gettext(\", \").join(result) I don't need depth>2, I don't need hours and minutes and by definition my function returns \"\" if both dates are the same. now must be bigger than d or else I don't know what will happen... I think you just get \"\" otherwise. ​https://github.com/speedy-net/speedy-net/blob/master/speedy/core/base/utils.py\nHi, I updated my code a little: from dateutil.relativedelta import relativedelta from django.utils.timesince import TIME_STRINGS as timesince_time_strings from django.utils.html import avoid_wrapping from django.utils.translation import pgettext, get_language def timesince(d, now): \"\"\" Like Django's timesince but more accurate. Returns results only when delta is at least one day (positive). Otherwise returns \"\". Result is either one or two in depth. \"\"\" delta = -relativedelta(d, now) result = [] if ((delta.years >= 0) and (delta.months >= 0) and (delta.days >= 0)): years = delta.years months = delta.months weeks = delta.days // 7 days = delta.days - weeks * 7 timesince_counts = [(years, \"year\"), (months, \"month\")] if (years == 0): timesince_counts.append((weeks, \"week\")) if (months == 0): timesince_counts.append((days, \"day\")) for (count, name) in timesince_counts: if (count > 0): result.append(avoid_wrapping(value=timesince_time_strings[name] % {\"num\": count})) result = pgettext(context=\"timesince\", message=\", \").join(result) if (get_language() == \"he\"): result = re.sub(pattern=r'(\\ {1}ו{1})(\\d{1})', repl=lambda m: \"-\".join(m.groups()), string=result) return result And also for Hebrew, in django.po: msgctxt \"timesince\" msgid \", \" msgstr \" ו\" I also think you can consider using dateutil.relativedelta if python-dateutil is installed, and adding it as an optional dependency on your docs. And if not, revert to the current algorithm. Notice, I used -relativedelta(d, now) since it displays more accurate results for dates in the past, than relativedelta(now, d). You can see ​https://github.com/dateutil/dateutil/issues/1228",
  "created_at": "2022-09-03T10:30:10Z",
  "version": "4.2",
  "FAIL_TO_PASS": "[\"test_depth (utils_tests.test_timesince.TimesinceTests)\", \"test_depth_invalid (utils_tests.test_timesince.TimesinceTests)\", \"test_months_edge (utils_tests.test_timesince.TimesinceTests)\", \"test_timesince19 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince20 (template_tests.filter_tests.test_timesince.TimesinceTests)\"]",
  "PASS_TO_PASS": "[\"test_explicit_date (template_tests.filter_tests.test_timesince.FunctionTests)\", \"test_no_args (template_tests.filter_tests.test_timesince.FunctionTests)\", \"test_since_now (template_tests.filter_tests.test_timesince.FunctionTests)\", \"Timesince should work with both date objects (#9672)\", \"Both timesince and timeuntil should work on date objects (#17937).\", \"When using two different timezones.\", \"If the two differing units aren't adjacent, only the first unit is\", \"When the second date occurs before the first, we should always\", \"equal datetimes.\", \"Microseconds and seconds are ignored.\", \"test_leap_year (utils_tests.test_timesince.TimesinceTests)\", \"test_leap_year_new_years_eve (utils_tests.test_timesince.TimesinceTests)\", \"Test multiple units.\", \"test_naive_datetime_with_tzinfo_attribute (utils_tests.test_timesince.TimesinceTests)\", \"Test other units.\", \"test_second_before_equal_first_humanize_time_strings (utils_tests.test_timesince.TimesinceTests)\", \"test_thousand_years_ago (utils_tests.test_timesince.TimesinceTests)\", \"test_timesince01 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince02 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince03 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince04 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince05 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince06 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince07 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince08 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince09 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince10 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince11 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince12 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince13 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince14 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince15 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince16 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince17 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_timesince18 (template_tests.filter_tests.test_timesince.TimesinceTests)\", \"test_apnumber (humanize_tests.tests.HumanizeTests)\", \"Allow html in output on i18n strings\", \"test_i18n_intcomma (humanize_tests.tests.HumanizeTests)\", \"test_i18n_intword (humanize_tests.tests.HumanizeTests)\", \"Translation of '%d day'/'%d month'/\\u2026 may differ depending on the context\", \"test_intcomma (humanize_tests.tests.HumanizeTests)\", \"test_intcomma_without_number_grouping (humanize_tests.tests.HumanizeTests)\", \"test_intword (humanize_tests.tests.HumanizeTests)\", \"test_l10n_intcomma (humanize_tests.tests.HumanizeTests)\", \"test_naturalday (humanize_tests.tests.HumanizeTests)\", \"test_naturalday_tz (humanize_tests.tests.HumanizeTests)\", \"test_naturalday_uses_localtime (humanize_tests.tests.HumanizeTests)\", \"test_naturaltime (humanize_tests.tests.HumanizeTests)\", \"#23340 -- Verify the documented behavior of humanize.naturaltime.\", \"test_ordinal (humanize_tests.tests.HumanizeTests)\"]",
  "environment_setup_commit": "0fbdb9784da915fce5dcc1fe82bac9b4785749e5",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.744887",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}