{
  "repo": "django/django",
  "instance_id": "django__django-14149",
  "base_commit": "a96c730431196b119559bbb18a0e85e6ee8b2597",
  "patch": "diff --git a/django/conf/__init__.py b/django/conf/__init__.py\n--- a/django/conf/__init__.py\n+++ b/django/conf/__init__.py\n@@ -141,6 +141,7 @@ def __init__(self, settings_module):\n         mod = importlib.import_module(self.SETTINGS_MODULE)\n \n         tuple_settings = (\n+            'ALLOWED_HOSTS',\n             \"INSTALLED_APPS\",\n             \"TEMPLATE_DIRS\",\n             \"LOCALE_PATHS\",\n",
  "test_patch": "diff --git a/tests/settings_tests/tests.py b/tests/settings_tests/tests.py\n--- a/tests/settings_tests/tests.py\n+++ b/tests/settings_tests/tests.py\n@@ -438,12 +438,13 @@ def test_settings_repr(self):\n         self.assertEqual(repr(lazy_settings), expected)\n \n \n-class TestListSettings(unittest.TestCase):\n+class TestListSettings(SimpleTestCase):\n     \"\"\"\n     Make sure settings that should be lists or tuples throw\n     ImproperlyConfigured if they are set to a string instead of a list or tuple.\n     \"\"\"\n     list_or_tuple_settings = (\n+        'ALLOWED_HOSTS',\n         \"INSTALLED_APPS\",\n         \"TEMPLATE_DIRS\",\n         \"LOCALE_PATHS\",\n@@ -452,11 +453,12 @@ class TestListSettings(unittest.TestCase):\n     def test_tuple_settings(self):\n         settings_module = ModuleType('fake_settings_module')\n         settings_module.SECRET_KEY = 'foo'\n+        msg = 'The %s setting must be a list or a tuple.'\n         for setting in self.list_or_tuple_settings:\n             setattr(settings_module, setting, ('non_list_or_tuple_value'))\n             sys.modules['fake_settings_module'] = settings_module\n             try:\n-                with self.assertRaises(ImproperlyConfigured):\n+                with self.assertRaisesMessage(ImproperlyConfigured, msg % setting):\n                     Settings('fake_settings_module')\n             finally:\n                 del sys.modules['fake_settings_module']\n",
  "problem_statement": "Validate the type of ALLOWED_HOSTS\nDescription\n\t\nPython has soft behavior for conducting iteration process over lists and over strings making them look the same:\n\tfor char_or_item in str_or_list:\n\t\t-- `char_or_item` can be character or list item\nIt would be better if it would have more strict behavior, for example,\n\tfor char in some_str.chars():\n\t\t-- now `char` can be only of string type and `list` class would not have `chars` method\nand for list\n\tfor item in some_list.list_items():\n\t\t-- `string` class would not have `list_items` method\nThis soft behavior usually leads to many nasty bugs to appear. Our two software engineers from our team wasted about 1 hour debugging the issue with ALLOWED_HOSTS being initialized with string in local_settings.py which is included at the end of settings.py. Django was matching each separate character of ALLOWED_HOSTS string against the \"Host:\" header from an incoming HTTP request.\nAn obvious self-suggesting solution is to add a new system check that will check the type of ALLOWED_HOSTS if it is string or not and notify the developer about possible improper configuration. I think blacklist checking (string or not) is more appropiate here, but I can be wrong.\n",
  "hints_text": "​PR I'm not sure if a system check is the way to go. The deployment checks must be run manually manage.py check --deploy. The developer might not do that as part of a debugging workflow.\nAlthough it may or may not have helped, I believe in general we should check as much configuration as possible up front. Another error I myself have made with ALLOWED_HOSTS is trying \"*.example.com\" instead of \".example.com\" (confusion with \"*\" being an allowed value) - this (or in general valid/invalid characters?) could also be checked for.\nI'm not opposed to some validation, my suggestion was merely that maybe we could be more helpful than a system check.\nSorry for the interfere but I would like to add my opinion on this. If this New Feature is added, then proportionate validations should apply on other settings.py variables (such as INTERNAL_IPS to be a list of valid IPs, STATIC_ROOT to be a string of valid pathname etc). See where it's going? I am not opposed on this improvement but if it's going to happen, IMO it should happen if not on the whole ​settings list, at least on most of them. Best regards, Nick\nHi, I've assigned this ticket to myself and would like to check my idea with you before writing any code. I'm not sure about what Nick Mavrakis stated, maybe that'd be a good idea. But sticking to this ticket, I believe the best way to proceed is checking the setting is both iterable and not a str. I would do so in two places: 1 - In runserver, where there's already one check related to ALLOWED_HOSTS 2 - As a deployment check, that would raise an error if the constraints are not satisfied. If you could confirm this would be the way to go, I'd be more than happy to add them in a PR.\nIt needs only be in one place, as a system check. runserver runs system checks at startup already. IMO it should not be a deployment check, as ALLOWED_HOSTS affects use of runserver locally too if DEBUG = False.\nHello, I am Akshat, new to this organisation and I would like to contribute on this bug. I do understand what rafis is trying to say here, but I don't understand how to proceed with fixing with this issue. Can someone tell me what files need to be modified or how to figure that out.\nWouldn't it be best to check if the entries in ALLOWED_HOSTS are actually valid hosts? So either IPv4/IPv6 Addresses or some dot separated string with valid characters. Maybe I didn't understand how the bug appeared. Or was it something like: # wrong ALLOWED_HOSTS=\"127.0.0.1\" vs. ALLOWED_HOSTS=[\"127.0.0.1\",] also, doesn't work a tuple too? thx for any hints giving me a better understanding...\nThe validation basically only needs to check it's an iterable of strings. Checking that everything looks like a hostname is very complicated - we also support wildcards. And it would probably break for someone out there using a proxy server or middleware that adds something not-quite-host-looking in the Host header.\nok, so here's what I came up with for the check: def check_allowedhosts(ALLOWED_HOSTS): if isinstance(ALLOWED_HOSTS,(list,tuple)): return all(isinstance(element,str) for element in ALLOWED_HOSTS) else: return False for this use-case all([]) returning True isn't really helpful, so the if else clause is needed I think ... but of course I'm happy to get hints for a better implementation. Besides, where would I put the check and the test?\nSee the PR linked in comment #1 for an intial implementation.\nI didn't see the PR earlier, thank you for pointing to it. Alright, so I could recreate or copy the PR, but there are things still open to discuss. Can someone point me in the right direction what Tim Graham is referring to? Like how could this be more helpful than a system check - maybe something that's hooked into a test run? (for a better understanding, I'm trying since yesterday my luck with \"easy picking\" issues to contribute something to Django - so please keep in mind I'm a beginner.)\nPersonally I think a system check would be fine. We point users to run them during deployment in the deplyoment checklist: ​https://docs.djangoproject.com/en/3.1/howto/deployment/checklist/\nwell, having an app running in production for several years now, I never knew this exists :P but, whatever - that's my responsibility. Anyways, I don't have a strong opinion on this, I'd just help closing this issue since I want to be some kind of contributor and head to the next issue. So, what needs to be done to merge this and close the issue?\nReplying to Marius Räsener: So, what needs to be done to merge this and close the issue? The second step is to send PR via GitHub.\nAlright, here is my PR :) ​https://github.com/django/django/pull/13927\nShould I ping this every ~24 hrs or what could be a good strategy?\nPlease refer to ​the contributing documentation to make sure your patch appears in the review queue. In this case you'll want to uncheck Patch needs improvement\nI hope that’s the right thing to do...\nI've recreated the PR and incorporated the feedback from the reviewers. It's ready for another review at ​https://github.com/django/django/pull/14149. Functionally i think it's good; the docs will need some review (especially if they needed to be included in other places)",
  "created_at": "2021-03-19T06:31:45Z",
  "version": "4.0",
  "FAIL_TO_PASS": "[\"test_tuple_settings (settings_tests.tests.TestListSettings)\"]",
  "PASS_TO_PASS": "[\"test_override_settings_inheritance (settings_tests.tests.ChildDecoratedTestCase)\", \"test_none (settings_tests.tests.SecureProxySslHeaderTest)\", \"test_set_with_xheader_right (settings_tests.tests.SecureProxySslHeaderTest)\", \"test_set_with_xheader_wrong (settings_tests.tests.SecureProxySslHeaderTest)\", \"test_set_without_xheader (settings_tests.tests.SecureProxySslHeaderTest)\", \"test_xheader_preferred_to_underlying_request (settings_tests.tests.SecureProxySslHeaderTest)\", \"test_max_recursion_error (settings_tests.tests.ClassDecoratedTestCaseSuper)\", \"Regression test for #19031\", \"test_configure (settings_tests.tests.IsOverriddenTest)\", \"test_evaluated_lazysettings_repr (settings_tests.tests.IsOverriddenTest)\", \"test_module (settings_tests.tests.IsOverriddenTest)\", \"test_override (settings_tests.tests.IsOverriddenTest)\", \"test_settings_repr (settings_tests.tests.IsOverriddenTest)\", \"test_unevaluated_lazysettings_repr (settings_tests.tests.IsOverriddenTest)\", \"test_usersettingsholder_repr (settings_tests.tests.IsOverriddenTest)\", \"test_already_configured (settings_tests.tests.SettingsTests)\", \"test_class_decorator (settings_tests.tests.SettingsTests)\", \"test_context_manager (settings_tests.tests.SettingsTests)\", \"test_decorator (settings_tests.tests.SettingsTests)\", \"test_incorrect_timezone (settings_tests.tests.SettingsTests)\", \"test_no_secret_key (settings_tests.tests.SettingsTests)\", \"test_no_settings_module (settings_tests.tests.SettingsTests)\", \"test_nonupper_settings_ignored_in_default_settings (settings_tests.tests.SettingsTests)\", \"test_nonupper_settings_prohibited_in_configure (settings_tests.tests.SettingsTests)\", \"test_override (settings_tests.tests.SettingsTests)\", \"test_override_change (settings_tests.tests.SettingsTests)\", \"test_override_doesnt_leak (settings_tests.tests.SettingsTests)\", \"Allow deletion of a setting in an overridden settings set (#18824)\", \"override_settings uses the actual _wrapped attribute at\", \"test_settings_delete (settings_tests.tests.SettingsTests)\", \"test_settings_delete_wrapped (settings_tests.tests.SettingsTests)\", \"test_signal_callback_context_manager (settings_tests.tests.SettingsTests)\", \"test_signal_callback_decorator (settings_tests.tests.SettingsTests)\", \"test_method_override (settings_tests.tests.FullyDecoratedTestCase)\", \"test_override (settings_tests.tests.FullyDecoratedTestCase)\", \"Overriding a method on a super class and then calling that method on\", \"test_method_override (settings_tests.tests.ClassDecoratedTestCase)\", \"test_override (settings_tests.tests.ClassDecoratedTestCase)\", \"Settings are overridden within setUpClass (#21281).\", \"test_add_script_name_prefix (settings_tests.tests.MediaURLStaticURLPrefixTest)\", \"test_not_prefixed (settings_tests.tests.MediaURLStaticURLPrefixTest)\", \"test_decorated_testcase_module (settings_tests.tests.FullyDecoratedTranTestCase)\", \"test_decorated_testcase_name (settings_tests.tests.FullyDecoratedTranTestCase)\", \"test_method_list_override (settings_tests.tests.FullyDecoratedTranTestCase)\", \"test_method_list_override_nested_order (settings_tests.tests.FullyDecoratedTranTestCase)\", \"test_method_list_override_no_ops (settings_tests.tests.FullyDecoratedTranTestCase)\", \"test_method_list_override_strings (settings_tests.tests.FullyDecoratedTranTestCase)\", \"test_method_override (settings_tests.tests.FullyDecoratedTranTestCase)\", \"test_override (settings_tests.tests.FullyDecoratedTranTestCase)\", \"Receiver fails on both enter and exit.\", \"Receiver fails on enter only.\", \"Receiver fails on exit only.\", \"Error is raised correctly when reusing the same override_settings\"]",
  "environment_setup_commit": "475cffd1d64c690cdad16ede4d5e81985738ceb4",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.682577",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}