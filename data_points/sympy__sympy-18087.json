{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-18087",
  "base_commit": "9da013ad0ddc3cd96fe505f2e47c63e372040916",
  "patch": "diff --git a/sympy/core/exprtools.py b/sympy/core/exprtools.py\n--- a/sympy/core/exprtools.py\n+++ b/sympy/core/exprtools.py\n@@ -358,8 +358,8 @@ def __init__(self, factors=None):  # Factors\n             for f in list(factors.keys()):\n                 if isinstance(f, Rational) and not isinstance(f, Integer):\n                     p, q = Integer(f.p), Integer(f.q)\n-                    factors[p] = (factors[p] if p in factors else 0) + factors[f]\n-                    factors[q] = (factors[q] if q in factors else 0) - factors[f]\n+                    factors[p] = (factors[p] if p in factors else S.Zero) + factors[f]\n+                    factors[q] = (factors[q] if q in factors else S.Zero) - factors[f]\n                     factors.pop(f)\n             if i:\n                 factors[I] = S.One*i\n@@ -448,14 +448,12 @@ def as_expr(self):  # Factors\n         args = []\n         for factor, exp in self.factors.items():\n             if exp != 1:\n-                b, e = factor.as_base_exp()\n-                if isinstance(exp, int):\n-                    e = _keep_coeff(Integer(exp), e)\n-                elif isinstance(exp, Rational):\n+                if isinstance(exp, Integer):\n+                    b, e = factor.as_base_exp()\n                     e = _keep_coeff(exp, e)\n+                    args.append(b**e)\n                 else:\n-                    e *= exp\n-                args.append(b**e)\n+                    args.append(factor**exp)\n             else:\n                 args.append(factor)\n         return Mul(*args)\n",
  "test_patch": "diff --git a/sympy/core/tests/test_exprtools.py b/sympy/core/tests/test_exprtools.py\n--- a/sympy/core/tests/test_exprtools.py\n+++ b/sympy/core/tests/test_exprtools.py\n@@ -27,6 +27,8 @@ def test_Factors():\n     assert Factors({x: 2, y: 3, sin(x): 4}).as_expr() == x**2*y**3*sin(x)**4\n     assert Factors(S.Infinity) == Factors({oo: 1})\n     assert Factors(S.NegativeInfinity) == Factors({oo: 1, -1: 1})\n+    # issue #18059:\n+    assert Factors((x**2)**S.Half).as_expr() == (x**2)**S.Half\n \n     a = Factors({x: 5, y: 3, z: 7})\n     b = Factors({      y: 4, z: 3, t: 10})\ndiff --git a/sympy/simplify/tests/test_fu.py b/sympy/simplify/tests/test_fu.py\n--- a/sympy/simplify/tests/test_fu.py\n+++ b/sympy/simplify/tests/test_fu.py\n@@ -276,6 +276,9 @@ def test_fu():\n     expr = Mul(*[cos(2**i) for i in range(10)])\n     assert fu(expr) == sin(1024)/(1024*sin(1))\n \n+    # issue #18059:\n+    assert fu(cos(x) + sqrt(sin(x)**2)) == cos(x) + sqrt(sin(x)**2)\n+\n \n def test_objective():\n     assert fu(sin(x)/cos(x), measure=lambda x: x.count_ops()) == \\\n",
  "problem_statement": "Simplify of simple trig expression fails\ntrigsimp in various versions, including 1.5, incorrectly simplifies cos(x)+sqrt(sin(x)**2) as though it were cos(x)+sin(x) for general complex x. (Oddly it gets this right if x is real.)\r\n\r\nEmbarrassingly I found this by accident while writing sympy-based teaching material...\r\n\n",
  "hints_text": "I guess you mean this:\r\n```julia\r\nIn [16]: cos(x) + sqrt(sin(x)**2)                                                                                                 \r\nOut[16]: \r\n   _________         \r\n  ╱    2             \r\n╲╱  sin (x)  + cos(x)\r\n\r\nIn [17]: simplify(cos(x) + sqrt(sin(x)**2))                                                                                       \r\nOut[17]: \r\n      ⎛    π⎞\r\n√2⋅sin⎜x + ─⎟\r\n      ⎝    4⎠\r\n```\r\nWhich is incorrect if `sin(x)` is negative:\r\n```julia\r\nIn [27]: (cos(x) + sqrt(sin(x)**2)).evalf(subs={x:-1})                                                                            \r\nOut[27]: 1.38177329067604\r\n\r\nIn [28]: simplify(cos(x) + sqrt(sin(x)**2)).evalf(subs={x:-1})                                                                    \r\nOut[28]: -0.301168678939757\r\n```\r\nFor real x this works because the sqrt auto simplifies to abs before simplify is called:\r\n```julia\r\nIn [18]: x = Symbol('x', real=True)                                                                                               \r\n\r\nIn [19]: simplify(cos(x) + sqrt(sin(x)**2))                                                                                       \r\nOut[19]: cos(x) + │sin(x)│\r\n\r\nIn [20]: cos(x) + sqrt(sin(x)**2)                                                                                                 \r\nOut[20]: cos(x) + │sin(x)│\r\n```\nYes, that's the issue I mean.\n`fu` and `trigsimp` return the same erroneous simplification. All three simplification functions end up in Fu's `TR10i()` and this is what it returns:\r\n```\r\nIn [5]: from sympy.simplify.fu import *\r\n\r\nIn [6]: e = cos(x) + sqrt(sin(x)**2)\r\n\r\nIn [7]: TR10i(sqrt(sin(x)**2))\r\nOut[7]: \r\n   _________\r\n  ╱    2    \r\n╲╱  sin (x) \r\n\r\nIn [8]: TR10i(e)\r\nOut[8]: \r\n      ⎛    π⎞\r\n√2⋅sin⎜x + ─⎟\r\n      ⎝    4⎠\r\n```\r\nThe other `TR*` functions keep the `sqrt` around, it's only `TR10i` that mishandles it. (Or it's called with an expression outside its scope of application...)\nI tracked down where the invalid simplification of `sqrt(x**2)` takes place or at least I think so:\r\n`TR10i` calls `trig_split` (also in fu.py) where the line\r\nhttps://github.com/sympy/sympy/blob/0d99c52566820e9a5bb72eaec575fce7c0df4782/sympy/simplify/fu.py#L1901\r\nin essence applies `._as_expr()` to `Factors({sin(x)**2: S.Half})` which then returns `sin(x)`.\r\n\r\nIf I understand `Factors` (sympy.core.exprtools) correctly, its intent is to have an efficient internal representation of products and `.as_expr()` is supposed to reconstruct a standard expression from such a representation. But here's what it does to a general complex variable `x`:\r\n```\r\nIn [21]: Factors(sqrt(x**2))\r\nOut[21]: Factors({x**2: 1/2})\r\nIn [22]: _.as_expr()\r\nOut[22]: x\r\n```\r\nIt seems line 455 below\r\nhttps://github.com/sympy/sympy/blob/0d99c52566820e9a5bb72eaec575fce7c0df4782/sympy/core/exprtools.py#L449-L458\r\nunconditionally multiplies exponents if a power of a power is encountered. However this is not generally valid for non-integer exponents...\r\n\r\nAnd line 457 does the same for other non-integer exponents:\r\n```\r\nIn [23]: Factors((x**y)**z)\r\nOut[23]: Factors({x**y: z})\r\n\r\nIn [24]: _.as_expr()\r\nOut[24]:\r\n y⋅z\r\nx\r\n```",
  "created_at": "2019-12-20T12:38:00Z",
  "version": "1.6",
  "FAIL_TO_PASS": "[\"test_Factors\", \"test_fu\"]",
  "PASS_TO_PASS": "[\"test_decompose_power\", \"test_Term\", \"test_gcd_terms\", \"test_factor_terms\", \"test_xreplace\", \"test_factor_nc\", \"test_issue_6360\", \"test_issue_7903\", \"test_issue_8263\", \"test_monotonic_sign\", \"test_TR1\", \"test_TR2\", \"test_TR2i\", \"test_TR3\", \"test__TR56\", \"test_TR5\", \"test_TR6\", \"test_TR7\", \"test_TR8\", \"test_TR9\", \"test_TR10\", \"test_TR10i\", \"test_TR11\", \"test_TR12\", \"test_TR13\", \"test_L\", \"test_objective\", \"test_process_common_addends\", \"test_trig_split\", \"test_TRmorrie\", \"test_TRpower\", \"test_hyper_as_trig\", \"test_TR12i\", \"test_TR14\", \"test_TR15_16_17\"]",
  "environment_setup_commit": "28b41c73c12b70d6ad9f6e45109a80649c4456da",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:31.119899",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}