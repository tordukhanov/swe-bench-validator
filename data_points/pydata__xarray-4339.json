{
  "repo": "pydata/xarray",
  "instance_id": "pydata__xarray-4339",
  "base_commit": "3b5a8ee46be7fd00d7ea9093d1941cb6c3be191c",
  "patch": "diff --git a/xarray/core/accessor_str.py b/xarray/core/accessor_str.py\n--- a/xarray/core/accessor_str.py\n+++ b/xarray/core/accessor_str.py\n@@ -90,7 +90,7 @@ def _apply(self, f, dtype=None):\n \n     def len(self):\n         \"\"\"\n-        Compute the length of each element in the array.\n+        Compute the length of each string in the array.\n \n         Returns\n         -------\n@@ -104,9 +104,9 @@ def __getitem__(self, key):\n         else:\n             return self.get(key)\n \n-    def get(self, i):\n+    def get(self, i, default=\"\"):\n         \"\"\"\n-        Extract element from indexable in each element in the array.\n+        Extract character number `i` from each string in the array.\n \n         Parameters\n         ----------\n@@ -120,12 +120,18 @@ def get(self, i):\n         -------\n         items : array of objects\n         \"\"\"\n-        obj = slice(-1, None) if i == -1 else slice(i, i + 1)\n-        return self._apply(lambda x: x[obj])\n+        s = slice(-1, None) if i == -1 else slice(i, i + 1)\n+\n+        def f(x):\n+            item = x[s]\n+\n+            return item if item else default\n+\n+        return self._apply(f)\n \n     def slice(self, start=None, stop=None, step=None):\n         \"\"\"\n-        Slice substrings from each element in the array.\n+        Slice substrings from each string in the array.\n \n         Parameters\n         ----------\n@@ -359,7 +365,7 @@ def count(self, pat, flags=0):\n \n     def startswith(self, pat):\n         \"\"\"\n-        Test if the start of each string element matches a pattern.\n+        Test if the start of each string in the array matches a pattern.\n \n         Parameters\n         ----------\n@@ -378,7 +384,7 @@ def startswith(self, pat):\n \n     def endswith(self, pat):\n         \"\"\"\n-        Test if the end of each string element matches a pattern.\n+        Test if the end of each string in the array matches a pattern.\n \n         Parameters\n         ----------\n@@ -432,8 +438,7 @@ def pad(self, width, side=\"left\", fillchar=\" \"):\n \n     def center(self, width, fillchar=\" \"):\n         \"\"\"\n-        Filling left and right side of strings in the array with an\n-        additional character.\n+        Pad left and right side of each string in the array.\n \n         Parameters\n         ----------\n@@ -451,8 +456,7 @@ def center(self, width, fillchar=\" \"):\n \n     def ljust(self, width, fillchar=\" \"):\n         \"\"\"\n-        Filling right side of strings in the array with an additional\n-        character.\n+        Pad right side of each string in the array.\n \n         Parameters\n         ----------\n@@ -470,7 +474,7 @@ def ljust(self, width, fillchar=\" \"):\n \n     def rjust(self, width, fillchar=\" \"):\n         \"\"\"\n-        Filling left side of strings in the array with an additional character.\n+        Pad left side of each string in the array.\n \n         Parameters\n         ----------\n@@ -488,7 +492,7 @@ def rjust(self, width, fillchar=\" \"):\n \n     def zfill(self, width):\n         \"\"\"\n-        Pad strings in the array by prepending '0' characters.\n+        Pad each string in the array by prepending '0' characters.\n \n         Strings in the array are padded with '0' characters on the\n         left of the string to reach a total string length  `width`. Strings\n@@ -508,7 +512,7 @@ def zfill(self, width):\n \n     def contains(self, pat, case=True, flags=0, regex=True):\n         \"\"\"\n-        Test if pattern or regex is contained within a string of the array.\n+        Test if pattern or regex is contained within each string of the array.\n \n         Return boolean array based on whether a given pattern or regex is\n         contained within a string of the array.\n@@ -554,7 +558,7 @@ def contains(self, pat, case=True, flags=0, regex=True):\n \n     def match(self, pat, case=True, flags=0):\n         \"\"\"\n-        Determine if each string matches a regular expression.\n+        Determine if each string in the array matches a regular expression.\n \n         Parameters\n         ----------\n@@ -613,7 +617,7 @@ def strip(self, to_strip=None, side=\"both\"):\n \n     def lstrip(self, to_strip=None):\n         \"\"\"\n-        Remove leading and trailing characters.\n+        Remove leading characters.\n \n         Strip whitespaces (including newlines) or a set of specified characters\n         from each string in the array from the left side.\n@@ -633,7 +637,7 @@ def lstrip(self, to_strip=None):\n \n     def rstrip(self, to_strip=None):\n         \"\"\"\n-        Remove leading and trailing characters.\n+        Remove trailing characters.\n \n         Strip whitespaces (including newlines) or a set of specified characters\n         from each string in the array from the right side.\n@@ -653,8 +657,7 @@ def rstrip(self, to_strip=None):\n \n     def wrap(self, width, **kwargs):\n         \"\"\"\n-        Wrap long strings in the array to be formatted in paragraphs with\n-        length less than a given width.\n+        Wrap long strings in the array in paragraphs with length less than `width`.\n \n         This method has the same keyword parameters and defaults as\n         :class:`textwrap.TextWrapper`.\n@@ -663,38 +666,20 @@ def wrap(self, width, **kwargs):\n         ----------\n         width : int\n             Maximum line-width\n-        expand_tabs : bool, optional\n-            If true, tab characters will be expanded to spaces (default: True)\n-        replace_whitespace : bool, optional\n-            If true, each whitespace character (as defined by\n-            string.whitespace) remaining after tab expansion will be replaced\n-            by a single space (default: True)\n-        drop_whitespace : bool, optional\n-            If true, whitespace that, after wrapping, happens to end up at the\n-            beginning or end of a line is dropped (default: True)\n-        break_long_words : bool, optional\n-            If true, then words longer than width will be broken in order to\n-            ensure that no lines are longer than width. If it is false, long\n-            words will not be broken, and some lines may be longer than width.\n-            (default: True)\n-        break_on_hyphens : bool, optional\n-            If true, wrapping will occur preferably on whitespace and right\n-            after hyphens in compound words, as it is customary in English. If\n-            false, only whitespaces will be considered as potentially good\n-            places for line breaks, but you need to set break_long_words to\n-            false if you want truly insecable words. (default: True)\n+        **kwargs\n+            keyword arguments passed into :class:`textwrap.TextWrapper`.\n \n         Returns\n         -------\n         wrapped : same type as values\n         \"\"\"\n-        tw = textwrap.TextWrapper(width=width)\n+        tw = textwrap.TextWrapper(width=width, **kwargs)\n         f = lambda x: \"\\n\".join(tw.wrap(x))\n         return self._apply(f)\n \n     def translate(self, table):\n         \"\"\"\n-        Map all characters in the string through the given mapping table.\n+        Map characters of each string through the given mapping table.\n \n         Parameters\n         ----------\n",
  "test_patch": "diff --git a/xarray/tests/test_accessor_str.py b/xarray/tests/test_accessor_str.py\n--- a/xarray/tests/test_accessor_str.py\n+++ b/xarray/tests/test_accessor_str.py\n@@ -596,7 +596,7 @@ def test_wrap():\n     )\n \n     # expected values\n-    xp = xr.DataArray(\n+    expected = xr.DataArray(\n         [\n             \"hello world\",\n             \"hello world!\",\n@@ -610,15 +610,29 @@ def test_wrap():\n         ]\n     )\n \n-    rs = values.str.wrap(12, break_long_words=True)\n-    assert_equal(rs, xp)\n+    result = values.str.wrap(12, break_long_words=True)\n+    assert_equal(result, expected)\n \n     # test with pre and post whitespace (non-unicode), NaN, and non-ascii\n     # Unicode\n     values = xr.DataArray([\"  pre  \", \"\\xac\\u20ac\\U00008000 abadcafe\"])\n-    xp = xr.DataArray([\"  pre\", \"\\xac\\u20ac\\U00008000 ab\\nadcafe\"])\n-    rs = values.str.wrap(6)\n-    assert_equal(rs, xp)\n+    expected = xr.DataArray([\"  pre\", \"\\xac\\u20ac\\U00008000 ab\\nadcafe\"])\n+    result = values.str.wrap(6)\n+    assert_equal(result, expected)\n+\n+\n+def test_wrap_kwargs_passed():\n+    # GH4334\n+\n+    values = xr.DataArray(\"  hello world  \")\n+\n+    result = values.str.wrap(7)\n+    expected = xr.DataArray(\"  hello\\nworld\")\n+    assert_equal(result, expected)\n+\n+    result = values.str.wrap(7, drop_whitespace=False)\n+    expected = xr.DataArray(\"  hello\\n world\\n  \")\n+    assert_equal(result, expected)\n \n \n def test_get(dtype):\n@@ -642,6 +656,15 @@ def test_get(dtype):\n     assert_equal(result, expected)\n \n \n+def test_get_default(dtype):\n+    # GH4334\n+    values = xr.DataArray([\"a_b\", \"c\", \"\"]).astype(dtype)\n+\n+    result = values.str.get(2, \"default\")\n+    expected = xr.DataArray([\"b\", \"default\", \"default\"]).astype(dtype)\n+    assert_equal(result, expected)\n+\n+\n def test_encode_decode():\n     data = xr.DataArray([\"a\", \"b\", \"a\\xe4\"])\n     encoded = data.str.encode(\"utf-8\")\n",
  "problem_statement": "missing parameter in DataArray.str.get\nWhile working on #4286 I noticed that the docstring of `DataArray.str.get` claims to allow passing a default value in addition to the index, but the python code doesn't have that parameter at all.\r\nI think the default value is a good idea and that we should make the code match the docstring.\n",
  "hints_text": "Similarly `str.wrap` does not pass on its `kwargs`\r\n\r\nhttps://github.com/pydata/xarray/blob/7daad4fce3bf8ad9b9bc8e7baa104c476437e68d/xarray/core/accessor_str.py#L654",
  "created_at": "2020-08-14T14:09:56Z",
  "version": "0.12",
  "FAIL_TO_PASS": "[\"xarray/tests/test_accessor_str.py::test_wrap_kwargs_passed\", \"xarray/tests/test_accessor_str.py::test_get_default[str_]\", \"xarray/tests/test_accessor_str.py::test_get_default[bytes_]\"]",
  "PASS_TO_PASS": "[\"xarray/tests/test_accessor_str.py::test_dask\", \"xarray/tests/test_accessor_str.py::test_count[str_]\", \"xarray/tests/test_accessor_str.py::test_count[bytes_]\", \"xarray/tests/test_accessor_str.py::test_contains[str_]\", \"xarray/tests/test_accessor_str.py::test_contains[bytes_]\", \"xarray/tests/test_accessor_str.py::test_starts_ends_with[str_]\", \"xarray/tests/test_accessor_str.py::test_starts_ends_with[bytes_]\", \"xarray/tests/test_accessor_str.py::test_case[str_]\", \"xarray/tests/test_accessor_str.py::test_case[bytes_]\", \"xarray/tests/test_accessor_str.py::test_replace[str_]\", \"xarray/tests/test_accessor_str.py::test_replace[bytes_]\", \"xarray/tests/test_accessor_str.py::test_replace_callable\", \"xarray/tests/test_accessor_str.py::test_replace_unicode\", \"xarray/tests/test_accessor_str.py::test_replace_compiled_regex[str_]\", \"xarray/tests/test_accessor_str.py::test_replace_compiled_regex[bytes_]\", \"xarray/tests/test_accessor_str.py::test_replace_literal[str_]\", \"xarray/tests/test_accessor_str.py::test_replace_literal[bytes_]\", \"xarray/tests/test_accessor_str.py::test_repeat[str_]\", \"xarray/tests/test_accessor_str.py::test_repeat[bytes_]\", \"xarray/tests/test_accessor_str.py::test_match[str_]\", \"xarray/tests/test_accessor_str.py::test_match[bytes_]\", \"xarray/tests/test_accessor_str.py::test_empty_str_methods\", \"xarray/tests/test_accessor_str.py::test_ismethods[str_]\", \"xarray/tests/test_accessor_str.py::test_ismethods[bytes_]\", \"xarray/tests/test_accessor_str.py::test_isnumeric\", \"xarray/tests/test_accessor_str.py::test_len[str_]\", \"xarray/tests/test_accessor_str.py::test_len[bytes_]\", \"xarray/tests/test_accessor_str.py::test_find[str_]\", \"xarray/tests/test_accessor_str.py::test_find[bytes_]\", \"xarray/tests/test_accessor_str.py::test_index[str_]\", \"xarray/tests/test_accessor_str.py::test_index[bytes_]\", \"xarray/tests/test_accessor_str.py::test_pad[str_]\", \"xarray/tests/test_accessor_str.py::test_pad[bytes_]\", \"xarray/tests/test_accessor_str.py::test_pad_fillchar[str_]\", \"xarray/tests/test_accessor_str.py::test_pad_fillchar[bytes_]\", \"xarray/tests/test_accessor_str.py::test_translate\", \"xarray/tests/test_accessor_str.py::test_center_ljust_rjust[str_]\", \"xarray/tests/test_accessor_str.py::test_center_ljust_rjust[bytes_]\", \"xarray/tests/test_accessor_str.py::test_center_ljust_rjust_fillchar[str_]\", \"xarray/tests/test_accessor_str.py::test_center_ljust_rjust_fillchar[bytes_]\", \"xarray/tests/test_accessor_str.py::test_zfill[str_]\", \"xarray/tests/test_accessor_str.py::test_zfill[bytes_]\", \"xarray/tests/test_accessor_str.py::test_slice[str_]\", \"xarray/tests/test_accessor_str.py::test_slice[bytes_]\", \"xarray/tests/test_accessor_str.py::test_slice_replace[str_]\", \"xarray/tests/test_accessor_str.py::test_slice_replace[bytes_]\", \"xarray/tests/test_accessor_str.py::test_strip_lstrip_rstrip[str_]\", \"xarray/tests/test_accessor_str.py::test_strip_lstrip_rstrip[bytes_]\", \"xarray/tests/test_accessor_str.py::test_strip_lstrip_rstrip_args[str_]\", \"xarray/tests/test_accessor_str.py::test_strip_lstrip_rstrip_args[bytes_]\", \"xarray/tests/test_accessor_str.py::test_wrap\", \"xarray/tests/test_accessor_str.py::test_get[str_]\", \"xarray/tests/test_accessor_str.py::test_get[bytes_]\", \"xarray/tests/test_accessor_str.py::test_encode_decode\", \"xarray/tests/test_accessor_str.py::test_encode_decode_errors\"]",
  "environment_setup_commit": "1c198a191127c601d091213c4b3292a8bb3054e1",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.878107",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}