{
  "repo": "mwaskom/seaborn",
  "instance_id": "mwaskom__seaborn-2946",
  "base_commit": "a1ede5eb82fa09164aff65da03136b7382fd5041",
  "patch": "diff --git a/seaborn/_statistics.py b/seaborn/_statistics.py\n--- a/seaborn/_statistics.py\n+++ b/seaborn/_statistics.py\n@@ -478,7 +478,12 @@ def __init__(self, estimator, errorbar=None, **boot_kws):\n     def __call__(self, data, var):\n         \"\"\"Aggregate over `var` column of `data` with estimate and error interval.\"\"\"\n         vals = data[var]\n-        estimate = vals.agg(self.estimator)\n+        if callable(self.estimator):\n+            # You would think we could pass to vals.agg, and yet:\n+            # https://github.com/mwaskom/seaborn/issues/2943\n+            estimate = self.estimator(vals)\n+        else:\n+            estimate = vals.agg(self.estimator)\n \n         # Options that produce no error bars\n         if self.error_method is None:\n",
  "test_patch": "diff --git a/tests/test_statistics.py b/tests/test_statistics.py\n--- a/tests/test_statistics.py\n+++ b/tests/test_statistics.py\n@@ -499,6 +499,15 @@ def test_name_estimator(self, long_df):\n         out = agg(long_df, \"x\")\n         assert out[\"x\"] == long_df[\"x\"].mean()\n \n+    def test_custom_func_estimator(self, long_df):\n+\n+        def func(x):\n+            return np.asarray(x).min()\n+\n+        agg = EstimateAggregator(func)\n+        out = agg(long_df, \"x\")\n+        assert out[\"x\"] == func(long_df[\"x\"])\n+\n     def test_se_errorbars(self, long_df):\n \n         agg = EstimateAggregator(\"mean\", \"se\")\n",
  "problem_statement": "Regression: `pointplot` and `barplot` raise when using a custom estimator\nThis may be related to #2866 . According to `pointplot` (and `barplot`) documentation, the `estimator` can be any callable that maps vector to scalar. However, the following example raises with `'0.12.0.dev0'` on my Windows and Mac machines (and doesn't raise with `'0.11.2'`):\r\n```python\r\nimport seaborn as sns\r\nimport numpy as np\r\ntips = sns.load_dataset(\"tips\")\r\n\r\ndef custom_min(x):\r\n    return float(np.asarray(x).min())\r\n\r\nax = sns.pointplot(x=\"day\", y=\"tip\", data=tips, estimator=custom_min)\r\n```\r\n\r\n<details><summary>Exception</summary>\r\n\r\n```\r\nC:\\Users\\admin\\seaborn\\seaborn\\categorical.py:1491: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\r\n  self.statistic = np.array(statistic)\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\admin\\miniconda3\\lib\\site-packages\\pandas\\core\\series.py\", line 191, in wrapper\r\n    raise TypeError(f\"cannot convert the series to {converter}\")\r\nTypeError: cannot convert the series to <class 'float'>\r\n```\r\n\r\n</details>\r\n\r\nIt does work, however, when changing the `custom_min` function to use the builtin `min` func:\r\n```python\r\nimport seaborn as sns\r\nimport numpy as np\r\ntips = sns.load_dataset(\"tips\")\r\n\r\ndef custom_min(x):\r\n    return float(min(x))\r\n\r\nax = sns.pointplot(x=\"day\", y=\"tip\", data=tips, estimator=custom_min)\r\n```\r\n\r\nThe same error is raised when changing the example code to use `barplot`, or when using a different numpy aggregator within the custom function.\n",
  "hints_text": "Thanks for reporting, I can reproduce. This is a weird one!\nI think this is the fundamental issue, and I do not understand what pandas as doing here:\r\n\r\n```python\r\ndef custom_min_asarray(x):\r\n    return np.asarray(x).min()\r\ntips[\"tip\"].agg(custom_min_asarray)\r\n```\r\n```\r\n0      1.01\r\n1      1.66\r\n2      3.50\r\n3      3.31\r\n4      3.61\r\n       ... \r\n239    5.92\r\n240    2.00\r\n241    2.00\r\n242    1.75\r\n243    3.00\r\nName: tip, Length: 244, dtype: float64\r\n```\r\n\r\n```python\r\ndef custom_min_native(x):\r\n    return x.min()\r\ntips[\"tip\"].agg(custom_min_native)\r\n```\r\n```\r\n1.0\r\n```\nOK I think I kind of understand, but also wtf. I gather that `Series.agg(f)` first tries `Series.apply(f)`. That passes numbers into the function so, if you're calling a numeric method, it fails. But `np.asarray(x).min()` where x is a scalar will produce a 0-dimensional array and then call `.min()` on it, which is valid. So `.agg` doesn't actually reduce, which then blows up downstream.\r\n\r\nArgh.\nI think we ran into https://github.com/pandas-dev/pandas/issues/46581 , as seaborn does `Series.agg` here: https://github.com/mwaskom/seaborn/blob/9771eae42a802f898f95c6b062f036bd7940e6b4/seaborn/_statistics.py#L481\r\nThis explains the change from 0.11.2 which was calling the estimator with the series as input:\r\nhttps://github.com/mwaskom/seaborn/blob/10fc8d74e7686ead56e6f621413926114d470daa/seaborn/categorical.py#L1520\r\n\nYep the intention of that change was to support `estimator: str` in a clean way. I guess we can change it to something like\r\n\r\n```python\r\nif callable(self.estimator):\r\n    estimate = self.estimator(vals)\r\nelse:\r\n    estimate = vals.agg(self.estimator)\r\n```",
  "created_at": "2022-08-08T10:48:52Z",
  "version": "0.12",
  "FAIL_TO_PASS": "[\"tests/test_statistics.py::TestEstimateAggregator::test_custom_func_estimator\"]",
  "PASS_TO_PASS": "[\"tests/test_statistics.py::TestKDE::test_gridsize\", \"tests/test_statistics.py::TestKDE::test_cut\", \"tests/test_statistics.py::TestKDE::test_clip\", \"tests/test_statistics.py::TestKDE::test_density_normalization\", \"tests/test_statistics.py::TestKDE::test_cumulative\", \"tests/test_statistics.py::TestKDE::test_cached_support\", \"tests/test_statistics.py::TestKDE::test_bw_method\", \"tests/test_statistics.py::TestKDE::test_bw_adjust\", \"tests/test_statistics.py::TestKDE::test_bivariate_grid\", \"tests/test_statistics.py::TestKDE::test_bivariate_normalization\", \"tests/test_statistics.py::TestKDE::test_bivariate_cumulative\", \"tests/test_statistics.py::TestHistogram::test_string_bins\", \"tests/test_statistics.py::TestHistogram::test_int_bins\", \"tests/test_statistics.py::TestHistogram::test_array_bins\", \"tests/test_statistics.py::TestHistogram::test_bivariate_string_bins\", \"tests/test_statistics.py::TestHistogram::test_bivariate_int_bins\", \"tests/test_statistics.py::TestHistogram::test_bivariate_array_bins\", \"tests/test_statistics.py::TestHistogram::test_binwidth\", \"tests/test_statistics.py::TestHistogram::test_bivariate_binwidth\", \"tests/test_statistics.py::TestHistogram::test_binrange\", \"tests/test_statistics.py::TestHistogram::test_bivariate_binrange\", \"tests/test_statistics.py::TestHistogram::test_discrete_bins\", \"tests/test_statistics.py::TestHistogram::test_odd_single_observation\", \"tests/test_statistics.py::TestHistogram::test_binwidth_roundoff\", \"tests/test_statistics.py::TestHistogram::test_histogram\", \"tests/test_statistics.py::TestHistogram::test_count_stat\", \"tests/test_statistics.py::TestHistogram::test_density_stat\", \"tests/test_statistics.py::TestHistogram::test_probability_stat\", \"tests/test_statistics.py::TestHistogram::test_frequency_stat\", \"tests/test_statistics.py::TestHistogram::test_cumulative_count\", \"tests/test_statistics.py::TestHistogram::test_cumulative_density\", \"tests/test_statistics.py::TestHistogram::test_cumulative_probability\", \"tests/test_statistics.py::TestHistogram::test_cumulative_frequency\", \"tests/test_statistics.py::TestHistogram::test_bivariate_histogram\", \"tests/test_statistics.py::TestHistogram::test_bivariate_count_stat\", \"tests/test_statistics.py::TestHistogram::test_bivariate_density_stat\", \"tests/test_statistics.py::TestHistogram::test_bivariate_probability_stat\", \"tests/test_statistics.py::TestHistogram::test_bivariate_frequency_stat\", \"tests/test_statistics.py::TestHistogram::test_bivariate_cumulative_count\", \"tests/test_statistics.py::TestHistogram::test_bivariate_cumulative_density\", \"tests/test_statistics.py::TestHistogram::test_bivariate_cumulative_frequency\", \"tests/test_statistics.py::TestHistogram::test_bivariate_cumulative_probability\", \"tests/test_statistics.py::TestHistogram::test_bad_stat\", \"tests/test_statistics.py::TestECDF::test_univariate_proportion\", \"tests/test_statistics.py::TestECDF::test_univariate_count\", \"tests/test_statistics.py::TestECDF::test_univariate_proportion_weights\", \"tests/test_statistics.py::TestECDF::test_univariate_count_weights\", \"tests/test_statistics.py::TestECDF::test_invalid_stat\", \"tests/test_statistics.py::TestECDF::test_bivariate_error\", \"tests/test_statistics.py::TestEstimateAggregator::test_func_estimator\", \"tests/test_statistics.py::TestEstimateAggregator::test_name_estimator\", \"tests/test_statistics.py::TestEstimateAggregator::test_se_errorbars\", \"tests/test_statistics.py::TestEstimateAggregator::test_sd_errorbars\", \"tests/test_statistics.py::TestEstimateAggregator::test_pi_errorbars\", \"tests/test_statistics.py::TestEstimateAggregator::test_ci_errorbars\", \"tests/test_statistics.py::TestEstimateAggregator::test_custom_errorbars\", \"tests/test_statistics.py::TestEstimateAggregator::test_singleton_errorbars\", \"tests/test_statistics.py::TestEstimateAggregator::test_errorbar_validation\"]",
  "environment_setup_commit": "d25872b0fc99dbf7e666a91f59bd4ed125186aa1",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.836285",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}