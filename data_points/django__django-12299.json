{
  "repo": "django/django",
  "instance_id": "django__django-12299",
  "base_commit": "f600e3fad6e92d9fe1ad8b351dc8446415f24345",
  "patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -711,6 +711,7 @@ def in_bulk(self, id_list=None, *, field_name='pk'):\n \n     def delete(self):\n         \"\"\"Delete the records in the current QuerySet.\"\"\"\n+        self._not_support_combined_queries('delete')\n         assert not self.query.is_sliced, \\\n             \"Cannot use 'limit' or 'offset' with delete.\"\n \n@@ -756,6 +757,7 @@ def update(self, **kwargs):\n         Update all elements in the current QuerySet, setting all the given\n         fields to the appropriate values.\n         \"\"\"\n+        self._not_support_combined_queries('update')\n         assert not self.query.is_sliced, \\\n             \"Cannot update a query once a slice has been taken.\"\n         self._for_write = True\n",
  "test_patch": "diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py\n--- a/tests/queries/test_qs_combinators.py\n+++ b/tests/queries/test_qs_combinators.py\n@@ -272,12 +272,14 @@ def test_unsupported_operations_on_combined_qs(self):\n             for operation in (\n                 'annotate',\n                 'defer',\n+                'delete',\n                 'exclude',\n                 'extra',\n                 'filter',\n                 'only',\n                 'prefetch_related',\n                 'select_related',\n+                'update',\n             ):\n                 with self.subTest(combinator=combinator, operation=operation):\n                     with self.assertRaisesMessage(\n",
  "problem_statement": "Raise a descriptive error on update()/delete() operations following QuerySet.union(), intersection(), and difference().\nDescription\n\t \n\t\t(last modified by Joon Hwan 김준환)\n\t \nb_filter() seems to merge but does not apply to the actual update\nq = M.objects.none()\nq = q.union(M.objects.a_filter())\nprint(q)\nq = q.union(M.objects.b_filter())\nprint(q)\nq.update(name='foo')\n<QuerySet [<M: M object (675)>]>\n<QuerySet [<M: M object (675)>, <M: M object (773)>]>\nUPDATE \"m\" SET \"name\" = \"foo\" WHERE `a_filter Conditional statement` ORDER BY U0.\"id\" ASC LIMIT 1); args=(...)\n",
  "hints_text": "This operation is unsupported, see ​documentation: In addition, only LIMIT, OFFSET, COUNT(*), ORDER BY, and specifying columns (i.e. slicing, count(), order_by(), and values()/values_list()) are allowed on the resulting QuerySet. but I agree that we should raise a descriptive error for update() and delete() (see related #27995).",
  "created_at": "2020-01-09T10:13:12Z",
  "version": "3.1",
  "FAIL_TO_PASS": "[\"test_unsupported_operations_on_combined_qs (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_unsupported_ordering_slicing_raises_db_error (queries.test_qs_combinators.QuerySetSetOperationTests)\"]",
  "PASS_TO_PASS": "[\"test_combining_multiple_models (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_count_difference (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_count_intersection (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_count_union (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_count_union_empty_result (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_difference_with_empty_qs (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_difference_with_values (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_intersection_with_empty_qs (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_intersection_with_values (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_limits (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_order_by_same_type (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_order_raises_on_non_selected_column (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_ordering (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_ordering_by_f_expression (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_qs_with_subcompound_qs (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_simple_difference (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_simple_intersection (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_simple_union (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_union_distinct (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_union_with_empty_qs (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_union_with_extra_and_values_list (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_union_with_two_annotated_values_list (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_union_with_values (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_union_with_values_list_and_order (queries.test_qs_combinators.QuerySetSetOperationTests)\", \"test_union_with_values_list_on_annotated_and_unannotated (queries.test_qs_combinators.QuerySetSetOperationTests)\"]",
  "environment_setup_commit": "0668164b4ac93a5be79f5b87fae83c657124d9ab",
  "_download_metadata": {
    "downloaded_at": "2025-10-07T21:23:30.621063",
    "dataset_name": "swe-bench",
    "split": "test",
    "downloader_version": "0.1.0"
  }
}